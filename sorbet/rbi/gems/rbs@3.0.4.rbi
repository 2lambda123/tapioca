# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rbs` gem.
# Please instead update this file by running `bin/tapioca gem rbs`.

module ::Bundler
  class << self
    sig { returns(::Pathname) }
    def default_lockfile; end

    sig { returns(::Bundler::Definition) }
    def definition; end
  end
end

class ::Bundler::Definition
  sig { returns(::T::Array[::Bundler::Dependency]) }
  def dependencies; end

  sig { returns(::Bundler::LockfileParser) }
  def locked_gems; end

  sig { returns(::Pathname) }
  def lockfile; end
end

class ::Bundler::Dependency < ::Gem::Dependency
  sig { returns(T.nilable(::T::Array[::String])) }
  def autorequire; end
end

class ::Bundler::LazySpecification
  sig { returns(::T::Array[::Gem::Dependency]) }
  def dependencies; end

  sig { returns(::String) }
  def name; end

  sig { returns(::String) }
  def version; end
end

class ::Bundler::LockfileParser
  sig { params(_arg0: ::String).void }
  def initialize(_arg0); end

  sig { returns(::T::Array[::Bundler::LazySpecification]) }
  def specs; end
end

module ::Gem; end

class ::Gem::Dependency
  sig { returns(::String) }
  def name; end
end

class ::Gem::Specification
  sig { returns(::T::Array[::Gem::Dependency]) }
  def dependencies; end

  sig { returns(::String) }
  def gem_dir; end

  sig { returns(::Gem::Version) }
  def version; end

  class << self
    sig { params(name: ::String, requirements: ::String).returns(T.attached_class) }
    def find_by_name(name, *requirements); end
  end
end

module ::Interfaces::Interface_Each
  extend T::Generic

  sig { params(blk: T.proc.params(_arg0: A).void).void }
  def each(&blk); end

  A = type_member
end

module ::Interfaces::Interface_ToJson
  sig { params(state: ::JSON::State).returns(::String) }
  def to_json(state = T.unsafe(nil)); end
end

module ::Interfaces::RBS::AST::Declarations::Interface_WithMember
  sig { returns(::T::Array[T.untyped]) }
  def members; end
end

module ::Interfaces::RBS::Annotate::RDocAnnotator::Interface_Annotated
  sig { returns(::T::Array[::RBS::AST::Annotation]) }
  def annotations; end
end

module ::Interfaces::RBS::Annotate::RDocAnnotator::Interface_Commented
  sig { returns(T.nilable(::RBS::AST::Comment)) }
  def comment; end
end

module ::Interfaces::RBS::Annotate::RDocAnnotator::Interface_PathTester
  sig { params(_arg0: ::String).returns(T::Boolean) }
  def test_path(_arg0); end
end

module ::Interfaces::RBS::Annotate::RDocAnnotator::Interface_WithRDocComment
  sig { returns(::RDoc::Markup::Document) }
  def comment; end
end

module ::Interfaces::RBS::CLI::Interface_IO
  sig { void }
  def flush; end

  sig { params(_arg0: T.untyped).void }
  def print(*_arg0); end

  sig { params(_arg0: T.untyped).void }
  def puts(*_arg0); end
end

module ::Interfaces::RBS::Collection::Sources::Interface_Source
  sig do
    params(
      name: ::String,
      version: ::String
    ).returns(T.nilable(::T::Array[::TypeAliases::RBS::Collection::Sources::TypeAlias_manifest_dependency]))
  end
  def dependencies_of(name, version); end

  sig { params(name: ::String, version: T.nilable(::String)).returns(::TypeAliases::TypeAlias_boolish) }
  def has?(name, version); end

  sig do
    params(
      dest: ::Pathname,
      name: ::String,
      version: ::String,
      stdout: ::Interfaces::RBS::CLI::Interface_IO
    ).void
  end
  def install(dest:, name:, version:, stdout:); end

  sig do
    params(
      name: ::String,
      version: ::String
    ).returns(T.nilable(::TypeAliases::RBS::Collection::Sources::TypeAlias_manifest_entry))
  end
  def manifest_of(name, version); end

  sig { returns(::TypeAliases::RBS::Collection::Sources::TypeAlias_source_entry) }
  def to_lockfile; end

  sig { params(name: ::String).returns(::T::Array[::String]) }
  def versions(name); end
end

module ::Interfaces::RBS::Environment::Interface_ModuleOrClass
  sig { returns(::RBS::TypeName) }
  def name; end

  sig { returns(::T::Array[::RBS::AST::TypeParam]) }
  def type_params; end
end

module ::Interfaces::RBS::Environment::Interface_NamedDecl
  sig { returns(::RBS::TypeName) }
  def name; end
end

module ::Interfaces::RBS::Interface_HashEqual
  alias eql? ==

  sig { params(other: T.untyped).returns(T::Boolean) }
  def ==(other); end

  sig { returns(::Integer) }
  def hash; end
end

module ::Interfaces::RBS::Interface_MethodName
  sig { returns(T.untyped) }
  def kind; end

  sig { returns(::Symbol) }
  def method_name; end

  sig { returns(::RBS::TypeName) }
  def type_name; end
end

# _DeclWithComment is a utility interface that has `#comment`
#
module ::Interfaces::RBS::RDocPlugin::Parser::Interface_DeclWithComment
  sig { returns(T.nilable(::RBS::AST::Comment)) }
  def comment; end
end

# _TypeBase interface represents the operations common to all of the types.
#
module ::Interfaces::RBS::Types::Interface_TypeBase
  include ::Interfaces::Interface_ToJson

  # Yields all direct sub types included in the type.
  # It doesn't yield the type itself.
  #
  #   parse("Hash[String, Array[Symbol]]").each_type do |ty|
  #     ...       # Yields String and Array[Symbol]
  #   end
  #
  sig { params(blk: T.proc.params(_arg0: ::TypeAliases::RBS::Types::TypeAlias_t).void).void }
  def each_type(&blk); end

  # Returns names of free variables of a type.
  # You can pass a Set instance to add the free variables to the set to avoid Set object allocation.
  #
  sig { params(_arg0: ::T::Set[::Symbol]).returns(::T::Set[::Symbol]) }
  def free_variables(_arg0 = T.unsafe(nil)); end

  # Maps type names included in the type and returns new instance of type.
  sig do
    params(
      blk: T.proc.params(_arg0: ::RBS::TypeName, _arg1: T.nilable(::RBS::Location[T.untyped, T.untyped]), _arg2: ::TypeAliases::RBS::Types::TypeAlias_t).returns(::RBS::TypeName)
    ).returns(::TypeAliases::RBS::Types::TypeAlias_t)
  end
  def map_type_name(&blk); end

  # Receives a substitution and returns a new type applied the substitution.
  #
  sig { params(_arg0: ::RBS::Substitution).returns(::TypeAliases::RBS::Types::TypeAlias_t) }
  def sub(_arg0); end

  # Returns a String representation.
  # `level` is used internally.
  #
  #   parse("String").to_s               # => "String"
  #   parse("String | Integer").to_s()   # => "String | Integer"
  #   parse("String | Integer").to_s(1)  # => "(String | Integer)"
  #
  sig { params(level: ::Integer).returns(::String) }
  def to_s(level = T.unsafe(nil)); end
end

module ::Interfaces::RBS::Writer::Interface_IO
  sig { void }
  def flush; end

  sig { params(_arg0: T.untyped).void }
  def puts(*_arg0); end
end

module ::Interfaces::RBS::Writer::Interface_Located
  sig { returns(T.nilable(::RBS::Location[T.untyped, T.untyped])) }
  def location; end
end

module ::Kernel
  # Parses given string and returns Namespace.
  #
  sig { params(_arg0: ::String).returns(::RBS::Namespace) }
  def Namespace(_arg0); end

  # Returns type name with given string representation.
  sig { params(name: ::String).returns(::RBS::TypeName) }
  def TypeName(name); end
end

class ::PP
  class << self
    sig { params(obj: T.untyped, out: ::IO, width: ::Integer).void }
    def pp(obj, out, width = T.unsafe(nil)); end
  end
end

module ::RBS::Annotate; end

class ::RBS::Annotate::Annotations
  sig { params(_arg0: ::T::Array[::TypeAliases::RBS::Annotate::Annotations::TypeAlias_t]).void }
  def initialize(_arg0); end

  sig { returns(T.nilable(::RBS::Annotate::Annotations::Copy)) }
  def copy_annotation; end

  sig { returns(::T::Array[::TypeAliases::RBS::Annotate::Annotations::TypeAlias_t]) }
  def items; end

  sig { returns(T::Boolean) }
  def skip?; end

  sig { returns(T::Boolean) }
  def skip_all?; end

  sig { params(path: ::String).returns(T::Boolean) }
  def test_path(path); end

  sig { params(pattern: ::String, path: ::String).returns(T::Boolean) }
  def test_path_string(pattern, path); end

  class << self
    sig do
      params(
        _arg0: ::RBS::AST::Annotation
      ).returns(T.nilable(::TypeAliases::RBS::Annotate::Annotations::TypeAlias_t))
    end
    def parse(_arg0); end
  end
end

# Copy annotation allows copying the doc from another subject.
# This helps working with incorrect RDoc annotations.
#
#     %a{annotate:rdoc:copy:Bar#baz}
#     %a{annotate:rdoc:copy:Bar.baz}
#     %a{annotate:rdoc:copy:Bar::Baz}
#
class ::RBS::Annotate::Annotations::Copy
  alias eql? ==

  sig { params(annotation: ::RBS::AST::Annotation, source: ::String).void }
  def initialize(annotation:, source:); end

  sig { params(_arg0: T.untyped).returns(T::Boolean) }
  def ==(_arg0); end

  sig { returns(::RBS::AST::Annotation) }
  def annotation; end

  sig { returns(::Integer) }
  def hash; end

  sig { returns(T.nilable(::Symbol)) }
  def method_name; end

  # Returns a tuple of:
  #
  # - Type name
  # - A pair of:
  #   - Boolean which holds if it is singleton
  #   - Name of method
  sig { returns([::RBS::TypeName, T.nilable([T::Boolean, ::Symbol])]) }
  def partition; end

  sig { returns(T::Boolean) }
  def singleton?; end

  sig { returns(::String) }
  def source; end

  sig { returns(::RBS::TypeName) }
  def type_name; end
end

# Skip annotation allows skipping generating annotation of a subject.
#
#     %a{annotate:rdoc:skip}
#     %a{annotate:rdoc:skip:all}
#
class ::RBS::Annotate::Annotations::Skip
  alias eql? ==

  sig { params(annotation: ::RBS::AST::Annotation, skip_children: T::Boolean).void }
  def initialize(annotation:, skip_children:); end

  sig { params(_arg0: T.untyped).returns(T::Boolean) }
  def ==(_arg0); end

  sig { returns(::RBS::AST::Annotation) }
  def annotation; end

  sig { returns(::Integer) }
  def hash; end

  sig { returns(T::Boolean) }
  def skip_children; end
end

# Source annotation allows where the documents are copied from.
#
# It allows specifying two directions: the source to read from, and the source to skip.
#
#     %a{annotate:rdoc:source:from=ext/pathname}
#     %a{annotate:rdoc:source:skip=ext/pathname/doc}
#
# When you want to specify several paths, repeat writing the Source annotation.
#
class ::RBS::Annotate::Annotations::Source
  alias eql? ==

  sig { params(annotation: ::RBS::AST::Annotation, include: ::String).void }
  def initialize(annotation:, include:); end

  sig { params(_arg0: T.untyped).returns(T::Boolean) }
  def ==(_arg0); end

  sig { returns(::RBS::AST::Annotation) }
  def annotation; end

  sig { returns(::Integer) }
  def hash; end

  sig { returns(T.nilable(::String)) }
  def include_source; end

  sig { returns(T.nilable(::String)) }
  def skip_source; end
end

class ::RBS::Annotate::Formatter
  sig { void }
  def initialize; end

  sig { params(_arg0: T.nilable(T.any(::RDoc::Markup::Document, ::String))).returns(T.self_type) }
  def <<(_arg0); end

  sig { returns(::String) }
  def buffer; end

  sig { returns(T::Boolean) }
  def empty?; end

  sig { params(newline_at_end: T::Boolean).returns(::String) }
  def format(newline_at_end:); end

  sig { params(separator: ::String).returns(T.self_type) }
  def margin(separator: T.unsafe(nil)); end

  class << self
    sig { params(_arg0: ::RDoc::Markup::Document, blk: T.proc.params(_arg0: ::RDoc::Markup::Document).void).void }
    def each_part(_arg0, &blk); end

    sig { params(_arg0: ::RDoc::Markup::Document).returns(T.nilable(::String)) }
    def translate(_arg0); end
  end
end

class ::RBS::Annotate::RDocAnnotator
  sig { params(source: ::RBS::Annotate::RDocSource).void }
  def initialize(source:); end

  sig { params(_arg0: ::RBS::TypeName, _arg1: ::RBS::AST::Members::Alias).void }
  def annotate_alias(_arg0, _arg1); end

  sig do
    params(
      _arg0: ::RBS::TypeName,
      _arg1: T.any(::RBS::AST::Members::AttrAccessor, ::RBS::AST::Members::AttrReader, ::RBS::AST::Members::AttrWriter)
    ).void
  end
  def annotate_attribute(_arg0, _arg1); end

  sig do
    params(
      _arg0: T.any(::RBS::AST::Declarations::Class, ::RBS::AST::Declarations::Module),
      outer: ::T::Array[::RBS::Namespace]
    ).void
  end
  def annotate_class(_arg0, outer:); end

  sig { params(_arg0: ::RBS::AST::Declarations::Constant, outer: ::T::Array[::RBS::Namespace]).void }
  def annotate_constant(_arg0, outer:); end

  sig do
    params(
      _arg0: ::T::Array[::TypeAliases::RBS::AST::Declarations::TypeAlias_t],
      outer: ::T::Array[::RBS::Namespace]
    ).void
  end
  def annotate_decls(_arg0, outer: T.unsafe(nil)); end

  sig { params(_arg0: ::Pathname, preserve: T::Boolean).void }
  def annotate_file(_arg0, preserve:); end

  sig { params(_arg0: ::RBS::TypeName, _arg1: ::RBS::AST::Members::MethodDefinition).void }
  def annotate_method(_arg0, _arg1); end

  sig do
    params(
      _arg0: ::Interfaces::RBS::Annotate::RDocAnnotator::Interface_Annotated
    ).returns(::RBS::Annotate::Annotations)
  end
  def annotations(_arg0); end

  sig do
    params(
      _arg0: ::RBS::TypeName,
      name: ::Symbol,
      singleton: T::Boolean,
      tester: ::Interfaces::RBS::Annotate::RDocAnnotator::Interface_PathTester
    ).returns(T.nilable(::String))
  end
  def doc_for_alias(_arg0, name:, singleton:, tester:); end

  # Having `require: nil` means any attribute is okay.
  # Having `require: "R"` means _read attr_ is required.
  # Having `require: "W"` means write attr_ is required.
  #
  sig do
    params(
      _arg0: ::RBS::TypeName,
      _arg1: ::Symbol,
      singleton: T::Boolean,
      tester: ::Interfaces::RBS::Annotate::RDocAnnotator::Interface_PathTester,
      require: T.untyped
    ).returns(T.nilable(::String))
  end
  def doc_for_attribute(_arg0, _arg1, singleton:, tester:, require: T.unsafe(nil)); end

  sig do
    params(
      _arg0: ::RBS::TypeName,
      tester: ::Interfaces::RBS::Annotate::RDocAnnotator::Interface_PathTester
    ).returns(T.nilable(::String))
  end
  def doc_for_class(_arg0, tester:); end

  sig do
    params(
      _arg0: ::RBS::TypeName,
      tester: ::Interfaces::RBS::Annotate::RDocAnnotator::Interface_PathTester
    ).returns(T.nilable(::String))
  end
  def doc_for_constant(_arg0, tester:); end

  # Returns the formatted document of given method.
  #
  # Expands attribute documents, or alias documents if needed.
  #
  sig do
    params(
      _arg0: ::RBS::TypeName,
      instance_method: ::Symbol,
      tester: ::Interfaces::RBS::Annotate::RDocAnnotator::Interface_PathTester
    ).returns(T.nilable(::String))
  end
  def doc_for_method(_arg0, instance_method:, tester:); end

  sig do
    params(
      _arg0: ::RBS::TypeName,
      instance_method: ::Symbol,
      tester: ::Interfaces::RBS::Annotate::RDocAnnotator::Interface_PathTester
    ).returns(T.nilable(::String))
  end
  def doc_for_method0(_arg0, instance_method:, tester:); end

  sig do
    params(
      _arg0: ::T::Array[T.all(::Interfaces::RBS::Annotate::RDocAnnotator::Interface_WithRDocComment, ::Object)],
      tester: ::Interfaces::RBS::Annotate::RDocAnnotator::Interface_PathTester,
      blk: T.proc.params(_arg0: [::RDoc::Markup::Document, T.all(::Interfaces::RBS::Annotate::RDocAnnotator::Interface_WithRDocComment, ::Object)]).void
    ).void
  end
  def each_part(_arg0, tester:, &blk); end

  sig { returns(T::Boolean) }
  def include_arg_lists; end

  sig { params(include_arg_lists: T::Boolean).returns(T::Boolean) }
  def include_arg_lists=(include_arg_lists); end

  sig { returns(T::Boolean) }
  def include_filename; end

  sig { params(include_filename: T::Boolean).returns(T::Boolean) }
  def include_filename=(include_filename); end

  sig { params(_arg0: ::T::Array[T.nilable(::String)], separator: ::String).returns(T.nilable(::String)) }
  def join_docs(_arg0, separator: T.unsafe(nil)); end

  # - If a string is given as `comment`, the content is attached to the object as a comment.
  # - If empty string is given as `comment`, it deletes the original comment.
  # - If `nil` is given as `comment`, it keeps the original comment.
  #
  sig do
    params(
      _arg0: T.all(::Interfaces::RBS::Annotate::RDocAnnotator::Interface_Commented, ::Object),
      comment: T.nilable(::String)
    ).void
  end
  def replace_comment(_arg0, comment); end

  sig do
    params(
      _arg0: T.nilable(::RBS::Annotate::Annotations::Copy),
      tester: ::Interfaces::RBS::Annotate::RDocAnnotator::Interface_PathTester,
      blk: T.proc.returns(T.nilable(::String))
    ).returns(T.nilable(::String))
  end
  def resolve_doc_source(_arg0, tester:, &blk); end

  sig { params(_arg0: ::RBS::TypeName, outer: ::T::Array[::RBS::Namespace]).returns(::RBS::TypeName) }
  def resolve_name(_arg0, outer:); end

  sig { returns(::RBS::Annotate::RDocSource) }
  def source; end
end

class ::RBS::Annotate::RDocSource
  sig { void }
  def initialize; end

  # Extract documents from `CodeObject`s
  sig do
    params(
      blk: T.proc.returns(T.nilable(::T::Array[::RDoc::CodeObject]))
    ).returns(T.nilable(::T::Array[::RDoc::Markup::Document]))
  end
  def docs(&blk); end

  sig { returns(::T::Array[::Pathname]) }
  def extra_dirs; end

  sig do
    params(
      _arg0: ::RBS::TypeName,
      _arg1: ::Symbol,
      singleton: T::Boolean
    ).returns(T.nilable(::T::Array[::RDoc::Attr]))
  end
  def find_attribute(_arg0, _arg1, singleton:); end

  sig { params(_arg0: ::RBS::TypeName).returns(T.nilable(::T::Array[::RDoc::ClassModule])) }
  def find_class(_arg0); end

  sig { params(_arg0: ::RBS::TypeName).returns(T.nilable(::T::Array[::RDoc::Constant])) }
  def find_const(_arg0); end

  sig { params(_arg0: ::RBS::TypeName, instance_method: ::Symbol).returns(T.nilable(::T::Array[::RDoc::AnyMethod])) }
  def find_method(_arg0, instance_method:); end

  sig { void }
  def load; end

  sig { returns(::T::Array[::RDoc::Store]) }
  def stores; end

  sig { returns(T::Boolean) }
  def with_gems_dir; end

  sig { params(with_gems_dir: T::Boolean).returns(T::Boolean) }
  def with_gems_dir=(with_gems_dir); end

  sig { returns(T::Boolean) }
  def with_home_dir; end

  sig { params(with_home_dir: T::Boolean).returns(T::Boolean) }
  def with_home_dir=(with_home_dir); end

  sig { returns(T::Boolean) }
  def with_site_dir; end

  sig { params(with_site_dir: T::Boolean).returns(T::Boolean) }
  def with_site_dir=(with_site_dir); end

  sig { returns(T::Boolean) }
  def with_system_dir; end

  sig { params(with_system_dir: T::Boolean).returns(T::Boolean) }
  def with_system_dir=(with_system_dir); end
end

class ::RBS::CLI
  sig { params(stdout: ::IO, stderr: ::IO).void }
  def initialize(stdout:, stderr:); end

  sig { params(_arg0: ::T::Array[::String]).returns(::OptionParser) }
  def collection_options(_arg0); end

  sig { returns(T::Boolean) }
  def has_parser?; end

  sig { params(_arg0: ::OptionParser, options: ::RBS::CLI::LibraryOptions).void }
  def library_parse(_arg0, options:); end

  sig { returns(::T::Array[::String]) }
  def original_args; end

  sig { params(_arg0: ::OptionParser).void }
  def parse_logging_options(_arg0); end

  sig { params(args: ::T::Array[::String]).void }
  def run(args); end

  sig { params(_arg0: ::T::Array[::String], _arg1: ::RBS::CLI::LibraryOptions).void }
  def run_ancestors(_arg0, _arg1); end

  sig { params(_arg0: ::T::Array[::String], _arg1: ::BasicObject).void }
  def run_annotate(_arg0, _arg1); end

  sig { params(_arg0: ::T::Array[::String], _arg1: ::RBS::CLI::LibraryOptions).void }
  def run_ast(_arg0, _arg1); end

  sig { params(_arg0: ::T::Array[::String], _arg1: ::RBS::CLI::LibraryOptions).void }
  def run_collection(_arg0, _arg1); end

  sig { params(_arg0: ::T::Array[::String], _arg1: ::RBS::CLI::LibraryOptions).void }
  def run_constant(_arg0, _arg1); end

  sig { params(_arg0: ::T::Array[::String], _arg1: ::RBS::CLI::LibraryOptions).void }
  def run_list(_arg0, _arg1); end

  sig { params(_arg0: ::T::Array[::String], _arg1: ::RBS::CLI::LibraryOptions).void }
  def run_method(_arg0, _arg1); end

  sig { params(_arg0: ::T::Array[::String], _arg1: ::RBS::CLI::LibraryOptions).void }
  def run_methods(_arg0, _arg1); end

  sig { params(_arg0: ::T::Array[::String], _arg1: ::RBS::CLI::LibraryOptions).void }
  def run_parse(_arg0, _arg1); end

  sig { params(_arg0: ::T::Array[::String], _arg1: ::RBS::CLI::LibraryOptions).void }
  def run_paths(_arg0, _arg1); end

  sig { params(_arg0: ::T::Array[::String], _arg1: ::RBS::CLI::LibraryOptions).void }
  def run_prototype(_arg0, _arg1); end

  sig { params(format: ::String, _arg1: ::T::Array[::String]).void }
  def run_prototype_file(format, _arg1); end

  sig { params(_arg0: ::T::Array[::String], _arg1: ::RBS::CLI::LibraryOptions).void }
  def run_test(_arg0, _arg1); end

  sig { params(_arg0: ::T::Array[::String], _arg1: ::RBS::CLI::LibraryOptions).void }
  def run_validate(_arg0, _arg1); end

  sig { params(_arg0: ::T::Array[::String], _arg1: ::RBS::CLI::LibraryOptions).void }
  def run_vendor(_arg0, _arg1); end

  sig { returns(::Interfaces::RBS::CLI::Interface_IO) }
  def stderr; end

  sig { returns(::Interfaces::RBS::CLI::Interface_IO) }
  def stdout; end

  sig { params(_arg0: ::RBS::CLI::LibraryOptions).returns(T.nilable(::String)) }
  def test_opt(_arg0); end
end

::RBS::CLI::COMMANDS = T.let(T.unsafe(nil), ::T::Array[::Symbol])

class ::RBS::CLI::LibraryOptions
  sig { void }
  def initialize; end

  sig { returns(T.nilable(::Pathname)) }
  def config_path; end

  sig { params(config_path: T.nilable(::Pathname)).returns(T.nilable(::Pathname)) }
  def config_path=(config_path); end

  sig { returns(T.nilable(::Pathname)) }
  def core_root; end

  sig { params(core_root: T.nilable(::Pathname)).returns(T.nilable(::Pathname)) }
  def core_root=(core_root); end

  sig { returns(::T::Array[::String]) }
  def dirs; end

  sig { returns(::T::Array[::String]) }
  def libs; end

  sig { returns(::RBS::EnvironmentLoader) }
  def loader; end

  sig { returns(::T::Array[::String]) }
  def repos; end

  sig { params(_arg0: ::OptionParser).returns(::OptionParser) }
  def setup_library_options(_arg0); end
end

class ::RBS::Sorter
  include ::RBS::AST

  sig { params(path: ::Pathname, stdout: ::IO).void }
  def initialize(path, stdout: T.unsafe(nil)); end

  sig { params(member: ::TypeAliases::RBS::Sorter::TypeAlias_member).returns(::Numeric) }
  def group(member); end

  sig { params(member: ::TypeAliases::RBS::Sorter::TypeAlias_member).returns(::String) }
  def key(member); end

  sig { returns(::Pathname) }
  def path; end

  sig { void }
  def run; end

  sig { params(decl: ::TypeAliases::RBS::AST::Declarations::TypeAlias_t).void }
  def sort_decl!(decl); end

  sig { returns(::IO) }
  def stdout; end
end

module ::RDoc; end

class ::RDoc::ClassModule < ::RDoc::Context
  sig { returns(::T::Array[::RDoc::Attr]) }
  def attributes; end

  sig { returns(::T::Array[::RDoc::Constant]) }
  def constants; end

  sig { returns(::T::Array[::RDoc::AnyMethod]) }
  def method_list; end
end

class ::RDoc::Context < ::RDoc::CodeObject; end
class ::RDoc::Markup; end

class ::RDoc::Markup::Document
  include ::Enumerable

  sig { params(_arg0: T.untyped).returns(::String) }
  def accept(_arg0); end

  sig { params(blk: T.proc.params(_arg0: ::RDoc::Markup::Document).void).void }
  def each(&blk); end

  sig { returns(T.nilable(::String)) }
  def file; end
end

class ::RDoc::Markup::ToMarkdown; end
class ::RDoc::Parser; end
module ::RDoc::RI; end

module ::RDoc::RI::Paths
  class << self
    sig do
      params(
        system: T::Boolean,
        site: T::Boolean,
        home: T::Boolean,
        gems: T.any(::TypeAliases::RDoc::RI::Paths::TypeAlias_gem_filter, T.untyped),
        extra_dirs: ::String,
        blk: T.proc.params(_arg0: ::String, _arg1: ::TypeAliases::RDoc::RI::Paths::TypeAlias_path_type).void
      ).void
    end
    def each(system = T.unsafe(nil), site = T.unsafe(nil), home = T.unsafe(nil), gems = T.unsafe(nil), *extra_dirs, &blk); end
  end
end

class ::RDoc::Store
  sig { params(path: T.nilable(::String), type: T.nilable(::Symbol)).void }
  def initialize(path = T.unsafe(nil), type = T.unsafe(nil)); end

  sig { params(_arg0: ::String).returns(T.nilable(::RDoc::ClassModule)) }
  def find_class_or_module(_arg0); end

  sig { void }
  def load_all; end
end

::TypeAliases::RBS::AST::Declarations::AliasDecl::TypeAlias_loc = T.type_alias { ::RBS::Location[T.untyped, T.untyped] }
::TypeAliases::RBS::AST::Declarations::Class::Super::TypeAlias_loc = T.type_alias { ::RBS::Location[T.untyped, T.untyped] }
::TypeAliases::RBS::AST::Declarations::Class::TypeAlias_loc = T.type_alias { ::RBS::Location[T.untyped, T.untyped] }
::TypeAliases::RBS::AST::Declarations::Class::TypeAlias_member = T.type_alias { T.any(::TypeAliases::RBS::AST::Declarations::TypeAlias_t, ::TypeAliases::RBS::AST::Members::TypeAlias_t) }
::TypeAliases::RBS::AST::Declarations::Constant::TypeAlias_loc = T.type_alias { ::RBS::Location[T.untyped, T.untyped] }
::TypeAliases::RBS::AST::Declarations::Global::TypeAlias_loc = T.type_alias { ::RBS::Location[T.untyped, T.untyped] }
::TypeAliases::RBS::AST::Declarations::Interface::TypeAlias_loc = T.type_alias { ::RBS::Location[T.untyped, T.untyped] }
::TypeAliases::RBS::AST::Declarations::Interface::TypeAlias_member = T.type_alias { ::TypeAliases::RBS::AST::Members::TypeAlias_t }
::TypeAliases::RBS::AST::Declarations::MixinHelper::TypeAlias_mixin_member = T.type_alias { T.any(::RBS::AST::Members::Extend, ::RBS::AST::Members::Include, ::RBS::AST::Members::Prepend) }
::TypeAliases::RBS::AST::Declarations::Module::Self::TypeAlias_loc = T.type_alias { ::RBS::Location[T.untyped, T.untyped] }
::TypeAliases::RBS::AST::Declarations::Module::TypeAlias_loc = T.type_alias { ::RBS::Location[T.untyped, T.untyped] }
::TypeAliases::RBS::AST::Declarations::Module::TypeAlias_member = T.type_alias { T.any(::TypeAliases::RBS::AST::Declarations::TypeAlias_t, ::TypeAliases::RBS::AST::Members::TypeAlias_t) }
::TypeAliases::RBS::AST::Declarations::TypeAlias::TypeAlias_loc = T.type_alias { ::RBS::Location[T.untyped, T.untyped] }
::TypeAliases::RBS::AST::Declarations::TypeAlias_t = T.type_alias { T.any(::RBS::AST::Declarations::Class, ::RBS::AST::Declarations::ClassAlias, ::RBS::AST::Declarations::Constant, ::RBS::AST::Declarations::Global, ::RBS::AST::Declarations::Interface, ::RBS::AST::Declarations::Module, ::RBS::AST::Declarations::ModuleAlias, ::RBS::AST::Declarations::TypeAlias) }
::TypeAliases::RBS::AST::Directives::TypeAlias_t = T.type_alias { ::RBS::AST::Directives::Use }
::TypeAliases::RBS::AST::Directives::Use::SingleClause::TypeAlias_loc = T.type_alias { ::RBS::Location[T.untyped, T.untyped] }
::TypeAliases::RBS::AST::Directives::Use::TypeAlias_clause = T.type_alias { T.any(::RBS::AST::Directives::Use::SingleClause, ::RBS::AST::Directives::Use::WildcardClause) }
::TypeAliases::RBS::AST::Directives::Use::TypeAlias_loc = T.type_alias { ::RBS::Location[T.untyped, T.untyped] }
::TypeAliases::RBS::AST::Directives::Use::WildcardClause::TypeAlias_loc = T.type_alias { ::RBS::Location[T.untyped, T.untyped] }
::TypeAliases::RBS::AST::Members::Alias::TypeAlias_kind = T.type_alias { T.untyped }
::TypeAliases::RBS::AST::Members::Alias::TypeAlias_loc = T.type_alias { ::RBS::Location[T.untyped, T.untyped] }
::TypeAliases::RBS::AST::Members::Attribute::TypeAlias_kind = T.type_alias { T.untyped }
::TypeAliases::RBS::AST::Members::Attribute::TypeAlias_loc = T.type_alias { ::RBS::Location[T.untyped, T.untyped] }
::TypeAliases::RBS::AST::Members::MethodDefinition::TypeAlias_kind = T.type_alias { T.untyped }
::TypeAliases::RBS::AST::Members::MethodDefinition::TypeAlias_loc = T.type_alias { ::RBS::Location[T.untyped, T.untyped] }
::TypeAliases::RBS::AST::Members::Mixin::TypeAlias_loc = T.type_alias { ::RBS::Location[T.untyped, T.untyped] }
::TypeAliases::RBS::AST::Members::TypeAlias_t = T.type_alias { T.any(::RBS::AST::Members::Alias, ::RBS::AST::Members::AttrAccessor, ::RBS::AST::Members::AttrReader, ::RBS::AST::Members::AttrWriter, ::RBS::AST::Members::ClassInstanceVariable, ::RBS::AST::Members::ClassVariable, ::RBS::AST::Members::Extend, ::RBS::AST::Members::Include, ::RBS::AST::Members::InstanceVariable, ::RBS::AST::Members::MethodDefinition, ::RBS::AST::Members::Prepend, ::RBS::AST::Members::Private, ::RBS::AST::Members::Public) }
::TypeAliases::RBS::AST::Members::TypeAlias_visibility = T.type_alias { T.untyped }
::TypeAliases::RBS::AST::Members::Var::TypeAlias_loc = T.type_alias { ::RBS::Location[T.untyped, T.untyped] }
::TypeAliases::RBS::AST::TypeParam::TypeAlias_bound = T.type_alias { T.any(::RBS::Types::ClassInstance, ::RBS::Types::ClassSingleton, ::RBS::Types::Interface) }
::TypeAliases::RBS::AST::TypeParam::TypeAlias_loc = T.type_alias { ::RBS::Location[T.untyped, T.untyped] }
::TypeAliases::RBS::AST::TypeParam::TypeAlias_variance = T.type_alias { T.untyped }
::TypeAliases::RBS::AncestorGraph::TypeAlias_node = T.type_alias { T.any(::RBS::AncestorGraph::InstanceNode, ::RBS::AncestorGraph::SingletonNode) }
::TypeAliases::RBS::Annotate::Annotations::TypeAlias_t = T.type_alias { T.any(::RBS::Annotate::Annotations::Copy, ::RBS::Annotate::Annotations::Skip, ::RBS::Annotate::Annotations::Source) }
::TypeAliases::RBS::Buffer::TypeAlias_loc = T.type_alias { [::Integer, ::Integer] }
::TypeAliases::RBS::Collection::Config::Lockfile::TypeAlias_library = T.type_alias { {name: ::String, version: ::String, source: ::TypeAliases::RBS::Collection::Sources::TypeAlias_t} }
::TypeAliases::RBS::Collection::Config::Lockfile::TypeAlias_library_data = T.type_alias { {"name" => ::String, "version" => ::String, "source" => ::TypeAliases::RBS::Collection::Sources::TypeAlias_source_entry} }
::TypeAliases::RBS::Collection::Config::Lockfile::TypeAlias_lockfile_data = T.type_alias { {"sources" => T.nilable(::T::Array[::TypeAliases::RBS::Collection::Sources::Git::TypeAlias_source_entry]), "path" => ::String, "gems" => T.nilable(::T::Array[::TypeAliases::RBS::Collection::Config::Lockfile::TypeAlias_library_data]), "gemfile_lock_path" => T.nilable(::String)} }
::TypeAliases::RBS::Collection::Config::TypeAlias_gem_entry = T.type_alias { {"name" => ::String, "version" => T.nilable(::String), "ignore" => ::TypeAliases::TypeAlias_boolish, "source" => T.nilable(::TypeAliases::RBS::Collection::Sources::TypeAlias_source_entry)} }
::TypeAliases::RBS::Collection::Sources::Git::TypeAlias_metadata = T.type_alias { {"name" => ::String, "version" => ::String, "source" => ::TypeAliases::RBS::Collection::Sources::Git::TypeAlias_source_entry} }
::TypeAliases::RBS::Collection::Sources::Git::TypeAlias_source_entry = T.type_alias { {"type" => T.untyped, "name" => ::String, "remote" => ::String, "revision" => ::String, "repo_dir" => T.nilable(::String)} }
::TypeAliases::RBS::Collection::Sources::Local::TypeAlias_source_entry = T.type_alias { {"type" => T.untyped, "path" => ::String} }
::TypeAliases::RBS::Collection::Sources::Rubygems::TypeAlias_source_entry = T.type_alias { {"type" => T.untyped} }
::TypeAliases::RBS::Collection::Sources::Stdlib::TypeAlias_source_entry = T.type_alias { {"type" => T.untyped} }
::TypeAliases::RBS::Collection::Sources::TypeAlias_manifest_dependency = T.type_alias { {"name" => ::String} }
::TypeAliases::RBS::Collection::Sources::TypeAlias_manifest_entry = T.type_alias { {"dependencies" => T.nilable(::T::Array[::TypeAliases::RBS::Collection::Sources::TypeAlias_manifest_dependency])} }
::TypeAliases::RBS::Collection::Sources::TypeAlias_source_entry = T.type_alias { T.any(::TypeAliases::RBS::Collection::Sources::Git::TypeAlias_source_entry, ::TypeAliases::RBS::Collection::Sources::Local::TypeAlias_source_entry, ::TypeAliases::RBS::Collection::Sources::Rubygems::TypeAlias_source_entry, ::TypeAliases::RBS::Collection::Sources::Stdlib::TypeAlias_source_entry) }
::TypeAliases::RBS::Collection::Sources::TypeAlias_t = T.type_alias { T.any(::RBS::Collection::Sources::Git, ::RBS::Collection::Sources::Local, ::RBS::Collection::Sources::Rubygems, ::RBS::Collection::Sources::Stdlib) }
::TypeAliases::RBS::Constant::TypeAlias_constant_entry = T.type_alias { T.any(::RBS::Environment::ClassEntry, ::RBS::Environment::ConstantEntry, ::RBS::Environment::ModuleEntry) }
::TypeAliases::RBS::Definition::Ancestor::Instance::TypeAlias_source = T.type_alias { T.nilable(T.any(::RBS::AST::Declarations::Module::Self, ::RBS::AST::Members::Extend, ::RBS::AST::Members::Include, ::RBS::AST::Members::Prepend, T.untyped)) }
::TypeAliases::RBS::Definition::Ancestor::TypeAlias_t = T.type_alias { T.any(::RBS::Definition::Ancestor::Instance, ::RBS::Definition::Ancestor::Singleton) }
::TypeAliases::RBS::Definition::Method::TypeAlias_method_member = T.type_alias { T.any(::RBS::AST::Members::AttrAccessor, ::RBS::AST::Members::AttrReader, ::RBS::AST::Members::AttrWriter, ::RBS::AST::Members::MethodDefinition) }
::TypeAliases::RBS::Definition::TypeAlias_accessibility = T.type_alias { T.untyped }
::TypeAliases::RBS::Definition::TypeAlias_definition_entry = T.type_alias { T.any(::RBS::Environment::ClassEntry, ::RBS::Environment::InterfaceEntry, ::RBS::Environment::ModuleEntry) }
::TypeAliases::RBS::Definition::TypeAlias_self_type = T.type_alias { T.any(::RBS::Types::ClassInstance, ::RBS::Types::ClassSingleton, ::RBS::Types::Interface) }
::TypeAliases::RBS::DefinitionBuilder::MethodBuilder::Methods::Definition::TypeAlias_accessibility = T.type_alias { ::TypeAliases::RBS::Definition::TypeAlias_accessibility }
::TypeAliases::RBS::DefinitionBuilder::MethodBuilder::Methods::Definition::TypeAlias_original = T.type_alias { T.any(::RBS::AST::Members::Alias, ::RBS::AST::Members::AttrAccessor, ::RBS::AST::Members::AttrReader, ::RBS::AST::Members::AttrWriter, ::RBS::AST::Members::MethodDefinition) }
::TypeAliases::RBS::DefinitionBuilder::MethodBuilder::Methods::TypeAlias_instance_type = T.type_alias { T.any(::RBS::Types::ClassInstance, ::RBS::Types::ClassSingleton, ::RBS::Types::Interface) }
::TypeAliases::RBS::DefinitionBuilder::TypeAlias_interface_methods = T.type_alias { ::T::Hash[::RBS::Definition::Ancestor::Instance, [::RBS::DefinitionBuilder::MethodBuilder::Methods, T.any(::RBS::AST::Members::Extend, ::RBS::AST::Members::Include)]] }
::TypeAliases::RBS::DuplicatedInterfaceMethodDefinitionError::TypeAlias_mixin_member = T.type_alias { T.any(::RBS::AST::Members::Extend, ::RBS::AST::Members::Include) }
::TypeAliases::RBS::DuplicatedInterfaceMethodDefinitionError::TypeAlias_ty = T.type_alias { T.any(::RBS::Types::ClassInstance, ::RBS::Types::ClassSingleton, ::RBS::Types::Interface) }
::TypeAliases::RBS::DuplicatedMethodDefinitionError::TypeAlias_original = T.type_alias { ::TypeAliases::RBS::DefinitionBuilder::MethodBuilder::Methods::Definition::TypeAlias_original }
::TypeAliases::RBS::DuplicatedMethodDefinitionError::TypeAlias_ty = T.type_alias { T.any(::RBS::Types::ClassInstance, ::RBS::Types::ClassSingleton, ::RBS::Types::Interface) }
::TypeAliases::RBS::Environment::TypeAlias_module_decl = T.type_alias { T.any(::RBS::AST::Declarations::Class, ::RBS::AST::Declarations::Module) }
::TypeAliases::RBS::EnvironmentLoader::TypeAlias_source = T.type_alias { T.any(::Pathname, ::RBS::EnvironmentLoader::Library, T.untyped) }
::TypeAliases::RBS::EnvironmentWalker::TypeAlias_node = T.type_alias { T.any(::RBS::EnvironmentWalker::InstanceNode, ::RBS::EnvironmentWalker::SingletonNode, ::RBS::EnvironmentWalker::TypeNameNode) }
::TypeAliases::RBS::Locator::TypeAlias_component = T.type_alias { T.any(::RBS::AST::Declarations::Class::Super, ::RBS::AST::Declarations::Module::Self, ::RBS::AST::TypeParam, ::RBS::MethodType, ::Symbol, ::TypeAliases::RBS::AST::Declarations::TypeAlias_t, ::TypeAliases::RBS::AST::Directives::TypeAlias_t, ::TypeAliases::RBS::AST::Directives::Use::TypeAlias_clause, ::TypeAliases::RBS::AST::Members::TypeAlias_t, ::TypeAliases::RBS::Types::TypeAlias_t) }
::TypeAliases::RBS::MethodType::TypeAlias_attr_loc = T.type_alias { ::TypeAliases::RBS::AST::Members::Attribute::TypeAlias_loc }
::TypeAliases::RBS::MethodType::TypeAlias_def_loc = T.type_alias { ::RBS::Location[T.untyped, T.untyped] }
::TypeAliases::RBS::MethodType::TypeAlias_loc = T.type_alias { T.any(::TypeAliases::RBS::MethodType::TypeAlias_attr_loc, ::TypeAliases::RBS::MethodType::TypeAlias_def_loc) }
::TypeAliases::RBS::MixinClassError::TypeAlias_member = T.type_alias { T.any(::RBS::AST::Members::Extend, ::RBS::AST::Members::Include, ::RBS::AST::Members::Prepend) }
::TypeAliases::RBS::Prototype::Helpers::TypeAlias_node = T.type_alias { ::RubyVM::AbstractSyntaxTree::Node }
::TypeAliases::RBS::Prototype::NodeUsage::TypeAlias_node = T.type_alias { ::RubyVM::AbstractSyntaxTree::Node }
::TypeAliases::RBS::Prototype::RB::Context::TypeAlias_method_kind = T.type_alias { T.untyped }
::TypeAliases::RBS::Prototype::RB::TypeAlias_decl = T.type_alias { T.any(::TypeAliases::RBS::AST::Declarations::TypeAlias_t, ::TypeAliases::RBS::AST::Members::TypeAlias_t) }
::TypeAliases::RBS::Prototype::RBI::TypeAlias_module_decl = T.type_alias { T.any(::RBS::AST::Declarations::Class, ::RBS::AST::Declarations::Module) }
::TypeAliases::RBS::RDocPlugin::Parser::TypeAlias_allowed_decls = T.type_alias { T.any(::RBS::AST::Declarations::Class, ::RBS::AST::Declarations::Constant, ::RBS::AST::Declarations::Module) }
::TypeAliases::RBS::RecursiveAliasDefinitionError::TypeAlias_defn = T.type_alias { ::RBS::DefinitionBuilder::MethodBuilder::Methods::Definition }
::TypeAliases::RBS::RecursiveAliasDefinitionError::TypeAlias_ty = T.type_alias { T.any(::RBS::Types::ClassInstance, ::RBS::Types::ClassSingleton, ::RBS::Types::Interface) }
::TypeAliases::RBS::Resolver::TypeAlias_context = T.type_alias { T.untyped }
::TypeAliases::RBS::Resolver::TypeNameResolver::TypeAlias_query = T.type_alias { [::RBS::TypeName, ::TypeAliases::RBS::Resolver::TypeAlias_context] }
::TypeAliases::RBS::Sorter::TypeAlias_member = T.type_alias { T.any(::TypeAliases::RBS::AST::Declarations::Class::TypeAlias_member, ::TypeAliases::RBS::AST::Declarations::Interface::TypeAlias_member, ::TypeAliases::RBS::AST::Declarations::Module::TypeAlias_member) }
::TypeAliases::RBS::TypeName::TypeAlias_kind = T.type_alias { T.untyped }
::TypeAliases::RBS::Types::Alias::TypeAlias_loc = T.type_alias { ::RBS::Location[T.untyped, T.untyped] }
::TypeAliases::RBS::Types::ClassInstance::TypeAlias_loc = T.type_alias { ::RBS::Location[T.untyped, T.untyped] }
::TypeAliases::RBS::Types::ClassSingleton::TypeAlias_loc = T.type_alias { ::RBS::Location[T.untyped, T.untyped] }
::TypeAliases::RBS::Types::Function::Param::TypeAlias_loc = T.type_alias { ::RBS::Location[T.untyped, T.untyped] }
::TypeAliases::RBS::Types::Interface::TypeAlias_loc = T.type_alias { ::RBS::Location[T.untyped, T.untyped] }
::TypeAliases::RBS::Types::Intersection::TypeAlias_loc = T.type_alias { ::RBS::Location[T.untyped, T.untyped] }
::TypeAliases::RBS::Types::Literal::TypeAlias_literal = T.type_alias { T.any(::Integer, ::String, ::Symbol, T::Boolean) }
::TypeAliases::RBS::Types::Literal::TypeAlias_loc = T.type_alias { ::RBS::Location[T.untyped, T.untyped] }
::TypeAliases::RBS::Types::Optional::TypeAlias_loc = T.type_alias { ::RBS::Location[T.untyped, T.untyped] }
::TypeAliases::RBS::Types::Proc::TypeAlias_loc = T.type_alias { ::RBS::Location[T.untyped, T.untyped] }
::TypeAliases::RBS::Types::Record::TypeAlias_loc = T.type_alias { ::RBS::Location[T.untyped, T.untyped] }
::TypeAliases::RBS::Types::Tuple::TypeAlias_loc = T.type_alias { ::RBS::Location[T.untyped, T.untyped] }
::TypeAliases::RBS::Types::TypeAlias_t = T.type_alias { T.any(::RBS::Types::Alias, ::RBS::Types::Bases::Any, ::RBS::Types::Bases::Bool, ::RBS::Types::Bases::Bottom, ::RBS::Types::Bases::Class, ::RBS::Types::Bases::Instance, ::RBS::Types::Bases::Nil, ::RBS::Types::Bases::Self, ::RBS::Types::Bases::Top, ::RBS::Types::Bases::Void, ::RBS::Types::ClassInstance, ::RBS::Types::ClassSingleton, ::RBS::Types::Interface, ::RBS::Types::Intersection, ::RBS::Types::Literal, ::RBS::Types::Optional, ::RBS::Types::Proc, ::RBS::Types::Record, ::RBS::Types::Tuple, ::RBS::Types::Union, ::RBS::Types::Variable) }
::TypeAliases::RBS::Types::Union::TypeAlias_loc = T.type_alias { ::RBS::Location[T.untyped, T.untyped] }
::TypeAliases::RBS::Types::Variable::TypeAlias_loc = T.type_alias { ::RBS::Location[T.untyped, T.untyped] }
::TypeAliases::RBS::VarianceCalculator::TypeAlias_variance = T.type_alias { T.untyped }
::TypeAliases::RDoc::RI::Paths::TypeAlias_gem_filter = T.type_alias { T.untyped }
::TypeAliases::RDoc::RI::Paths::TypeAlias_path_type = T.type_alias { T.untyped }
::TypeAliases::TypeAlias_boolish = T.type_alias { ::BasicObject }

# source://rbs//lib/rbs/version.rb#3
module RBS
  class << self
    sig { returns(::Logger) }
    def logger; end

    sig { returns(T.nilable(::Integer)) }
    def logger_level; end

    sig { params(_arg0: T.nilable(::Integer)).returns(T.nilable(::Integer)) }
    def logger_level=(_arg0); end

    sig { returns(::IO) }
    def logger_output; end

    sig { params(_arg0: ::IO).returns(::IO) }
    def logger_output=(_arg0); end

    sig { params(blk: T.proc.returns(::String)).void }
    def print_warning(&blk); end
  end
end

# source://rbs//lib/rbs/ast/type_param.rb#4
module RBS::AST; end

# source://rbs//lib/rbs/ast/annotation.rb#5
# RBS allows writing annotations of declarations and members.
#
# ```rbs
# %a{annotation_here}
# class Hello
#   %a{rbs:test:skip}
#   def foo: () -> void
# end
# ```
class RBS::AST::Annotation
  include ::Interfaces::Interface_ToJson

  alias eql? ==

  sig { params(string: ::String, location: T.nilable(::RBS::Location[T.untyped, T.untyped])).void }
  def initialize(string:, location:); end

  sig { params(other: T.untyped).returns(T::Boolean) }
  def ==(other); end

  sig { returns(::Integer) }
  def hash; end

  sig { returns(T.nilable(::RBS::Location[T.untyped, T.untyped])) }
  def location; end

  sig { returns(::String) }
  def string; end
end

# source://rbs//lib/rbs/ast/comment.rb#5
# RBS allows writing documentation of declarations and members.
#
# ```
# # This is a doc for class.
# class Hello
# end
class RBS::AST::Comment
  include ::Interfaces::Interface_ToJson

  alias eql? ==

  sig { params(string: ::String, location: T.nilable(::RBS::Location[T.untyped, T.untyped])).void }
  def initialize(string:, location:); end

  sig { params(other: T.untyped).returns(T::Boolean) }
  def ==(other); end

  sig { returns(::Integer) }
  def hash; end

  sig { returns(T.nilable(::RBS::Location[T.untyped, T.untyped])) }
  def location; end

  sig { returns(::String) }
  def string; end
end

# source://rbs//lib/rbs/ast/declarations.rb#5
module RBS::AST::Declarations; end

# source://rbs//lib/rbs/ast/declarations.rb#383
class RBS::AST::Declarations::AliasDecl < ::RBS::AST::Declarations::Base
  include ::Interfaces::RBS::Interface_HashEqual

  sig do
    params(
      new_name: ::RBS::TypeName,
      old_name: ::RBS::TypeName,
      location: T.nilable(::TypeAliases::RBS::AST::Declarations::AliasDecl::TypeAlias_loc),
      comment: T.nilable(::RBS::AST::Comment)
    ).void
  end
  def initialize(new_name:, old_name:, location:, comment:); end

  sig { returns(T.nilable(::RBS::AST::Comment)) }
  def comment; end

  sig { returns(T.nilable(::TypeAliases::RBS::AST::Declarations::AliasDecl::TypeAlias_loc)) }
  def location; end

  sig { returns(::RBS::TypeName) }
  def new_name; end

  sig { returns(::RBS::TypeName) }
  def old_name; end
end

# source://rbs//lib/rbs/ast/declarations.rb#6
class RBS::AST::Declarations::Base; end

# source://rbs//lib/rbs/ast/declarations.rb#55
class RBS::AST::Declarations::Class < ::RBS::AST::Declarations::Base
  include ::RBS::AST::Declarations::NestedDeclarationHelper
  include ::RBS::AST::Declarations::MixinHelper
  include ::Interfaces::RBS::Interface_HashEqual
  include ::Interfaces::Interface_ToJson

  sig do
    params(
      name: ::RBS::TypeName,
      type_params: ::T::Array[::RBS::AST::TypeParam],
      members: ::T::Array[::TypeAliases::RBS::AST::Declarations::Class::TypeAlias_member],
      super_class: T.nilable(::RBS::AST::Declarations::Class::Super),
      annotations: ::T::Array[::RBS::AST::Annotation],
      location: T.nilable(::TypeAliases::RBS::AST::Declarations::Class::TypeAlias_loc),
      comment: T.nilable(::RBS::AST::Comment)
    ).void
  end
  def initialize(name:, type_params:, members:, super_class:, annotations:, location:, comment:); end

  sig { returns(::T::Array[::RBS::AST::Annotation]) }
  def annotations; end

  sig { returns(T.nilable(::RBS::AST::Comment)) }
  def comment; end

  sig { returns(T.nilable(::TypeAliases::RBS::AST::Declarations::Class::TypeAlias_loc)) }
  def location; end

  sig { returns(::T::Array[::TypeAliases::RBS::AST::Declarations::Class::TypeAlias_member]) }
  def members; end

  sig { returns(::RBS::TypeName) }
  def name; end

  sig { returns(T.nilable(::RBS::AST::Declarations::Class::Super)) }
  def super_class; end

  sig { returns(::T::Array[::RBS::AST::TypeParam]) }
  def type_params; end
end

# source://rbs//lib/rbs/ast/declarations.rb#56
class RBS::AST::Declarations::Class::Super
  include ::Interfaces::RBS::Interface_HashEqual
  include ::Interfaces::Interface_ToJson

  sig do
    params(
      name: ::RBS::TypeName,
      args: ::T::Array[::TypeAliases::RBS::Types::TypeAlias_t],
      location: T.nilable(::TypeAliases::RBS::AST::Declarations::Class::Super::TypeAlias_loc)
    ).void
  end
  def initialize(name:, args:, location:); end

  sig { returns(::T::Array[::TypeAliases::RBS::Types::TypeAlias_t]) }
  def args; end

  sig { returns(T.nilable(::TypeAliases::RBS::AST::Declarations::Class::Super::TypeAlias_loc)) }
  def location; end

  sig { returns(::RBS::TypeName) }
  def name; end
end

# source://rbs//lib/rbs/ast/declarations.rb#406
class RBS::AST::Declarations::ClassAlias < ::RBS::AST::Declarations::AliasDecl
  include ::Interfaces::Interface_ToJson
end

# source://rbs//lib/rbs/ast/declarations.rb#311
class RBS::AST::Declarations::Constant < ::RBS::AST::Declarations::Base
  include ::Interfaces::RBS::Interface_HashEqual
  include ::Interfaces::Interface_ToJson

  sig do
    params(
      name: ::RBS::TypeName,
      type: ::TypeAliases::RBS::Types::TypeAlias_t,
      location: T.nilable(::TypeAliases::RBS::AST::Declarations::Constant::TypeAlias_loc),
      comment: T.nilable(::RBS::AST::Comment)
    ).void
  end
  def initialize(name:, type:, location:, comment:); end

  sig { returns(T.nilable(::RBS::AST::Comment)) }
  def comment; end

  sig { returns(T.nilable(::TypeAliases::RBS::AST::Declarations::Constant::TypeAlias_loc)) }
  def location; end

  sig { returns(::RBS::TypeName) }
  def name; end

  sig { returns(::TypeAliases::RBS::Types::TypeAlias_t) }
  def type; end
end

# source://rbs//lib/rbs/ast/declarations.rb#347
class RBS::AST::Declarations::Global < ::RBS::AST::Declarations::Base
  include ::Interfaces::RBS::Interface_HashEqual
  include ::Interfaces::Interface_ToJson

  sig do
    params(
      name: ::Symbol,
      type: ::TypeAliases::RBS::Types::TypeAlias_t,
      location: T.nilable(::TypeAliases::RBS::AST::Declarations::Global::TypeAlias_loc),
      comment: T.nilable(::RBS::AST::Comment)
    ).void
  end
  def initialize(name:, type:, location:, comment:); end

  sig { returns(T.nilable(::RBS::AST::Comment)) }
  def comment; end

  sig { returns(T.nilable(::TypeAliases::RBS::AST::Declarations::Global::TypeAlias_loc)) }
  def location; end

  sig { returns(::Symbol) }
  def name; end

  sig { returns(::TypeAliases::RBS::Types::TypeAlias_t) }
  def type; end
end

# source://rbs//lib/rbs/ast/declarations.rb#223
class RBS::AST::Declarations::Interface < ::RBS::AST::Declarations::Base
  include ::RBS::AST::Declarations::MixinHelper
  include ::Interfaces::RBS::Interface_HashEqual
  include ::Interfaces::Interface_ToJson

  sig do
    params(
      name: ::RBS::TypeName,
      type_params: ::T::Array[::RBS::AST::TypeParam],
      members: ::T::Array[::TypeAliases::RBS::AST::Declarations::Interface::TypeAlias_member],
      annotations: ::T::Array[::RBS::AST::Annotation],
      location: T.nilable(::TypeAliases::RBS::AST::Declarations::Interface::TypeAlias_loc),
      comment: T.nilable(::RBS::AST::Comment)
    ).void
  end
  def initialize(name:, type_params:, members:, annotations:, location:, comment:); end

  sig { returns(::T::Array[::RBS::AST::Annotation]) }
  def annotations; end

  sig { returns(T.nilable(::RBS::AST::Comment)) }
  def comment; end

  sig { returns(T.nilable(::TypeAliases::RBS::AST::Declarations::Interface::TypeAlias_loc)) }
  def location; end

  sig { returns(::T::Array[::TypeAliases::RBS::AST::Declarations::Interface::TypeAlias_member]) }
  def members; end

  sig { returns(::RBS::TypeName) }
  def name; end

  sig { returns(::T::Array[::RBS::AST::TypeParam]) }
  def type_params; end
end

# source://rbs//lib/rbs/ast/declarations.rb#35
module RBS::AST::Declarations::MixinHelper
  sig do
    params(
      blk: T.proc.params(_arg0: ::TypeAliases::RBS::AST::Declarations::MixinHelper::TypeAlias_mixin_member).void
    ).void
  end
  def each_mixin(&blk); end
end

# source://rbs//lib/rbs/ast/declarations.rb#135
class RBS::AST::Declarations::Module < ::RBS::AST::Declarations::Base
  include ::RBS::AST::Declarations::NestedDeclarationHelper
  include ::RBS::AST::Declarations::MixinHelper
  include ::Interfaces::RBS::Interface_HashEqual
  include ::Interfaces::Interface_ToJson

  sig do
    params(
      name: ::RBS::TypeName,
      type_params: ::T::Array[::RBS::AST::TypeParam],
      members: ::T::Array[::TypeAliases::RBS::AST::Declarations::Module::TypeAlias_member],
      location: T.nilable(::TypeAliases::RBS::AST::Declarations::Module::TypeAlias_loc),
      annotations: ::T::Array[::RBS::AST::Annotation],
      self_types: ::T::Array[::RBS::AST::Declarations::Module::Self],
      comment: T.nilable(::RBS::AST::Comment)
    ).void
  end
  def initialize(name:, type_params:, members:, location:, annotations:, self_types:, comment:); end

  sig { returns(::T::Array[::RBS::AST::Annotation]) }
  def annotations; end

  sig { returns(T.nilable(::RBS::AST::Comment)) }
  def comment; end

  sig { returns(T.nilable(::TypeAliases::RBS::AST::Declarations::Module::TypeAlias_loc)) }
  def location; end

  sig { returns(::T::Array[::TypeAliases::RBS::AST::Declarations::Module::TypeAlias_member]) }
  def members; end

  sig { returns(::RBS::TypeName) }
  def name; end

  sig { returns(::T::Array[::RBS::AST::Declarations::Module::Self]) }
  def self_types; end

  sig { returns(::T::Array[::RBS::AST::TypeParam]) }
  def type_params; end
end

# source://rbs//lib/rbs/ast/declarations.rb#136
class RBS::AST::Declarations::Module::Self
  include ::Interfaces::RBS::Interface_HashEqual
  include ::Interfaces::Interface_ToJson

  sig do
    params(
      name: ::RBS::TypeName,
      args: ::T::Array[::TypeAliases::RBS::Types::TypeAlias_t],
      location: T.nilable(::TypeAliases::RBS::AST::Declarations::Module::Self::TypeAlias_loc)
    ).void
  end
  def initialize(name:, args:, location:); end

  sig { returns(::T::Array[::TypeAliases::RBS::Types::TypeAlias_t]) }
  def args; end

  sig { returns(T.nilable(::TypeAliases::RBS::AST::Declarations::Module::Self::TypeAlias_loc)) }
  def location; end

  sig { returns(::RBS::TypeName) }
  def name; end

  sig { returns(::String) }
  def to_s; end
end

# source://rbs//lib/rbs/ast/declarations.rb#418
class RBS::AST::Declarations::ModuleAlias < ::RBS::AST::Declarations::AliasDecl
  include ::Interfaces::Interface_ToJson
end

# source://rbs//lib/rbs/ast/declarations.rb#9
module RBS::AST::Declarations::NestedDeclarationHelper
  sig { params(blk: T.proc.params(_arg0: ::TypeAliases::RBS::AST::Declarations::TypeAlias_t).void).void }
  def each_decl(&blk); end

  sig { params(blk: T.proc.params(_arg0: ::TypeAliases::RBS::AST::Members::TypeAlias_t).void).void }
  def each_member(&blk); end
end

# source://rbs//lib/rbs/ast/declarations.rb#268
class RBS::AST::Declarations::TypeAlias < ::RBS::AST::Declarations::Base
  include ::Interfaces::RBS::Interface_HashEqual
  include ::Interfaces::Interface_ToJson

  sig do
    params(
      name: ::RBS::TypeName,
      type_params: ::T::Array[::RBS::AST::TypeParam],
      type: ::TypeAliases::RBS::Types::TypeAlias_t,
      annotations: ::T::Array[::RBS::AST::Annotation],
      location: T.nilable(::TypeAliases::RBS::AST::Declarations::TypeAlias::TypeAlias_loc),
      comment: T.nilable(::RBS::AST::Comment)
    ).void
  end
  def initialize(name:, type_params:, type:, annotations:, location:, comment:); end

  sig { returns(::T::Array[::RBS::AST::Annotation]) }
  def annotations; end

  sig { returns(T.nilable(::RBS::AST::Comment)) }
  def comment; end

  sig { returns(T.nilable(::TypeAliases::RBS::AST::Declarations::TypeAlias::TypeAlias_loc)) }
  def location; end

  sig { returns(::RBS::TypeName) }
  def name; end

  sig { returns(::TypeAliases::RBS::Types::TypeAlias_t) }
  def type; end

  sig { returns(::T::Array[::RBS::AST::TypeParam]) }
  def type_params; end
end

# source://rbs//lib/rbs/ast/directives.rb#5
module RBS::AST::Directives; end

# source://rbs//lib/rbs/ast/directives.rb#6
class RBS::AST::Directives::Base; end

# source://rbs//lib/rbs/ast/directives.rb#9
# ```
# use Foo, Foo::Bar as FBar, Foo:Baz::*
#
class RBS::AST::Directives::Use < ::RBS::AST::Directives::Base
  sig do
    params(
      clauses: ::T::Array[::TypeAliases::RBS::AST::Directives::Use::TypeAlias_clause],
      location: T.nilable(::TypeAliases::RBS::AST::Directives::Use::TypeAlias_loc)
    ).void
  end
  def initialize(clauses:, location:); end

  sig { returns(::T::Array[::TypeAliases::RBS::AST::Directives::Use::TypeAlias_clause]) }
  def clauses; end

  sig { returns(T.nilable(::TypeAliases::RBS::AST::Directives::Use::TypeAlias_loc)) }
  def location; end
end

# source://rbs//lib/rbs/ast/directives.rb#10
class RBS::AST::Directives::Use::SingleClause
  sig do
    params(
      type_name: ::RBS::TypeName,
      new_name: T.nilable(::Symbol),
      location: T.nilable(::TypeAliases::RBS::AST::Directives::Use::SingleClause::TypeAlias_loc)
    ).void
  end
  def initialize(type_name:, new_name:, location:); end

  sig { returns(T.nilable(::TypeAliases::RBS::AST::Directives::Use::SingleClause::TypeAlias_loc)) }
  def location; end

  sig { returns(T.nilable(::Symbol)) }
  def new_name; end

  sig { returns(::RBS::TypeName) }
  def type_name; end
end

# source://rbs//lib/rbs/ast/directives.rb#20
class RBS::AST::Directives::Use::WildcardClause
  sig do
    params(
      namespace: ::RBS::Namespace,
      location: T.nilable(::TypeAliases::RBS::AST::Directives::Use::WildcardClause::TypeAlias_loc)
    ).void
  end
  def initialize(namespace:, location:); end

  sig { returns(T.nilable(::TypeAliases::RBS::AST::Directives::Use::WildcardClause::TypeAlias_loc)) }
  def location; end

  sig { returns(::RBS::Namespace) }
  def namespace; end
end

# source://rbs//lib/rbs/ast/members.rb#5
module RBS::AST::Members; end

# source://rbs//lib/rbs/ast/members.rb#397
class RBS::AST::Members::Alias < ::RBS::AST::Members::Base
  include ::Interfaces::RBS::Interface_HashEqual
  include ::Interfaces::Interface_ToJson

  sig do
    params(
      new_name: ::Symbol,
      old_name: ::Symbol,
      kind: ::TypeAliases::RBS::AST::Members::Alias::TypeAlias_kind,
      annotations: ::T::Array[::RBS::AST::Annotation],
      location: T.nilable(::TypeAliases::RBS::AST::Members::Alias::TypeAlias_loc),
      comment: T.nilable(::RBS::AST::Comment)
    ).void
  end
  def initialize(new_name:, old_name:, kind:, annotations:, location:, comment:); end

  sig { returns(::T::Array[::RBS::AST::Annotation]) }
  def annotations; end

  sig { returns(T.nilable(::RBS::AST::Comment)) }
  def comment; end

  sig { returns(T::Boolean) }
  def instance?; end

  sig { returns(::TypeAliases::RBS::AST::Members::Alias::TypeAlias_kind) }
  def kind; end

  sig { returns(T.nilable(::TypeAliases::RBS::AST::Members::Alias::TypeAlias_loc)) }
  def location; end

  sig { returns(::Symbol) }
  def new_name; end

  sig { returns(::Symbol) }
  def old_name; end

  sig { returns(T::Boolean) }
  def singleton?; end
end

# source://rbs//lib/rbs/ast/members.rb#327
class RBS::AST::Members::AttrAccessor < ::RBS::AST::Members::Base
  include ::RBS::AST::Members::Attribute
  include ::Interfaces::Interface_ToJson
end

# source://rbs//lib/rbs/ast/members.rb#309
class RBS::AST::Members::AttrReader < ::RBS::AST::Members::Base
  include ::RBS::AST::Members::Attribute
  include ::Interfaces::Interface_ToJson
end

# source://rbs//lib/rbs/ast/members.rb#345
class RBS::AST::Members::AttrWriter < ::RBS::AST::Members::Base
  include ::RBS::AST::Members::Attribute
  include ::Interfaces::Interface_ToJson
end

# source://rbs//lib/rbs/ast/members.rb#258
module RBS::AST::Members::Attribute
  include ::Interfaces::RBS::Interface_HashEqual

  sig do
    params(
      name: ::Symbol,
      type: ::TypeAliases::RBS::Types::TypeAlias_t,
      ivar_name: T.nilable(T.any(::Symbol, T.untyped)),
      kind: ::TypeAliases::RBS::AST::Members::Attribute::TypeAlias_kind,
      annotations: ::T::Array[::RBS::AST::Annotation],
      location: T.nilable(::TypeAliases::RBS::AST::Members::Attribute::TypeAlias_loc),
      comment: T.nilable(::RBS::AST::Comment),
      visibility: T.nilable(::TypeAliases::RBS::AST::Members::TypeAlias_visibility)
    ).void
  end
  def initialize(name:, type:, ivar_name:, kind:, annotations:, location:, comment:, visibility: T.unsafe(nil)); end

  sig { returns(::T::Array[::RBS::AST::Annotation]) }
  def annotations; end

  sig { returns(T.nilable(::RBS::AST::Comment)) }
  def comment; end

  sig { returns(T.nilable(T.any(::Symbol, T.untyped))) }
  def ivar_name; end

  sig { returns(::TypeAliases::RBS::AST::Members::Attribute::TypeAlias_kind) }
  def kind; end

  sig { returns(T.nilable(::TypeAliases::RBS::AST::Members::Attribute::TypeAlias_loc)) }
  def location; end

  sig { returns(::Symbol) }
  def name; end

  sig { returns(::TypeAliases::RBS::Types::TypeAlias_t) }
  def type; end

  sig do
    params(
      name: ::Symbol,
      type: ::TypeAliases::RBS::Types::TypeAlias_t,
      ivar_name: T.nilable(T.any(::Symbol, T.untyped)),
      kind: ::TypeAliases::RBS::AST::Members::Attribute::TypeAlias_kind,
      annotations: ::T::Array[::RBS::AST::Annotation],
      location: T.nilable(::TypeAliases::RBS::AST::Members::Attribute::TypeAlias_loc),
      comment: T.nilable(::RBS::AST::Comment),
      visibility: T.nilable(::TypeAliases::RBS::AST::Members::TypeAlias_visibility)
    ).returns(T.untyped)
  end
  def update(name: T.unsafe(nil), type: T.unsafe(nil), ivar_name: T.unsafe(nil), kind: T.unsafe(nil), annotations: T.unsafe(nil), location: T.unsafe(nil), comment: T.unsafe(nil), visibility: T.unsafe(nil)); end

  sig { returns(T.nilable(::TypeAliases::RBS::AST::Members::TypeAlias_visibility)) }
  def visibility; end
end

# source://rbs//lib/rbs/ast/members.rb#6
# Base class for members.
class RBS::AST::Members::Base; end

# source://rbs//lib/rbs/ast/members.rb#157
class RBS::AST::Members::ClassInstanceVariable < ::RBS::AST::Members::Base
  include ::RBS::AST::Members::Var
  include ::Interfaces::Interface_ToJson
end

# source://rbs//lib/rbs/ast/members.rb#171
class RBS::AST::Members::ClassVariable < ::RBS::AST::Members::Base
  include ::RBS::AST::Members::Var
  include ::Interfaces::Interface_ToJson
end

# source://rbs//lib/rbs/ast/members.rb#228
class RBS::AST::Members::Extend < ::RBS::AST::Members::Base
  include ::RBS::AST::Members::Mixin
  include ::Interfaces::Interface_ToJson
end

# source://rbs//lib/rbs/ast/members.rb#213
class RBS::AST::Members::Include < ::RBS::AST::Members::Base
  include ::RBS::AST::Members::Mixin
  include ::Interfaces::Interface_ToJson
end

# source://rbs//lib/rbs/ast/members.rb#143
class RBS::AST::Members::InstanceVariable < ::RBS::AST::Members::Base
  include ::RBS::AST::Members::Var
  include ::Interfaces::Interface_ToJson
end

# source://rbs//lib/rbs/ast/members.rb#363
module RBS::AST::Members::LocationOnly
  include ::Interfaces::RBS::Interface_HashEqual

  sig { params(location: T.nilable(::RBS::Location[T.untyped, T.untyped])).void }
  def initialize(location:); end

  sig { returns(T.nilable(::RBS::Location[T.untyped, T.untyped])) }
  def location; end
end

# source://rbs//lib/rbs/ast/members.rb#9
class RBS::AST::Members::MethodDefinition < ::RBS::AST::Members::Base
  include ::Interfaces::RBS::Interface_HashEqual
  include ::Interfaces::Interface_ToJson

  sig do
    params(
      name: ::Symbol,
      kind: ::TypeAliases::RBS::AST::Members::MethodDefinition::TypeAlias_kind,
      overloads: ::T::Array[::RBS::AST::Members::MethodDefinition::Overload],
      annotations: ::T::Array[::RBS::AST::Annotation],
      location: T.nilable(::TypeAliases::RBS::AST::Members::MethodDefinition::TypeAlias_loc),
      comment: T.nilable(::RBS::AST::Comment),
      overloading: T::Boolean,
      visibility: T.nilable(::TypeAliases::RBS::AST::Members::TypeAlias_visibility)
    ).void
  end
  def initialize(name:, kind:, overloads:, annotations:, location:, comment:, overloading:, visibility:); end

  sig { returns(::T::Array[::RBS::AST::Annotation]) }
  def annotations; end

  sig { returns(T.nilable(::RBS::AST::Comment)) }
  def comment; end

  # Returns true if the `def` is to define instance method
  sig { returns(T::Boolean) }
  def instance?; end

  sig { returns(::TypeAliases::RBS::AST::Members::MethodDefinition::TypeAlias_kind) }
  def kind; end

  sig { returns(T.nilable(::TypeAliases::RBS::AST::Members::MethodDefinition::TypeAlias_loc)) }
  def location; end

  sig { returns(::Symbol) }
  def name; end

  sig { returns(T::Boolean) }
  def overloading; end

  # Returns true if the `def` is overloading (== with `...`)
  #
  sig { returns(T::Boolean) }
  def overloading?; end

  sig { returns(::T::Array[::RBS::AST::Members::MethodDefinition::Overload]) }
  def overloads; end

  # Returns true if the `def` is to define singleton method
  sig { returns(T::Boolean) }
  def singleton?; end

  sig do
    params(
      name: ::Symbol,
      kind: ::TypeAliases::RBS::AST::Members::MethodDefinition::TypeAlias_kind,
      overloads: ::T::Array[::RBS::AST::Members::MethodDefinition::Overload],
      annotations: ::T::Array[::RBS::AST::Annotation],
      location: T.nilable(::TypeAliases::RBS::AST::Members::MethodDefinition::TypeAlias_loc),
      comment: T.nilable(::RBS::AST::Comment),
      overloading: T::Boolean,
      visibility: T.nilable(::TypeAliases::RBS::AST::Members::TypeAlias_visibility)
    ).returns(::RBS::AST::Members::MethodDefinition)
  end
  def update(name: T.unsafe(nil), kind: T.unsafe(nil), overloads: T.unsafe(nil), annotations: T.unsafe(nil), location: T.unsafe(nil), comment: T.unsafe(nil), overloading: T.unsafe(nil), visibility: T.unsafe(nil)); end

  sig { returns(T.nilable(::TypeAliases::RBS::AST::Members::TypeAlias_visibility)) }
  def visibility; end
end

# source://rbs//lib/rbs/ast/members.rb#10
class RBS::AST::Members::MethodDefinition::Overload
  include ::Interfaces::Interface_ToJson

  alias eql? ==

  sig { params(method_type: ::RBS::MethodType, annotations: ::T::Array[::RBS::AST::Annotation]).void }
  def initialize(method_type:, annotations:); end

  sig { params(_arg0: T.untyped).returns(T::Boolean) }
  def ==(_arg0); end

  sig { returns(::T::Array[::RBS::AST::Annotation]) }
  def annotations; end

  sig { returns(::Integer) }
  def hash; end

  sig { returns(::RBS::MethodType) }
  def method_type; end

  sig { params(_arg0: ::RBS::Substitution).returns(::RBS::AST::Members::MethodDefinition::Overload) }
  def sub(_arg0); end

  sig do
    params(
      annotations: ::T::Array[::RBS::AST::Annotation],
      method_type: ::RBS::MethodType
    ).returns(::RBS::AST::Members::MethodDefinition::Overload)
  end
  def update(annotations: T.unsafe(nil), method_type: T.unsafe(nil)); end
end

# source://rbs//lib/rbs/ast/members.rb#185
module RBS::AST::Members::Mixin
  include ::Interfaces::RBS::Interface_HashEqual

  sig do
    params(
      name: ::RBS::TypeName,
      args: ::T::Array[::TypeAliases::RBS::Types::TypeAlias_t],
      annotations: ::T::Array[::RBS::AST::Annotation],
      location: T.nilable(::TypeAliases::RBS::AST::Members::Mixin::TypeAlias_loc),
      comment: T.nilable(::RBS::AST::Comment)
    ).void
  end
  def initialize(name:, args:, annotations:, location:, comment:); end

  sig { returns(::T::Array[::RBS::AST::Annotation]) }
  def annotations; end

  sig { returns(::T::Array[::TypeAliases::RBS::Types::TypeAlias_t]) }
  def args; end

  sig { returns(T.nilable(::RBS::AST::Comment)) }
  def comment; end

  sig { returns(T.nilable(::TypeAliases::RBS::AST::Members::Mixin::TypeAlias_loc)) }
  def location; end

  sig { returns(::RBS::TypeName) }
  def name; end
end

# source://rbs//lib/rbs/ast/members.rb#243
class RBS::AST::Members::Prepend < ::RBS::AST::Members::Base
  include ::RBS::AST::Members::Mixin
  include ::Interfaces::Interface_ToJson
end

# source://rbs//lib/rbs/ast/members.rb#389
class RBS::AST::Members::Private < ::RBS::AST::Members::Base
  include ::RBS::AST::Members::LocationOnly
  include ::Interfaces::Interface_ToJson
end

# source://rbs//lib/rbs/ast/members.rb#381
class RBS::AST::Members::Public < ::RBS::AST::Members::Base
  include ::RBS::AST::Members::LocationOnly
  include ::Interfaces::Interface_ToJson
end

# source://rbs//lib/rbs/ast/members.rb#119
module RBS::AST::Members::Var
  include ::Interfaces::RBS::Interface_HashEqual

  sig do
    params(
      name: ::Symbol,
      type: ::TypeAliases::RBS::Types::TypeAlias_t,
      location: T.nilable(::TypeAliases::RBS::AST::Members::Var::TypeAlias_loc),
      comment: T.nilable(::RBS::AST::Comment)
    ).void
  end
  def initialize(name:, type:, location:, comment:); end

  sig { returns(T.nilable(::RBS::AST::Comment)) }
  def comment; end

  sig { returns(T.nilable(::TypeAliases::RBS::AST::Members::Var::TypeAlias_loc)) }
  def location; end

  sig { returns(::Symbol) }
  def name; end

  sig { returns(::TypeAliases::RBS::Types::TypeAlias_t) }
  def type; end
end

# source://rbs//lib/rbs/ast/type_param.rb#5
class RBS::AST::TypeParam
  include ::Interfaces::Interface_ToJson

  sig do
    params(
      name: ::Symbol,
      variance: ::TypeAliases::RBS::AST::TypeParam::TypeAlias_variance,
      upper_bound: T.nilable(::TypeAliases::RBS::AST::TypeParam::TypeAlias_bound),
      location: T.nilable(::TypeAliases::RBS::AST::TypeParam::TypeAlias_loc)
    ).void
  end
  def initialize(name:, variance:, upper_bound:, location:); end

  sig { params(_arg0: T.untyped).returns(T::Boolean) }
  def ==(_arg0); end

  sig { params(_arg0: T.untyped).returns(T::Boolean) }
  def eql?(_arg0); end

  sig { returns(::Integer) }
  def hash; end

  sig { returns(T.nilable(::TypeAliases::RBS::AST::TypeParam::TypeAlias_loc)) }
  def location; end

  sig do
    params(
      blk: T.proc.params(_arg0: ::TypeAliases::RBS::AST::TypeParam::TypeAlias_bound).returns(::TypeAliases::RBS::AST::TypeParam::TypeAlias_bound)
    ).returns(::RBS::AST::TypeParam)
  end
  def map_type(&blk); end

  sig { returns(::Symbol) }
  def name; end

  sig { returns(::String) }
  def to_s; end

  sig { params(_arg0: ::TypeAliases::TypeAlias_boolish).returns(T.self_type) }
  def unchecked!(_arg0 = T.unsafe(nil)); end

  sig { returns(T::Boolean) }
  def unchecked?; end

  sig { returns(T.nilable(::TypeAliases::RBS::AST::TypeParam::TypeAlias_bound)) }
  def upper_bound; end

  sig { returns(::TypeAliases::RBS::AST::TypeParam::TypeAlias_variance) }
  def variance; end

  class << self
    # Rename type parameter name.
    #
    # The renaming cannot be done separately because a set of `TypeParam` decls may be mutual recursive.
    #
    # Example:
    #
    # * Renaming `A -> X, B -> Y`
    # * Input `[A, B < _Pushable[A]]`
    # * Result `[X, Y < _Pushable[X]]`
    #
    sig do
      params(
        _arg0: ::T::Array[::RBS::AST::TypeParam],
        new_names: ::T::Array[::Symbol]
      ).returns(::T::Array[::RBS::AST::TypeParam])
    end
    def rename(_arg0, new_names:); end

    # Helper function to resolve _class instance types_ to _type variables_.
    #
    # We need this step because RBS language has an identical syntax for both unqualified class instance types and type variables.
    # `String` may be an instance of `::String` class or type variable depending on the list of bound type variables.
    #
    # So, we need second pass to parse the following generics parameter declaration.
    #
    # ```rbs
    # class Foo[X < _Each[Y], Y]
    #                   # ^ We want this `Y` to be a type variable.
    # end
    # ```
    #
    sig { params(_arg0: ::T::Array[::RBS::AST::TypeParam]).void }
    def resolve_variables(_arg0); end

    sig do
      params(
        _arg0: ::T::Set[::Symbol],
        _arg1: ::TypeAliases::RBS::Types::TypeAlias_t
      ).returns(::TypeAliases::RBS::Types::TypeAlias_t)
    end
    def subst_var(_arg0, _arg1); end
  end
end

# source://rbs//lib/rbs/ancestor_graph.rb#4
# AncestorGraph is a utility class that helps iterating through ancestors and decendants of a class/module
#
# ```ruby
# graph = AncestorGraph.new(env: env, ancestor_builder: ancestor_builder)
# graph.each_parent(AncestorGraph::InstanceNode.new(type_name: TypeName("::Object")))
# graph.each_ancestor(AncestorGraph::InstanceNode.new(type_name: TypeName("::Object")))
# graph.each_child(AncestorGraph::InstanceNode.new(type_name: TypeName("::Object")))
# graph.each_descendant(AncestorGraph::InstanceNode.new(type_name: TypeName("::Object")))
# ```
# Note that the class works for class/module declarations.
# All of the *alias* classes/modules are ignored.
# * Alias classes/modules doesn't count as a parent nor child
# * Passing alias classes/modules to the method doesn't yield anything
class RBS::AncestorGraph
  sig { params(env: ::RBS::Environment, ancestor_builder: ::RBS::DefinitionBuilder::AncestorBuilder).void }
  def initialize(env:, ancestor_builder: T.unsafe(nil)); end

  sig { returns(::RBS::DefinitionBuilder::AncestorBuilder) }
  def ancestor_builder; end

  sig do
    returns(::T::Hash[::TypeAliases::RBS::AncestorGraph::TypeAlias_node, ::T::Set[::TypeAliases::RBS::AncestorGraph::TypeAlias_node]])
  end
  def children; end

  sig do
    params(
      _arg0: ::TypeAliases::RBS::AncestorGraph::TypeAlias_node,
      yielded: ::T::Set[::TypeAliases::RBS::AncestorGraph::TypeAlias_node],
      blk: T.proc.params(_arg0: ::TypeAliases::RBS::AncestorGraph::TypeAlias_node).void
    ).void
  end
  def each_ancestor(_arg0, yielded: T.unsafe(nil), &blk); end

  sig do
    params(
      _arg0: ::TypeAliases::RBS::AncestorGraph::TypeAlias_node,
      blk: T.proc.params(_arg0: ::TypeAliases::RBS::AncestorGraph::TypeAlias_node).void
    ).void
  end
  def each_child(_arg0, &blk); end

  sig do
    params(
      _arg0: ::TypeAliases::RBS::AncestorGraph::TypeAlias_node,
      yielded: ::T::Set[::TypeAliases::RBS::AncestorGraph::TypeAlias_node],
      blk: T.proc.params(_arg0: ::TypeAliases::RBS::AncestorGraph::TypeAlias_node).void
    ).void
  end
  def each_descendant(_arg0, yielded: T.unsafe(nil), &blk); end

  sig do
    params(
      _arg0: ::TypeAliases::RBS::AncestorGraph::TypeAlias_node,
      blk: T.proc.params(_arg0: ::TypeAliases::RBS::AncestorGraph::TypeAlias_node).void
    ).void
  end
  def each_parent(_arg0, &blk); end

  sig { returns(::RBS::Environment) }
  def env; end

  sig do
    returns(::T::Hash[::TypeAliases::RBS::AncestorGraph::TypeAlias_node, ::T::Set[::TypeAliases::RBS::AncestorGraph::TypeAlias_node]])
  end
  def parents; end

  private

  sig { void }
  def build; end

  sig do
    params(
      _arg0: ::TypeAliases::RBS::AncestorGraph::TypeAlias_node,
      _arg1: ::RBS::DefinitionBuilder::AncestorBuilder::OneAncestors
    ).void
  end
  def build_ancestors(_arg0, _arg1); end

  sig do
    params(
      parent: ::TypeAliases::RBS::AncestorGraph::TypeAlias_node,
      child: ::TypeAliases::RBS::AncestorGraph::TypeAlias_node
    ).void
  end
  def register(parent:, child:); end
end

# source://rbs//lib/rbs/ancestor_graph.rb#5
class RBS::AncestorGraph::InstanceNode < ::Struct
  sig { params(type_name: ::RBS::TypeName).void }
  def initialize(type_name:); end

  sig { returns(::RBS::TypeName) }
  def type_name; end
end

# source://rbs//lib/rbs/ancestor_graph.rb#6
class RBS::AncestorGraph::SingletonNode < ::Struct
  sig { params(type_name: ::RBS::TypeName).void }
  def initialize(type_name:); end

  sig { returns(::RBS::TypeName) }
  def type_name; end
end

# source://rbs//lib/rbs/errors.rb#19
# Error class for errors defined in RBS.
#
class RBS::BaseError < ::StandardError; end

# source://rbs//lib/rbs/buffer.rb#4
class RBS::Buffer
  sig { params(name: T.untyped, content: ::String).void }
  def initialize(name:, content:); end

  sig { returns(::String) }
  def content; end

  sig { returns(::Integer) }
  def last_position; end

  sig { returns(::T::Array[::String]) }
  def lines; end

  # Translate location to position.
  sig { params(loc: ::TypeAliases::RBS::Buffer::TypeAlias_loc).returns(::Integer) }
  def loc_to_pos(loc); end

  sig { returns(T.untyped) }
  def name; end

  # Translate position to location.
  sig { params(pos: ::Integer).returns(::TypeAliases::RBS::Buffer::TypeAlias_loc) }
  def pos_to_loc(pos); end

  sig { returns(::T::Array[::T::Range[::Integer]]) }
  def ranges; end
end

# source://rbs//lib/rbs/builtin_names.rb#4
module RBS::BuiltinNames; end

# source://rbs//lib/rbs/builtin_names.rb#45
RBS::BuiltinNames::Array = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)

# source://rbs//lib/rbs/builtin_names.rb#37
RBS::BuiltinNames::BasicObject = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)

# source://rbs//lib/rbs/builtin_names.rb#43
RBS::BuiltinNames::Class = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)

# source://rbs//lib/rbs/builtin_names.rb#41
RBS::BuiltinNames::Comparable = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)

# source://rbs//lib/rbs/builtin_names.rb#42
RBS::BuiltinNames::Enumerable = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)

# source://rbs//lib/rbs/builtin_names.rb#48
RBS::BuiltinNames::Enumerator = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)

# source://rbs//lib/rbs/builtin_names.rb#55
RBS::BuiltinNames::FalseClass = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)

# source://rbs//lib/rbs/builtin_names.rb#52
RBS::BuiltinNames::Float = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)

# source://rbs//lib/rbs/builtin_names.rb#46
RBS::BuiltinNames::Hash = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)

# source://rbs//lib/rbs/builtin_names.rb#51
RBS::BuiltinNames::Integer = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)

# source://rbs//lib/rbs/builtin_names.rb#39
RBS::BuiltinNames::Kernel = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)

# source://rbs//lib/rbs/builtin_names.rb#44
RBS::BuiltinNames::Module = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)

# source://rbs//lib/rbs/builtin_names.rb#5
class RBS::BuiltinNames::Name
  sig { params(name: ::RBS::TypeName).void }
  def initialize(name:); end

  sig { params(_arg0: ::TypeAliases::RBS::Types::TypeAlias_t).returns(::RBS::Types::ClassInstance) }
  def instance_type(*_arg0); end

  sig { params(_arg0: ::TypeAliases::RBS::Types::TypeAlias_t).returns(T::Boolean) }
  def instance_type?(_arg0); end

  sig { returns(::RBS::TypeName) }
  def name; end

  sig { returns(::RBS::Types::ClassSingleton) }
  def singleton_type; end

  sig { params(_arg0: ::TypeAliases::RBS::Types::TypeAlias_t).returns(T::Boolean) }
  def singleton_type?(_arg0); end

  sig { returns(::String) }
  def to_s; end

  class << self
    sig { params(_arg0: ::Symbol, namespace: ::RBS::Namespace).returns(T.attached_class) }
    def define(_arg0, namespace: T.unsafe(nil)); end
  end
end

# source://rbs//lib/rbs/builtin_names.rb#56
RBS::BuiltinNames::Numeric = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)

# source://rbs//lib/rbs/builtin_names.rb#38
RBS::BuiltinNames::Object = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)

# source://rbs//lib/rbs/builtin_names.rb#47
RBS::BuiltinNames::Range = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)

# source://rbs//lib/rbs/builtin_names.rb#53
RBS::BuiltinNames::Regexp = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)

# source://rbs//lib/rbs/builtin_names.rb#49
RBS::BuiltinNames::Set = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)

# source://rbs//lib/rbs/builtin_names.rb#40
RBS::BuiltinNames::String = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)

# source://rbs//lib/rbs/builtin_names.rb#50
RBS::BuiltinNames::Symbol = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)

# source://rbs//lib/rbs/builtin_names.rb#54
RBS::BuiltinNames::TrueClass = T.let(T.unsafe(nil), RBS::BuiltinNames::Name)

# source://rbs//lib/rbs/collection/sources/base.rb#4
module RBS::Collection; end

# source://rbs//lib/rbs/collection/cleaner.rb#5
class RBS::Collection::Cleaner
  sig { params(lockfile_path: ::Pathname).void }
  def initialize(lockfile_path:); end

  sig { void }
  def clean; end

  sig { returns(::RBS::Collection::Config) }
  def lock; end

  sig { params(gem_name: ::String, version: ::String).returns(T::Boolean) }
  def needed?(gem_name, version); end
end

# This class represent the configuration file.
#
# source://rbs//lib/rbs/collection/config.rb#7
class RBS::Collection::Config
  # config_path is necessary to resolve relative repo_path
  sig { params(data: T.untyped, config_path: ::Pathname).void }
  def initialize(data, config_path:); end

  sig { returns(::Pathname) }
  def config_path; end

  sig { returns(T.untyped) }
  def data; end

  sig { params(gem_name: ::String).returns(T.nilable(::TypeAliases::RBS::Collection::Config::TypeAlias_gem_entry)) }
  def gem(gem_name); end

  sig { returns(::T::Array[::TypeAliases::RBS::Collection::Config::TypeAlias_gem_entry]) }
  def gems; end

  sig { returns(::Pathname) }
  def repo_path; end

  sig { returns(::Pathname) }
  def repo_path_data; end

  sig { returns(::T::Array[::TypeAliases::RBS::Collection::Sources::TypeAlias_t]) }
  def sources; end

  class << self
    sig { returns(T.nilable(::Pathname)) }
    def find_config_path; end

    sig { params(path: ::Pathname).returns(::RBS::Collection::Config) }
    def from_path(path); end

    sig do
      params(
        config_path: ::Pathname,
        definition: ::Bundler::Definition,
        with_lockfile: ::TypeAliases::TypeAlias_boolish
      ).returns([::RBS::Collection::Config, ::RBS::Collection::Config::Lockfile])
    end
    def generate_lockfile(config_path:, definition:, with_lockfile: T.unsafe(nil)); end

    sig { params(config_path: ::Pathname).returns(::Pathname) }
    def to_lockfile_path(config_path); end
  end
end

# source://rbs//lib/rbs/collection/config.rb#8
class RBS::Collection::Config::CollectionNotAvailable < ::StandardError
  sig { void }
  def initialize; end
end

# source://rbs//lib/rbs/collection/config/lockfile.rb#6
# Lockfile represents the `rbs_collection.lock.yaml`, that contains configurations and *resolved* gems with their sources
#
class RBS::Collection::Config::Lockfile
  sig { params(lockfile_path: ::Pathname, path: ::Pathname, gemfile_lock_path: T.nilable(::Pathname)).void }
  def initialize(lockfile_path:, path:, gemfile_lock_path:); end

  # Validates if directories are set up correctly
  #
  # * Ensures if `path` is a directory
  # * Ensures if `git` sources are set up correctly
  #
  sig { void }
  def check_rbs_availability!; end

  sig { params(blk: T.proc.params(_arg0: ::TypeAliases::RBS::Collection::Sources::TypeAlias_t).void).void }
  def each_source(&blk); end

  # `lockfile_dir` + `path`
  #
  sig { returns(::Pathname) }
  def fullpath; end

  # `lockfile_dir` + `gemfile_lock_path`
  #
  sig { returns(T.nilable(::Pathname)) }
  def gemfile_lock_fullpath; end

  sig { returns(T.nilable(::Pathname)) }
  def gemfile_lock_path; end

  sig { returns(::T::Hash[::String, ::TypeAliases::RBS::Collection::Config::Lockfile::TypeAlias_library]) }
  def gems; end

  sig { returns(::Pathname) }
  def lockfile_dir; end

  sig { returns(::Pathname) }
  def lockfile_path; end

  sig { returns(::Pathname) }
  def path; end

  sig { returns(::T::Hash[::String, ::RBS::Collection::Sources::Git]) }
  def sources; end

  sig { returns(::TypeAliases::RBS::Collection::Config::Lockfile::TypeAlias_lockfile_data) }
  def to_lockfile; end

  private

  sig do
    params(
      _arg0: ::TypeAliases::RBS::Collection::Config::Lockfile::TypeAlias_library
    ).returns(::TypeAliases::RBS::Collection::Config::Lockfile::TypeAlias_library_data)
  end
  def library_data(_arg0); end

  class << self
    sig do
      params(
        lockfile_path: ::Pathname,
        data: ::TypeAliases::RBS::Collection::Config::Lockfile::TypeAlias_lockfile_data
      ).returns(::RBS::Collection::Config::Lockfile)
    end
    def from_lockfile(lockfile_path:, data:); end
  end
end

# source://rbs//lib/rbs/collection/config/lockfile_generator.rb#6
class RBS::Collection::Config::LockfileGenerator
  sig do
    params(
      config: ::RBS::Collection::Config,
      definition: ::Bundler::Definition,
      with_lockfile: ::TypeAliases::TypeAlias_boolish
    ).void
  end
  def initialize(config:, definition:, with_lockfile:); end

  sig { returns(::RBS::Collection::Config) }
  def config; end

  sig { returns(::Bundler::Definition) }
  def definition; end

  sig { returns(T.nilable(::RBS::Collection::Config::Lockfile)) }
  def existing_lockfile; end

  sig { returns(::T::Hash[::String, ::Bundler::LazySpecification]) }
  def gem_hash; end

  sig { void }
  def generate; end

  sig { returns(::RBS::Collection::Config::Lockfile) }
  def lockfile; end

  private

  # Inserts a entry to lockfile of a gem and its dependencies, if not included in `ignored_gems:`
  #
  sig do
    params(
      name: ::String,
      version: T.nilable(::String),
      src_data: T.nilable(::TypeAliases::RBS::Collection::Sources::TypeAlias_source_entry),
      ignored_gems: ::T::Set[::String]
    ).void
  end
  def assign_gem(name:, version:, src_data:, ignored_gems:); end

  sig { params(name: ::String, from_gem: T.nilable(::String)).void }
  def assign_stdlib(name:, from_gem:); end

  sig { params(version: T.nilable(::String), versions: ::T::Array[::String]).returns(::Gem::Version) }
  def find_best_version(version:, versions:); end

  # Find a source of a gem from ones registered in `config.sources`
  #
  # Returns `nil` if no source contains the definition of the gem.
  #
  sig { params(name: ::String).returns(T.nilable(::TypeAliases::RBS::Collection::Sources::TypeAlias_t)) }
  def find_source(name:); end

  # Ensure if current `gemfile_lock_path` is the same with the path saved in `lock`
  #
  sig { params(lock: T.nilable(::RBS::Collection::Config::Lockfile), gemfile_lock_path: ::Pathname).void }
  def validate_gemfile_lock_path!(lock:, gemfile_lock_path:); end

  class << self
    sig do
      params(
        config: ::RBS::Collection::Config,
        definition: ::Bundler::Definition,
        with_lockfile: ::TypeAliases::TypeAlias_boolish
      ).returns(::RBS::Collection::Config::Lockfile)
    end
    def generate(config:, definition:, with_lockfile: T.unsafe(nil)); end
  end
end

# source://rbs//lib/rbs/collection/config/lockfile_generator.rb#7
class RBS::Collection::Config::LockfileGenerator::GemfileLockMismatchError < ::StandardError
  sig { params(expected: ::Pathname, actual: ::Pathname).void }
  def initialize(expected:, actual:); end

  sig { returns(::String) }
  def message; end
end

# source://rbs//lib/rbs/collection/config.rb#17
RBS::Collection::Config::PATH = T.let(T.unsafe(nil), Pathname)

# source://rbs//lib/rbs/collection/installer.rb#5
class RBS::Collection::Installer
  sig { params(lockfile_path: ::Pathname, stdout: ::Interfaces::RBS::CLI::Interface_IO).void }
  def initialize(lockfile_path:, stdout: T.unsafe(nil)); end

  sig { void }
  def install_from_lockfile; end

  sig { returns(::RBS::Collection::Config::Lockfile) }
  def lockfile; end

  sig { returns(::Interfaces::RBS::CLI::Interface_IO) }
  def stdout; end

  private

  sig do
    params(
      _arg0: ::TypeAliases::RBS::Collection::Config::TypeAlias_gem_entry
    ).returns(::Interfaces::RBS::Collection::Sources::Interface_Source)
  end
  def source_for(_arg0); end
end

# source://rbs//lib/rbs/collection/sources/base.rb#5
module RBS::Collection::Sources
  class << self
    sig do
      params(
        _arg0: ::TypeAliases::RBS::Collection::Sources::Git::TypeAlias_source_entry,
        base_directory: ::Pathname
      ).returns(::RBS::Collection::Sources::Git)
    end
    def from_config_entry(_arg0, base_directory:); end
  end
end

# source://rbs//lib/rbs/collection/sources/base.rb#6
module RBS::Collection::Sources::Base
  sig do
    params(
      name: ::String,
      version: ::String
    ).returns(T.nilable(::T::Array[::TypeAliases::RBS::Collection::Sources::TypeAlias_manifest_dependency]))
  end
  def dependencies_of(name, version); end
end

# source://rbs//lib/rbs/collection/sources/git.rb#10
class RBS::Collection::Sources::Git
  include ::RBS::Collection::Sources::Base

  sig { params(name: ::String, revision: ::String, remote: ::String, repo_dir: T.nilable(::String)).void }
  def initialize(name:, revision:, remote:, repo_dir:); end

  sig { params(name: ::String, version: T.nilable(::String)).returns(::TypeAliases::TypeAlias_boolish) }
  def has?(name, version); end

  sig do
    params(
      dest: ::Pathname,
      name: ::String,
      version: ::String,
      stdout: ::Interfaces::RBS::CLI::Interface_IO
    ).void
  end
  def install(dest:, name:, version:, stdout:); end

  sig do
    params(
      name: ::String,
      version: ::String
    ).returns(T.nilable(::TypeAliases::RBS::Collection::Sources::TypeAlias_manifest_entry))
  end
  def manifest_of(name, version); end

  sig { returns(::String) }
  def name; end

  sig { returns(::String) }
  def remote; end

  sig { returns(::String) }
  def repo_dir; end

  sig { returns(::String) }
  def resolved_revision; end

  sig { returns(::String) }
  def revision; end

  sig { returns(::TypeAliases::RBS::Collection::Sources::Git::TypeAlias_source_entry) }
  def to_lockfile; end

  sig { params(name: ::String).returns(::T::Array[::String]) }
  def versions(name); end

  private

  sig { params(dest: ::Pathname, name: ::String, version: ::String).void }
  def _install(dest:, name:, version:); end

  # Returns `true` if `revision` looks like a commit hash
  sig { returns(T::Boolean) }
  def commit_hash?; end

  sig { params(_arg0: ::Pathname, _arg1: ::Pathname).void }
  def cp_r(_arg0, _arg1); end

  sig { params(name: ::String, version: ::String).returns(::String) }
  def format_config_entry(name, version); end

  # The full path of `repo_dir` in the local git repository
  sig { returns(::Pathname) }
  def gem_repo_dir; end

  sig { returns(::T::Hash[::String, ::T::Set[::String]]) }
  def gems_versions; end

  # Executes a git command, raises an error if failed
  sig { params(cmd: ::String, opt: T.untyped).returns(::String) }
  def git(*cmd, **opt); end

  # Executes a git command, returns `nil` if failed
  sig { params(cmd: ::String, opt: T.untyped).returns(T.nilable(::String)) }
  def git?(*cmd, **opt); end

  # The full path of local git repository
  sig { returns(::Pathname) }
  def git_dir; end

  # Load `.rbs_meta.yaml` from the `dir`, where is the destination of the RBS file installation, and return the cleaned up content
  #
  sig { params(dir: ::Pathname).returns(::TypeAliases::RBS::Collection::Sources::Git::TypeAlias_metadata) }
  def load_metadata(dir:); end

  sig do
    params(
      name: ::String,
      version: ::String
    ).returns(::TypeAliases::RBS::Collection::Sources::Git::TypeAlias_metadata)
  end
  def metadata_content(name:, version:); end

  sig { params(revision: ::String).returns(T::Boolean) }
  def need_to_fetch?(revision); end

  # Ensure the git repository exists, and
  #
  # * When `revision` is a commit hash, the commit exists in the local repository, or
  # * When `revision` is a branch name, the latest version is fetched from `origin`
  #
  # It may require a network connection to fetch or clone the repository from remote.
  #
  # * If `revision` is a commit hash and the commit doesn't exists in the local repository, it runs `git fetch`
  # * If `revision` is a branch name, it runs `git fetch` once per instance
  #
  sig { type_parameters(:T).params(blk: T.proc.returns(T.type_parameter(:T))).returns(T.type_parameter(:T)) }
  def setup!(&blk); end

  sig { params(cmd: ::String, opt: T.untyped).returns(::String) }
  def sh!(*cmd, **opt); end

  # Write `.rbs_meta.yaml`
  sig { params(dir: ::Pathname, name: ::String, version: ::String).void }
  def write_metadata(dir:, name:, version:); end
end

# source://rbs//lib/rbs/collection/sources/git.rb#14
class RBS::Collection::Sources::Git::CommandError < ::StandardError; end

# source://rbs//lib/rbs/collection/sources/git.rb#12
RBS::Collection::Sources::Git::METADATA_FILENAME = T.let(T.unsafe(nil), String)

# source://rbs//lib/rbs/collection/sources/local.rb#6
class RBS::Collection::Sources::Local
  include ::RBS::Collection::Sources::Base

  sig { params(path: ::String, base_directory: ::Pathname).void }
  def initialize(path:, base_directory:); end

  sig { returns(::Pathname) }
  def full_path; end

  sig { params(name: ::String, version: T.nilable(::String)).returns(::TypeAliases::TypeAlias_boolish) }
  def has?(name, version); end

  sig do
    params(
      dest: ::Pathname,
      name: ::String,
      version: ::String,
      stdout: ::Interfaces::RBS::CLI::Interface_IO
    ).void
  end
  def install(dest:, name:, version:, stdout:); end

  sig do
    params(
      name: ::String,
      version: ::String
    ).returns(T.nilable(::TypeAliases::RBS::Collection::Sources::TypeAlias_manifest_entry))
  end
  def manifest_of(name, version); end

  sig { returns(::Pathname) }
  def path; end

  sig { returns(::TypeAliases::RBS::Collection::Sources::Local::TypeAlias_source_entry) }
  def to_lockfile; end

  sig { params(name: ::String).returns(::T::Array[::String]) }
  def versions(name); end

  private

  sig { params(src: ::Pathname, dest: ::Pathname).void }
  def _install(src, dest); end
end

# Signatures that are inclduded in gem package as sig/ directory.
#
# source://rbs//lib/rbs/collection/sources/rubygems.rb#9
# sig/ directory
class RBS::Collection::Sources::Rubygems
  include ::RBS::Collection::Sources::Base
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  sig { params(name: ::String, version: T.nilable(::String)).returns(::TypeAliases::TypeAlias_boolish) }
  def has?(name, version); end

  sig do
    params(
      dest: ::Pathname,
      name: ::String,
      version: ::String,
      stdout: ::Interfaces::RBS::CLI::Interface_IO
    ).void
  end
  def install(dest:, name:, version:, stdout:); end

  sig do
    params(
      name: ::String,
      version: ::String
    ).returns(T.nilable(::TypeAliases::RBS::Collection::Sources::TypeAlias_manifest_entry))
  end
  def manifest_of(name, version); end

  sig { returns(::TypeAliases::RBS::Collection::Sources::Rubygems::TypeAlias_source_entry) }
  def to_lockfile; end

  sig { params(name: ::String).returns(::T::Array[::String]) }
  def versions(name); end

  private

  sig { params(name: ::String, version: T.nilable(::String)).returns(T.nilable([::Gem::Specification, ::Pathname])) }
  def gem_sig_path(name, version); end

  class << self
    # polyfill of singleton module
    sig { returns(T.attached_class) }
    def instance; end
  end
end

# signatures that are bundled in rbs gem under the stdlib/ directory
#
# source://rbs//lib/rbs/collection/sources/stdlib.rb#9
# signatures that are bundled in rbs gem under the stdlib/ directory
class RBS::Collection::Sources::Stdlib
  include ::RBS::Collection::Sources::Base
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  sig { params(name: ::String, version: T.nilable(::String)).returns(::TypeAliases::TypeAlias_boolish) }
  def has?(name, version); end

  sig do
    params(
      dest: ::Pathname,
      name: ::String,
      version: ::String,
      stdout: ::Interfaces::RBS::CLI::Interface_IO
    ).void
  end
  def install(dest:, name:, version:, stdout:); end

  sig do
    params(
      name: ::String,
      version: ::String
    ).returns(T.nilable(::TypeAliases::RBS::Collection::Sources::TypeAlias_manifest_entry))
  end
  def manifest_of(name, version); end

  sig { returns(::TypeAliases::RBS::Collection::Sources::Stdlib::TypeAlias_source_entry) }
  def to_lockfile; end

  sig { params(name: ::String).returns(::T::Array[::String]) }
  def versions(name); end

  private

  sig { params(name: ::String, version: T.nilable(::String)).returns(T.nilable(::Pathname)) }
  def lookup(name, version); end

  class << self
    # polyfill of singleton module
    sig { returns(T.attached_class) }
    def instance; end
  end
end

# source://rbs//lib/rbs/collection/sources/stdlib.rb#13
RBS::Collection::Sources::Stdlib::REPO = T.let(T.unsafe(nil), RBS::Repository)

# source://rbs//lib/rbs/constant.rb#4
class RBS::Constant
  alias eql? ==

  sig do
    params(
      name: ::RBS::TypeName,
      type: ::TypeAliases::RBS::Types::TypeAlias_t,
      entry: ::TypeAliases::RBS::Constant::TypeAlias_constant_entry
    ).void
  end
  def initialize(name:, type:, entry:); end

  sig { params(other: T.untyped).returns(T::Boolean) }
  def ==(other); end

  sig { returns(::TypeAliases::RBS::Constant::TypeAlias_constant_entry) }
  def entry; end

  sig { returns(::Integer) }
  def hash; end

  sig { returns(::RBS::TypeName) }
  def name; end

  sig { returns(::TypeAliases::RBS::Types::TypeAlias_t) }
  def type; end
end

# source://rbs//lib/rbs/errors.rb#487
# A module/class alias declaration is cyclic
#
class RBS::CyclicClassAliasDefinitionError < ::RBS::BaseError
  sig { params(_arg0: T.any(::RBS::Environment::ClassAliasEntry, ::RBS::Environment::ModuleAliasEntry)).void }
  def initialize(_arg0); end

  sig { returns(T.any(::RBS::Environment::ClassAliasEntry, ::RBS::Environment::ModuleAliasEntry)) }
  def alias_entry; end
end

# source://rbs//lib/rbs/errors.rb#456
class RBS::CyclicTypeParameterBound < ::RBS::BaseError
  sig do
    params(
      type_name: ::RBS::TypeName,
      method_name: T.nilable(::Symbol),
      params: ::T::Array[::RBS::AST::TypeParam],
      location: T.nilable(::RBS::Location[T.untyped, T.untyped])
    ).void
  end
  def initialize(type_name:, method_name:, params:, location:); end

  sig { returns(T.nilable(::RBS::Location[T.untyped, T.untyped])) }
  def location; end

  sig { returns(T.nilable(::Symbol)) }
  def method_name; end

  sig { returns(::T::Array[::RBS::AST::TypeParam]) }
  def params; end

  sig { returns(::RBS::TypeName) }
  def type_name; end
end

# source://rbs//lib/rbs/definition.rb#4
class RBS::Definition
  sig do
    params(
      type_name: ::RBS::TypeName,
      entry: ::TypeAliases::RBS::Definition::TypeAlias_definition_entry,
      self_type: ::TypeAliases::RBS::Definition::TypeAlias_self_type,
      ancestors: T.nilable(T.any(::RBS::Definition::InstanceAncestors, ::RBS::Definition::SingletonAncestors))
    ).void
  end
  def initialize(type_name:, entry:, self_type:, ancestors:); end

  sig { returns(T.nilable(T.any(::RBS::Definition::InstanceAncestors, ::RBS::Definition::SingletonAncestors))) }
  def ancestors; end

  sig { returns(T::Boolean) }
  def class?; end

  sig { returns(T::Boolean) }
  def class_type?; end

  sig { returns(::T::Hash[::Symbol, ::RBS::Definition::Variable]) }
  def class_variables; end

  sig { params(blk: T.proc.params(_arg0: ::TypeAliases::RBS::Types::TypeAlias_t).void).void }
  def each_type(&blk); end

  sig { returns(::TypeAliases::RBS::Definition::TypeAlias_definition_entry) }
  def entry; end

  sig { returns(T::Boolean) }
  def instance_type?; end

  sig { returns(::T::Hash[::Symbol, ::RBS::Definition::Variable]) }
  def instance_variables; end

  sig { returns(T::Boolean) }
  def interface?; end

  sig { returns(T::Boolean) }
  def interface_type?; end

  sig { params(blk: T.proc.params(_arg0: ::RBS::MethodType).returns(::RBS::MethodType)).returns(::RBS::Definition) }
  def map_method_type(&blk); end

  sig { returns(::T::Hash[::Symbol, ::RBS::Definition::Method]) }
  def methods; end

  sig { returns(T::Boolean) }
  def module?; end

  sig { returns(::TypeAliases::RBS::Definition::TypeAlias_self_type) }
  def self_type; end

  sig { params(_arg0: ::RBS::Substitution).returns(::RBS::Definition) }
  def sub(_arg0); end

  sig { returns(::RBS::TypeName) }
  def type_name; end

  sig { returns(::T::Array[::Symbol]) }
  def type_params; end

  sig { returns(::T::Array[::RBS::AST::TypeParam]) }
  def type_params_decl; end
end

# source://rbs//lib/rbs/definition.rb#189
module RBS::Definition::Ancestor; end

# source://rbs//lib/rbs/definition.rb#190
class RBS::Definition::Ancestor::Instance
  sig do
    params(
      name: ::RBS::TypeName,
      args: ::T::Array[::TypeAliases::RBS::Types::TypeAlias_t],
      source: ::TypeAliases::RBS::Definition::Ancestor::Instance::TypeAlias_source
    ).void
  end
  def initialize(name:, args:, source:); end

  sig { returns(::T::Array[::TypeAliases::RBS::Types::TypeAlias_t]) }
  def args; end

  sig { returns(::RBS::TypeName) }
  def name; end

  sig { returns(::TypeAliases::RBS::Definition::Ancestor::Instance::TypeAlias_source) }
  def source; end
end

# source://rbs//lib/rbs/definition.rb#210
class RBS::Definition::Ancestor::Singleton
  sig { params(name: ::RBS::TypeName).void }
  def initialize(name:); end

  sig { returns(::RBS::TypeName) }
  def name; end
end

# source://rbs//lib/rbs/definition.rb#229
class RBS::Definition::InstanceAncestors
  sig do
    params(
      type_name: ::RBS::TypeName,
      params: ::T::Array[::Symbol],
      ancestors: ::T::Array[::TypeAliases::RBS::Definition::Ancestor::TypeAlias_t]
    ).void
  end
  def initialize(type_name:, params:, ancestors:); end

  sig { returns(::T::Array[::TypeAliases::RBS::Definition::Ancestor::TypeAlias_t]) }
  def ancestors; end

  sig do
    params(
      _arg0: ::T::Array[::TypeAliases::RBS::Types::TypeAlias_t],
      location: T.nilable(::RBS::Location[T.untyped, T.untyped])
    ).returns(::T::Array[::TypeAliases::RBS::Definition::Ancestor::TypeAlias_t])
  end
  def apply(_arg0, location:); end

  sig { returns(::T::Array[::Symbol]) }
  def params; end

  sig { returns(::RBS::TypeName) }
  def type_name; end
end

# source://rbs//lib/rbs/definition.rb#25
class RBS::Definition::Method
  sig do
    params(
      super_method: T.nilable(::RBS::Definition::Method),
      defs: ::T::Array[::RBS::Definition::Method::TypeDef],
      accessibility: ::TypeAliases::RBS::Definition::TypeAlias_accessibility,
      alias_of: T.nilable(::RBS::Definition::Method),
      annotations: ::T::Array[::RBS::AST::Annotation]
    ).void
  end
  def initialize(super_method:, defs:, accessibility:, alias_of:, annotations: T.unsafe(nil)); end

  sig { returns(::TypeAliases::RBS::Definition::TypeAlias_accessibility) }
  def accessibility; end

  sig { returns(T.nilable(::RBS::Definition::Method)) }
  def alias_of; end

  sig { returns(::T::Array[::RBS::AST::Annotation]) }
  def annotations; end

  sig { returns(::T::Array[::RBS::AST::Comment]) }
  def comments; end

  sig { returns(T.nilable(::RBS::TypeName)) }
  def defined_in; end

  sig { returns(::T::Array[::RBS::Definition::Method::TypeDef]) }
  def defs; end

  sig { returns(::T::Array[::RBS::AST::Annotation]) }
  def extra_annotations; end

  sig { returns(T.nilable(::RBS::TypeName)) }
  def implemented_in; end

  sig do
    params(
      blk: T.proc.params(_arg0: ::RBS::MethodType).returns(::RBS::MethodType)
    ).returns(::RBS::Definition::Method)
  end
  def map_method_type(&blk); end

  # Applies the mapping from `Types::t` to `Types::t`.
  #
  # Note this method doesn't handle upper bound in type params.
  # You may want to use `#map_type_bound` explicitly, or `#sub` for simple substitution.
  #
  sig do
    params(
      blk: T.proc.params(_arg0: ::TypeAliases::RBS::Types::TypeAlias_t).returns(::TypeAliases::RBS::Types::TypeAlias_t)
    ).returns(::RBS::Definition::Method)
  end
  def map_type(&blk); end

  sig do
    params(
      blk: T.proc.params(_arg0: ::TypeAliases::RBS::AST::TypeParam::TypeAlias_bound).returns(::TypeAliases::RBS::AST::TypeParam::TypeAlias_bound)
    ).returns(::RBS::Definition::Method)
  end
  def map_type_bound(&blk); end

  sig { returns(::T::Array[::TypeAliases::RBS::Definition::Method::TypeAlias_method_member]) }
  def members; end

  sig { returns(::T::Array[::RBS::MethodType]) }
  def method_types; end

  sig { returns(T::Boolean) }
  def private?; end

  sig { returns(T::Boolean) }
  def public?; end

  # Substitutes type variables to some types.
  # Takes care of type parameter bounds.
  #
  sig { params(_arg0: ::RBS::Substitution).returns(::RBS::Definition::Method) }
  def sub(_arg0); end

  sig { returns(T.nilable(::RBS::Definition::Method)) }
  def super_method; end

  sig do
    params(
      super_method: T.nilable(::RBS::Definition::Method),
      defs: ::T::Array[::RBS::Definition::Method::TypeDef],
      accessibility: ::TypeAliases::RBS::Definition::TypeAlias_accessibility,
      alias_of: T.nilable(::RBS::Definition::Method),
      annotations: ::T::Array[::RBS::AST::Annotation]
    ).returns(::RBS::Definition::Method)
  end
  def update(super_method: T.unsafe(nil), defs: T.unsafe(nil), accessibility: T.unsafe(nil), alias_of: T.unsafe(nil), annotations: T.unsafe(nil)); end
end

# source://rbs//lib/rbs/definition.rb#26
class RBS::Definition::Method::TypeDef
  sig do
    params(
      type: ::RBS::MethodType,
      member: ::TypeAliases::RBS::Definition::Method::TypeAlias_method_member,
      defined_in: ::RBS::TypeName,
      implemented_in: T.nilable(::RBS::TypeName)
    ).void
  end
  def initialize(type:, member:, defined_in:, implemented_in:); end

  sig { returns(::T::Array[::RBS::AST::Annotation]) }
  def annotations; end

  sig { returns(T.nilable(::RBS::AST::Comment)) }
  def comment; end

  sig { returns(::RBS::TypeName) }
  def defined_in; end

  sig { returns(T.nilable(::RBS::TypeName)) }
  def implemented_in; end

  sig { returns(::TypeAliases::RBS::Definition::Method::TypeAlias_method_member) }
  def member; end

  sig { returns(T::Boolean) }
  def overload?; end

  sig { returns(::RBS::MethodType) }
  def type; end

  sig do
    params(
      type: ::RBS::MethodType,
      member: ::TypeAliases::RBS::Definition::Method::TypeAlias_method_member,
      defined_in: ::RBS::TypeName,
      implemented_in: T.nilable(::RBS::TypeName)
    ).returns(::RBS::Definition::Method::TypeDef)
  end
  def update(type: T.unsafe(nil), member: T.unsafe(nil), defined_in: T.unsafe(nil), implemented_in: T.unsafe(nil)); end
end

# source://rbs//lib/rbs/definition.rb#269
class RBS::Definition::SingletonAncestors
  sig do
    params(
      type_name: ::RBS::TypeName,
      ancestors: ::T::Array[::TypeAliases::RBS::Definition::Ancestor::TypeAlias_t]
    ).void
  end
  def initialize(type_name:, ancestors:); end

  sig { returns(::T::Array[::TypeAliases::RBS::Definition::Ancestor::TypeAlias_t]) }
  def ancestors; end

  sig { returns(::RBS::TypeName) }
  def type_name; end
end

# source://rbs//lib/rbs/definition.rb#5
class RBS::Definition::Variable
  sig do
    params(
      parent_variable: T.nilable(::RBS::Definition::Variable),
      type: ::TypeAliases::RBS::Types::TypeAlias_t,
      declared_in: ::RBS::TypeName
    ).void
  end
  def initialize(parent_variable:, type:, declared_in:); end

  sig { returns(::RBS::TypeName) }
  def declared_in; end

  sig { returns(T.nilable(::RBS::Definition::Variable)) }
  def parent_variable; end

  sig { params(_arg0: ::RBS::Substitution).returns(::RBS::Definition::Variable) }
  def sub(_arg0); end

  sig { returns(::TypeAliases::RBS::Types::TypeAlias_t) }
  def type; end
end

# source://rbs//lib/rbs/definition_builder.rb#4
class RBS::DefinitionBuilder
  sig do
    params(
      env: ::RBS::Environment,
      ancestor_builder: T.nilable(::RBS::DefinitionBuilder::AncestorBuilder),
      method_builder: T.nilable(::RBS::DefinitionBuilder::MethodBuilder)
    ).void
  end
  def initialize(env:, ancestor_builder: T.unsafe(nil), method_builder: T.unsafe(nil)); end

  sig { returns(::RBS::DefinitionBuilder::AncestorBuilder) }
  def ancestor_builder; end

  # Returns a Definition of an instance type
  #
  # If TypeName is a module and `no_self_types` is `true`, it won't have methods of _self type constraints_.
  # This typically happens when definition is being calculated for mixin.
  #
  sig { params(_arg0: ::RBS::TypeName).returns(::RBS::Definition) }
  def build_instance(_arg0); end

  # Returns a Definition of a interface
  #
  sig { params(_arg0: ::RBS::TypeName).returns(::RBS::Definition) }
  def build_interface(_arg0); end

  # Returns a Definition of a singleton type
  sig { params(_arg0: ::RBS::TypeName).returns(::RBS::Definition) }
  def build_singleton(_arg0); end

  # Validates the given Namespace and its ancestor namespaces exists
  #
  # Raises NoTypeFoundError
  #
  sig { params(_arg0: ::RBS::Namespace, location: T.nilable(::RBS::Location[T.untyped, T.untyped])).void }
  def ensure_namespace!(_arg0, location:); end

  sig { returns(::RBS::Environment) }
  def env; end

  # Expand a type alias of given name without type arguments.
  # Raises an error if the type alias requires arguments.
  #
  # Assume `type foo[T] = [T, T]`:
  #
  # ```
  # expand_alias("::foo")   # => error
  # ```
  #
  sig { params(_arg0: ::RBS::TypeName).returns(::TypeAliases::RBS::Types::TypeAlias_t) }
  def expand_alias(_arg0); end

  # Expand a type alias of given name with arguments of `untyped`.
  #
  # Assume `type foo[T] = [T, T]`:
  #
  # ```
  # expand_alias1("::foo")   # => [untyped, untyped]
  # ```
  #
  sig { params(_arg0: ::RBS::TypeName).returns(::TypeAliases::RBS::Types::TypeAlias_t) }
  def expand_alias1(_arg0); end

  # Expand a type alias of given name with `args`.
  #
  # Assume `type foo[T] = [T, T]`:
  #
  # ```
  # expand_alias2("::foo", ["::Integer"])   # => [::Integer, ::Integer]
  # ```
  #
  sig do
    params(
      _arg0: ::RBS::TypeName,
      args: ::T::Array[::TypeAliases::RBS::Types::TypeAlias_t]
    ).returns(::TypeAliases::RBS::Types::TypeAlias_t)
  end
  def expand_alias2(_arg0, args); end

  sig { returns(::T::Hash[::RBS::TypeName, T.nilable(T.any(::RBS::Definition, T.untyped))]) }
  def instance_cache; end

  sig { returns(::T::Hash[::RBS::TypeName, T.nilable(T.any(::RBS::Definition, T.untyped))]) }
  def interface_cache; end

  sig { returns(::RBS::DefinitionBuilder::MethodBuilder) }
  def method_builder; end

  sig { returns(::T::Hash[::RBS::TypeName, T.nilable(T.any(::RBS::Definition, T.untyped))]) }
  def singleton0_cache; end

  sig { returns(::T::Hash[::RBS::TypeName, T.nilable(T.any(::RBS::Definition, T.untyped))]) }
  def singleton_cache; end

  # Returns a new DefinitionBuilder with updated Environment, AncestorBuilder, and exceptions
  #
  sig do
    params(
      env: ::RBS::Environment,
      ancestor_builder: ::RBS::DefinitionBuilder::AncestorBuilder,
      except: T::Enumerable[::RBS::TypeName]
    ).returns(::RBS::DefinitionBuilder)
  end
  def update(env:, ancestor_builder:, except:); end

  # Validates presence of an absolute type name
  #
  # Raises NoTypeFoundError in case of error.
  #
  sig { params(_arg0: ::RBS::TypeName, _arg1: T.nilable(::RBS::Location[T.untyped, T.untyped])).void }
  def validate_type_name(_arg0, _arg1); end

  # Validates presence of type names recursively
  #
  # Assumes the type names are already resolved.
  # Raises NoTypeFoundError in case of failure.
  #
  sig { params(_arg0: ::TypeAliases::RBS::Types::TypeAlias_t).void }
  def validate_type_presence(_arg0); end

  private

  sig { params(_arg0: ::RBS::TypeName).returns(::RBS::Definition) }
  def build_singleton0(_arg0); end

  # Updates `definition` with methods and variables of `type_name` that can be a module or a class
  #
  # It processes includes and prepends recursively.
  #
  sig { params(definition: ::RBS::Definition, type_name: ::RBS::TypeName, subst: ::RBS::Substitution).void }
  def define_instance(definition, type_name, subst); end

  # Updates `definition` with methods defined in an interface `type_name`
  #
  # It processes includes recursively
  #
  sig { params(definition: ::RBS::Definition, type_name: ::RBS::TypeName, subst: ::RBS::Substitution).void }
  def define_interface(definition, type_name, subst); end

  # Add method definition to `methods`, which will be merged to `class_definition` after defining all methods at this *level* -- class, module, or interface
  #
  # `class_definition` is a definition of given type, but it has definitions of prior levels.
  #
  sig do
    params(
      methods: ::T::Hash[::Symbol, ::RBS::Definition::Method],
      class_definition: ::RBS::Definition,
      method_definition: ::RBS::DefinitionBuilder::MethodBuilder::Methods::Definition,
      subst: ::RBS::Substitution,
      defined_in: ::RBS::TypeName,
      implemented_in: T.nilable(::RBS::TypeName)
    ).void
  end
  def define_method(methods, class_definition, method_definition, subst, defined_in:, implemented_in: T.unsafe(nil)); end

  # Add method definitions from `module_methods` to `definition`
  #
  # It also processes interface mixins, with duplication detection.
  # It doesn't process module mixins.
  #
  sig do
    params(
      definition: ::RBS::Definition,
      module_name: ::RBS::TypeName,
      module_methods: ::RBS::DefinitionBuilder::MethodBuilder::Methods,
      interface_methods: ::TypeAliases::RBS::DefinitionBuilder::TypeAlias_interface_methods,
      subst: ::RBS::Substitution
    ).void
  end
  def import_methods(definition, module_name, module_methods, interface_methods, subst); end

  sig do
    params(
      _arg0: ::RBS::TypeName,
      _arg1: ::T::Hash[::Symbol, ::RBS::Definition::Variable],
      name: ::Symbol,
      type: ::TypeAliases::RBS::Types::TypeAlias_t
    ).void
  end
  def insert_variable(_arg0, _arg1, name:, type:); end

  # Returns `interface_methods` from given array of interface ancestors
  #
  sig do
    params(
      interface_ancestors: ::T::Array[::RBS::Definition::Ancestor::Instance]
    ).returns(::TypeAliases::RBS::DefinitionBuilder::TypeAlias_interface_methods)
  end
  def interface_methods(interface_ancestors); end

  sig do
    params(
      _arg0: ::TypeAliases::RBS::Definition::Ancestor::Instance::TypeAlias_source,
      _arg1: ::TypeAliases::RBS::AST::Declarations::TypeAlias_t
    ).returns(T.nilable(::RBS::Location[T.untyped, T.untyped]))
  end
  def source_location(_arg0, _arg1); end

  # Returns a substitution that corresponds to type application
  #
  # ```
  # tapp_subst(`::Array`, [`::Integer`]) # => Subsitution.build([:Elem], [`::Integer`])
  # ```
  #
  sig do
    params(
      _arg0: ::RBS::TypeName,
      _arg1: ::T::Array[::TypeAliases::RBS::Types::TypeAlias_t]
    ).returns(::RBS::Substitution)
  end
  def tapp_subst(_arg0, _arg1); end

  sig do
    params(
      _arg0: ::RBS::TypeName,
      cache: ::T::Hash[::RBS::TypeName, T.nilable(T.any(::RBS::Definition, T.untyped))],
      blk: T.proc.returns(::RBS::Definition)
    ).returns(::RBS::Definition)
  end
  def try_cache(_arg0, cache:, &blk); end

  sig do
    params(
      _arg0: ::T::Array[::RBS::AST::TypeParam],
      result: ::RBS::VarianceCalculator::Result,
      blk: T.proc.params(_arg0: ::RBS::AST::TypeParam).void
    ).void
  end
  def validate_params_with(_arg0, result:, &blk); end

  sig { params(_arg0: ::RBS::TypeName, _arg1: ::RBS::Environment::ClassEntry).void }
  def validate_super_class!(_arg0, _arg1); end

  sig do
    params(
      _arg0: ::RBS::Definition,
      ancestors: ::RBS::DefinitionBuilder::AncestorBuilder::OneAncestors,
      methods: ::RBS::DefinitionBuilder::MethodBuilder::Methods
    ).void
  end
  def validate_type_params(_arg0, ancestors:, methods:); end
end

# source://rbs//lib/rbs/definition_builder/ancestor_builder.rb#5
# AncestorBuilder calculates the ancestors of a class or module.
#
class RBS::DefinitionBuilder::AncestorBuilder
  sig { params(env: ::RBS::Environment).void }
  def initialize(env:); end

  sig { returns(::RBS::Environment) }
  def env; end

  sig do
    params(
      _arg0: ::RBS::TypeName,
      building_ancestors: ::T::Array[::TypeAliases::RBS::Definition::Ancestor::TypeAlias_t]
    ).returns(::RBS::Definition::InstanceAncestors)
  end
  def instance_ancestors(_arg0, building_ancestors: T.unsafe(nil)); end

  sig { returns(::T::Hash[::RBS::TypeName, ::RBS::Definition::InstanceAncestors]) }
  def instance_ancestors_cache; end

  sig do
    params(
      _arg0: ::RBS::TypeName,
      building_ancestors: ::T::Array[::TypeAliases::RBS::Definition::Ancestor::TypeAlias_t]
    ).returns(::RBS::Definition::InstanceAncestors)
  end
  def interface_ancestors(_arg0, building_ancestors: T.unsafe(nil)); end

  sig { returns(::T::Hash[::RBS::TypeName, ::RBS::Definition::InstanceAncestors]) }
  def interface_ancestors_cache; end

  sig { params(_arg0: ::RBS::TypeName).returns(::RBS::DefinitionBuilder::AncestorBuilder::OneAncestors) }
  def one_instance_ancestors(_arg0); end

  sig { returns(::T::Hash[::RBS::TypeName, ::RBS::DefinitionBuilder::AncestorBuilder::OneAncestors]) }
  def one_instance_ancestors_cache; end

  sig { params(_arg0: ::RBS::TypeName).returns(::RBS::DefinitionBuilder::AncestorBuilder::OneAncestors) }
  def one_interface_ancestors(_arg0); end

  sig { returns(::T::Hash[::RBS::TypeName, ::RBS::DefinitionBuilder::AncestorBuilder::OneAncestors]) }
  def one_interface_ancestors_cache; end

  sig { params(_arg0: ::RBS::TypeName).returns(::RBS::DefinitionBuilder::AncestorBuilder::OneAncestors) }
  def one_singleton_ancestors(_arg0); end

  sig { returns(::T::Hash[::RBS::TypeName, ::RBS::DefinitionBuilder::AncestorBuilder::OneAncestors]) }
  def one_singleton_ancestors_cache; end

  sig do
    params(
      _arg0: ::RBS::TypeName,
      building_ancestors: ::T::Array[::TypeAliases::RBS::Definition::Ancestor::TypeAlias_t]
    ).returns(::RBS::Definition::SingletonAncestors)
  end
  def singleton_ancestors(_arg0, building_ancestors: T.unsafe(nil)); end

  sig { returns(::T::Hash[::RBS::TypeName, ::RBS::Definition::SingletonAncestors]) }
  def singleton_ancestors_cache; end

  private

  # Fill `#source` of instance ancestor if `ancestor.name == name` and its `source` is `nil`
  #
  sig do
    params(
      _arg0: ::TypeAliases::RBS::Definition::Ancestor::TypeAlias_t,
      name: ::RBS::TypeName,
      source: ::TypeAliases::RBS::Definition::Ancestor::Instance::TypeAlias_source
    ).returns(::TypeAliases::RBS::Definition::Ancestor::TypeAlias_t)
  end
  def fill_ancestor_source(_arg0, name:, source:); end

  sig do
    params(
      _arg0: T.any(::RBS::Environment::ClassEntry, ::RBS::Environment::ModuleEntry),
      _arg1: ::RBS::TypeName,
      included_modules: T.nilable(::T::Array[::RBS::Definition::Ancestor::Instance]),
      included_interfaces: T.nilable(::T::Array[::RBS::Definition::Ancestor::Instance]),
      prepended_modules: T.nilable(::T::Array[::RBS::Definition::Ancestor::Instance]),
      extended_modules: T.nilable(::T::Array[::RBS::Definition::Ancestor::Instance]),
      extended_interfaces: T.nilable(::T::Array[::RBS::Definition::Ancestor::Instance])
    ).void
  end
  def mixin_ancestors(_arg0, _arg1, included_modules:, included_interfaces:, prepended_modules:, extended_modules:, extended_interfaces:); end

  sig do
    params(
      _arg0: T.any(::RBS::AST::Declarations::Class, ::RBS::AST::Declarations::Interface, ::RBS::AST::Declarations::Module),
      _arg1: ::RBS::TypeName,
      align_params: T.nilable(::RBS::Substitution),
      included_modules: T.nilable(::T::Array[::RBS::Definition::Ancestor::Instance]),
      included_interfaces: T.nilable(::T::Array[::RBS::Definition::Ancestor::Instance]),
      prepended_modules: T.nilable(::T::Array[::RBS::Definition::Ancestor::Instance]),
      extended_modules: T.nilable(::T::Array[::RBS::Definition::Ancestor::Instance]),
      extended_interfaces: T.nilable(::T::Array[::RBS::Definition::Ancestor::Instance])
    ).void
  end
  def mixin_ancestors0(_arg0, _arg1, align_params:, included_modules:, included_interfaces:, prepended_modules:, extended_modules:, extended_interfaces:); end

  sig { params(_arg0: ::RBS::TypeName, _arg1: ::RBS::Environment::ClassEntry).void }
  def validate_super_class!(_arg0, _arg1); end
end

# source://rbs//lib/rbs/definition_builder/ancestor_builder.rb#6
# OneAncestors represents a list of _direct_ ancestors of a type name
#
# _Direct_ ancestors is defined as follows:
# * Super class is a direct ancestor
# * Self type constraints are direct ancestors
# * Mixin modules are direct ancestors
# * Mixin interfaces are direct ancestors
# The optional attributes are defined by the type of the ancestors object, one of the following five groups:
# 1. Instance of a class -- with super_class, included_modules, included_interfaces, and prepended_modules
# 2. Instance of a module -- with self_types, included_modules, included_interfaces, and prepended_modules
# 3. Singleton of a class or module -- with super_class, extended_modules, and extended_interfaces
# 4. Interface -- with included_interfaces
class RBS::DefinitionBuilder::AncestorBuilder::OneAncestors
  sig do
    params(
      type_name: ::RBS::TypeName,
      params: T.nilable(::T::Array[::Symbol]),
      super_class: T.nilable(::TypeAliases::RBS::Definition::Ancestor::TypeAlias_t),
      self_types: T.nilable(::T::Array[::RBS::Definition::Ancestor::Instance]),
      included_modules: T.nilable(::T::Array[::RBS::Definition::Ancestor::Instance]),
      included_interfaces: T.nilable(::T::Array[::RBS::Definition::Ancestor::Instance]),
      prepended_modules: T.nilable(::T::Array[::RBS::Definition::Ancestor::Instance]),
      extended_modules: T.nilable(::T::Array[::RBS::Definition::Ancestor::Instance]),
      extended_interfaces: T.nilable(::T::Array[::RBS::Definition::Ancestor::Instance])
    ).void
  end
  def initialize(type_name:, params:, super_class:, self_types:, included_modules:, included_interfaces:, prepended_modules:, extended_modules:, extended_interfaces:); end

  sig { params(blk: T.proc.params(_arg0: ::TypeAliases::RBS::Definition::Ancestor::TypeAlias_t).void).void }
  def each_ancestor(&blk); end

  sig { params(blk: T.proc.params(_arg0: ::RBS::Definition::Ancestor::Instance).void).void }
  def each_extended_interface(&blk); end

  sig { params(blk: T.proc.params(_arg0: ::RBS::Definition::Ancestor::Instance).void).void }
  def each_extended_module(&blk); end

  sig { params(blk: T.proc.params(_arg0: ::RBS::Definition::Ancestor::Instance).void).void }
  def each_included_interface(&blk); end

  sig { params(blk: T.proc.params(_arg0: ::RBS::Definition::Ancestor::Instance).void).void }
  def each_included_module(&blk); end

  sig { params(blk: T.proc.params(_arg0: ::RBS::Definition::Ancestor::Instance).void).void }
  def each_prepended_module(&blk); end

  sig { params(blk: T.proc.params(_arg0: ::RBS::Definition::Ancestor::Instance).void).void }
  def each_self_type(&blk); end

  sig { returns(T.nilable(::T::Array[::RBS::Definition::Ancestor::Instance])) }
  def extended_interfaces; end

  sig { returns(T.nilable(::T::Array[::RBS::Definition::Ancestor::Instance])) }
  def extended_modules; end

  sig { returns(T.nilable(::T::Array[::RBS::Definition::Ancestor::Instance])) }
  def included_interfaces; end

  sig { returns(T.nilable(::T::Array[::RBS::Definition::Ancestor::Instance])) }
  def included_modules; end

  sig { returns(T.nilable(::T::Array[::Symbol])) }
  def params; end

  sig { returns(T.nilable(::T::Array[::RBS::Definition::Ancestor::Instance])) }
  def prepended_modules; end

  sig { returns(T.nilable(::T::Array[::RBS::Definition::Ancestor::Instance])) }
  def self_types; end

  sig { returns(T.nilable(::TypeAliases::RBS::Definition::Ancestor::TypeAlias_t)) }
  def super_class; end

  sig { returns(::RBS::TypeName) }
  def type_name; end

  class << self
    # Returns a OneAncestors object for class instance
    sig do
      params(
        type_name: ::RBS::TypeName,
        params: ::T::Array[::Symbol],
        super_class: T.nilable(::TypeAliases::RBS::Definition::Ancestor::TypeAlias_t)
      ).returns(T.attached_class)
    end
    def class_instance(type_name:, params:, super_class:); end

    # Returns a OneAncestors object for interface
    sig { params(type_name: ::RBS::TypeName, params: ::T::Array[::Symbol]).returns(T.attached_class) }
    def interface(type_name:, params:); end

    # Returns a OneAncestors object for module instance
    sig { params(type_name: ::RBS::TypeName, params: ::T::Array[::Symbol]).returns(T.attached_class) }
    def module_instance(type_name:, params:); end

    # Returns a OneAncestors object for class/module singleton
    sig do
      params(
        type_name: ::RBS::TypeName,
        super_class: ::TypeAliases::RBS::Definition::Ancestor::TypeAlias_t
      ).returns(T.attached_class)
    end
    def singleton(type_name:, super_class:); end
  end
end

# source://rbs//lib/rbs/definition_builder/method_builder.rb#5
# MethodBuilder calculates the sequence of methods available on given type
#
# The sequence are sorted topologically.
class RBS::DefinitionBuilder::MethodBuilder
  sig { params(env: ::RBS::Environment).void }
  def initialize(env:); end

  sig do
    params(
      _arg0: ::RBS::DefinitionBuilder::MethodBuilder::Methods,
      _arg1: ::TypeAliases::RBS::DefinitionBuilder::MethodBuilder::Methods::TypeAlias_instance_type,
      member: ::RBS::AST::Members::Alias
    ).void
  end
  def build_alias(_arg0, _arg1, member:); end

  sig do
    params(
      _arg0: ::RBS::DefinitionBuilder::MethodBuilder::Methods,
      _arg1: ::TypeAliases::RBS::DefinitionBuilder::MethodBuilder::Methods::TypeAlias_instance_type,
      member: T.any(::RBS::AST::Members::AttrAccessor, ::RBS::AST::Members::AttrReader, ::RBS::AST::Members::AttrWriter),
      accessibility: ::TypeAliases::RBS::Definition::TypeAlias_accessibility
    ).void
  end
  def build_attribute(_arg0, _arg1, member:, accessibility:); end

  sig { params(_arg0: ::RBS::TypeName).returns(::RBS::DefinitionBuilder::MethodBuilder::Methods) }
  def build_instance(_arg0); end

  sig { params(_arg0: ::RBS::TypeName).returns(::RBS::DefinitionBuilder::MethodBuilder::Methods) }
  def build_interface(_arg0); end

  sig do
    params(
      _arg0: ::RBS::DefinitionBuilder::MethodBuilder::Methods,
      _arg1: ::TypeAliases::RBS::DefinitionBuilder::MethodBuilder::Methods::TypeAlias_instance_type,
      member: ::RBS::AST::Members::MethodDefinition,
      accessibility: ::TypeAliases::RBS::Definition::TypeAlias_accessibility
    ).void
  end
  def build_method(_arg0, _arg1, member:, accessibility:); end

  sig { params(_arg0: ::RBS::TypeName).returns(::RBS::DefinitionBuilder::MethodBuilder::Methods) }
  def build_singleton(_arg0); end

  sig do
    params(
      _arg0: ::T::Array[T.any(::TypeAliases::RBS::AST::Declarations::TypeAlias_t, ::TypeAliases::RBS::AST::Members::TypeAlias_t)],
      accessibility: ::TypeAliases::RBS::Definition::TypeAlias_accessibility,
      blk: T.proc.params(_arg0: T.any(::TypeAliases::RBS::AST::Declarations::TypeAlias_t, ::TypeAliases::RBS::AST::Members::TypeAlias_t), _arg1: ::TypeAliases::RBS::Definition::TypeAlias_accessibility).void
    ).void
  end
  def each_member_with_accessibility(_arg0, accessibility: T.unsafe(nil), &blk); end

  sig { returns(::RBS::Environment) }
  def env; end

  sig { returns(::T::Hash[::RBS::TypeName, ::RBS::DefinitionBuilder::MethodBuilder::Methods]) }
  def instance_methods; end

  sig { returns(::T::Hash[::RBS::TypeName, ::RBS::DefinitionBuilder::MethodBuilder::Methods]) }
  def interface_methods; end

  sig { returns(::T::Hash[::RBS::TypeName, ::RBS::DefinitionBuilder::MethodBuilder::Methods]) }
  def singleton_methods; end

  sig do
    params(
      env: ::RBS::Environment,
      except: T::Enumerable[::RBS::TypeName]
    ).returns(::RBS::DefinitionBuilder::MethodBuilder)
  end
  def update(env:, except:); end
end

# source://rbs//lib/rbs/definition_builder/method_builder.rb#6
# Set of methods defined in a type.
#
class RBS::DefinitionBuilder::MethodBuilder::Methods
  sig { params(type: ::TypeAliases::RBS::DefinitionBuilder::MethodBuilder::Methods::TypeAlias_instance_type).void }
  def initialize(type:); end

  sig { params(blk: T.proc.params(_arg0: ::RBS::DefinitionBuilder::MethodBuilder::Methods::Definition).void).void }
  def each(&blk); end

  sig { returns(::T::Hash[::Symbol, ::RBS::DefinitionBuilder::MethodBuilder::Methods::Definition]) }
  def methods; end

  sig { returns(::TypeAliases::RBS::DefinitionBuilder::MethodBuilder::Methods::TypeAlias_instance_type) }
  def type; end

  sig { returns(T.self_type) }
  def validate!; end
end

# source://rbs//lib/rbs/definition_builder/method_builder.rb#7
class RBS::DefinitionBuilder::MethodBuilder::Methods::Definition < ::Struct
  sig do
    params(
      name: ::Symbol,
      type: ::TypeAliases::RBS::DefinitionBuilder::MethodBuilder::Methods::TypeAlias_instance_type,
      originals: ::T::Array[::TypeAliases::RBS::DefinitionBuilder::MethodBuilder::Methods::Definition::TypeAlias_original],
      overloads: ::T::Array[::RBS::AST::Members::MethodDefinition],
      accessibilities: ::T::Array[::TypeAliases::RBS::DefinitionBuilder::MethodBuilder::Methods::Definition::TypeAlias_accessibility]
    ).void
  end
  def initialize(name:, type:, originals:, overloads:, accessibilities:); end

  sig do
    returns(::T::Array[::TypeAliases::RBS::DefinitionBuilder::MethodBuilder::Methods::Definition::TypeAlias_accessibility])
  end
  def accessibilities; end

  sig { returns(::TypeAliases::RBS::DefinitionBuilder::MethodBuilder::Methods::Definition::TypeAlias_accessibility) }
  def accessibility; end

  sig { returns(::Symbol) }
  def name; end

  sig do
    returns(T.nilable(::TypeAliases::RBS::DefinitionBuilder::MethodBuilder::Methods::Definition::TypeAlias_original))
  end
  def original; end

  sig do
    returns(::T::Array[::TypeAliases::RBS::DefinitionBuilder::MethodBuilder::Methods::Definition::TypeAlias_original])
  end
  def originals; end

  sig { returns(::T::Array[::RBS::AST::Members::MethodDefinition]) }
  def overloads; end

  sig { returns(::TypeAliases::RBS::DefinitionBuilder::MethodBuilder::Methods::TypeAlias_instance_type) }
  def type; end

  class << self
    sig do
      params(
        name: ::Symbol,
        type: ::TypeAliases::RBS::DefinitionBuilder::MethodBuilder::Methods::TypeAlias_instance_type
      ).returns(::RBS::DefinitionBuilder::MethodBuilder::Methods::Definition)
    end
    def empty(name:, type:); end
  end
end

# source://rbs//lib/rbs/definition_builder/method_builder.rb#63
class RBS::DefinitionBuilder::MethodBuilder::Methods::Sorter
  include ::TSort

  sig { params(_arg0: ::T::Hash[::Symbol, ::RBS::DefinitionBuilder::MethodBuilder::Methods::Definition]).void }
  def initialize(_arg0); end

  sig { returns(::T::Hash[::Symbol, ::RBS::DefinitionBuilder::MethodBuilder::Methods::Definition]) }
  def methods; end

  sig do
    params(
      _arg0: ::RBS::DefinitionBuilder::MethodBuilder::Methods::Definition,
      blk: T.proc.params(_arg0: ::RBS::DefinitionBuilder::MethodBuilder::Methods::Definition).void
    ).void
  end
  def tsort_each_child(_arg0, &blk); end

  sig { params(blk: T.proc.params(_arg0: ::RBS::DefinitionBuilder::MethodBuilder::Methods::Definition).void).void }
  def tsort_each_node(&blk); end
end

# source://rbs//lib/rbs/errors.rb#21
# Error class for errors raised during building definitions.
#
class RBS::DefinitionError < ::RBS::BaseError; end

# source://rbs//lib/rbs/errors.rb#23
module RBS::DetailedMessageable; end

# source://rbs//lib/rbs/errors.rb#346
class RBS::DuplicatedDeclarationError < ::RBS::LoadingError
  sig do
    params(
      _arg0: T.any(::RBS::TypeName, ::Symbol),
      _arg1: ::TypeAliases::RBS::AST::Declarations::TypeAlias_t
    ).void
  end
  def initialize(_arg0, *_arg1); end

  sig { returns(::T::Array[::TypeAliases::RBS::AST::Declarations::TypeAlias_t]) }
  def decls; end

  sig { returns(T.any(::RBS::TypeName, ::Symbol)) }
  def name; end
end

# source://rbs//lib/rbs/errors.rb#258
# An interface mixin causes a duplication of a method definition
#
# ```rbs
# interface _Foo1
#   def foo: () -> void
# end
# interface _Foo2
# class Foo
#   include _Foo1
#   include _Foo2    # <= The error will be reported here (or the line of _Foo1)
# ```
class RBS::DuplicatedInterfaceMethodDefinitionError < ::RBS::DefinitionError
  sig do
    params(
      type: ::TypeAliases::RBS::DuplicatedInterfaceMethodDefinitionError::TypeAlias_ty,
      method_name: ::Symbol,
      member: ::TypeAliases::RBS::DuplicatedInterfaceMethodDefinitionError::TypeAlias_mixin_member
    ).void
  end
  def initialize(type:, method_name:, member:); end

  sig { returns(::TypeAliases::RBS::DuplicatedInterfaceMethodDefinitionError::TypeAlias_mixin_member) }
  def member; end

  sig { returns(::Symbol) }
  def method_name; end

  sig { returns(::String) }
  def qualified_method_name; end

  sig { returns(::TypeAliases::RBS::DuplicatedInterfaceMethodDefinitionError::TypeAlias_ty) }
  def type; end

  sig { returns(::RBS::TypeName) }
  def type_name; end
end

# source://rbs//lib/rbs/errors.rb#219
class RBS::DuplicatedMethodDefinitionError < ::RBS::DefinitionError
  sig do
    params(
      type: ::TypeAliases::RBS::DuplicatedMethodDefinitionError::TypeAlias_ty,
      method_name: ::Symbol,
      members: ::T::Array[::TypeAliases::RBS::DuplicatedMethodDefinitionError::TypeAlias_original]
    ).void
  end
  def initialize(type:, method_name:, members:); end

  sig { returns(T.nilable(::RBS::Location[T.untyped, T.untyped])) }
  def location; end

  sig { returns(::T::Array[::TypeAliases::RBS::DuplicatedMethodDefinitionError::TypeAlias_original]) }
  def members; end

  sig { returns(::Symbol) }
  def method_name; end

  sig { returns(::T::Array[T.nilable(::RBS::Location[T.untyped, T.untyped])]) }
  def other_locations; end

  sig { returns(::String) }
  def qualified_method_name; end

  sig { returns(::TypeAliases::RBS::DuplicatedMethodDefinitionError::TypeAlias_ty) }
  def type; end

  sig { returns(::RBS::TypeName) }
  def type_name; end
end

# source://rbs//lib/rbs/environment.rb#4
class RBS::Environment
  sig { void }
  def initialize; end

  # Insert a toplevel declaration into the environment
  #
  sig { params(decl: ::TypeAliases::RBS::AST::Declarations::TypeAlias_t).returns(T.self_type) }
  def <<(decl); end

  sig do
    params(
      buffer: ::RBS::Buffer,
      directives: ::T::Array[::TypeAliases::RBS::AST::Directives::TypeAlias_t],
      decls: ::T::Array[::TypeAliases::RBS::AST::Declarations::TypeAlias_t]
    ).void
  end
  def add_signature(buffer:, directives:, decls:); end

  sig { returns(::T::Array[::RBS::Buffer]) }
  def buffers; end

  # Returns true if the type name is a class alias
  sig { params(_arg0: ::RBS::TypeName).returns(T::Boolean) }
  def class_alias?(_arg0); end

  sig do
    returns(::T::Hash[::RBS::TypeName, T.any(::RBS::Environment::ClassAliasEntry, ::RBS::Environment::ModuleAliasEntry)])
  end
  def class_alias_decls; end

  # Returns true if the type name is defined by class declaration
  #
  sig { params(_arg0: ::RBS::TypeName).returns(T::Boolean) }
  def class_decl?(_arg0); end

  sig { returns(::T::Hash[::RBS::TypeName, T.any(::RBS::Environment::ClassEntry, ::RBS::Environment::ModuleEntry)]) }
  def class_decls; end

  sig do
    params(
      _arg0: ::RBS::TypeName
    ).returns(T.nilable(T.any(::RBS::Environment::ClassAliasEntry, ::RBS::Environment::ClassEntry)))
  end
  def class_entry(_arg0); end

  # Returns true if the type name is defined by constant declaration
  #
  sig { params(_arg0: ::RBS::TypeName).returns(T::Boolean) }
  def constant_decl?(_arg0); end

  sig { returns(::T::Hash[::RBS::TypeName, ::RBS::Environment::ConstantEntry]) }
  def constant_decls; end

  sig do
    params(
      _arg0: ::RBS::TypeName
    ).returns(T.nilable(T.any(::RBS::Environment::ClassAliasEntry, ::RBS::Environment::ClassEntry, ::RBS::Environment::ConstantEntry, ::RBS::Environment::ModuleAliasEntry, ::RBS::Environment::ModuleEntry)))
  end
  def constant_entry(_arg0); end

  # Returns if a constant of the name is defined
  #
  sig { params(_arg0: ::RBS::TypeName).returns(T::Boolean) }
  def constant_name?(_arg0); end

  sig { returns(::T::Array[::TypeAliases::RBS::AST::Declarations::TypeAlias_t]) }
  def declarations; end

  sig { returns(::T::Hash[::Symbol, ::RBS::Environment::GlobalEntry]) }
  def global_decls; end

  sig { params(_arg0: ::RBS::Environment).void }
  def initialize_copy(_arg0); end

  sig { returns(::String) }
  def inspect; end

  sig { returns(::T::Hash[::RBS::TypeName, ::RBS::Environment::InterfaceEntry]) }
  def interface_decls; end

  # Returns true if an interface with the type name is defined
  #
  sig { params(_arg0: ::RBS::TypeName).returns(T::Boolean) }
  def interface_name?(_arg0); end

  # Returns true if the type name is a module alias
  #
  sig { params(_arg0: ::RBS::TypeName).returns(T::Boolean) }
  def module_alias?(_arg0); end

  sig do
    params(
      _arg0: ::RBS::TypeName
    ).returns(T.nilable(T.any(::RBS::Environment::ClassAliasEntry, ::RBS::Environment::ClassEntry, ::RBS::Environment::ModuleAliasEntry, ::RBS::Environment::ModuleEntry)))
  end
  def module_class_entry(_arg0); end

  # Returns true if the type name is defined by module declaration
  #
  sig { params(_arg0: ::RBS::TypeName).returns(T::Boolean) }
  def module_decl?(_arg0); end

  sig do
    params(
      _arg0: ::RBS::TypeName
    ).returns(T.nilable(T.any(::RBS::Environment::ModuleAliasEntry, ::RBS::Environment::ModuleEntry)))
  end
  def module_entry(_arg0); end

  # Returns true if a module or class with the type name is defined
  #
  sig { params(_arg0: ::RBS::TypeName).returns(T::Boolean) }
  def module_name?(_arg0); end

  # Returns the original module name that is defined with `module` declaration
  #
  # * Raises an error if given type name is not module
  # * Calls `#absolute!` for relative module names
  # * Returns the name itself if the name cannot be normalized to a class/module
  #
  sig { params(_arg0: ::RBS::TypeName).returns(::RBS::TypeName) }
  def normalize_module_name(_arg0); end

  # Returns the original module name that is defined with `module` declaration
  #
  # * Calls `#absolute!` for relative module names
  # * Returns `nil` if the rhs name cannot be found
  # * Returns `false` if the name is cyclic
  #
  sig { params(_arg0: ::RBS::TypeName).returns(T.nilable(T.any(::RBS::TypeName, T.untyped))) }
  def normalize_module_name?(_arg0); end

  # Returns ClassEntry if the class definition is found, normalized in case of alias
  #
  sig { params(_arg0: ::RBS::TypeName).returns(T.nilable(::RBS::Environment::ClassEntry)) }
  def normalized_class_entry(_arg0); end

  sig do
    params(
      _arg0: ::RBS::TypeName
    ).returns(T.nilable(T.any(::RBS::Environment::ClassEntry, ::RBS::Environment::ModuleEntry)))
  end
  def normalized_module_class_entry(_arg0); end

  # Returns ModuleEntry if the module definition is found, normalized in case of alias
  #
  sig { params(_arg0: ::RBS::TypeName).returns(T.nilable(::RBS::Environment::ModuleEntry)) }
  def normalized_module_entry(_arg0); end

  # Resolve all type names in the environment to absolute type names.
  # Relative type name will be left if absolute type name cannot be found.
  #
  # When `only` is given, it skips other _top-level_ declarations not included in the collection.
  # This helps running resolution faster in the case of _partial updates_.
  #
  sig do
    params(
      only: T.nilable(::T::Set[::TypeAliases::RBS::AST::Declarations::TypeAlias_t])
    ).returns(::RBS::Environment)
  end
  def resolve_type_names(only: T.unsafe(nil)); end

  sig do
    returns(::T::Hash[::RBS::Buffer, [::T::Array[::TypeAliases::RBS::AST::Directives::TypeAlias_t], ::T::Array[::TypeAliases::RBS::AST::Declarations::TypeAlias_t]]])
  end
  def signatures; end

  sig { returns(::T::Hash[::RBS::TypeName, ::RBS::Environment::TypeAliasEntry]) }
  def type_alias_decls; end

  # Returns true if a type alias with the type name is defined
  #
  sig { params(_arg0: ::RBS::TypeName).returns(T::Boolean) }
  def type_alias_name?(_arg0); end

  # Returns true if the type name is defined
  #
  sig { params(_arg0: ::RBS::TypeName).returns(T::Boolean) }
  def type_name?(_arg0); end

  # Remove declarations and directives that are loaded from `buffers`
  #
  sig { params(buffers: ::T::Set[::RBS::Buffer]).returns(::RBS::Environment) }
  def unload(buffers); end

  # Runs generics type params validation over each class definitions
  sig { void }
  def validate_type_params; end

  private

  sig do
    params(
      _arg0: ::RBS::Resolver::TypeNameResolver,
      map: ::RBS::Environment::UseMap,
      _arg2: ::TypeAliases::RBS::Types::TypeAlias_t,
      context: ::TypeAliases::RBS::Resolver::TypeAlias_context
    ).returns(::TypeAliases::RBS::Types::TypeAlias_t)
  end
  def absolute_type(_arg0, map, _arg2, context:); end

  sig do
    params(
      _arg0: ::RBS::Resolver::TypeNameResolver,
      map: ::RBS::Environment::UseMap,
      _arg2: ::RBS::TypeName,
      context: ::TypeAliases::RBS::Resolver::TypeAlias_context
    ).returns(::RBS::TypeName)
  end
  def absolute_type_name(_arg0, map, _arg2, context:); end

  sig do
    params(
      _arg0: ::TypeAliases::RBS::Resolver::TypeAlias_context,
      _arg1: ::TypeAliases::RBS::Environment::TypeAlias_module_decl
    ).returns(::TypeAliases::RBS::Resolver::TypeAlias_context)
  end
  def append_context(_arg0, _arg1); end

  # Insert a declaration into the environment
  #
  sig do
    params(
      _arg0: ::TypeAliases::RBS::AST::Declarations::TypeAlias_t,
      outer: ::T::Array[::TypeAliases::RBS::Environment::TypeAlias_module_decl],
      namespace: ::RBS::Namespace
    ).void
  end
  def insert_decl(_arg0, outer:, namespace:); end

  sig do
    params(
      resolver: ::RBS::Resolver::TypeNameResolver,
      map: ::RBS::Environment::UseMap,
      decl: ::TypeAliases::RBS::AST::Declarations::TypeAlias_t,
      outer: ::T::Array[::TypeAliases::RBS::Environment::TypeAlias_module_decl],
      prefix: ::RBS::Namespace
    ).returns(::TypeAliases::RBS::AST::Declarations::TypeAlias_t)
  end
  def resolve_declaration(resolver, map, decl, outer:, prefix:); end

  sig do
    params(
      _arg0: ::RBS::Resolver::TypeNameResolver,
      map: ::RBS::Environment::UseMap,
      _arg2: ::TypeAliases::RBS::AST::Members::TypeAlias_t,
      context: ::TypeAliases::RBS::Resolver::TypeAlias_context
    ).returns(::TypeAliases::RBS::AST::Members::TypeAlias_t)
  end
  def resolve_member(_arg0, map, _arg2, context:); end

  sig do
    params(
      _arg0: ::RBS::Resolver::TypeNameResolver,
      map: ::RBS::Environment::UseMap,
      _arg2: ::RBS::MethodType,
      context: ::TypeAliases::RBS::Resolver::TypeAlias_context
    ).returns(::RBS::MethodType)
  end
  def resolve_method_type(_arg0, map, _arg2, context:); end

  sig do
    params(
      resolver: ::RBS::Resolver::TypeNameResolver,
      map: ::RBS::Environment::UseMap,
      _arg2: ::T::Array[::RBS::AST::TypeParam],
      context: ::TypeAliases::RBS::Resolver::TypeAlias_context
    ).returns(::T::Array[::RBS::AST::TypeParam])
  end
  def resolve_type_params(resolver, map, _arg2, context:); end

  # Returns a context for inside given decls
  #
  sig do
    params(
      _arg0: ::TypeAliases::RBS::Environment::TypeAlias_module_decl
    ).returns(::TypeAliases::RBS::Resolver::TypeAlias_context)
  end
  def resolver_context(*_arg0); end

  class << self
    # Construct an environment from EnvironmentLoader
    #
    sig { params(_arg0: ::RBS::EnvironmentLoader).returns(::RBS::Environment) }
    def from_loader(_arg0); end
  end
end

# source://rbs//lib/rbs/environment.rb#130
class RBS::Environment::ClassAliasEntry < ::RBS::Environment::SingleEntry
  D = type_member { { fixed: ::RBS::AST::Declarations::ClassAlias } }
  N = type_member { { fixed: ::RBS::TypeName } }
end

# source://rbs//lib/rbs/environment.rb#100
class RBS::Environment::ClassEntry < ::RBS::Environment::MultiEntry
  M = type_member { { fixed: ::RBS::AST::Declarations::Class } }
end

# source://rbs//lib/rbs/environment.rb#139
class RBS::Environment::ConstantEntry < ::RBS::Environment::SingleEntry
  D = type_member { { fixed: ::RBS::AST::Declarations::Constant } }
  N = type_member { { fixed: ::RBS::TypeName } }
end

# source://rbs//lib/rbs/environment.rb#16
module RBS::Environment::ContextUtil
  sig do
    params(
      _arg0: ::T::Array[::Interfaces::RBS::Environment::Interface_NamedDecl]
    ).returns(::TypeAliases::RBS::Resolver::TypeAlias_context)
  end
  def calculate_context(_arg0); end
end

# source://rbs//lib/rbs/environment.rb#142
class RBS::Environment::GlobalEntry < ::RBS::Environment::SingleEntry
  D = type_member { { fixed: ::RBS::AST::Declarations::Global } }
  N = type_member { { fixed: ::Symbol } }
end

# source://rbs//lib/rbs/environment.rb#133
class RBS::Environment::InterfaceEntry < ::RBS::Environment::SingleEntry
  D = type_member { { fixed: ::RBS::AST::Declarations::Interface } }
  N = type_member { { fixed: ::RBS::TypeName } }
end

# source://rbs//lib/rbs/environment.rb#127
class RBS::Environment::ModuleAliasEntry < ::RBS::Environment::SingleEntry
  D = type_member { { fixed: ::RBS::AST::Declarations::ModuleAlias } }
  N = type_member { { fixed: ::RBS::TypeName } }
end

# source://rbs//lib/rbs/environment.rb#85
class RBS::Environment::ModuleEntry < ::RBS::Environment::MultiEntry
  sig { returns(::T::Array[::RBS::AST::Declarations::Module::Self]) }
  def self_types; end

  M = type_member { { fixed: ::RBS::AST::Declarations::Module } }
end

# source://rbs//lib/rbs/environment.rb#29
# Name of object, it's (multiple) declarations with the outer module declarations
#
class RBS::Environment::MultiEntry
  extend T::Generic

  sig { params(name: ::RBS::TypeName).void }
  def initialize(name:); end

  sig do
    params(
      _arg0: ::T::Array[::RBS::AST::TypeParam],
      _arg1: ::T::Array[::RBS::AST::TypeParam]
    ).returns(::TypeAliases::TypeAlias_boolish)
  end
  def compatible_params?(_arg0, _arg1); end

  sig { returns(::T::Array[::RBS::Environment::MultiEntry::D[M]]) }
  def decls; end

  sig { params(decl: M, outer: ::T::Array[::TypeAliases::RBS::Environment::TypeAlias_module_decl]).void }
  def insert(decl:, outer:); end

  sig { returns(::RBS::TypeName) }
  def name; end

  sig { returns(::RBS::Environment::MultiEntry::D[M]) }
  def primary; end

  sig { returns(::T::Array[::RBS::AST::TypeParam]) }
  def type_params; end

  sig { void }
  def validate_type_params; end

  M = type_member
end

# source://rbs//lib/rbs/environment.rb#30
class RBS::Environment::MultiEntry::D < ::Struct
  include ::RBS::Environment::ContextUtil
  extend T::Generic

  sig { params(decl: M, outer: ::T::Array[::TypeAliases::RBS::Environment::TypeAlias_module_decl]).void }
  def initialize(decl:, outer:); end

  sig { returns(::TypeAliases::RBS::Resolver::TypeAlias_context) }
  def context; end

  sig { returns(M) }
  def decl; end

  sig { returns(::T::Array[::TypeAliases::RBS::Environment::TypeAlias_module_decl]) }
  def outer; end

  M = type_member
end

# source://rbs//lib/rbs/environment.rb#109
# Name of object, it's (single) declaration, and the outer module declarations
#
class RBS::Environment::SingleEntry
  include ::RBS::Environment::ContextUtil
  extend T::Generic

  sig { params(name: N, decl: D, outer: ::T::Array[::TypeAliases::RBS::Environment::TypeAlias_module_decl]).void }
  def initialize(name:, decl:, outer:); end

  sig { returns(::TypeAliases::RBS::Resolver::TypeAlias_context) }
  def context; end

  sig { returns(D) }
  def decl; end

  sig { returns(N) }
  def name; end

  sig { returns(::T::Array[::TypeAliases::RBS::Environment::TypeAlias_module_decl]) }
  def outer; end

  D = type_member
  N = type_member
end

# source://rbs//lib/rbs/environment.rb#136
class RBS::Environment::TypeAliasEntry < ::RBS::Environment::SingleEntry
  D = type_member { { fixed: ::RBS::AST::Declarations::TypeAlias } }
  N = type_member { { fixed: ::RBS::TypeName } }
end

# source://rbs//lib/rbs/environment/use_map.rb#5
# ```rb
# map = UseMap.build(environment)
#
# map.resolve?(TypeName("TN"))   # => nil or resolved type name
# ```
class RBS::Environment::UseMap
  sig { params(table: ::RBS::Environment::UseMap::Table).void }
  def initialize(table:); end

  sig { params(_arg0: ::TypeAliases::RBS::AST::Directives::Use::TypeAlias_clause).returns(T.self_type) }
  def build_map(_arg0); end

  sig { params(_arg0: ::RBS::TypeName).returns(::RBS::TypeName) }
  def resolve(_arg0); end

  sig { params(_arg0: ::RBS::TypeName).returns(T.nilable(::RBS::TypeName)) }
  def resolve?(_arg0); end

  sig { returns(::T::Array[::RBS::AST::Directives::Use]) }
  def use_dirs; end
end

# source://rbs//lib/rbs/environment/use_map.rb#6
class RBS::Environment::UseMap::Table
  sig { void }
  def initialize; end

  sig { returns(::T::Hash[::RBS::Namespace, ::T::Set[::RBS::TypeName]]) }
  def children; end

  sig { returns(T.self_type) }
  def compute_children; end

  sig { returns(::T::Set[::RBS::TypeName]) }
  def known_types; end
end

# source://rbs//lib/rbs/environment_loader.rb#4
# EnvironmentLoader is an object to load RBS files from filesystem.
#
# Set up your configuration through repository and `#add` method.
#   # Set up the repository to load library RBSs from.
#   repo = RBS::Repository.default
#   repo.add(Pathname("vendor/rbs/gem-rbs"))
#   repo.add(Pathname("vendor/rbs/internal-rbs"))
#   loader = RBS::EnvironmentLoader.new(repository: repo)
#   # Add libraries to load RBS files.
#   loader.add(library: "minitest")
#   loader.add(library: "rbs", version: "1.0.0")
#   # Add dirs to load RBS files from.
#   loader.add(path: Pathname("sig"))
#   # Load RBSs into an environment.
#   environment = RBS::Environment.new()
#   loader.load(env: environment)
class RBS::EnvironmentLoader
  # Accepts two optional keyword arguments.
  #
  # `core_root` is the path to the directory with RBSs for core classes.
  # The default value is the core library included in RBS gem. (EnvironmentLoader::DEFAULT_CORE_ROOT)
  # Passing `nil` means it skips loading core class definitions.
  #
  # `repository` is the repository for library classes.
  # The default value is repository only with stdlib classes. (Repository.new)
  #
  sig { params(core_root: T.nilable(::Pathname), repository: ::RBS::Repository).void }
  def initialize(core_root: T.unsafe(nil), repository: T.unsafe(nil)); end

  # Add a path or library to load RBSs from.
  #
  # `path` can be a file or a directory.
  # All `.rbs` files from the given directory will be loaded.
  # Specifying a file will load the file regardless the extension of the file is.
  #
  # `library` can be a name of a gem.
  # Specifying `nil` to `version` will load any version available.
  # It first tries to load RBS files from gem with specified version.
  # If RBS files cannot be found in the gem, it tries to load RBSs from repository.
  #
  sig { params(path: ::Pathname).void }
  def add(path:); end

  # Add repository path and libraries via rbs_collection.lock.yaml.
  sig { params(lockfile: ::RBS::Collection::Config::Lockfile).void }
  def add_collection(lockfile); end

  sig { returns(T.nilable(::Pathname)) }
  def core_root; end

  sig { returns(::T::Array[::Pathname]) }
  def dirs; end

  sig do
    params(
      blk: T.proc.params(_arg0: ::TypeAliases::RBS::EnvironmentLoader::TypeAlias_source, _arg1: ::Pathname).void
    ).void
  end
  def each_dir(&blk); end

  sig do
    params(
      path: ::Pathname,
      immediate: ::TypeAliases::TypeAlias_boolish,
      skip_hidden: ::TypeAliases::TypeAlias_boolish,
      blk: T.proc.params(_arg0: ::Pathname).void
    ).void
  end
  def each_file(path, immediate:, skip_hidden:, &blk); end

  sig do
    params(
      blk: T.proc.params(_arg0: ::TypeAliases::RBS::EnvironmentLoader::TypeAlias_source, _arg1: ::Pathname, _arg2: ::RBS::Buffer, _arg3: ::T::Array[::TypeAliases::RBS::AST::Declarations::TypeAlias_t], _arg4: ::T::Array[::TypeAliases::RBS::AST::Directives::TypeAlias_t]).void
    ).void
  end
  def each_signature(&blk); end

  # This is helper function to test if RBS for a library is available or not.
  #
  sig { params(library: ::String, version: T.nilable(::String)).returns(T::Boolean) }
  def has_library?(library:, version:); end

  sig { returns(::T::Set[::RBS::EnvironmentLoader::Library]) }
  def libs; end

  # Add all declarations to environment.
  #
  # Raises `UnknownLibraryError` if RBS cannot be loaded from a library.
  #
  # Returns an array of tuples of the declaration, path to the file, and the source.
  #
  sig do
    params(
      env: ::RBS::Environment
    ).returns(::T::Array[[::TypeAliases::RBS::AST::Declarations::TypeAlias_t, ::Pathname, ::TypeAliases::RBS::EnvironmentLoader::TypeAlias_source]])
  end
  def load(env:); end

  sig { returns(::RBS::Repository) }
  def repository; end

  sig { params(library: ::String, version: T.nilable(::String)).void }
  def resolve_dependencies(library:, version:); end

  class << self
    # Returns a pair of spec and path for a gem with RBS.
    # Returns nil if the gem is not installed, or the gem doesn't provide RBS.
    #
    sig { params(name: ::String, version: T.nilable(::String)).returns(T.nilable([::Gem::Specification, ::Pathname])) }
    def gem_sig_path(name, version); end
  end
end

# source://rbs//lib/rbs/environment_loader.rb#23
RBS::EnvironmentLoader::DEFAULT_CORE_ROOT = T.let(T.unsafe(nil), Pathname)

# source://rbs//lib/rbs/environment_loader.rb#15
class RBS::EnvironmentLoader::Library < ::Struct
  sig { params(name: ::String, version: T.nilable(::String)).void }
  def initialize(name:, version:); end

  sig { returns(::String) }
  def name; end

  sig { returns(T.nilable(::String)) }
  def version; end

  Elem = type_member { { fixed: T.nilable(::String) } }
end

# source://rbs//lib/rbs/environment_loader.rb#5
class RBS::EnvironmentLoader::UnknownLibraryError < ::StandardError
  sig { params(lib: ::RBS::EnvironmentLoader::Library).void }
  def initialize(lib:); end

  sig { returns(::RBS::EnvironmentLoader::Library) }
  def library; end
end

# source://rbs//lib/rbs/environment_walker.rb#4
# EnvironmentWalker provides topological sort of class/module definitions.
#
# If a method, attribute, or ancestor in a class definition have a reference to another class, it is dependency.
# ```rb
# walker = EnvironmentWalker.new(env: env)
# walker.each_strongly_connected_component do |scc|
#   # Yields an array of strongly connected components.
# end
# ```
# The `#only_ancestors!` method limits the dependency only to ancestors.
# Only super classes and included modules are dependencies with the option.
# This is useful to calculate the dependencies of class hierarchy.
# walker = EnvironmentWalker.new(env: env).only_ancestors!
class RBS::EnvironmentWalker
  include ::TSort

  sig { params(env: ::RBS::Environment).void }
  def initialize(env:); end

  sig { returns(::RBS::DefinitionBuilder) }
  def builder; end

  sig { returns(::RBS::Environment) }
  def env; end

  sig { returns(T::Boolean) }
  def only_ancestors; end

  sig { params(only: T::Boolean).returns(T.self_type) }
  def only_ancestors!(only = T.unsafe(nil)); end

  sig { returns(T::Boolean) }
  def only_ancestors?; end

  sig do
    params(
      _arg0: ::TypeAliases::RBS::EnvironmentWalker::TypeAlias_node,
      blk: T.proc.params(_arg0: ::TypeAliases::RBS::EnvironmentWalker::TypeAlias_node).void
    ).void
  end
  def tsort_each_child(_arg0, &blk); end

  sig { params(blk: T.proc.params(_arg0: ::TypeAliases::RBS::EnvironmentWalker::TypeAlias_node).void).void }
  def tsort_each_node(&blk); end

  private

  sig { params(_arg0: ::TypeAliases::RBS::Types::TypeAlias_t, blk: T.proc.params(_arg0: ::RBS::TypeName).void).void }
  def each_type_name(_arg0, &blk); end

  sig do
    params(
      _arg0: ::TypeAliases::RBS::Types::TypeAlias_t,
      blk: T.proc.params(_arg0: ::TypeAliases::RBS::EnvironmentWalker::TypeAlias_node).void
    ).void
  end
  def each_type_node(_arg0, &blk); end
end

# source://rbs//lib/rbs/environment_walker.rb#5
class RBS::EnvironmentWalker::InstanceNode < ::Struct
  sig { params(type_name: ::RBS::TypeName).void }
  def initialize(type_name:); end

  sig { returns(::RBS::TypeName) }
  def type_name; end
end

# source://rbs//lib/rbs/environment_walker.rb#6
class RBS::EnvironmentWalker::SingletonNode < ::Struct
  sig { params(type_name: ::RBS::TypeName).void }
  def initialize(type_name:); end

  sig { returns(::RBS::TypeName) }
  def type_name; end
end

# source://rbs//lib/rbs/environment_walker.rb#7
class RBS::EnvironmentWalker::TypeNameNode < ::Struct
  sig { params(type_name: ::RBS::TypeName).void }
  def initialize(type_name:); end

  sig { returns(::RBS::TypeName) }
  def type_name; end
end

# source://rbs//lib/rbs/factory.rb#4
class RBS::Factory
  sig { params(_arg0: ::String).returns(::RBS::TypeName) }
  def type_name(_arg0); end
end

# source://rbs//lib/rbs/errors.rb#335
class RBS::GenericParameterMismatchError < ::RBS::LoadingError
  sig do
    params(
      name: ::RBS::TypeName,
      decl: T.any(::RBS::AST::Declarations::Class, ::RBS::AST::Declarations::Module)
    ).void
  end
  def initialize(name:, decl:); end

  sig { returns(T.any(::RBS::AST::Declarations::Class, ::RBS::AST::Declarations::Module)) }
  def decl; end

  sig { returns(::RBS::TypeName) }
  def name; end
end

# source://rbs//lib/rbs/errors.rb#469
# A module/class alias declaration has inconsistent right-hand-side
#
# ```rbs
# module Foo = Object     # Error
# class Bar = Kernel      # Error
# ```
class RBS::InconsistentClassModuleAliasError < ::RBS::BaseError
  sig { params(_arg0: T.any(::RBS::Environment::ClassAliasEntry, ::RBS::Environment::ModuleAliasEntry)).void }
  def initialize(_arg0); end

  sig { returns(T.any(::RBS::Environment::ClassAliasEntry, ::RBS::Environment::ModuleAliasEntry)) }
  def alias_entry; end
end

# source://rbs//lib/rbs/errors.rb#165
# InheritModuleError is raised if a class definition inherits a module (not a class)
#
class RBS::InheritModuleError < ::RBS::DefinitionError
  sig { params(_arg0: ::RBS::AST::Declarations::Class::Super).void }
  def initialize(_arg0); end

  sig { returns(T.nilable(::RBS::Location[T.untyped, T.untyped])) }
  def location; end

  sig { returns(::RBS::AST::Declarations::Class::Super) }
  def super_decl; end

  class << self
    sig { params(_arg0: ::RBS::AST::Declarations::Class::Super, env: ::RBS::Environment).void }
    def check!(_arg0, env:); end
  end
end

# source://rbs//lib/rbs/errors.rb#312
# The *overloading* method definition cannot find *non-overloading* method definition
#
class RBS::InvalidOverloadMethodError < ::RBS::DefinitionError
  sig do
    params(
      type_name: ::RBS::TypeName,
      method_name: ::Symbol,
      kind: T.untyped,
      members: ::T::Array[::RBS::AST::Members::MethodDefinition]
    ).void
  end
  def initialize(type_name:, method_name:, kind:, members:); end

  sig { returns(T.untyped) }
  def kind; end

  sig { returns(::T::Array[::RBS::AST::Members::MethodDefinition]) }
  def members; end

  sig { returns(::Symbol) }
  def method_name; end

  sig { returns(::RBS::TypeName) }
  def type_name; end
end

# source://rbs//lib/rbs/errors.rb#69
class RBS::InvalidTypeApplicationError < ::RBS::DefinitionError
  sig do
    params(
      type_name: ::RBS::TypeName,
      args: ::T::Array[::TypeAliases::RBS::Types::TypeAlias_t],
      params: ::T::Array[::Symbol],
      location: T.nilable(::RBS::Location[T.untyped, T.untyped])
    ).void
  end
  def initialize(type_name:, args:, params:, location:); end

  sig { returns(::T::Array[::TypeAliases::RBS::Types::TypeAlias_t]) }
  def args; end

  sig { returns(T.nilable(::RBS::Location[T.untyped, T.untyped])) }
  def location; end

  sig { returns(::T::Array[::Symbol]) }
  def params; end

  sig { returns(::RBS::TypeName) }
  def type_name; end

  class << self
    sig do
      params(
        type_name: ::RBS::TypeName,
        args: ::T::Array[::TypeAliases::RBS::Types::TypeAlias_t],
        params: ::T::Array[::Symbol],
        location: T.nilable(::RBS::Location[T.untyped, T.untyped])
      ).void
    end
    def check!(type_name:, args:, params:, location:); end
  end
end

# source://rbs//lib/rbs/errors.rb#359
class RBS::InvalidVarianceAnnotationError < ::RBS::DefinitionError
  sig do
    params(
      type_name: ::RBS::TypeName,
      param: ::RBS::AST::TypeParam,
      location: T.nilable(::RBS::Location[T.untyped, T.untyped])
    ).void
  end
  def initialize(type_name:, param:, location:); end

  sig { returns(T.nilable(::RBS::Location[T.untyped, T.untyped])) }
  def location; end

  sig { returns(::RBS::AST::TypeParam) }
  def param; end

  sig { returns(::RBS::TypeName) }
  def type_name; end
end

# source://rbs//lib/rbs/errors.rb#20
# Error class for errors raised during loading environments.
#
class RBS::LoadingError < ::RBS::BaseError; end

# source://rbs//lib/rbs/location_aux.rb#4
# Location is the range on buffer, `start_pos..end_pos`.
# The index is based on characters.
#
# A location can have _child_ locations.
class RBS::Location
  extend T::Generic
  include ::Interfaces::Interface_ToJson

  alias aref []

  sig { params(_arg0: ::RBS::Buffer, start_pos: ::Integer, end_pos: ::Integer).void }
  def initialize(_arg0, start_pos, end_pos); end

  sig { params(other: T.untyped).returns(T::Boolean) }
  def ==(other); end

  # Returns `Location` instance for given _child_ name.
  #
  #     # @type var loc: Location::WithChildren[:name, :args]
  #     loc[:name]      # => Location
  #     loc[:args]      # => may be nil
  #
  # Note that passing unknown symbol raises an error even if the child is _optional_.
  # You need explicitly set `nil` for absent optional children.
  #
  sig { params(_arg0: RequiredChildKeys).returns(::RBS::Location[T.untyped, T.untyped]) }
  def [](_arg0); end

  sig { params(name: OptionalChildKeys, range: T.nilable(::T::Range[::Integer])).void }
  def add_optional_child(name, range); end

  sig { params(name: RequiredChildKeys, range: ::T::Range[::Integer]).void }
  def add_required_child(name, range); end

  sig { returns(::RBS::Buffer) }
  def buffer; end

  sig { params(blk: T.proc.params(_arg0: ::Symbol).void).void }
  def each_optional_key(&blk); end

  sig { params(blk: T.proc.params(_arg0: ::Symbol).void).void }
  def each_required_key(&blk); end

  sig { returns(::Integer) }
  def end_column; end

  sig { returns(::Integer) }
  def end_line; end

  sig { returns(::TypeAliases::RBS::Buffer::TypeAlias_loc) }
  def end_loc; end

  sig { returns(::Integer) }
  def end_pos; end

  sig { returns(::String) }
  def inspect; end

  sig { params(_arg0: ::Symbol).returns(T::Boolean) }
  def key?(_arg0); end

  # Returns the name of the buffer.
  sig { returns(T.untyped) }
  def name; end

  sig { params(_arg0: ::Symbol).returns(T::Boolean) }
  def optional_key?(_arg0); end

  sig { returns(::T::Range[::Integer]) }
  def range; end

  sig { params(_arg0: ::Symbol).returns(T::Boolean) }
  def required_key?(_arg0); end

  # A substring of buffer associated to the location.
  sig { returns(::String) }
  def source; end

  sig { returns(::Integer) }
  def start_column; end

  sig { returns(::Integer) }
  def start_line; end

  sig { returns(::TypeAliases::RBS::Buffer::TypeAlias_loc) }
  def start_loc; end

  sig { returns(::Integer) }
  def start_pos; end

  sig { returns(::String) }
  def to_s; end

  private

  sig { params(name: OptionalChildKeys, start_pos: ::Integer, end_pos: ::Integer).void }
  def _add_optional_child(name, start_pos, end_pos); end

  sig { params(name: OptionalChildKeys).void }
  def _add_optional_no_child(name); end

  sig { params(name: RequiredChildKeys, start_pos: ::Integer, end_pos: ::Integer).void }
  def _add_required_child(name, start_pos, end_pos); end

  sig { returns(T.nilable(::TypeAliases::RBS::Buffer::TypeAlias_loc)) }
  def _end_loc; end

  sig { returns(::T::Array[::Symbol]) }
  def _optional_keys; end

  sig { returns(::T::Array[::Symbol]) }
  def _required_keys; end

  sig { returns(T.nilable(::TypeAliases::RBS::Buffer::TypeAlias_loc)) }
  def _start_loc; end

  class << self
    sig { params(_arg0: ::RBS::Buffer, start_pos: ::Integer, end_pos: ::Integer).returns(T.attached_class) }
    def new(_arg0, start_pos, end_pos); end

    # Returns a string representation suitable for terminal output.
    #
    #     Location.to_string(loc)  # => a.rb:1:0...3:4
    #     Location.to_string(nil)  # => *:*:*..*:*
    #
    sig { params(location: T.nilable(::RBS::Location[T.untyped, T.untyped]), default: ::String).returns(::String) }
    def to_string(location, default: T.unsafe(nil)); end
  end

  OptionalChildKeys = type_member
  RequiredChildKeys = type_member
end

# source://rbs//lib/rbs/location_aux.rb#24
RBS::Location::WithChildren = RBS::Location

# source://rbs//lib/rbs/locator.rb#4
# Locator helps finding RBS elements based on locations in the RBS source text.
#
class RBS::Locator
  sig do
    params(
      buffer: ::RBS::Buffer,
      decls: ::T::Array[::TypeAliases::RBS::AST::Declarations::TypeAlias_t],
      dirs: ::T::Array[::TypeAliases::RBS::AST::Directives::TypeAlias_t]
    ).void
  end
  def initialize(buffer:, decls:, dirs:); end

  sig { returns(::RBS::Buffer) }
  def buffer; end

  sig { returns(::T::Array[::TypeAliases::RBS::AST::Declarations::TypeAlias_t]) }
  def decls; end

  sig { returns(::T::Array[::TypeAliases::RBS::AST::Directives::TypeAlias_t]) }
  def dirs; end

  # Returns list of components.
  # Inner component comes first.
  #
  sig do
    params(
      line: ::Integer,
      column: ::Integer
    ).returns(::T::Array[::TypeAliases::RBS::Locator::TypeAlias_component])
  end
  def find(line:, column:); end

  # Returns pair of the inner most symbol and outer components.
  # It ensures the array starts with a AST/type component.
  #
  sig do
    params(
      line: ::Integer,
      column: ::Integer
    ).returns(T.nilable([T.nilable(::Symbol), ::T::Array[::TypeAliases::RBS::Locator::TypeAlias_component]]))
  end
  def find2(line:, column:); end

  private

  sig do
    params(
      pos: ::Integer,
      decl: ::TypeAliases::RBS::AST::Declarations::TypeAlias_t,
      array: ::T::Array[::TypeAliases::RBS::Locator::TypeAlias_component]
    ).returns(T::Boolean)
  end
  def find_in_decl(pos, decl:, array:); end

  sig do
    params(
      pos: ::Integer,
      _arg1: ::TypeAliases::RBS::AST::Directives::TypeAlias_t,
      _arg2: ::T::Array[::TypeAliases::RBS::Locator::TypeAlias_component]
    ).returns(T::Boolean)
  end
  def find_in_directive(pos, _arg1, _arg2); end

  sig do
    params(
      pos: ::Integer,
      location: T.nilable(::RBS::Location[T.untyped, T.untyped]),
      array: ::T::Array[::TypeAliases::RBS::Locator::TypeAlias_component]
    ).returns(T::Boolean)
  end
  def find_in_loc(pos, location:, array:); end

  sig do
    params(
      pos: ::Integer,
      member: ::TypeAliases::RBS::AST::Members::TypeAlias_t,
      array: ::T::Array[::TypeAliases::RBS::Locator::TypeAlias_component]
    ).returns(T::Boolean)
  end
  def find_in_member(pos, member:, array:); end

  sig do
    params(
      pos: ::Integer,
      method_type: ::RBS::MethodType,
      array: ::T::Array[::TypeAliases::RBS::Locator::TypeAlias_component]
    ).returns(T::Boolean)
  end
  def find_in_method_type(pos, method_type:, array:); end

  sig do
    params(
      pos: ::Integer,
      type: ::TypeAliases::RBS::Types::TypeAlias_t,
      array: ::T::Array[::TypeAliases::RBS::Locator::TypeAlias_component]
    ).returns(T::Boolean)
  end
  def find_in_type(pos, type:, array:); end

  sig do
    params(
      pos: ::Integer,
      type_param: ::RBS::AST::TypeParam,
      array: ::T::Array[::TypeAliases::RBS::Locator::TypeAlias_component]
    ).returns(T::Boolean)
  end
  def find_in_type_param(pos, type_param:, array:); end

  sig { params(pos: ::Integer, location: T.nilable(::RBS::Location[T.untyped, T.untyped])).returns(T::Boolean) }
  def test_loc(pos, location:); end
end

# source://rbs//lib/rbs/errors.rb#4
module RBS::MethodNameHelper
  sig { returns(::String) }
  def method_name_string; end
end

# source://rbs//lib/rbs/method_type.rb#4
class RBS::MethodType
  include ::Interfaces::Interface_ToJson

  sig do
    params(
      type_params: ::T::Array[::RBS::AST::TypeParam],
      type: ::RBS::Types::Function,
      block: T.nilable(::RBS::Types::Block),
      location: T.nilable(::TypeAliases::RBS::MethodType::TypeAlias_loc)
    ).void
  end
  def initialize(type_params:, type:, block:, location:); end

  sig { params(other: T.untyped).returns(T::Boolean) }
  def ==(other); end

  sig { returns(T.nilable(::RBS::Types::Block)) }
  def block; end

  sig { params(blk: T.proc.params(_arg0: ::TypeAliases::RBS::Types::TypeAlias_t).void).void }
  def each_type(&blk); end

  sig { params(set: ::T::Set[::Symbol]).returns(::T::Set[::Symbol]) }
  def free_variables(set = T.unsafe(nil)); end

  sig { returns(T.nilable(::TypeAliases::RBS::MethodType::TypeAlias_loc)) }
  def location; end

  # Apply the mapping included in the MethodType.
  #
  # Note that type bound in generics parameter is not handled by this method.
  # You may want to use `#map_type_bound` explicitly, or `#sub` for simple substitution.
  #
  sig do
    params(
      blk: T.proc.params(_arg0: ::TypeAliases::RBS::Types::TypeAlias_t).returns(::TypeAliases::RBS::Types::TypeAlias_t)
    ).returns(::RBS::MethodType)
  end
  def map_type(&blk); end

  sig do
    params(
      blk: T.proc.params(_arg0: ::TypeAliases::RBS::AST::TypeParam::TypeAlias_bound).returns(::TypeAliases::RBS::AST::TypeParam::TypeAlias_bound)
    ).returns(::RBS::MethodType)
  end
  def map_type_bound(&blk); end

  # Substitute type variables to some types.
  # Takes care of type parameter bounds.
  #
  sig { params(_arg0: ::RBS::Substitution).returns(::RBS::MethodType) }
  def sub(_arg0); end

  sig { returns(::String) }
  def to_s; end

  sig { returns(::RBS::Types::Function) }
  def type; end

  sig { returns(::T::Array[::Symbol]) }
  def type_param_names; end

  sig { returns(::T::Array[::RBS::AST::TypeParam]) }
  def type_params; end

  sig do
    params(
      type_params: ::T::Array[::RBS::AST::TypeParam],
      type: ::RBS::Types::Function,
      block: T.nilable(::RBS::Types::Block),
      location: T.nilable(::TypeAliases::RBS::MethodType::TypeAlias_loc)
    ).returns(::RBS::MethodType)
  end
  def update(type_params: T.unsafe(nil), type: T.unsafe(nil), block: T.unsafe(nil), location: T.unsafe(nil)); end
end

# source://rbs//lib/rbs/errors.rb#391
# MixinClassError is raised if a include/prepend/extend has a class (not a module) to mix-in
#
class RBS::MixinClassError < ::RBS::DefinitionError
  sig { params(type_name: ::RBS::TypeName, member: ::TypeAliases::RBS::MixinClassError::TypeAlias_member).void }
  def initialize(type_name:, member:); end

  sig { returns(T.nilable(::RBS::Location[T.untyped, T.untyped])) }
  def location; end

  sig { returns(::TypeAliases::RBS::MixinClassError::TypeAlias_member) }
  def member; end

  sig { returns(::String) }
  def mixin_name; end

  sig { returns(::RBS::TypeName) }
  def type_name; end

  class << self
    sig do
      params(
        type_name: ::RBS::TypeName,
        env: ::RBS::Environment,
        member: ::TypeAliases::RBS::MixinClassError::TypeAlias_member
      ).void
    end
    def check!(type_name:, env:, member:); end
  end
end

# source://rbs//lib/rbs/namespace.rb#4
# Namespace instance represents a _prefix of module names_.
#
# ```
# vvvvvvvvvvvvvv  TypeName
# RBS::Namespace
# ^^^^^           Namespace
# vvvvvvvvvv    TypeName
# RBS::Types
# ^^^^^         Namespace
# vvvvvvvvvvvvvvvvv    TypeName
# RBS::Types::Union
# ^^^^^^^^^^^^         Namespace
# Note that `Namespace` is an RBS specific concept and there is no corresponding concept in Ruby.
# There are _absolute_ and _relative_ namespaces.
# Namespace(::RBS::)         # Absolute namespace
# Namespace(  RBS::)         # Relative namespace
# It also defines two special namespaces.
# ::              # _Root_ namespace
#                 # _Empty_ namespace
class RBS::Namespace
  alias eql? ==

  sig { params(path: ::T::Array[::Symbol], absolute: ::TypeAliases::TypeAlias_boolish).void }
  def initialize(path:, absolute:); end

  # Concat two namespaces.
  #
  # ```rb
  # Namespace("Foo::") + Namespace("Bar::")   # => Foo::Bar::
  # Namespace("::Foo::") + Namespace("Bar::") # => ::Foo::Bar::
  # ```
  #
  # If `other` is an absolute namespace, it returns `other`.
  #
  # ```rb
  # Namespace("Foo::") + Namespace("::Bar::")  # =>  ::Bar::
  # ```
  sig { params(other: ::RBS::Namespace).returns(::RBS::Namespace) }
  def +(other); end

  # Equality is defined by its structure.
  #
  sig { params(other: T.untyped).returns(T::Boolean) }
  def ==(other); end

  # Returns absolute namespace.
  #
  # ```rb
  # Namespace("A").absolute!      # => Namespace("::A")
  # Namespace("::A").absolute!    # => Namespace("::A")
  # ```
  sig { returns(::RBS::Namespace) }
  def absolute!; end

  # Returns true if self is absolute namespace.
  sig { returns(T::Boolean) }
  def absolute?; end

  # Add one path component to self.
  #
  # ```rb
  # Namespace("Foo::").append(:Bar) # => Namespace("Foo::Bar::")
  # ```
  sig { params(component: ::Symbol).returns(::RBS::Namespace) }
  def append(component); end

  # Iterate over Namespace for each element in ascending order.
  #
  # ```rb
  # Namespace.parse("::A::B::C").ascend {|ns| p ns }
  #   # => ::A::B::C
  #   # => ::A::B
  #   # => ::A
  #   # => ::(root)
  # ```
  sig { params(blk: T.proc.params(_arg0: ::RBS::Namespace).void).void }
  def ascend(&blk); end

  sig { returns(T::Boolean) }
  def empty?; end

  # Hash is defined based on its structure.
  #
  sig { returns(::Integer) }
  def hash; end

  # Returns parent namespace.
  # Raises error there is no parent namespace.
  #
  # ```rb
  # Namespace("::A").parent    # => Namespace("::")
  # Namespace("::").parent     # raises error
  # Namespace("A::B").parent   # => Namespace("A")
  # ```
  sig { returns(::RBS::Namespace) }
  def parent; end

  sig { returns(::T::Array[::Symbol]) }
  def path; end

  # Returns _relative_ namespace.
  #
  sig { returns(::RBS::Namespace) }
  def relative!; end

  # Returns true if self is relative namespace.
  sig { returns(T::Boolean) }
  def relative?; end

  # Returns a pair of parent namespace and a symbol of last component.
  #
  # ```rb
  # Namespace("::A::B::C").split    # => [Namespace("::A::B::"), :C]
  # ```
  sig { returns(T.nilable([::RBS::Namespace, ::Symbol])) }
  def split; end

  sig { returns(::String) }
  def to_s; end

  # Construct a type name which points to the same name type.
  #
  sig { returns(::RBS::TypeName) }
  def to_type_name; end

  class << self
    # Returns new _empty_ namespace.
    sig { returns(::RBS::Namespace) }
    def empty; end

    sig { params(string: ::String).returns(::RBS::Namespace) }
    def parse(string); end

    # Returns new _root_ namespace.
    sig { returns(::RBS::Namespace) }
    def root; end
  end
end

# source://rbs//lib/rbs/errors.rb#199
class RBS::NoMixinFoundError < ::RBS::DefinitionError
  sig { params(type_name: ::RBS::TypeName, member: ::TypeAliases::RBS::AST::Members::TypeAlias_t).void }
  def initialize(type_name:, member:); end

  sig { returns(T.nilable(::RBS::Location[T.untyped, T.untyped])) }
  def location; end

  sig { returns(::TypeAliases::RBS::AST::Members::TypeAlias_t) }
  def member; end

  sig { returns(::RBS::TypeName) }
  def type_name; end

  class << self
    sig do
      params(
        _arg0: ::RBS::TypeName,
        env: ::RBS::Environment,
        member: ::TypeAliases::RBS::AST::Members::TypeAlias_t
      ).void
    end
    def check!(_arg0, env:, member:); end
  end
end

# source://rbs//lib/rbs/errors.rb#181
class RBS::NoSelfTypeFoundError < ::RBS::DefinitionError
  sig { params(type_name: ::RBS::TypeName, location: T.nilable(::RBS::Location[T.untyped, T.untyped])).void }
  def initialize(type_name:, location:); end

  sig { returns(T.nilable(::RBS::Location[T.untyped, T.untyped])) }
  def location; end

  sig { returns(::RBS::TypeName) }
  def type_name; end

  class << self
    sig { params(_arg0: ::RBS::AST::Declarations::Module::Self, env: ::RBS::Environment).void }
    def check!(_arg0, env:); end
  end
end

# source://rbs//lib/rbs/errors.rb#145
class RBS::NoSuperclassFoundError < ::RBS::DefinitionError
  sig { params(type_name: ::RBS::TypeName, location: T.nilable(::RBS::Location[T.untyped, T.untyped])).void }
  def initialize(type_name:, location:); end

  sig { returns(T.nilable(::RBS::Location[T.untyped, T.untyped])) }
  def location; end

  sig { returns(::RBS::TypeName) }
  def type_name; end

  class << self
    sig do
      params(
        _arg0: ::RBS::TypeName,
        env: ::RBS::Environment,
        location: T.nilable(::RBS::Location[T.untyped, T.untyped])
      ).void
    end
    def check!(_arg0, env:, location:); end
  end
end

# source://rbs//lib/rbs/errors.rb#128
class RBS::NoTypeFoundError < ::RBS::BaseError
  sig { params(type_name: ::RBS::TypeName, location: T.nilable(::RBS::Location[T.untyped, T.untyped])).void }
  def initialize(type_name:, location:); end

  sig { returns(T.nilable(::RBS::Location[T.untyped, T.untyped])) }
  def location; end

  sig { returns(::RBS::TypeName) }
  def type_name; end

  class << self
    sig do
      params(
        _arg0: ::RBS::TypeName,
        env: ::RBS::Environment,
        location: T.nilable(::RBS::Location[T.untyped, T.untyped])
      ).returns(::RBS::TypeName)
    end
    def check!(_arg0, env:, location:); end
  end
end

# source://rbs//lib/rbs/errors.rb#444
class RBS::NonregularTypeAliasError < ::RBS::BaseError
  sig do
    params(
      diagnostic: ::RBS::TypeAliasRegularity::Diagnostic,
      location: T.nilable(::RBS::Location[T.untyped, T.untyped])
    ).void
  end
  def initialize(diagnostic:, location:); end

  sig { returns(::RBS::TypeAliasRegularity::Diagnostic) }
  def diagnostic; end

  sig { returns(T.nilable(::RBS::Location[T.untyped, T.untyped])) }
  def location; end
end

# source://rbs//lib/rbs/parser_aux.rb#4
class RBS::Parser
  class << self
    # Parse a method type and return it
    #
    # When `pos` keyword is specified, skips the first `pos` characters from the input.
    # If no token is left in the input, it returns `nil`.
    #
    # ```ruby
    # RBS::Parser.parse_method_type("() -> void")                                # => `() -> void`
    # RBS::Parser.parse_method_type("() -> void", range: 0...)                   # => `() -> void`
    # RBS::Parser.parse_method_type("() -> void () -> String", range: 11...)     # => `() -> String`
    # RBS::Parser.parse_method_type("() -> void () -> String", range: 23...)     # => nil
    # ```
    #
    sig do
      params(
        _arg0: T.any(::RBS::Buffer, ::String),
        range: ::T::Range[T.nilable(::Integer)],
        variables: ::T::Array[::Symbol]
      ).returns(T.nilable(::RBS::MethodType))
    end
    def parse_method_type(_arg0, range: T.unsafe(nil), variables: T.unsafe(nil)); end

    # Parse whole RBS file and return an array of declarations
    #
    sig do
      params(
        _arg0: T.any(::RBS::Buffer, ::String)
      ).returns([::RBS::Buffer, ::T::Array[::TypeAliases::RBS::AST::Directives::TypeAlias_t], ::T::Array[::TypeAliases::RBS::AST::Declarations::TypeAlias_t]])
    end
    def parse_signature(_arg0); end

    # Parse a type and return it
    #
    # When `pos` keyword is specified, skips the first `pos` characters from the input.
    # If no token is left in the input, it returns `nil`.
    #
    # ```ruby
    # RBS::Parser.parse_type("String")                          # => `String`
    # RBS::Parser.parse_type("String", range: 0...)             # => `String`
    # RBS::Parser.parse_type("String Integer", pos: 7...)       # => `Integer`
    # RBS::Parser.parse_type("String Integer", pos: 14...)      # => nil
    # ```
    #
    sig do
      params(
        _arg0: T.any(::RBS::Buffer, ::String),
        range: ::T::Range[T.nilable(::Integer)],
        variables: ::T::Array[::Symbol]
      ).returns(T.nilable(::TypeAliases::RBS::Types::TypeAlias_t))
    end
    def parse_type(_arg0, range: T.unsafe(nil), variables: T.unsafe(nil)); end

    private

    sig do
      params(
        _arg0: ::RBS::Buffer,
        start_pos: ::Integer,
        end_pos: ::Integer,
        variables: ::T::Array[::Symbol]
      ).returns(T.nilable(::RBS::MethodType))
    end
    def _parse_method_type(_arg0, start_pos, end_pos, variables); end

    sig do
      params(
        _arg0: ::RBS::Buffer,
        end_pos: ::Integer
      ).returns([::T::Array[::TypeAliases::RBS::AST::Directives::TypeAlias_t], ::T::Array[::TypeAliases::RBS::AST::Declarations::TypeAlias_t]])
    end
    def _parse_signature(_arg0, end_pos); end

    sig do
      params(
        _arg0: ::RBS::Buffer,
        start_pos: ::Integer,
        end_pos: ::Integer,
        variables: ::T::Array[::Symbol]
      ).returns(T.nilable(::TypeAliases::RBS::Types::TypeAlias_t))
    end
    def _parse_type(_arg0, start_pos, end_pos, variables); end

    sig { params(source: T.any(::RBS::Buffer, ::String)).returns(::RBS::Buffer) }
    def buffer(source); end
  end
end

# source://rbs//lib/rbs/parser_aux.rb#36
RBS::Parser::KEYWORDS = T.let(T.unsafe(nil), Hash)

# source://rbs//lib/rbs/parser_compat/lexer_error.rb#6
RBS::Parser::LexerError = RBS::ParsingError

# source://rbs//lib/rbs/parser_compat/located_value.rb#6
class RBS::Parser::LocatedValue; end

# source://rbs//lib/rbs/parser_compat/semantics_error.rb#6
RBS::Parser::SemanticsError = RBS::ParsingError

# source://rbs//lib/rbs/parser_compat/syntax_error.rb#6
RBS::Parser::SyntaxError = RBS::ParsingError

# source://rbs//lib/rbs/errors.rb#39
# Error class for errors raised during parsing.
#
class RBS::ParsingError < ::RBS::BaseError
  include ::RBS::DetailedMessageable

  sig { params(_arg0: ::RBS::Location[T.untyped, T.untyped], error_message: ::String, token_type: ::String).void }
  def initialize(_arg0, error_message, token_type); end

  sig { returns(::String) }
  def error_message; end

  sig { returns(::String) }
  def error_value; end

  sig { returns(::RBS::Location[T.untyped, T.untyped]) }
  def location; end

  sig { returns(::String) }
  def token_str; end

  sig { returns(::String) }
  def token_type; end
end

# source://rbs//lib/rbs/prototype/helpers.rb#4
module RBS::Prototype; end

# source://rbs//lib/rbs/prototype/helpers.rb#5
module RBS::Prototype::Helpers
  sig do
    params(
      _arg0: ::TypeAliases::RBS::Prototype::Helpers::TypeAlias_node,
      nodes: ::T::Array[::TypeAliases::RBS::Prototype::Helpers::TypeAlias_node],
      blk: T.proc.params(_arg0: ::TypeAliases::RBS::Prototype::Helpers::TypeAlias_node).returns(T::Boolean)
    ).returns(T.nilable(::T::Array[::TypeAliases::RBS::Prototype::Helpers::TypeAlias_node]))
  end
  def any_node?(_arg0, nodes: T.unsafe(nil), &blk); end

  sig do
    params(
      _arg0: T.nilable(::TypeAliases::RBS::Prototype::Helpers::TypeAlias_node)
    ).returns(::T::Array[T.untyped])
  end
  def args_from_node(_arg0); end

  sig { params(_arg0: ::TypeAliases::RBS::Prototype::Helpers::TypeAlias_node).returns(T.nilable(::RBS::Types::Block)) }
  def block_from_body(_arg0); end

  sig do
    params(
      _arg0: ::TypeAliases::RBS::Prototype::Helpers::TypeAlias_node,
      blk: T.proc.params(child: ::TypeAliases::RBS::Prototype::Helpers::TypeAlias_node).void
    ).void
  end
  def each_child(_arg0, &blk); end

  sig do
    params(
      nodes: ::T::Array[T.untyped],
      blk: T.proc.params(_arg0: ::TypeAliases::RBS::Prototype::Helpers::TypeAlias_node).void
    ).void
  end
  def each_node(nodes, &blk); end

  sig { params(_arg0: ::TypeAliases::RBS::Prototype::Helpers::TypeAlias_node).returns(T::Boolean) }
  def keyword_hash?(_arg0); end

  sig { returns(::RBS::Types::Bases::Any) }
  def untyped; end
end

# source://rbs//lib/rbs/prototype/node_usage.rb#5
class RBS::Prototype::NodeUsage
  include ::RBS::Prototype::Helpers

  sig { params(_arg0: ::TypeAliases::RBS::Prototype::NodeUsage::TypeAlias_node).void }
  def initialize(_arg0); end

  sig { params(_arg0: ::TypeAliases::RBS::Prototype::NodeUsage::TypeAlias_node, conditional: T::Boolean).void }
  def calculate(_arg0, conditional:); end

  sig { returns(::T::Set[::TypeAliases::RBS::Prototype::NodeUsage::TypeAlias_node]) }
  def conditional_nodes; end

  sig { params(blk: T.proc.params(_arg0: ::TypeAliases::RBS::Prototype::NodeUsage::TypeAlias_node).void).void }
  def each_conditional_node(&blk); end

  sig { returns(::TypeAliases::RBS::Prototype::NodeUsage::TypeAlias_node) }
  def node; end
end

# source://rbs//lib/rbs/prototype/rb.rb#5
class RBS::Prototype::RB
  include ::RBS::Prototype::Helpers

  alias node_type param_type

  sig { void }
  def initialize; end

  sig { params(node: ::RubyVM::AbstractSyntaxTree::Node).returns(::TypeAliases::RBS::Types::TypeAlias_t) }
  def block_type(node); end

  sig { params(node: ::RubyVM::AbstractSyntaxTree::Node).returns(::TypeAliases::RBS::Types::TypeAlias_t) }
  def body_type(node); end

  # Returns a type name that represents the name of the constant.
  # `node` can be `SELF` for `extend self` pattern.
  #
  sig do
    params(
      node: T.nilable(::RubyVM::AbstractSyntaxTree::Node),
      context: ::RBS::Prototype::RB::Context
    ).returns(T.nilable(::RBS::TypeName))
  end
  def const_to_name(node, context:); end

  # Returns a type name that represents the name of the constant.
  # `node` must be _constant_ node, `CONST`, `COLON2`, or `COLON3` node.
  #
  sig { params(node: ::RubyVM::AbstractSyntaxTree::Node).returns(::RBS::TypeName) }
  def const_to_name!(node); end

  sig do
    params(
      decls: ::T::Array[::TypeAliases::RBS::Prototype::RB::TypeAlias_decl],
      index: ::Integer
    ).returns(T.any(::RBS::AST::Members::Private, ::RBS::AST::Members::Public))
  end
  def current_accessibility(decls, index = T.unsafe(nil)); end

  sig { returns(::T::Array[::TypeAliases::RBS::AST::Declarations::TypeAlias_t]) }
  def decls; end

  sig do
    params(
      decls: ::T::Array[::TypeAliases::RBS::Prototype::RB::TypeAlias_decl],
      name: ::Symbol
    ).returns(T.nilable([::Integer, T.any(::RBS::AST::Members::AttrReader, ::RBS::AST::Members::AttrWriter, ::RBS::AST::Members::MethodDefinition)]))
  end
  def find_def_index_by_name(decls, name); end

  sig { params(node: ::RubyVM::AbstractSyntaxTree::Node).returns(::TypeAliases::RBS::Types::TypeAlias_t) }
  def function_return_type_from_body(node); end

  sig { params(node: ::RubyVM::AbstractSyntaxTree::Node, def_name: ::Symbol).returns(::RBS::Types::Function) }
  def function_type_from_body(node, def_name); end

  sig { params(node: ::RubyVM::AbstractSyntaxTree::Node).returns(::TypeAliases::RBS::Types::TypeAlias_t) }
  def if_unless_type(node); end

  sig { params(_arg0: ::TypeAliases::RBS::Prototype::RB::TypeAlias_decl).returns(T::Boolean) }
  def is_accessibility?(_arg0); end

  sig { params(node: ::RubyVM::AbstractSyntaxTree::Node).returns(T.nilable(::Symbol)) }
  def literal_to_symbol(node); end

  sig { params(node: ::RubyVM::AbstractSyntaxTree::Node).returns(::TypeAliases::RBS::Types::TypeAlias_t) }
  def literal_to_type(node); end

  sig do
    params(
      node: ::RubyVM::AbstractSyntaxTree::Node,
      default: ::RBS::Types::Bases::Any
    ).returns(::TypeAliases::RBS::Types::TypeAlias_t)
  end
  def param_type(node, default: T.unsafe(nil)); end

  sig { params(_arg0: ::String).void }
  def parse(_arg0); end

  sig { returns(::RBS::AST::Members::Private) }
  def private; end

  sig do
    params(
      node: T.untyped,
      decls: ::T::Array[T.any(::TypeAliases::RBS::AST::Declarations::TypeAlias_t, ::TypeAliases::RBS::AST::Members::TypeAlias_t)],
      comments: ::T::Hash[::Integer, ::RBS::AST::Comment],
      context: ::RBS::Prototype::RB::Context
    ).void
  end
  def process(node, decls:, comments:, context:); end

  sig do
    params(
      node: ::RubyVM::AbstractSyntaxTree::Node,
      decls: ::T::Array[::TypeAliases::RBS::Prototype::RB::TypeAlias_decl],
      comments: ::T::Hash[::Integer, ::RBS::AST::Comment],
      context: ::RBS::Prototype::RB::Context
    ).void
  end
  def process_children(node, decls:, comments:, context:); end

  sig { returns(::RBS::AST::Members::Public) }
  def public; end

  sig do
    params(
      types: ::T::Array[::TypeAliases::RBS::Types::TypeAlias_t]
    ).returns(::TypeAliases::RBS::Types::TypeAlias_t)
  end
  def range_element_type(types); end

  sig { params(_arg0: ::T::Array[::TypeAliases::RBS::Prototype::RB::TypeAlias_decl]).void }
  def remove_unnecessary_accessibility_methods!(_arg0); end

  sig { returns(::T::Array[::TypeAliases::RBS::Prototype::RB::TypeAlias_decl]) }
  def source_decls; end

  sig do
    params(
      types: ::T::Array[::TypeAliases::RBS::Types::TypeAlias_t]
    ).returns(::TypeAliases::RBS::Types::TypeAlias_t)
  end
  def types_to_union_type(types); end
end

# source://rbs//lib/rbs/prototype/rb.rb#8
class RBS::Prototype::RB::Context < ::Struct
  sig { params(module_function: T::Boolean, singleton: T::Boolean, namespace: ::RBS::Namespace).void }
  def initialize(module_function:, singleton:, namespace:); end

  sig { returns(T.untyped) }
  def attribute_kind; end

  sig { returns(::TypeAliases::RBS::Prototype::RB::Context::TypeAlias_method_kind) }
  def method_kind; end

  sig { returns(T::Boolean) }
  def module_function; end

  sig { params(module_function: T::Boolean).returns(T::Boolean) }
  def module_function=(module_function); end

  sig { returns(::RBS::Namespace) }
  def namespace; end

  sig { params(namespace: ::RBS::Namespace).returns(::RBS::Namespace) }
  def namespace=(namespace); end

  sig { returns(T::Boolean) }
  def singleton; end

  sig { params(singleton: T::Boolean).returns(T::Boolean) }
  def singleton=(singleton); end

  class << self
    sig { params(namespace: ::RBS::Namespace).returns(::RBS::Prototype::RB::Context) }
    def initial(namespace: T.unsafe(nil)); end
  end
end

# source://rbs//lib/rbs/prototype/rbi.rb#5
class RBS::Prototype::RBI
  sig { void }
  def initialize; end

  sig do
    params(
      node: ::RubyVM::AbstractSyntaxTree::Node,
      name: ::Symbol,
      receiver: T.proc.params(_arg0: ::RubyVM::AbstractSyntaxTree::Node).returns(T::Boolean),
      args: T.proc.params(_arg0: ::RubyVM::AbstractSyntaxTree::Node).returns(T::Boolean)
    ).returns(T::Boolean)
  end
  def call_node?(node, name:, receiver: T.unsafe(nil), args: T.unsafe(nil)); end

  # Receives a constant node and returns `TypeName` instance
  sig { params(node: ::RubyVM::AbstractSyntaxTree::Node).returns(::RBS::TypeName) }
  def const_to_name(node); end

  # The inner most module/class definition, returns `nil` on toplevel
  sig { returns(T.nilable(::TypeAliases::RBS::Prototype::RBI::TypeAlias_module_decl)) }
  def current_module; end

  # The inner most module/class definition, raises on toplevel
  sig { returns(::TypeAliases::RBS::Prototype::RBI::TypeAlias_module_decl) }
  def current_module!; end

  sig { returns(::RBS::Namespace) }
  def current_namespace; end

  sig { returns(::T::Array[::TypeAliases::RBS::AST::Declarations::TypeAlias_t]) }
  def decls; end

  # Receives `:ARRAY` or `:LIST` node and yields the child nodes.
  sig do
    params(
      array: ::RubyVM::AbstractSyntaxTree::Node,
      blk: T.proc.params(_arg0: ::RubyVM::AbstractSyntaxTree::Node).void
    ).void
  end
  def each_arg(array, &blk); end

  # Receives node and yields the child nodes.
  sig do
    params(
      node: ::RubyVM::AbstractSyntaxTree::Node,
      blk: T.proc.params(_arg0: ::RubyVM::AbstractSyntaxTree::Node).void
    ).void
  end
  def each_child(node, &blk); end

  sig do
    params(
      nodes: ::T::Array[::RubyVM::AbstractSyntaxTree::Node],
      comments: ::T::Hash[::Integer, ::RBS::AST::Comment]
    ).returns(::RBS::AST::Comment)
  end
  def join_comments(nodes, comments); end

  sig { returns(T.nilable(::T::Array[::RubyVM::AbstractSyntaxTree::Node])) }
  def last_sig; end

  sig do
    params(
      args_node: T.nilable(::RubyVM::AbstractSyntaxTree::Node),
      type_node: T.nilable(::RubyVM::AbstractSyntaxTree::Node),
      variables: ::T::Array[::RBS::AST::TypeParam],
      overloads: ::Integer
    ).returns(T.nilable(::RBS::MethodType))
  end
  def method_type(args_node, type_node, variables:, overloads:); end

  sig { returns(::T::Array[::TypeAliases::RBS::Prototype::RBI::TypeAlias_module_decl]) }
  def modules; end

  sig { params(name: ::RubyVM::AbstractSyntaxTree::Node).returns(::RBS::TypeName) }
  def nested_name(name); end

  # Receives a keyword `:HASH` node and returns hash instance.
  sig do
    params(
      node: ::RubyVM::AbstractSyntaxTree::Node
    ).returns(T.nilable(::T::Hash[::Symbol, ::RubyVM::AbstractSyntaxTree::Node]))
  end
  def node_to_hash(node); end

  sig { params(_arg0: ::String).void }
  def parse(_arg0); end

  sig do
    params(
      args_node: ::RubyVM::AbstractSyntaxTree::Node,
      args: ::RubyVM::AbstractSyntaxTree::Node,
      method_type: ::RBS::MethodType,
      variables: ::T::Array[::RBS::AST::TypeParam],
      overloads: ::Integer
    ).returns(::RBS::MethodType)
  end
  def parse_params(args_node, args, method_type, variables:, overloads:); end

  # Clear the `sig` call list
  sig { returns(T.nilable(::T::Array[::RubyVM::AbstractSyntaxTree::Node])) }
  def pop_sig; end

  sig { params(type_node: ::RubyVM::AbstractSyntaxTree::Node).returns(T::Boolean) }
  def proc_type?(type_node); end

  sig do
    params(
      node: ::RubyVM::AbstractSyntaxTree::Node,
      comments: ::T::Hash[::Integer, ::RBS::AST::Comment],
      outer: ::T::Array[::RubyVM::AbstractSyntaxTree::Node]
    ).void
  end
  def process(node, comments:, outer: T.unsafe(nil)); end

  sig do
    params(
      name: ::RubyVM::AbstractSyntaxTree::Node,
      super_class: ::RubyVM::AbstractSyntaxTree::Node,
      comment: T.nilable(::RBS::AST::Comment),
      blk: T.proc.void
    ).void
  end
  def push_class(name, super_class, comment:, &blk); end

  sig do
    params(
      name: ::RubyVM::AbstractSyntaxTree::Node,
      comment: T.nilable(::RBS::AST::Comment),
      blk: T.proc.void
    ).void
  end
  def push_module(name, comment:, &blk); end

  # Put a `sig` call to current list.
  sig { params(node: ::RubyVM::AbstractSyntaxTree::Node).void }
  def push_sig(node); end

  sig do
    params(
      type_node: ::RubyVM::AbstractSyntaxTree::Node,
      variables: ::T::Array[::RBS::AST::TypeParam]
    ).returns(::TypeAliases::RBS::Types::TypeAlias_t)
  end
  def type_of(type_node, variables:); end

  sig do
    params(
      type_node: ::RubyVM::AbstractSyntaxTree::Node,
      variables: ::T::Array[::RBS::AST::TypeParam]
    ).returns(::TypeAliases::RBS::Types::TypeAlias_t)
  end
  def type_of0(type_node, variables:); end
end

# source://rbs//lib/rbs/prototype/runtime.rb#5
class RBS::Prototype::Runtime
  include ::RBS::Prototype::Helpers
end

# source://rbs//lib/rdoc_plugin/parser.rb#6
module RBS::RDocPlugin; end

# source://rbs//lib/rdoc_plugin/parser.rb#7
class RBS::RDocPlugin::Parser
  sig { params(top_level: ::RDoc::TopLevel, content: ::String).void }
  def initialize(top_level, content); end

  # Extract comment string from a declaration with comment
  #
  # * If `#comment" returns a Comment object, it returns its `#string` value
  # * If `#comment` returns `nil`, it raises an error
  #
  # Note that you have to confirm if the `#comment` of given declaration exists.
  #
  # ```ruby
  # comment = construct_comment(context: context, comment: comment_string(decl)) if decl.comment
  # ```
  #
  sig { params(_arg0: ::Interfaces::RBS::RDocPlugin::Parser::Interface_DeclWithComment).returns(::String) }
  def comment_string(_arg0); end

  sig do
    params(
      outer_name: T.nilable(::RBS::TypeName),
      decl: ::TypeAliases::RBS::RDocPlugin::Parser::TypeAlias_allowed_decls
    ).returns(::RBS::TypeName)
  end
  def fully_qualified_name(outer_name:, decl:); end

  sig do
    params(
      decl: T.any(::RBS::AST::Members::AttrAccessor, ::RBS::AST::Members::AttrReader, ::RBS::AST::Members::AttrWriter),
      context: ::RDoc::Context,
      outer_name: T.nilable(::RBS::TypeName)
    ).void
  end
  def parse_attr_decl(decl:, context:, outer_name: T.unsafe(nil)); end

  sig do
    params(
      decl: ::RBS::AST::Declarations::Class,
      context: ::RDoc::Context,
      outer_name: T.nilable(::RBS::TypeName)
    ).void
  end
  def parse_class_decl(decl:, context:, outer_name: T.unsafe(nil)); end

  sig do
    params(
      decl: ::RBS::AST::Declarations::Constant,
      context: ::RDoc::Context,
      outer_name: T.nilable(::RBS::TypeName)
    ).void
  end
  def parse_constant_decl(decl:, context:, outer_name: T.unsafe(nil)); end

  sig do
    params(
      decl: ::RBS::AST::Members::Extend,
      context: ::RDoc::Context,
      outer_name: T.nilable(::RBS::TypeName)
    ).void
  end
  def parse_extend_decl(decl:, context:, outer_name: T.unsafe(nil)); end

  sig do
    params(
      decl: ::RBS::AST::Members::Include,
      context: ::RDoc::Context,
      outer_name: T.nilable(::RBS::TypeName)
    ).void
  end
  def parse_include_decl(decl:, context:, outer_name: T.unsafe(nil)); end

  sig do
    params(
      decl: T.any(::TypeAliases::RBS::AST::Declarations::TypeAlias_t, ::TypeAliases::RBS::AST::Members::TypeAlias_t),
      context: ::RDoc::Context,
      outer_name: T.nilable(::RBS::TypeName)
    ).void
  end
  def parse_member(decl:, context:, outer_name: T.unsafe(nil)); end

  sig do
    params(
      decl: ::RBS::AST::Members::Alias,
      context: ::RDoc::Context,
      outer_name: T.nilable(::RBS::TypeName)
    ).void
  end
  def parse_method_alias_decl(decl:, context:, outer_name: T.unsafe(nil)); end

  sig do
    params(
      decl: ::RBS::AST::Members::MethodDefinition,
      context: ::RDoc::Context,
      outer_name: T.nilable(::RBS::TypeName)
    ).void
  end
  def parse_method_decl(decl:, context:, outer_name: T.unsafe(nil)); end

  sig do
    params(
      decl: T.any(::RBS::AST::Declarations::Interface, ::RBS::AST::Declarations::Module),
      context: ::RDoc::Context,
      outer_name: T.nilable(::RBS::TypeName)
    ).void
  end
  def parse_module_decl(decl:, context:, outer_name: T.unsafe(nil)); end

  sig { returns(::RDoc::TopLevel) }
  def scan; end

  private

  sig { params(context: ::RDoc::Context, comment: ::String).returns(::RDoc::Comment) }
  def construct_comment(context:, comment:); end
end

# source://rbs//lib/rbs/errors.rb#373
class RBS::RecursiveAliasDefinitionError < ::RBS::DefinitionError
  sig do
    params(
      type: ::TypeAliases::RBS::RecursiveAliasDefinitionError::TypeAlias_ty,
      defs: ::T::Array[::TypeAliases::RBS::RecursiveAliasDefinitionError::TypeAlias_defn]
    ).void
  end
  def initialize(type:, defs:); end

  sig { returns(::T::Array[::TypeAliases::RBS::RecursiveAliasDefinitionError::TypeAlias_defn]) }
  def defs; end

  sig { returns(T.nilable(::RBS::Location[T.untyped, T.untyped])) }
  def location; end

  sig { returns(::TypeAliases::RBS::RecursiveAliasDefinitionError::TypeAlias_ty) }
  def type; end
end

# source://rbs//lib/rbs/errors.rb#90
class RBS::RecursiveAncestorError < ::RBS::DefinitionError
  sig do
    params(
      ancestors: ::T::Array[::TypeAliases::RBS::Definition::Ancestor::TypeAlias_t],
      location: T.nilable(::RBS::Location[T.untyped, T.untyped])
    ).void
  end
  def initialize(ancestors:, location:); end

  sig { returns(::T::Array[::TypeAliases::RBS::Definition::Ancestor::TypeAlias_t]) }
  def ancestors; end

  sig { returns(T.nilable(::RBS::Location[T.untyped, T.untyped])) }
  def location; end

  class << self
    sig do
      params(
        _arg0: ::TypeAliases::RBS::Definition::Ancestor::TypeAlias_t,
        ancestors: ::T::Array[::TypeAliases::RBS::Definition::Ancestor::TypeAlias_t],
        location: T.nilable(::RBS::Location[T.untyped, T.untyped])
      ).void
    end
    def check!(_arg0, ancestors:, location:); end
  end
end

# source://rbs//lib/rbs/errors.rb#428
class RBS::RecursiveTypeAliasError < ::RBS::BaseError
  sig do
    params(
      alias_names: ::T::Array[::RBS::TypeName],
      location: T.nilable(::RBS::Location[T.untyped, T.untyped])
    ).void
  end
  def initialize(alias_names:, location:); end

  sig { returns(::T::Array[::RBS::TypeName]) }
  def alias_names; end

  sig { returns(T.nilable(::RBS::Location[T.untyped, T.untyped])) }
  def location; end

  sig { returns(::String) }
  def name; end
end

# source://rbs//lib/rbs/repository.rb#4
# Set of RBS repositories.
#
# A repository object can handle multiple repository roots.
#   repo = RBS::Repository.new()
#   repo.add(Pathname("vendor/rbs/gem-rbs"))
#   repo.add(Pathname("vendor/rbs/internal-rbs"))
#   repo.add(Pathname("vendor/rbs/definitely-rbs"))
#   repo.lookup("minitest", "2.1.3") => Pathname or nil
# If one gem version can resolve to several directories, the last added dir wins.
class RBS::Repository
  # An optional keyword argument `no_stdlib` is to skip adding directory for stdlib classes.
  # Passing truthy value will skip loading stdlib. (You can add the stdlib root by yourself.)
  #
  sig { params(no_stdlib: T::Boolean).void }
  def initialize(no_stdlib: T.unsafe(nil)); end

  # Add new _root dir_ to the repository set.
  # If two repository dirs have exactly same gem-version definitions, the latter overwrites the prior.
  #
  sig { params(dir: ::Pathname).void }
  def add(dir); end

  sig { returns(::T::Array[::Pathname]) }
  def dirs; end

  sig { returns(::T::Hash[::String, ::RBS::Repository::GemRBS]) }
  def gems; end

  # Returns a directory for given `gem` name and `version`.
  # `version` can be `nil` for _any version_.
  #
  # If the given gem cannot be found, it returns `nil`.
  #
  sig { params(gem: ::String, version: T.nilable(::String)).returns(T.nilable(::Pathname)) }
  def lookup(gem, version); end

  sig do
    params(
      gem: ::String,
      version: T.nilable(::String)
    ).returns(T.nilable([::RBS::Repository::GemRBS, ::RBS::Repository::VersionPath]))
  end
  def lookup_path(gem, version); end

  class << self
    sig { returns(T.attached_class) }
    def default; end

    sig { params(version: T.nilable(::Gem::Version), candidates: ::T::Array[::Gem::Version]).returns(::Gem::Version) }
    def find_best_version(version, candidates); end
  end
end

# source://rbs//lib/rbs/repository.rb#5
RBS::Repository::DEFAULT_STDLIB_ROOT = T.let(T.unsafe(nil), Pathname)

# source://rbs//lib/rbs/repository.rb#7
class RBS::Repository::GemRBS
  sig { params(name: ::String).void }
  def initialize(name:); end

  # Returns true if versions is empty.
  sig { returns(T::Boolean) }
  def empty?; end

  sig { params(_arg0: T.nilable(::Gem::Version)).returns(::RBS::Repository::VersionPath) }
  def find_best_version(_arg0); end

  sig { returns(::RBS::Repository::VersionPath) }
  def latest_version; end

  sig { void }
  def load!; end

  sig { returns(::String) }
  def name; end

  sig { returns(::RBS::Repository::VersionPath) }
  def oldest_version; end

  sig { returns(::T::Array[::Pathname]) }
  def paths; end

  sig { returns(::T::Array[::Gem::Version]) }
  def version_names; end

  sig { returns(::T::Hash[::Gem::Version, ::RBS::Repository::VersionPath]) }
  def versions; end
end

# source://rbs//lib/rbs/repository.rb#69
class RBS::Repository::VersionPath < ::Struct
  sig { params(gem: ::RBS::Repository::GemRBS, version: ::Gem::Version, path: ::Pathname).void }
  def initialize(gem:, version:, path:); end

  sig { returns(::RBS::Repository::GemRBS) }
  def gem; end

  sig { returns(::Pathname) }
  def path; end

  sig { returns(::Gem::Version) }
  def version; end
end

# source://rbs//lib/rbs/resolver/constant_resolver.rb#4
module RBS::Resolver; end

# source://rbs//lib/rbs/resolver/constant_resolver.rb#5
class RBS::Resolver::ConstantResolver
  private

  sig { params(builder: ::RBS::DefinitionBuilder).void }
  def initialize(builder:); end

  sig { returns(::RBS::DefinitionBuilder) }
  def builder; end

  sig { returns(::T::Hash[::RBS::TypeName, ::T::Hash[::Symbol, ::RBS::Constant]]) }
  def child_constants_cache; end

  # Returns the table of all constants accessible with `::` (colon2) operator.
  #
  # * The constants under the module are included.
  # * The constants under the ancestor modules are included.
  #   * The constants under the `::Object` class are not included.
  #   * The top level constants are not included.
  #
  sig { params(module_name: ::RBS::TypeName).returns(::T::Hash[::Symbol, ::RBS::Constant]) }
  def children(module_name); end

  # Returns the available all constants from `context`.
  #
  # Returns `nil` when the `context` is invalid.
  sig do
    params(
      _arg0: ::TypeAliases::RBS::Resolver::TypeAlias_context
    ).returns(T.nilable(::T::Hash[::Symbol, ::RBS::Constant]))
  end
  def constants(_arg0); end

  sig { params(_arg0: ::RBS::TypeName, constants: ::T::Hash[::Symbol, ::RBS::Constant]).void }
  def constants_from_ancestors(_arg0, constants:); end

  sig do
    params(
      _arg0: ::TypeAliases::RBS::Resolver::TypeAlias_context,
      constants: ::T::Hash[::Symbol, ::RBS::Constant]
    ).returns(T::Boolean)
  end
  def constants_from_context(_arg0, constants:); end

  sig do
    params(
      _arg0: ::TypeAliases::RBS::Resolver::TypeAlias_context,
      constants: ::T::Hash[::Symbol, ::RBS::Constant]
    ).void
  end
  def constants_itself(_arg0, constants:); end

  sig do
    returns(::T::Hash[::TypeAliases::RBS::Resolver::TypeAlias_context, T.nilable(::T::Hash[::Symbol, ::RBS::Constant])])
  end
  def context_constants_cache; end

  sig { params(_arg0: ::RBS::TypeName).void }
  def load_child_constants(_arg0); end

  sig { params(_arg0: ::TypeAliases::RBS::Resolver::TypeAlias_context).void }
  def load_context_constants(_arg0); end

  # Resolves to `Constant` with given constant name `name` and `context`.
  # Returns `nil` if the constant cannot be resolved from the context.
  #
  sig do
    params(
      name: ::Symbol,
      context: ::TypeAliases::RBS::Resolver::TypeAlias_context
    ).returns(T.nilable(::RBS::Constant))
  end
  def resolve(name, context:); end

  # Resolves the module_name and constant name to `Constant`
  #
  # ```ruby
  # A::B
  # ^     <- module_name
  #    ^  <- constant_name
  # ```
  #
  sig { params(module_name: ::RBS::TypeName, constant_name: ::Symbol).returns(T.nilable(::RBS::Constant)) }
  def resolve_child(module_name, constant_name); end

  sig { returns(::RBS::Resolver::ConstantResolver::Table) }
  def table; end
end

# source://rbs//lib/rbs/resolver/constant_resolver.rb#6
# Table stores the set of immediate child constants of a module.
#
# ```rb
# table = RBS::ConstantResolver::Table.new(env)
# table.children(TypeName("::Object"))                # -> { ... }  Returns a hash of name and constants.
# table.children(TypeName("::File::PATH_SEPARATOR"))  # -> nil      Returns nil because the constant is not a module.
# table.toplevel                                      # -> { ... }  Returns a hash of top level constants.
# ```
# The `#toplevel` is incompatible with Ruby.
# All constants in Ruby are defined under `Object`, and they are accessed with `::` (Colon3) operator.
# RBS is different.
# `::` constants are _toplevel_ constants, and they are not defined under `::Object`.
# The behavior is simulated in `ConstantResolver`.
class RBS::Resolver::ConstantResolver::Table
  sig { params(_arg0: ::RBS::Environment).void }
  def initialize(_arg0); end

  # Returns a set of constants defined under `module_name`.
  # Returns `nil` if there is no module with given `module_name`.
  #
  sig { params(module_name: ::RBS::TypeName).returns(T.nilable(::T::Hash[::Symbol, ::RBS::Constant])) }
  def children(module_name); end

  sig { returns(::T::Hash[::RBS::TypeName, T.nilable(::T::Hash[::Symbol, ::RBS::Constant])]) }
  def children_table; end

  sig { params(constant_name: ::RBS::TypeName).returns(T.nilable(::RBS::Constant)) }
  def constant(constant_name); end

  sig { returns(::T::Hash[::RBS::TypeName, ::RBS::Constant]) }
  def constants_table; end

  sig { returns(::T::Hash[::Symbol, ::RBS::Constant]) }
  def toplevel; end

  private

  sig { params(name: ::RBS::TypeName, _arg1: ::RBS::Environment::ConstantEntry).returns(::RBS::Constant) }
  def constant_of_constant(name, _arg1); end

  sig do
    params(
      name: ::RBS::TypeName,
      _arg1: T.any(::RBS::Environment::ClassEntry, ::RBS::Environment::ModuleEntry)
    ).returns(::RBS::Constant)
  end
  def constant_of_module(name, _arg1); end
end

# source://rbs//lib/rbs/resolver/type_name_resolver.rb#5
# TypeNameResolver resolves given relative type name to absolute type name under a module nesting context.
#
# The type name resolution doesn't take account of ancestors of modules.
# It just ignores included modules and super classes.
class RBS::Resolver::TypeNameResolver
  sig { params(_arg0: ::RBS::Environment).void }
  def initialize(_arg0); end

  # Translates given type name to absolute type name.
  # Returns `nil` if cannot find associated type name.
  #
  sig do
    params(
      _arg0: ::RBS::TypeName,
      context: ::TypeAliases::RBS::Resolver::TypeAlias_context
    ).returns(T.nilable(::RBS::TypeName))
  end
  def resolve(_arg0, context:); end

  private

  sig { returns(::T::Set[::RBS::TypeName]) }
  def all_names; end

  sig do
    returns(::T::Hash[::TypeAliases::RBS::Resolver::TypeNameResolver::TypeAlias_query, T.nilable(::RBS::TypeName)])
  end
  def cache; end

  sig { params(_arg0: ::RBS::TypeName).returns(T.nilable(::RBS::TypeName)) }
  def has_name?(_arg0); end

  sig do
    params(
      _arg0: ::RBS::TypeName,
      _arg1: ::TypeAliases::RBS::Resolver::TypeAlias_context
    ).returns(T.nilable(::RBS::TypeName))
  end
  def resolve_in(_arg0, _arg1); end

  sig do
    params(
      _arg0: ::TypeAliases::RBS::Resolver::TypeNameResolver::TypeAlias_query,
      blk: T.proc.returns(T.nilable(::RBS::TypeName))
    ).returns(T.nilable(::RBS::TypeName))
  end
  def try_cache(_arg0, &blk); end
end

# source://rbs//lib/rbs/substitution.rb#4
# Substitution from type variables to types.
#
# The substitution construction is in _destructive_ manner.
#    sub = Substitution.new
#    sub.add(from: :A, to: type1)
#    sub.add(from: :B, to: type2)
#    sub.instance_type = type3
class RBS::Substitution
  alias [] apply

  sig { void }
  def initialize; end

  # (s1 + s2)[t] == s2[s1[t]]
  #
  sig { params(_arg0: ::RBS::Substitution).returns(::RBS::Substitution) }
  def +(_arg0); end

  # Add mapping to this substitution.
  # Overwrites the previous mapping if same `from` is given.
  sig { params(from: ::Symbol, to: ::TypeAliases::RBS::Types::TypeAlias_t).void }
  def add(from:, to:); end

  # Applies the substitution to given type.
  sig { params(_arg0: ::TypeAliases::RBS::Types::TypeAlias_t).returns(::TypeAliases::RBS::Types::TypeAlias_t) }
  def apply(_arg0); end

  # Returns true if given substitution is identity.
  sig { returns(T::Boolean) }
  def empty?; end

  sig { returns(T.nilable(::TypeAliases::RBS::Types::TypeAlias_t)) }
  def instance_type; end

  sig do
    params(
      instance_type: T.nilable(::TypeAliases::RBS::Types::TypeAlias_t)
    ).returns(T.nilable(::TypeAliases::RBS::Types::TypeAlias_t))
  end
  def instance_type=(instance_type); end

  sig { returns(::T::Hash[::Symbol, ::TypeAliases::RBS::Types::TypeAlias_t]) }
  def mapping; end

  # Returns a substitution without variables given in `vars`.
  sig { params(vars: ::Symbol).returns(::RBS::Substitution) }
  def without(*vars); end

  class << self
    # Utility method to construct a substitution.
    # Raises an error when `variables.size != types.size`.
    # `instance_type` defaults to `nil`.
    #
    # Yields types in `types` and the block value is used if block is given.
    #
    sig do
      params(
        variables: ::T::Array[::Symbol],
        types: ::T::Array[::TypeAliases::RBS::Types::TypeAlias_t],
        instance_type: T.nilable(::TypeAliases::RBS::Types::TypeAlias_t),
        blk: T.nilable(T.proc.params(_arg0: ::TypeAliases::RBS::Types::TypeAlias_t).returns(::TypeAliases::RBS::Types::TypeAlias_t))
      ).returns(T.attached_class)
    end
    def build(variables, types, instance_type: T.unsafe(nil), &blk); end
  end
end

# source://rbs//lib/rbs/errors.rb#301
class RBS::SuperclassMismatchError < ::RBS::DefinitionError
  sig { params(name: ::RBS::TypeName, entry: ::RBS::Environment::ClassEntry).void }
  def initialize(name:, entry:); end

  sig { returns(::RBS::Environment::ClassEntry) }
  def entry; end

  sig { returns(::RBS::TypeName) }
  def name; end
end

# source://rbs//lib/rbs/type_alias_dependency.rb#4
class RBS::TypeAliasDependency
  sig { params(env: ::RBS::Environment).void }
  def initialize(env:); end

  sig { void }
  def build_dependencies; end

  sig { params(alias_name: ::RBS::TypeName).returns(T::Boolean) }
  def circular_definition?(alias_name); end

  sig { returns(::T::Hash[::RBS::TypeName, ::T::Hash[::RBS::TypeName, T::Boolean]]) }
  def dependencies; end

  sig { returns(::T::Hash[::RBS::TypeName, ::T::Set[::RBS::TypeName]]) }
  def direct_dependencies; end

  sig { returns(::RBS::Environment) }
  def env; end

  sig { void }
  def transitive_closure; end

  private

  sig { params(start: ::RBS::TypeName, vertex: ::RBS::TypeName, nested: ::TypeAliases::TypeAlias_boolish).void }
  def dependency(start, vertex, nested = T.unsafe(nil)); end

  sig do
    params(
      type: ::TypeAliases::RBS::Types::TypeAlias_t,
      result: ::T::Set[::RBS::TypeName]
    ).returns(::T::Set[::RBS::TypeName])
  end
  def direct_dependency(type, result = T.unsafe(nil)); end
end

# source://rbs//lib/rbs/type_alias_regularity.rb#4
# `TypeAliasRegularity` validates if a type alias is regular or not.
#
# Generic and recursive type alias cannot be polymorphic in their definitions.
# ```rbs
# type foo[T] = Integer
#             | foo[T]?     # Allowed. The type argument of `foo` doesn't change.
# type bar[T] = Integer
#             | foo[T]
#             | foo[Array[T]]  # Allowed. There are two type arguments `T` and `Array[T]` of `foo`, but it's not definition of `foo`.
# type baz[T] = Integer
#             | baz[Array[T]]  # Error. Recursive definition of `baz` has different type argument from the definition.
# ```
# The `#nonregular?` method can be used to test if given type name is regular or not.
# ```rb
# validator = RBS::TypeAliasRegularity.validate(env: env)
# validator.nonregular?(TypeName("::foo"))    # => nil
# validator.nonregular?(TypeName("::bar"))    # => nil
# validator.nonregular?(TypeName("::baz"))    # => TypeAliasRegularity::Diagnostic
# A special case is when the type argument is `untyped`.
# type foo[T] = Integer | foo[untyped]    # This is allowed.
class RBS::TypeAliasRegularity
  sig { params(env: ::RBS::Environment).void }
  def initialize(env:); end

  sig { returns(::RBS::DefinitionBuilder) }
  def builder; end

  sig { returns(::T::Hash[::RBS::TypeName, ::RBS::TypeAliasRegularity::Diagnostic]) }
  def diagnostics; end

  sig { returns(::RBS::Environment) }
  def env; end

  # Returns `Diagnostic` instance if the alias type is nonregular.
  # Regurns `nil` if the alias type is regular.
  #
  sig { params(_arg0: ::RBS::TypeName).returns(T.nilable(::RBS::TypeAliasRegularity::Diagnostic)) }
  def nonregular?(_arg0); end

  sig { void }
  def validate; end

  private

  # Returns alias type for given type name, if the alias is generic.
  # Returns nil if the type alias is not generic.
  #
  sig { params(_arg0: ::RBS::TypeName).returns(T.nilable(::RBS::Types::Alias)) }
  def build_alias_type(_arg0); end

  sig do
    params(
      _arg0: ::T::Array[::TypeAliases::RBS::Types::TypeAlias_t],
      _arg1: ::T::Array[::TypeAliases::RBS::Types::TypeAlias_t]
    ).returns(::TypeAliases::TypeAlias_boolish)
  end
  def compatible_args?(_arg0, _arg1); end

  sig do
    params(
      _arg0: ::TypeAliases::RBS::Types::TypeAlias_t,
      blk: T.proc.params(_arg0: ::RBS::Types::Alias).void
    ).void
  end
  def each_alias_type(_arg0, &blk); end

  sig { params(blk: T.proc.params(_arg0: ::T::Set[::RBS::TypeName]).void).void }
  def each_mutual_alias_defs(&blk); end

  sig do
    params(
      _arg0: ::RBS::Types::Alias,
      _arg1: ::T::Set[::RBS::TypeName],
      _arg2: ::T::Hash[::RBS::TypeName, ::RBS::Types::Alias]
    ).void
  end
  def validate_alias_type(_arg0, _arg1, _arg2); end

  class << self
    # Returns new instance which already run `#validate`.
    #
    sig { params(env: ::RBS::Environment).returns(::RBS::TypeAliasRegularity) }
    def validate(env:); end
  end
end

# source://rbs//lib/rbs/type_alias_regularity.rb#5
# `Diagnostic` represents an non-regular type alias declaration error.
# It consists of the name of the alias type and a type on which the nonregularity is detected.
#
# ```rbs
# type t[T] = Integer | t[T?]
# ```
# The type `t` is nonregular because it contains `t[T?]` on it's right hand side.
# diagnostic = validator.nonregular?(TypeName("::t"))
# diagnostic.type_name         # => TypeName("::t")
# diagnostic.nonregular_type   # => t[T?]
class RBS::TypeAliasRegularity::Diagnostic
  sig { params(type_name: ::RBS::TypeName, nonregular_type: ::RBS::Types::Alias).void }
  def initialize(type_name:, nonregular_type:); end

  sig { returns(::RBS::Types::Alias) }
  def nonregular_type; end

  sig { returns(::RBS::TypeName) }
  def type_name; end
end

# source://rbs//lib/rbs/type_name.rb#4
# TypeName represents name of types in RBS.
#
# TypeNames are one of the three kind, class, alias, and interface.
# *class* type names corresponds to Ruby classes and modules.
# There are no corresponding Ruby value to *alias* and *interface* type names.
class RBS::TypeName
  include ::Interfaces::Interface_ToJson

  # Initializer accepts two keyword args, `namespace` and `name`.
  # Note that `kind` is automatically determined from its `name`.
  #
  # If the name starts with capital alphabet, it is _class_.
  # If the name starts with lower case alphabet, it is _alias_.
  # If the name starts with an underscore, it is _interface_.
  #
  sig { params(namespace: ::RBS::Namespace, name: ::Symbol).void }
  def initialize(namespace:, name:); end

  sig { params(_arg0: ::RBS::TypeName).returns(::RBS::TypeName) }
  def +(_arg0); end

  sig { params(other: T.untyped).returns(T::Boolean) }
  def ==(other); end

  sig { returns(::RBS::TypeName) }
  def absolute!; end

  sig { returns(T::Boolean) }
  def absolute?; end

  # Returns true when self is an _alias_ type name.
  sig { returns(T::Boolean) }
  def alias?; end

  # Returns true when self is a _class_ type name.
  sig { returns(T::Boolean) }
  def class?; end

  sig { returns(::Integer) }
  def hash; end

  # Returns true when self is an _interface_ type name.
  sig { returns(T::Boolean) }
  def interface?; end

  sig { returns(::TypeAliases::RBS::TypeName::TypeAlias_kind) }
  def kind; end

  sig { returns(::Symbol) }
  def name; end

  sig { returns(::RBS::Namespace) }
  def namespace; end

  sig { returns(::RBS::TypeName) }
  def relative!; end

  sig { returns(::T::Array[::Symbol]) }
  def split; end

  # Returns a namespace with same components of self.
  sig { returns(::RBS::Namespace) }
  def to_namespace; end

  sig { returns(::String) }
  def to_s; end

  # Returns a new type name with a namespace appended to given namespace.
  #
  # ```rb
  # TypeName("Hello").with_prefix(Namespace("World"))           # => World::Hello
  # TypeName("Foo::Bar").with_prefix(Namespace("::Hello"))      # => ::Hello::Foo::Bar
  # TypeName("::A::B").with_prefix(Namespace("C"))              # => ::A::B
  # ```
  #
  sig { params(namespace: ::RBS::Namespace).returns(::RBS::TypeName) }
  def with_prefix(namespace); end
end

# source://rbs//lib/rbs/types.rb#4
module RBS::Types; end

# source://rbs//lib/rbs/types.rb#330
class RBS::Types::Alias
  include ::RBS::Types::Application
  include ::Interfaces::RBS::Types::Interface_TypeBase

  sig do
    params(
      name: ::RBS::TypeName,
      args: ::T::Array[::TypeAliases::RBS::Types::TypeAlias_t],
      location: T.nilable(::TypeAliases::RBS::Types::Alias::TypeAlias_loc)
    ).void
  end
  def initialize(name:, args:, location:); end

  sig { returns(T.nilable(::TypeAliases::RBS::Types::Alias::TypeAlias_loc)) }
  def location; end

  sig do
    params(
      blk: T.proc.params(_arg0: ::TypeAliases::RBS::Types::TypeAlias_t).returns(::TypeAliases::RBS::Types::TypeAlias_t)
    ).returns(::RBS::Types::Alias)
  end
  def map_type(&blk); end
end

# source://rbs//lib/rbs/types.rb#207
module RBS::Types::Application
  alias eql? ==

  sig { params(_arg0: T.untyped).returns(T::Boolean) }
  def ==(_arg0); end

  sig { returns(::T::Array[::TypeAliases::RBS::Types::TypeAlias_t]) }
  def args; end

  sig { params(blk: T.proc.params(_arg0: ::TypeAliases::RBS::Types::TypeAlias_t).void).void }
  def each_type(&blk); end

  sig { params(_arg0: ::T::Set[::Symbol]).returns(::T::Set[::Symbol]) }
  def free_variables(_arg0 = T.unsafe(nil)); end

  sig { returns(::Integer) }
  def hash; end

  sig { returns(::RBS::TypeName) }
  def name; end

  sig { params(level: ::Integer).returns(::String) }
  def to_s(level = T.unsafe(nil)); end
end

# source://rbs//lib/rbs/types.rb#41
module RBS::Types::Bases; end

# source://rbs//lib/rbs/types.rb#97
class RBS::Types::Bases::Any < ::RBS::Types::Bases::Base; end

# source://rbs//lib/rbs/types.rb#42
class RBS::Types::Bases::Base
  include ::RBS::Types::NoFreeVariables
  include ::RBS::Types::NoSubst
  include ::RBS::Types::EmptyEachType
  include ::RBS::Types::NoTypeName
  include ::Interfaces::RBS::Types::Interface_TypeBase

  alias eql? ==

  sig { params(location: T.nilable(::RBS::Location[T.untyped, T.untyped])).void }
  def initialize(location:); end

  sig { params(other: T.untyped).returns(T::Boolean) }
  def ==(other); end

  sig { returns(::Integer) }
  def hash; end

  sig { returns(T.nilable(::RBS::Location[T.untyped, T.untyped])) }
  def location; end
end

# source://rbs//lib/rbs/types.rb#95
class RBS::Types::Bases::Bool < ::RBS::Types::Bases::Base; end

# source://rbs//lib/rbs/types.rb#100
class RBS::Types::Bases::Bottom < ::RBS::Types::Bases::Base; end

# source://rbs//lib/rbs/types.rb#107
class RBS::Types::Bases::Class < ::RBS::Types::Bases::Base; end

# source://rbs//lib/rbs/types.rb#102
class RBS::Types::Bases::Instance < ::RBS::Types::Bases::Base
  sig { params(sub: ::RBS::Substitution).returns(::TypeAliases::RBS::Types::TypeAlias_t) }
  def sub(sub); end
end

# source://rbs//lib/rbs/types.rb#98
class RBS::Types::Bases::Nil < ::RBS::Types::Bases::Base; end

# source://rbs//lib/rbs/types.rb#101
class RBS::Types::Bases::Self < ::RBS::Types::Bases::Base; end

# source://rbs//lib/rbs/types.rb#99
class RBS::Types::Bases::Top < ::RBS::Types::Bases::Base; end

# source://rbs//lib/rbs/types.rb#96
class RBS::Types::Bases::Void < ::RBS::Types::Bases::Base; end

# source://rbs//lib/rbs/types.rb#1034
class RBS::Types::Block
  include ::Interfaces::Interface_ToJson

  sig do
    params(
      type: ::RBS::Types::Function,
      required: ::TypeAliases::TypeAlias_boolish,
      self_type: T.nilable(::TypeAliases::RBS::Types::TypeAlias_t)
    ).void
  end
  def initialize(type:, required:, self_type: T.unsafe(nil)); end

  sig { params(other: T.untyped).returns(T::Boolean) }
  def ==(other); end

  sig do
    params(
      blk: T.proc.params(_arg0: ::TypeAliases::RBS::Types::TypeAlias_t).returns(::TypeAliases::RBS::Types::TypeAlias_t)
    ).returns(::RBS::Types::Block)
  end
  def map_type(&blk); end

  sig { returns(T::Boolean) }
  def required; end

  sig { returns(T.nilable(::TypeAliases::RBS::Types::TypeAlias_t)) }
  def self_type; end

  sig { params(_arg0: ::RBS::Substitution).returns(::RBS::Types::Block) }
  def sub(_arg0); end

  sig { returns(::RBS::Types::Function) }
  def type; end
end

# source://rbs//lib/rbs/types.rb#288
# ClassInstance represents a type of an instance of a class.
#
#    String           # Type of an instance of String class.
#    Array[String]    # Type of an instance of Array class with instances of String.
#    Kernel           # Type of an instance of a class which includes Kernel.
class RBS::Types::ClassInstance
  include ::RBS::Types::Application
  include ::Interfaces::RBS::Types::Interface_TypeBase

  sig do
    params(
      name: ::RBS::TypeName,
      args: ::T::Array[::TypeAliases::RBS::Types::TypeAlias_t],
      location: T.nilable(::TypeAliases::RBS::Types::ClassInstance::TypeAlias_loc)
    ).void
  end
  def initialize(name:, args:, location:); end

  sig { returns(T.nilable(::TypeAliases::RBS::Types::ClassInstance::TypeAlias_loc)) }
  def location; end

  sig do
    params(
      blk: T.proc.params(_arg0: ::TypeAliases::RBS::Types::TypeAlias_t).returns(::TypeAliases::RBS::Types::TypeAlias_t)
    ).returns(::RBS::Types::ClassInstance)
  end
  def map_type(&blk); end
end

# source://rbs//lib/rbs/types.rb#167
class RBS::Types::ClassSingleton
  include ::RBS::Types::NoFreeVariables
  include ::RBS::Types::NoSubst
  include ::RBS::Types::EmptyEachType
  include ::Interfaces::RBS::Types::Interface_TypeBase

  alias eql? ==

  sig do
    params(
      name: ::RBS::TypeName,
      location: T.nilable(::TypeAliases::RBS::Types::ClassSingleton::TypeAlias_loc)
    ).void
  end
  def initialize(name:, location:); end

  sig { params(other: T.untyped).returns(T::Boolean) }
  def ==(other); end

  sig { returns(::Integer) }
  def hash; end

  sig { returns(T.nilable(::TypeAliases::RBS::Types::ClassSingleton::TypeAlias_loc)) }
  def location; end

  sig { returns(::RBS::TypeName) }
  def name; end
end

# source://rbs//lib/rbs/types.rb#23
module RBS::Types::EmptyEachType
  sig { params(blk: T.proc.params(_arg0: ::TypeAliases::RBS::Types::TypeAlias_t).void).void }
  def each_type(&blk); end

  # `map_type` returns itself, because there is no sub type.
  #
  sig do
    params(
      blk: T.proc.params(_arg0: ::TypeAliases::RBS::Types::TypeAlias_t).returns(::TypeAliases::RBS::Types::TypeAlias_t)
    ).returns(T.self_type)
  end
  def map_type(&blk); end
end

# source://rbs//lib/rbs/types.rb#724
class RBS::Types::Function
  include ::Interfaces::Interface_ToJson

  sig do
    params(
      required_positionals: ::T::Array[::RBS::Types::Function::Param],
      optional_positionals: ::T::Array[::RBS::Types::Function::Param],
      rest_positionals: T.nilable(::RBS::Types::Function::Param),
      trailing_positionals: ::T::Array[::RBS::Types::Function::Param],
      required_keywords: ::T::Hash[::Symbol, ::RBS::Types::Function::Param],
      optional_keywords: ::T::Hash[::Symbol, ::RBS::Types::Function::Param],
      rest_keywords: T.nilable(::RBS::Types::Function::Param),
      return_type: ::TypeAliases::RBS::Types::TypeAlias_t
    ).void
  end
  def initialize(required_positionals:, optional_positionals:, rest_positionals:, trailing_positionals:, required_keywords:, optional_keywords:, rest_keywords:, return_type:); end

  sig do
    type_parameters(:A, :B)
      .params(
        _arg0: ::T::Array[T.type_parameter(:A)],
        blk: T.proc.params(_arg0: T.type_parameter(:A)).returns(T.type_parameter(:B))
      ).returns(::T::Array[T.type_parameter(:B)])
  end
  def amap(_arg0, &blk); end

  sig { returns([::RBS::Types::Function::Param, ::RBS::Types::Function]) }
  def drop_head; end

  sig { returns([::RBS::Types::Function::Param, ::RBS::Types::Function]) }
  def drop_tail; end

  sig { params(blk: T.proc.params(_arg0: ::RBS::Types::Function::Param).void).void }
  def each_param(&blk); end

  sig { params(blk: T.proc.params(_arg0: ::TypeAliases::RBS::Types::TypeAlias_t).void).void }
  def each_type(&blk); end

  sig { returns(T::Boolean) }
  def empty?; end

  sig { params(_arg0: ::T::Set[::Symbol]).returns(::T::Set[::Symbol]) }
  def free_variables(_arg0 = T.unsafe(nil)); end

  sig { returns(T::Boolean) }
  def has_keyword?; end

  sig do
    type_parameters(:X, :Y, :Z)
      .params(
        _arg0: ::T::Hash[T.type_parameter(:X), T.type_parameter(:Y)],
        blk: T.proc.params(_arg0: T.type_parameter(:Y)).returns(T.type_parameter(:Z))
      ).returns(::T::Hash[T.type_parameter(:X), T.type_parameter(:Z)])
  end
  def hmapv(_arg0, &blk); end

  sig do
    params(
      blk: T.proc.params(_arg0: ::TypeAliases::RBS::Types::TypeAlias_t).returns(::TypeAliases::RBS::Types::TypeAlias_t)
    ).returns(::RBS::Types::Function)
  end
  def map_type(&blk); end

  sig do
    params(
      blk: T.proc.params(_arg0: ::RBS::TypeName, _arg1: T.nilable(::RBS::Location[T.untyped, T.untyped]), _arg2: ::TypeAliases::RBS::Types::TypeAlias_t).returns(::RBS::TypeName)
    ).returns(::RBS::Types::Function)
  end
  def map_type_name(&blk); end

  sig { returns(::T::Hash[::Symbol, ::RBS::Types::Function::Param]) }
  def optional_keywords; end

  sig { returns(::T::Array[::RBS::Types::Function::Param]) }
  def optional_positionals; end

  sig { returns(::String) }
  def param_to_s; end

  sig { returns(::T::Hash[::Symbol, ::RBS::Types::Function::Param]) }
  def required_keywords; end

  sig { returns(::T::Array[::RBS::Types::Function::Param]) }
  def required_positionals; end

  sig { returns(T.nilable(::RBS::Types::Function::Param)) }
  def rest_keywords; end

  sig { returns(T.nilable(::RBS::Types::Function::Param)) }
  def rest_positionals; end

  sig { returns(::String) }
  def return_to_s; end

  sig { returns(::TypeAliases::RBS::Types::TypeAlias_t) }
  def return_type; end

  sig { params(_arg0: ::RBS::Substitution).returns(::RBS::Types::Function) }
  def sub(_arg0); end

  sig { returns(::T::Array[::RBS::Types::Function::Param]) }
  def trailing_positionals; end

  sig do
    params(
      required_positionals: ::T::Array[::RBS::Types::Function::Param],
      optional_positionals: ::T::Array[::RBS::Types::Function::Param],
      rest_positionals: T.nilable(::RBS::Types::Function::Param),
      trailing_positionals: ::T::Array[::RBS::Types::Function::Param],
      required_keywords: ::T::Hash[::Symbol, ::RBS::Types::Function::Param],
      optional_keywords: ::T::Hash[::Symbol, ::RBS::Types::Function::Param],
      rest_keywords: T.nilable(::RBS::Types::Function::Param),
      return_type: ::TypeAliases::RBS::Types::TypeAlias_t
    ).returns(::RBS::Types::Function)
  end
  def update(required_positionals: T.unsafe(nil), optional_positionals: T.unsafe(nil), rest_positionals: T.unsafe(nil), trailing_positionals: T.unsafe(nil), required_keywords: T.unsafe(nil), optional_keywords: T.unsafe(nil), rest_keywords: T.unsafe(nil), return_type: T.unsafe(nil)); end

  sig { params(_arg0: ::TypeAliases::RBS::Types::TypeAlias_t).returns(::RBS::Types::Function) }
  def with_return_type(_arg0); end

  class << self
    sig { params(_arg0: ::TypeAliases::RBS::Types::TypeAlias_t).returns(T.attached_class) }
    def empty(_arg0); end
  end
end

# source://rbs//lib/rbs/types.rb#725
class RBS::Types::Function::Param
  sig do
    params(
      type: ::TypeAliases::RBS::Types::TypeAlias_t,
      name: T.nilable(::Symbol),
      location: T.nilable(::TypeAliases::RBS::Types::Function::Param::TypeAlias_loc)
    ).void
  end
  def initialize(type:, name:, location: T.unsafe(nil)); end

  sig { returns(T.nilable(::TypeAliases::RBS::Types::Function::Param::TypeAlias_loc)) }
  def location; end

  sig do
    params(
      blk: T.proc.params(_arg0: ::TypeAliases::RBS::Types::TypeAlias_t).returns(::TypeAliases::RBS::Types::TypeAlias_t)
    ).returns(::RBS::Types::Function::Param)
  end
  def map_type(&blk); end

  sig { returns(T.nilable(::Symbol)) }
  def name; end

  sig { returns(::TypeAliases::RBS::Types::TypeAlias_t) }
  def type; end
end

# source://rbs//lib/rbs/types.rb#246
class RBS::Types::Interface
  include ::RBS::Types::Application
  include ::Interfaces::RBS::Types::Interface_TypeBase

  sig do
    params(
      name: ::RBS::TypeName,
      args: ::T::Array[::TypeAliases::RBS::Types::TypeAlias_t],
      location: T.nilable(::TypeAliases::RBS::Types::Interface::TypeAlias_loc)
    ).void
  end
  def initialize(name:, args:, location:); end

  sig { returns(T.nilable(::TypeAliases::RBS::Types::Interface::TypeAlias_loc)) }
  def location; end

  sig do
    params(
      blk: T.proc.params(_arg0: ::TypeAliases::RBS::Types::TypeAlias_t).returns(::TypeAliases::RBS::Types::TypeAlias_t)
    ).returns(::RBS::Types::Interface)
  end
  def map_type(&blk); end
end

# source://rbs//lib/rbs/types.rb#655
class RBS::Types::Intersection
  include ::Interfaces::RBS::Types::Interface_TypeBase

  sig do
    params(
      types: ::T::Array[::TypeAliases::RBS::Types::TypeAlias_t],
      location: T.nilable(::TypeAliases::RBS::Types::Intersection::TypeAlias_loc)
    ).void
  end
  def initialize(types:, location:); end

  sig { returns(T.nilable(::TypeAliases::RBS::Types::Intersection::TypeAlias_loc)) }
  def location; end

  sig do
    params(
      blk: T.proc.params(_arg0: ::TypeAliases::RBS::Types::TypeAlias_t).returns(::TypeAliases::RBS::Types::TypeAlias_t)
    ).returns(::RBS::Types::Intersection)
  end
  def map_type(&blk); end

  sig { returns(::T::Array[::TypeAliases::RBS::Types::TypeAlias_t]) }
  def types; end
end

# source://rbs//lib/rbs/types.rb#1186
class RBS::Types::Literal
  include ::RBS::Types::NoFreeVariables
  include ::RBS::Types::NoSubst
  include ::RBS::Types::EmptyEachType
  include ::RBS::Types::NoTypeName
  include ::Interfaces::RBS::Types::Interface_TypeBase

  sig do
    params(
      literal: ::TypeAliases::RBS::Types::Literal::TypeAlias_literal,
      location: T.nilable(::TypeAliases::RBS::Types::Literal::TypeAlias_loc)
    ).void
  end
  def initialize(literal:, location:); end

  sig { returns(::TypeAliases::RBS::Types::Literal::TypeAlias_literal) }
  def literal; end

  sig { returns(T.nilable(::TypeAliases::RBS::Types::Literal::TypeAlias_loc)) }
  def location; end
end

# source://rbs//lib/rbs/types.rb#5
module RBS::Types::NoFreeVariables
  sig { params(_arg0: ::T::Set[::Symbol]).returns(::T::Set[::Symbol]) }
  def free_variables(_arg0 = T.unsafe(nil)); end
end

# source://rbs//lib/rbs/types.rb#11
module RBS::Types::NoSubst
  sig { params(_arg0: ::RBS::Substitution).returns(T.self_type) }
  def sub(_arg0); end
end

# source://rbs//lib/rbs/types.rb#17
module RBS::Types::NoTypeName
  sig do
    params(
      blk: T.proc.params(_arg0: ::RBS::TypeName, _arg1: T.nilable(::RBS::Location[T.untyped, T.untyped]), _arg2: ::TypeAliases::RBS::Types::TypeAlias_t).returns(::RBS::TypeName)
    ).returns(T.self_type)
  end
  def map_type_name(&blk); end
end

# source://rbs//lib/rbs/types.rb#517
class RBS::Types::Optional
  include ::Interfaces::RBS::Types::Interface_TypeBase

  sig do
    params(
      type: ::TypeAliases::RBS::Types::TypeAlias_t,
      location: T.nilable(::TypeAliases::RBS::Types::Optional::TypeAlias_loc)
    ).void
  end
  def initialize(type:, location:); end

  sig { returns(T.nilable(::TypeAliases::RBS::Types::Optional::TypeAlias_loc)) }
  def location; end

  sig do
    params(
      blk: T.proc.params(_arg0: ::TypeAliases::RBS::Types::TypeAlias_t).returns(::TypeAliases::RBS::Types::TypeAlias_t)
    ).returns(::RBS::Types::Optional)
  end
  def map_type(&blk); end

  sig { returns(::TypeAliases::RBS::Types::TypeAlias_t) }
  def type; end
end

# source://rbs//lib/rbs/types.rb#1089
class RBS::Types::Proc
  include ::Interfaces::RBS::Types::Interface_TypeBase

  sig do
    params(
      location: T.nilable(::TypeAliases::RBS::Types::Proc::TypeAlias_loc),
      type: ::RBS::Types::Function,
      block: T.nilable(::RBS::Types::Block),
      self_type: T.nilable(::TypeAliases::RBS::Types::TypeAlias_t)
    ).void
  end
  def initialize(location:, type:, block:, self_type: T.unsafe(nil)); end

  sig { returns(T.nilable(::RBS::Types::Block)) }
  def block; end

  sig { returns(T.nilable(::TypeAliases::RBS::Types::Proc::TypeAlias_loc)) }
  def location; end

  sig do
    params(
      blk: T.proc.params(_arg0: ::TypeAliases::RBS::Types::TypeAlias_t).returns(::TypeAliases::RBS::Types::TypeAlias_t)
    ).returns(::RBS::Types::Proc)
  end
  def map_type(&blk); end

  sig { returns(T.nilable(::TypeAliases::RBS::Types::TypeAlias_t)) }
  def self_type; end

  sig { returns(::RBS::Types::Function) }
  def type; end
end

# source://rbs//lib/rbs/types.rb#441
class RBS::Types::Record
  include ::Interfaces::RBS::Types::Interface_TypeBase

  sig do
    params(
      fields: ::T::Hash[::Symbol, ::TypeAliases::RBS::Types::TypeAlias_t],
      location: T.nilable(::TypeAliases::RBS::Types::Record::TypeAlias_loc)
    ).void
  end
  def initialize(fields:, location:); end

  sig { returns(::T::Hash[::Symbol, ::TypeAliases::RBS::Types::TypeAlias_t]) }
  def fields; end

  sig { returns(T.nilable(::TypeAliases::RBS::Types::Record::TypeAlias_loc)) }
  def location; end

  sig do
    params(
      blk: T.proc.params(_arg0: ::TypeAliases::RBS::Types::TypeAlias_t).returns(::TypeAliases::RBS::Types::TypeAlias_t)
    ).returns(::RBS::Types::Record)
  end
  def map_type(&blk); end
end

# source://rbs//lib/rbs/types.rb#1077
module RBS::Types::SelfTypeBindingHelper
  class << self
    sig { params(_arg0: T.nilable(::TypeAliases::RBS::Types::TypeAlias_t)).returns(::String) }
    def self_type_binding_to_s(_arg0); end
  end
end

# source://rbs//lib/rbs/types.rb#370
class RBS::Types::Tuple
  include ::Interfaces::RBS::Types::Interface_TypeBase

  sig do
    params(
      types: ::T::Array[::TypeAliases::RBS::Types::TypeAlias_t],
      location: T.nilable(::TypeAliases::RBS::Types::Tuple::TypeAlias_loc)
    ).void
  end
  def initialize(types:, location:); end

  sig { returns(T.nilable(::TypeAliases::RBS::Types::Tuple::TypeAlias_loc)) }
  def location; end

  sig do
    params(
      blk: T.proc.params(_arg0: ::TypeAliases::RBS::Types::TypeAlias_t).returns(::TypeAliases::RBS::Types::TypeAlias_t)
    ).returns(::RBS::Types::Tuple)
  end
  def map_type(&blk); end

  sig { returns(::T::Array[::TypeAliases::RBS::Types::TypeAlias_t]) }
  def types; end
end

# source://rbs//lib/rbs/types.rb#587
class RBS::Types::Union
  include ::Interfaces::RBS::Types::Interface_TypeBase

  sig do
    params(
      types: ::T::Array[::TypeAliases::RBS::Types::TypeAlias_t],
      location: T.nilable(::TypeAliases::RBS::Types::Union::TypeAlias_loc)
    ).void
  end
  def initialize(types:, location:); end

  sig { returns(T.nilable(::TypeAliases::RBS::Types::Union::TypeAlias_loc)) }
  def location; end

  sig do
    params(
      blk: T.proc.params(_arg0: ::TypeAliases::RBS::Types::TypeAlias_t).returns(::TypeAliases::RBS::Types::TypeAlias_t)
    ).returns(::RBS::Types::Union)
  end
  def map_type(&blk); end

  sig { returns(::T::Array[::TypeAliases::RBS::Types::TypeAlias_t]) }
  def types; end
end

# source://rbs//lib/rbs/types.rb#110
class RBS::Types::Variable
  include ::RBS::Types::NoTypeName
  include ::RBS::Types::EmptyEachType
  include ::Interfaces::RBS::Types::Interface_TypeBase

  alias eql? ==

  sig { params(name: ::Symbol, location: T.nilable(::TypeAliases::RBS::Types::Variable::TypeAlias_loc)).void }
  def initialize(name:, location:); end

  sig { params(other: T.untyped).returns(T::Boolean) }
  def ==(other); end

  sig { returns(::Integer) }
  def hash; end

  sig { returns(T.nilable(::TypeAliases::RBS::Types::Variable::TypeAlias_loc)) }
  def location; end

  sig { returns(::Symbol) }
  def name; end

  class << self
    sig { params(_arg0: ::Symbol).returns(::RBS::Types::Variable) }
    def build(_arg0); end

    # Returns fresh type variable with prefix (if given.)
    #
    #     Variable.fresh(:S)       # => S@1
    #     Variable.fresh(:S)       # => S@2
    #     Variable.fresh()         # => T@3
    #
    sig { params(prefix: ::Symbol).returns(::RBS::Types::Variable) }
    def fresh(prefix = T.unsafe(nil)); end
  end
end

# source://rbs//lib/rbs/errors.rb#285
# The `alias` member declares an alias from unknown method
#
class RBS::UnknownMethodAliasError < ::RBS::DefinitionError
  sig do
    params(
      type_name: ::RBS::TypeName,
      original_name: ::Symbol,
      aliased_name: ::Symbol,
      location: T.nilable(::RBS::Location[T.untyped, T.untyped])
    ).void
  end
  def initialize(type_name:, original_name:, aliased_name:, location:); end

  sig { returns(::Symbol) }
  def aliased_name; end

  sig { returns(T.nilable(::RBS::Location[T.untyped, T.untyped])) }
  def location; end

  sig { returns(::Symbol) }
  def original_name; end

  sig { returns(::RBS::TypeName) }
  def type_name; end
end

# source://rbs//lib/rbs/version.rb#4
RBS::VERSION = T.let(T.unsafe(nil), String)

# source://rbs//lib/rbs/validator.rb#4
class RBS::Validator
  sig { params(env: ::RBS::Environment, resolver: ::RBS::Resolver::TypeNameResolver).void }
  def initialize(env:, resolver:); end

  sig { returns(::RBS::DefinitionBuilder) }
  def definition_builder; end

  sig { returns(::RBS::Environment) }
  def env; end

  sig { returns(::RBS::Resolver::TypeNameResolver) }
  def resolver; end

  sig { returns(::RBS::TypeAliasDependency) }
  def type_alias_dependency; end

  sig { returns(::RBS::TypeAliasRegularity) }
  def type_alias_regularity; end

  # Validates class alias declaration
  #
  # - The right hand side can be normalized
  # - No mixing alias declaration between class and modules
  #
  sig { params(entry: T.any(::RBS::Environment::ClassAliasEntry, ::RBS::Environment::ModuleAliasEntry)).void }
  def validate_class_alias(entry:); end

  # Validates the type parameters in generic methods.
  #
  sig { params(_arg0: ::RBS::AST::Members::MethodDefinition, type_name: ::RBS::TypeName).void }
  def validate_method_definition(_arg0, type_name:); end

  # Validates the presence of type names and type application arity match.
  #
  sig do
    params(
      _arg0: ::TypeAliases::RBS::Types::TypeAlias_t,
      context: ::TypeAliases::RBS::Resolver::TypeAlias_context
    ).void
  end
  def validate_type(_arg0, context:); end

  # Validates type alias definition:
  #
  # - There is no circular definition between aliases
  # - The type alias is _regular_
  # - The generics type parameter variance annotation is consistent with respect to their usage
  # - There is no circular dependencies between the generics type parameter bounds
  #
  # It yields the rhs type if block is given, so that you can validate the rhs type.
  #
  sig do
    params(
      entry: ::RBS::Environment::TypeAliasEntry,
      blk: T.nilable(T.proc.params(rhs_type: ::TypeAliases::RBS::Types::TypeAlias_t).void)
    ).void
  end
  def validate_type_alias(entry:, &blk); end

  # Validates the type parameters if there is no circular dependencies between the bounds.
  #
  # ```rbs
  # [X, Y]                      # OK
  # [X, Y < _Foo[X]]            # OK
  # [X < _Foo[Y], Y]            # OK
  # [X < _Foo[Y], Y < _Foo[X]]  # Error
  # ```
  #
  sig do
    params(
      params: ::T::Array[::RBS::AST::TypeParam],
      type_name: ::RBS::TypeName,
      location: T.nilable(::RBS::Location[T.untyped, T.untyped]),
      method_name: T.nilable(::Symbol)
    ).void
  end
  def validate_type_params(params, type_name:, location:, method_name: T.unsafe(nil)); end

  private

  # Resolves relative type names to absolute type names in given context.
  # Yields the type when the type name resolution using `#resolver` fails.
  #
  sig do
    params(
      _arg0: ::TypeAliases::RBS::Types::TypeAlias_t,
      context: ::TypeAliases::RBS::Resolver::TypeAlias_context,
      blk: T.proc.params(_arg0: ::TypeAliases::RBS::Types::TypeAlias_t).returns(::RBS::TypeName)
    ).returns(::TypeAliases::RBS::Types::TypeAlias_t)
  end
  def absolute_type(_arg0, context:, &blk); end
end

# source://rbs//lib/rbs/variance_calculator.rb#4
# Calculate the use variances of type variables in declaration.
#
# ```rb
# calculator = VarianceCalculator.new(builder: builder)
# # Calculates variances in a method type
# result = calculator.in_method_type(method_type: method_type, variables: variables)
# # Calculates variances in a inheritance/mixin/...
# result = calculator.in_inherit(name: name, args: args, variables: variables)
# # Calculates variances in a type alias
# result = calculator.in_type_alias(name: name, args: args, variables: variables)
# ```
# See `RBS::VarianceCalculator::Result` for information recorded in the `Result` object.
class RBS::VarianceCalculator
  sig { params(builder: ::RBS::DefinitionBuilder).void }
  def initialize(builder:); end

  sig { returns(::RBS::DefinitionBuilder) }
  def builder; end

  sig { returns(::RBS::Environment) }
  def env; end

  sig do
    params(
      name: ::RBS::TypeName,
      args: ::T::Array[::TypeAliases::RBS::Types::TypeAlias_t],
      variables: ::T::Array[::Symbol]
    ).returns(::RBS::VarianceCalculator::Result)
  end
  def in_inherit(name:, args:, variables:); end

  sig do
    params(
      method_type: ::RBS::MethodType,
      variables: ::T::Array[::Symbol]
    ).returns(::RBS::VarianceCalculator::Result)
  end
  def in_method_type(method_type:, variables:); end

  sig { params(name: ::RBS::TypeName).returns(::RBS::VarianceCalculator::Result) }
  def in_type_alias(name:); end

  private

  sig do
    params(
      _arg0: ::RBS::Types::Function,
      result: ::RBS::VarianceCalculator::Result,
      context: ::TypeAliases::RBS::VarianceCalculator::TypeAlias_variance
    ).void
  end
  def function(_arg0, result:, context:); end

  sig do
    params(
      _arg0: ::TypeAliases::RBS::VarianceCalculator::TypeAlias_variance
    ).returns(::TypeAliases::RBS::VarianceCalculator::TypeAlias_variance)
  end
  def negate(_arg0); end

  sig do
    params(
      _arg0: ::TypeAliases::RBS::Types::TypeAlias_t,
      result: ::RBS::VarianceCalculator::Result,
      context: ::TypeAliases::RBS::VarianceCalculator::TypeAlias_variance
    ).void
  end
  def type(_arg0, result:, context:); end
end

# source://rbs//lib/rbs/variance_calculator.rb#5
# Result contains the set of type variables and it's variance in a occurrence.
#
# ```rb
# # Enumerates recorded type variables
# result.each do |name, variance|
#   # name is the name of a type variable
#   # variance is one of :unused | :covariant | :contravariant | :invariant
# end
# ```
# You can test with `compatible?` method if the type variable occurrences are compatible with specified (annotated) variance.
# # When T is declared as `out T`
# result.compatible?(:T, with_annotation: :covariant)
# # When T is declared as `in T`
# result.compatible?(:T, with_annotation: :contravariant)
# # When T is declared as `T`
# result.compatible?(:T, with_annotation: :invariant)
class RBS::VarianceCalculator::Result
  sig { params(variables: ::T::Array[::Symbol]).void }
  def initialize(variables:); end

  sig do
    params(
      _arg0: ::Symbol,
      with_annotation: ::TypeAliases::RBS::VarianceCalculator::TypeAlias_variance
    ).returns(T::Boolean)
  end
  def compatible?(_arg0, with_annotation:); end

  sig { params(_arg0: ::Symbol).void }
  def contravariant(_arg0); end

  sig { params(_arg0: ::Symbol).void }
  def covariant(_arg0); end

  sig do
    params(
      blk: T.proc.params(_arg0: [::Symbol, ::TypeAliases::RBS::VarianceCalculator::TypeAlias_variance]).void
    ).void
  end
  def each(&blk); end

  sig { params(_arg0: ::Symbol).returns(T::Boolean) }
  def include?(_arg0); end

  sig { params(_arg0: ::T::Array[::RBS::AST::TypeParam]).returns(T.nilable(::T::Set[::Symbol])) }
  def incompatible?(_arg0); end

  sig { params(_arg0: ::Symbol).void }
  def invariant(_arg0); end

  sig { returns(::T::Hash[::Symbol, ::TypeAliases::RBS::VarianceCalculator::TypeAlias_variance]) }
  def result; end
end

# source://rbs//lib/rbs/vendorer.rb#4
# Copies RBS files loaded through `loader` under `vendor_dir`.
#
# Core libraries and library RBS files will be copied.
# ```rb
# loader = RBS::EnvironmentLoader.new()
# loader.add(library: set)               # Libraries will be copied.
# loader.add(library: "minitest", version: "1.2.3")
# loader.add(path: Pathname("sig"))      # Dirs will be ignored.
# vendorer = RBS::Vendorer.new(vendor_dir: Pathname("vendor/rbs"), loader: loader)
# vendorer.clean!
# vendorer.copy!
# ```
# The result will be:
# vendor/rbs/core            => Will include core RBSs
# vendor/rbs/set-0           => Will include `set` library RBSs.
# vendor/rbs/minitest-1.2.3  => Will include `minitest` library RBSs.
# The vendorerd RBSs will be loaded through :dir source.
# loader = RBS::EnvironmentLoader.new(core_root: nil, repository: RBS::Repository.new(no_stdlib: true))
# loader.add(path: Pathname("vendor/rbs"))
# loader.add(path: Pathname("sig"))
class RBS::Vendorer
  sig { params(vendor_dir: ::Pathname, loader: ::RBS::EnvironmentLoader).void }
  def initialize(vendor_dir:, loader:); end

  # Deletes `vendor_dir` and its content if exists.
  #
  sig { void }
  def clean!; end

  # Copy RBS files into `vendor_dir`.
  # Ensures the `vendor_dir` exists.
  sig { void }
  def copy!; end

  sig { type_parameters(:A).params(blk: T.proc.returns(T.type_parameter(:A))).returns(T.type_parameter(:A)) }
  def ensure_dir(&blk); end

  sig { returns(::RBS::EnvironmentLoader) }
  def loader; end

  sig { returns(::Pathname) }
  def vendor_dir; end
end

# source://rbs//lib/rbs/writer.rb#4
# Writer prints RBS AST to String.
#
class RBS::Writer
  sig { params(out: ::Interfaces::RBS::Writer::Interface_IO).void }
  def initialize(out:); end

  sig { returns(::T::Array[::String]) }
  def indentation; end

  sig { returns(::Interfaces::RBS::Writer::Interface_IO) }
  def out; end

  sig { params(preserve: T::Boolean).returns(T.self_type) }
  def preserve!(preserve: T.unsafe(nil)); end

  sig { returns(T::Boolean) }
  def preserve?; end

  sig do
    params(
      _arg0: T.nilable(::Interfaces::RBS::Writer::Interface_Located),
      _arg1: ::Interfaces::RBS::Writer::Interface_Located
    ).void
  end
  def preserve_empty_line(_arg0, _arg1); end

  # Output the array of declarations.
  # It automatically inserts empty lines between the declarations.
  #
  sig do
    params(
      _arg0: ::T::Array[T.any(::TypeAliases::RBS::AST::Declarations::TypeAlias_t, ::TypeAliases::RBS::AST::Directives::TypeAlias_t)]
    ).void
  end
  def write(_arg0); end

  private

  sig { params(_arg0: T.untyped, _arg1: ::RBS::AST::Members::Attribute).void }
  def attribute(_arg0, _arg1); end

  sig { params(_arg0: ::RBS::AST::Annotation).returns(::String) }
  def format_annotation(_arg0); end

  # Increases the indentation and yields the block.
  #
  sig { params(size: ::Integer, blk: T.proc.void).void }
  def indent(size = T.unsafe(nil), &blk); end

  sig { params(_arg0: ::Symbol).returns(::String) }
  def method_name(_arg0); end

  sig do
    params(
      _arg0: ::RBS::TypeName,
      _arg1: ::T::Array[::TypeAliases::RBS::Types::TypeAlias_t]
    ).returns(T.nilable(::String))
  end
  def name_and_args(_arg0, _arg1); end

  sig { params(_arg0: ::RBS::TypeName, _arg1: ::T::Array[::RBS::AST::TypeParam]).returns(T.nilable(::String)) }
  def name_and_params(_arg0, _arg1); end

  # Returns the current indentation of lines.
  #
  sig { returns(::String) }
  def prefix; end

  # Prints a (possibly) multi-line string.
  #
  # Drops `leading_spaces` of spaces at the beginning of each line.
  #
  # ```ruby
  # put_lines(<<TEXT, leading_spaces: 0)
  # Hello
  #   world!
  # TEXT
  #
  # # Outputs
  # # Hello
  # #   world!
  #
  # put_lines(<<TEXT, leading_spaces: 2)
  # Hello
  #   world!
  # TEXT
  #
  # # Outputs
  # # Hello
  # # world!
  # ```
  #
  # This is for `Location#source`.
  # The `#source` returns the text spans from the beginning to end of the element.
  # It will look like the following.
  #
  # ```rbs
  # module Foo
  #   type t = Integer     # the definition of `t` starts from line=2, column=2
  #          | String
  #          | :false      # the definition of `t` ends from line=4, column=17
  # end
  # ```
  #
  # The expected output will be something like:
  #
  # ```rbs
  # type t = Integer       # Extracted from `Foo` definition and keeps the line breaks
  #        | String
  #        | :false
  # ```
  #
  # And it can be done with a `#put_lines(source, leading_spaces: 2)` call.
  #
  sig { params(_arg0: ::String, leading_spaces: ::Integer).void }
  def put_lines(_arg0, leading_spaces:); end

  # Prints a string.
  # Automatically appends the `#prefix` and newline at the end.
  #
  sig { params(_arg0: ::String).void }
  def puts(_arg0 = T.unsafe(nil)); end

  sig { params(_arg0: ::RBS::AST::Declarations::TypeAlias).void }
  def write_alias(_arg0); end

  sig { params(_arg0: ::T::Array[::RBS::AST::Annotation]).void }
  def write_annotation(_arg0); end

  sig { params(_arg0: T.nilable(::RBS::AST::Comment)).void }
  def write_comment(_arg0); end

  sig { params(_arg0: ::TypeAliases::RBS::AST::Declarations::TypeAlias_t).void }
  def write_decl(_arg0); end

  sig { params(_arg0: ::RBS::AST::Members::MethodDefinition).void }
  def write_def(_arg0); end

  sig { params(_arg0: ::TypeAliases::RBS::AST::Directives::TypeAlias_t).void }
  def write_directive(_arg0); end

  sig { params(_arg0: ::Interfaces::RBS::Writer::Interface_Located, blk: T.proc.void).void }
  def write_loc_source(_arg0, &blk); end

  sig { params(_arg0: ::TypeAliases::RBS::AST::Declarations::Module::TypeAlias_member).void }
  def write_member(_arg0); end
end

# source://rbs//lib/rdoc/discover.rb#8
class RDoc::Parser::RBS < ::RDoc::Parser; end
