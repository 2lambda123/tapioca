module Newton
  include ::LUSolve
  include ::Jacobian
  private def nlsolve(f, x); end
  private def norm(fv, zero = T.unsafe(nil)); end
  def self.nlsolve(f, x); end
  def self.norm(fv, zero = T.unsafe(nil)); end
end

module BigMath
  private def E(prec); end
  private def PI(prec); end
  private def atan(x, prec); end
  private def cos(x, prec); end
  private def sin(x, prec); end
  private def sqrt(x, prec); end
  def self.E(prec); end
  def self.PI(prec); end
  def self.atan(x, prec); end
  def self.cos(x, prec); end
  def self.exp(_arg0, _arg1); end
  def self.log(_arg0, _arg1); end
  def self.sin(x, prec); end
  def self.sqrt(x, prec); end
end

module LUSolve
  private def ludecomp(a, n, zero = T.unsafe(nil), one = T.unsafe(nil)); end
  private def lusolve(a, b, ps, zero = T.unsafe(nil)); end
  def self.ludecomp(a, n, zero = T.unsafe(nil), one = T.unsafe(nil)); end
  def self.lusolve(a, b, ps, zero = T.unsafe(nil)); end
end

module Jacobian
  private def dfdxi(f, fx, x, i); end
  private def isEqual(a, b, zero = T.unsafe(nil), e = T.unsafe(nil)); end
  private def jacobian(f, fx, x); end
  def self.dfdxi(f, fx, x, i); end
  def self.isEqual(a, b, zero = T.unsafe(nil), e = T.unsafe(nil)); end
  def self.jacobian(f, fx, x); end
end

class BigDecimal < ::Numeric
  def %(_arg0); end
  def *(_arg0); end
  def **(_arg0); end
  def +(_arg0); end
  def +@; end
  def -(_arg0); end
  def -@; end
  def /(_arg0); end
  def <(_arg0); end
  def <=(_arg0); end
  def <=>(_arg0); end
  def ==(_arg0); end
  def ===(_arg0); end
  def >(_arg0); end
  def >=(_arg0); end
  def _dump(*_arg0); end
  def abs; end
  def add(_arg0, _arg1); end
  def ceil(*_arg0); end
  def clone; end
  def coerce(_arg0); end
  def div(*_arg0); end
  def divmod(_arg0); end
  def dup; end
  def eql?(_arg0); end
  def exponent; end
  def finite?; end
  def fix; end
  def floor(*_arg0); end
  def frac; end
  def hash; end
  def infinite?; end
  def inspect; end
  def modulo(_arg0); end
  def mult(_arg0, _arg1); end
  def n_significant_digits; end
  def nan?; end
  def nonzero?; end
  def power(*_arg0); end
  def precision; end
  def precs; end
  def quo(_arg0); end
  def remainder(_arg0); end
  def round(*_arg0); end
  def sign; end
  def split; end
  def sqrt(_arg0); end
  def sub(_arg0, _arg1); end
  def to_d; end
  def to_digits; end
  def to_f; end
  def to_i; end
  def to_int; end
  def to_r; end
  def to_s(*_arg0); end
  def truncate(*_arg0); end
  def zero?; end
  def self._load(_arg0); end
  def self.double_fig; end
  def self.interpret_loosely(_arg0); end
  def self.limit(*_arg0); end
  def self.mode(*_arg0); end
  def self.save_exception_mode; end
  def self.save_limit; end
  def self.save_rounding_mode; end
end

class Numeric
  include ::Comparable
  def %(_arg0); end
  def +@; end
  def -@; end
  def <=>(_arg0); end
  def abs; end
  def abs2; end
  def angle; end
  def arg; end
  def ceil(*_arg0); end
  def clone(*_arg0); end
  def coerce(_arg0); end
  def conj; end
  def conjugate; end
  def denominator; end
  def div(_arg0); end
  def divmod(_arg0); end
  def dup; end
  def eql?(_arg0); end
  def fdiv(_arg0); end
  def finite?; end
  def floor(*_arg0); end
  def i; end
  def imag; end
  def imaginary; end
  def infinite?; end
  def integer?; end
  def magnitude; end
  def modulo(_arg0); end
  def negative?; end
  def nonzero?; end
  def numerator; end
  def phase; end
  def polar; end
  def positive?; end
  def quo(_arg0); end
  def real; end
  def real?; end
  def rect; end
  def rectangular; end
  def remainder(_arg0); end
  def round(*_arg0); end
  def singleton_method_added(_arg0); end
  def step(*_arg0); end
  def to_c; end
  def to_int; end
  def truncate(*_arg0); end
  def zero?; end
end

BigDecimal::BASE = T.let(T.unsafe(nil), Integer)
BigDecimal::EXCEPTION_ALL = T.let(T.unsafe(nil), Integer)
BigDecimal::EXCEPTION_INFINITY = T.let(T.unsafe(nil), Integer)
BigDecimal::EXCEPTION_NaN = T.let(T.unsafe(nil), Integer)
BigDecimal::EXCEPTION_OVERFLOW = T.let(T.unsafe(nil), Integer)
BigDecimal::EXCEPTION_UNDERFLOW = T.let(T.unsafe(nil), Integer)
BigDecimal::EXCEPTION_ZERODIVIDE = T.let(T.unsafe(nil), Integer)
BigDecimal::INFINITY = T.let(T.unsafe(nil), BigDecimal)
BigDecimal::NAN = T.let(T.unsafe(nil), BigDecimal)
BigDecimal::ROUND_CEILING = T.let(T.unsafe(nil), Integer)
BigDecimal::ROUND_DOWN = T.let(T.unsafe(nil), Integer)
BigDecimal::ROUND_FLOOR = T.let(T.unsafe(nil), Integer)
BigDecimal::ROUND_HALF_DOWN = T.let(T.unsafe(nil), Integer)
BigDecimal::ROUND_HALF_EVEN = T.let(T.unsafe(nil), Integer)
BigDecimal::ROUND_HALF_UP = T.let(T.unsafe(nil), Integer)
BigDecimal::ROUND_MODE = T.let(T.unsafe(nil), Integer)
BigDecimal::ROUND_UP = T.let(T.unsafe(nil), Integer)
BigDecimal::SIGN_NEGATIVE_FINITE = T.let(T.unsafe(nil), Integer)
BigDecimal::SIGN_NEGATIVE_INFINITE = T.let(T.unsafe(nil), Integer)
BigDecimal::SIGN_NEGATIVE_ZERO = T.let(T.unsafe(nil), Integer)
BigDecimal::SIGN_NaN = T.let(T.unsafe(nil), Integer)
BigDecimal::SIGN_POSITIVE_FINITE = T.let(T.unsafe(nil), Integer)
BigDecimal::SIGN_POSITIVE_INFINITE = T.let(T.unsafe(nil), Integer)
BigDecimal::SIGN_POSITIVE_ZERO = T.let(T.unsafe(nil), Integer)
BigDecimal::VERSION = T.let(T.unsafe(nil), String)

module Comparable
  def <(_arg0); end
  def <=(_arg0); end
  def ==(_arg0); end
  def >(_arg0); end
  def >=(_arg0); end
  def between?(_arg0, _arg1); end
  def clamp(*_arg0); end
end
module Etc
  private def confstr(_arg0); end
  private def endgrent; end
  private def endpwent; end
  private def getgrent; end
  private def getgrgid(*_arg0); end
  private def getgrnam(_arg0); end
  private def getlogin; end
  private def getpwent; end
  private def getpwnam(_arg0); end
  private def getpwuid(*_arg0); end
  private def group; end
  private def nprocessors; end
  private def passwd; end
  private def setgrent; end
  private def setpwent; end
  private def sysconf(_arg0); end
  private def sysconfdir; end
  private def systmpdir; end
  private def uname; end
  def self.confstr(_arg0); end
  def self.endgrent; end
  def self.endpwent; end
  def self.getgrent; end
  def self.getgrgid(*_arg0); end
  def self.getgrnam(_arg0); end
  def self.getlogin; end
  def self.getpwent; end
  def self.getpwnam(_arg0); end
  def self.getpwuid(*_arg0); end
  def self.group; end
  def self.nprocessors; end
  def self.passwd; end
  def self.setgrent; end
  def self.setpwent; end
  def self.sysconf(_arg0); end
  def self.sysconfdir; end
  def self.systmpdir; end
  def self.uname; end
end

module FileUtils
  include ::FileUtils::StreamUtils_
  extend ::FileUtils::StreamUtils_
  private def apply_mask(mode, user_mask, op, mode_mask); end
  private def cd(dir, verbose: T.unsafe(nil), &block); end
  private def chdir(dir, verbose: T.unsafe(nil), &block); end
  private def chmod(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def chmod_R(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end
  private def chown(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def chown_R(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end
  private def cmp(a, b); end
  private def compare_file(a, b); end
  private def compare_stream(a, b); end
  private def copy(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def copy_entry(src, dest, preserve = T.unsafe(nil), dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end
  private def copy_file(src, dest, preserve = T.unsafe(nil), dereference = T.unsafe(nil)); end
  private def copy_stream(src, dest); end
  private def cp(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end
  private def cp_r(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end
  private def fu_each_src_dest(src, dest); end
  private def fu_each_src_dest0(src, dest); end
  private def fu_get_gid(group); end
  private def fu_get_uid(user); end
  private def fu_have_symlink?; end
  private def fu_list(arg); end
  private def fu_mkdir(path, mode); end
  private def fu_mode(mode, path); end
  private def fu_output_message(msg); end
  private def fu_same?(a, b); end
  private def fu_stat_identical_entry?(a, b); end
  private def getwd; end
  private def identical?(a, b); end
  private def install(src, dest, mode: T.unsafe(nil), owner: T.unsafe(nil), group: T.unsafe(nil), preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def link(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def link_entry(src, dest, dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end
  private def ln(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def ln_s(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def ln_sf(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def makedirs(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def mkdir(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def mkdir_p(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def mkpath(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def mode_to_s(mode); end
  private def move(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def mv(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def pwd; end
  private def remove(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def remove_dir(path, force = T.unsafe(nil)); end
  private def remove_entry(path, force = T.unsafe(nil)); end
  private def remove_entry_secure(path, force = T.unsafe(nil)); end
  private def remove_file(path, force = T.unsafe(nil)); end
  private def remove_trailing_slash(dir); end
  private def rm(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def rm_f(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def rm_r(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def rm_rf(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def rmdir(list, parents: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def rmtree(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def safe_unlink(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def symbolic_modes_to_i(mode_sym, path); end
  private def symlink(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def touch(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), mtime: T.unsafe(nil), nocreate: T.unsafe(nil)); end
  private def uptodate?(new, old_list); end
  private def user_mask(target); end
  def self.cd(dir, verbose: T.unsafe(nil), &block); end
  def self.chdir(dir, verbose: T.unsafe(nil), &block); end
  def self.chmod(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.chmod_R(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end
  def self.chown(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.chown_R(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end
  def self.cmp(a, b); end
  def self.collect_method(opt); end
  def self.commands; end
  def self.compare_file(a, b); end
  def self.compare_stream(a, b); end
  def self.copy(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.copy_entry(src, dest, preserve = T.unsafe(nil), dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end
  def self.copy_file(src, dest, preserve = T.unsafe(nil), dereference = T.unsafe(nil)); end
  def self.copy_stream(src, dest); end
  def self.cp(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end
  def self.cp_r(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end
  def self.getwd; end
  def self.have_option?(mid, opt); end
  def self.identical?(a, b); end
  def self.install(src, dest, mode: T.unsafe(nil), owner: T.unsafe(nil), group: T.unsafe(nil), preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.link(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.link_entry(src, dest, dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end
  def self.ln(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.ln_s(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.ln_sf(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.makedirs(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.mkdir(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.mkdir_p(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.mkpath(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.move(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.mv(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.options; end
  def self.options_of(mid); end
  def self.private_module_function(name); end
  def self.pwd; end
  def self.remove(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.remove_dir(path, force = T.unsafe(nil)); end
  def self.remove_entry(path, force = T.unsafe(nil)); end
  def self.remove_entry_secure(path, force = T.unsafe(nil)); end
  def self.remove_file(path, force = T.unsafe(nil)); end
  def self.rm(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.rm_f(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.rm_r(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.rm_rf(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.rmdir(list, parents: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.rmtree(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.safe_unlink(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.symlink(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.touch(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), mtime: T.unsafe(nil), nocreate: T.unsafe(nil)); end
  def self.uptodate?(new, old_list); end
  private def self.apply_mask(mode, user_mask, op, mode_mask); end
  private def self.fu_each_src_dest(src, dest); end
  private def self.fu_each_src_dest0(src, dest); end
  private def self.fu_get_gid(group); end
  private def self.fu_get_uid(user); end
  private def self.fu_have_symlink?; end
  private def self.fu_list(arg); end
  private def self.fu_mkdir(path, mode); end
  private def self.fu_mode(mode, path); end
  private def self.fu_output_message(msg); end
  private def self.fu_same?(a, b); end
  private def self.fu_stat_identical_entry?(a, b); end
  private def self.mode_to_s(mode); end
  private def self.remove_trailing_slash(dir); end
  private def self.symbolic_modes_to_i(mode_sym, path); end
  private def self.user_mask(target); end
end

class CGI
  include ::CGI::Util
  include ::CGI::Escape
  extend ::CGI::Util
  extend ::CGI::Escape
  def initialize(options = T.unsafe(nil), &block); end
  def accept_charset; end
  def header(options = T.unsafe(nil)); end
  def http_header(options = T.unsafe(nil)); end
  def nph?; end
  def out(options = T.unsafe(nil)); end
  def print(*options); end
  private def _header_for_hash(options); end
  private def _header_for_modruby(buf); end
  private def _header_for_string(content_type); end
  private def env_table; end
  private def stdinput; end
  private def stdoutput; end
  def self.accept_charset; end
  def self.accept_charset=(accept_charset); end
  def self.parse(query); end
end

Etc::CS_PATH = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_ILP32_OFF32_CFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_ILP32_OFF32_LDFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_ILP32_OFF32_LIBS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_ILP32_OFFBIG_LIBS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_LP64_OFF64_CFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_LP64_OFF64_LDFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_LP64_OFF64_LIBS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_LPBIG_OFFBIG_LIBS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_WIDTH_RESTRICTED_ENVS = T.let(T.unsafe(nil), Integer)

class Etc::Group < ::Struct
  extend ::Enumerable
  def gid; end
  def gid=(_); end
  def mem; end
  def mem=(_); end
  def name; end
  def name=(_); end
  def passwd; end
  def passwd=(_); end
  def self.[](*_arg0); end
  def self.each; end
  def self.inspect; end
  def self.members; end
  def self.new(*_arg0); end
end

Etc::PC_2_SYMLINKS = T.let(T.unsafe(nil), Integer)
Etc::PC_ALLOC_SIZE_MIN = T.let(T.unsafe(nil), Integer)
Etc::PC_ASYNC_IO = T.let(T.unsafe(nil), Integer)
Etc::PC_CHOWN_RESTRICTED = T.let(T.unsafe(nil), Integer)
Etc::PC_FILESIZEBITS = T.let(T.unsafe(nil), Integer)
Etc::PC_LINK_MAX = T.let(T.unsafe(nil), Integer)
Etc::PC_MAX_CANON = T.let(T.unsafe(nil), Integer)
Etc::PC_MAX_INPUT = T.let(T.unsafe(nil), Integer)
Etc::PC_NAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::PC_NO_TRUNC = T.let(T.unsafe(nil), Integer)
Etc::PC_PATH_MAX = T.let(T.unsafe(nil), Integer)
Etc::PC_PIPE_BUF = T.let(T.unsafe(nil), Integer)
Etc::PC_PRIO_IO = T.let(T.unsafe(nil), Integer)
Etc::PC_REC_INCR_XFER_SIZE = T.let(T.unsafe(nil), Integer)
Etc::PC_REC_MAX_XFER_SIZE = T.let(T.unsafe(nil), Integer)
Etc::PC_REC_MIN_XFER_SIZE = T.let(T.unsafe(nil), Integer)
Etc::PC_REC_XFER_ALIGN = T.let(T.unsafe(nil), Integer)
Etc::PC_SYMLINK_MAX = T.let(T.unsafe(nil), Integer)
Etc::PC_SYNC_IO = T.let(T.unsafe(nil), Integer)
Etc::PC_VDISABLE = T.let(T.unsafe(nil), Integer)

class Etc::Passwd < ::Struct
  extend ::Enumerable
  def change; end
  def change=(_); end
  def dir; end
  def dir=(_); end
  def expire; end
  def expire=(_); end
  def gecos; end
  def gecos=(_); end
  def gid; end
  def gid=(_); end
  def name; end
  def name=(_); end
  def passwd; end
  def passwd=(_); end
  def shell; end
  def shell=(_); end
  def uclass; end
  def uclass=(_); end
  def uid; end
  def uid=(_); end
  def self.[](*_arg0); end
  def self.each; end
  def self.inspect; end
  def self.members; end
  def self.new(*_arg0); end
end

Etc::SC_2_CHAR_TERM = T.let(T.unsafe(nil), Integer)
Etc::SC_2_C_BIND = T.let(T.unsafe(nil), Integer)
Etc::SC_2_C_DEV = T.let(T.unsafe(nil), Integer)
Etc::SC_2_FORT_DEV = T.let(T.unsafe(nil), Integer)
Etc::SC_2_FORT_RUN = T.let(T.unsafe(nil), Integer)
Etc::SC_2_LOCALEDEF = T.let(T.unsafe(nil), Integer)
Etc::SC_2_PBS = T.let(T.unsafe(nil), Integer)
Etc::SC_2_PBS_ACCOUNTING = T.let(T.unsafe(nil), Integer)
Etc::SC_2_PBS_CHECKPOINT = T.let(T.unsafe(nil), Integer)
Etc::SC_2_PBS_LOCATE = T.let(T.unsafe(nil), Integer)
Etc::SC_2_PBS_MESSAGE = T.let(T.unsafe(nil), Integer)
Etc::SC_2_PBS_TRACK = T.let(T.unsafe(nil), Integer)
Etc::SC_2_SW_DEV = T.let(T.unsafe(nil), Integer)
Etc::SC_2_UPE = T.let(T.unsafe(nil), Integer)
Etc::SC_2_VERSION = T.let(T.unsafe(nil), Integer)
Etc::SC_ADVISORY_INFO = T.let(T.unsafe(nil), Integer)
Etc::SC_AIO_LISTIO_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_AIO_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_AIO_PRIO_DELTA_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_ARG_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_ASYNCHRONOUS_IO = T.let(T.unsafe(nil), Integer)
Etc::SC_ATEXIT_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_BARRIERS = T.let(T.unsafe(nil), Integer)
Etc::SC_BC_BASE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_BC_DIM_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_BC_SCALE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_BC_STRING_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_CHILD_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_CLK_TCK = T.let(T.unsafe(nil), Integer)
Etc::SC_CLOCK_SELECTION = T.let(T.unsafe(nil), Integer)
Etc::SC_COLL_WEIGHTS_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_CPUTIME = T.let(T.unsafe(nil), Integer)
Etc::SC_DELAYTIMER_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_EXPR_NEST_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_FSYNC = T.let(T.unsafe(nil), Integer)
Etc::SC_GETGR_R_SIZE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_GETPW_R_SIZE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_HOST_NAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_IOV_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_IPV6 = T.let(T.unsafe(nil), Integer)
Etc::SC_JOB_CONTROL = T.let(T.unsafe(nil), Integer)
Etc::SC_LINE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_LOGIN_NAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_MAPPED_FILES = T.let(T.unsafe(nil), Integer)
Etc::SC_MEMLOCK = T.let(T.unsafe(nil), Integer)
Etc::SC_MEMLOCK_RANGE = T.let(T.unsafe(nil), Integer)
Etc::SC_MEMORY_PROTECTION = T.let(T.unsafe(nil), Integer)
Etc::SC_MESSAGE_PASSING = T.let(T.unsafe(nil), Integer)
Etc::SC_MONOTONIC_CLOCK = T.let(T.unsafe(nil), Integer)
Etc::SC_MQ_OPEN_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_MQ_PRIO_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_NGROUPS_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_NPROCESSORS_CONF = T.let(T.unsafe(nil), Integer)
Etc::SC_NPROCESSORS_ONLN = T.let(T.unsafe(nil), Integer)
Etc::SC_OPEN_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_PAGESIZE = T.let(T.unsafe(nil), Integer)
Etc::SC_PAGE_SIZE = T.let(T.unsafe(nil), Integer)
Etc::SC_PHYS_PAGES = T.let(T.unsafe(nil), Integer)
Etc::SC_PRIORITIZED_IO = T.let(T.unsafe(nil), Integer)
Etc::SC_PRIORITY_SCHEDULING = T.let(T.unsafe(nil), Integer)
Etc::SC_RAW_SOCKETS = T.let(T.unsafe(nil), Integer)
Etc::SC_READER_WRITER_LOCKS = T.let(T.unsafe(nil), Integer)
Etc::SC_REALTIME_SIGNALS = T.let(T.unsafe(nil), Integer)
Etc::SC_REGEXP = T.let(T.unsafe(nil), Integer)
Etc::SC_RE_DUP_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_RTSIG_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_SAVED_IDS = T.let(T.unsafe(nil), Integer)
Etc::SC_SEMAPHORES = T.let(T.unsafe(nil), Integer)
Etc::SC_SEM_NSEMS_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_SEM_VALUE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_SHARED_MEMORY_OBJECTS = T.let(T.unsafe(nil), Integer)
Etc::SC_SHELL = T.let(T.unsafe(nil), Integer)
Etc::SC_SIGQUEUE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_SPAWN = T.let(T.unsafe(nil), Integer)
Etc::SC_SPIN_LOCKS = T.let(T.unsafe(nil), Integer)
Etc::SC_SPORADIC_SERVER = T.let(T.unsafe(nil), Integer)
Etc::SC_SS_REPL_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_STREAM_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_SYMLOOP_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_SYNCHRONIZED_IO = T.let(T.unsafe(nil), Integer)
Etc::SC_THREADS = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_ATTR_STACKADDR = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_ATTR_STACKSIZE = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_CPUTIME = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_DESTRUCTOR_ITERATIONS = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_KEYS_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_PRIORITY_SCHEDULING = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_PRIO_INHERIT = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_PRIO_PROTECT = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_PROCESS_SHARED = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_SAFE_FUNCTIONS = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_SPORADIC_SERVER = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_STACK_MIN = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_THREADS_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TIMEOUTS = T.let(T.unsafe(nil), Integer)
Etc::SC_TIMERS = T.let(T.unsafe(nil), Integer)
Etc::SC_TIMER_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_EVENT_FILTER = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_EVENT_NAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_INHERIT = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_LOG = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_NAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_SYS_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_USER_EVENT_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TTY_NAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TYPED_MEMORY_OBJECTS = T.let(T.unsafe(nil), Integer)
Etc::SC_TZNAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_V6_ILP32_OFF32 = T.let(T.unsafe(nil), Integer)
Etc::SC_V6_ILP32_OFFBIG = T.let(T.unsafe(nil), Integer)
Etc::SC_V6_LP64_OFF64 = T.let(T.unsafe(nil), Integer)
Etc::SC_V6_LPBIG_OFFBIG = T.let(T.unsafe(nil), Integer)
Etc::SC_VERSION = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_CRYPT = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_ENH_I18N = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_REALTIME = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_REALTIME_THREADS = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_SHM = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_STREAMS = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_UNIX = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_VERSION = T.let(T.unsafe(nil), Integer)
Etc::VERSION = T.let(T.unsafe(nil), String)

module FileUtils::DryRun
  include ::FileUtils::StreamUtils_
  include ::FileUtils
  include ::FileUtils::LowMethods
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils
  extend ::FileUtils::LowMethods
  extend ::FileUtils::DryRun
  private def chmod(*args, **options); end
  private def chmod_R(*args, **options); end
  private def chown(*args, **options); end
  private def chown_R(*args, **options); end
  private def copy(*args, **options); end
  private def cp(*args, **options); end
  private def cp_lr(*args, **options); end
  private def cp_r(*args, **options); end
  private def install(*args, **options); end
  private def link(*args, **options); end
  private def ln(*args, **options); end
  private def ln_s(*args, **options); end
  private def ln_sf(*args, **options); end
  private def makedirs(*args, **options); end
  private def mkdir(*args, **options); end
  private def mkdir_p(*args, **options); end
  private def mkpath(*args, **options); end
  private def move(*args, **options); end
  private def mv(*args, **options); end
  private def remove(*args, **options); end
  private def rm(*args, **options); end
  private def rm_f(*args, **options); end
  private def rm_r(*args, **options); end
  private def rm_rf(*args, **options); end
  private def rmdir(*args, **options); end
  private def rmtree(*args, **options); end
  private def safe_unlink(*args, **options); end
  private def symlink(*args, **options); end
  private def touch(*args, **options); end
end

class FileUtils::Entry_
  include ::FileUtils::StreamUtils_
  def initialize(a, b = T.unsafe(nil), deref = T.unsafe(nil)); end
  def blockdev?; end
  def chardev?; end
  def chmod(mode); end
  def chown(uid, gid); end
  def copy(dest); end
  def copy_file(dest); end
  def copy_metadata(path); end
  def dereference?; end
  def directory?; end
  def door?; end
  def entries; end
  def exist?; end
  def file?; end
  def inspect; end
  def link(dest); end
  def lstat; end
  def lstat!; end
  def path; end
  def pipe?; end
  def platform_support; end
  def postorder_traverse; end
  def prefix; end
  def preorder_traverse; end
  def rel; end
  def remove; end
  def remove_dir1; end
  def remove_file; end
  def socket?; end
  def stat; end
  def stat!; end
  def symlink?; end
  def traverse; end
  def wrap_traverse(pre, post); end
  private def check_have_lchmod?; end
  private def check_have_lchown?; end
  private def descendant_directory?(descendant, ascendant); end
  private def have_lchmod?; end
  private def have_lchown?; end
  private def join(dir, base); end
end

FileUtils::LOW_METHODS = T.let(T.unsafe(nil), Array)

module FileUtils::LowMethods
  private def _do_nothing(*_arg0); end
  private def cd(*_arg0); end
  private def chdir(*_arg0); end
  private def cmp(*_arg0); end
  private def collect_method(*_arg0); end
  private def commands(*_arg0); end
  private def compare_file(*_arg0); end
  private def compare_stream(*_arg0); end
  private def copy_entry(*_arg0); end
  private def copy_file(*_arg0); end
  private def copy_stream(*_arg0); end
  private def getwd(*_arg0); end
  private def have_option?(*_arg0); end
  private def identical?(*_arg0); end
  private def link_entry(*_arg0); end
  private def options(*_arg0); end
  private def options_of(*_arg0); end
  private def private_module_function(*_arg0); end
  private def pwd(*_arg0); end
  private def remove_dir(*_arg0); end
  private def remove_entry(*_arg0); end
  private def remove_entry_secure(*_arg0); end
  private def remove_file(*_arg0); end
  private def uptodate?(*_arg0); end
end

FileUtils::METHODS = T.let(T.unsafe(nil), Array)

module FileUtils::NoWrite
  include ::FileUtils::StreamUtils_
  include ::FileUtils
  include ::FileUtils::LowMethods
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils
  extend ::FileUtils::LowMethods
  extend ::FileUtils::NoWrite
  private def chmod(*args, **options); end
  private def chmod_R(*args, **options); end
  private def chown(*args, **options); end
  private def chown_R(*args, **options); end
  private def copy(*args, **options); end
  private def cp(*args, **options); end
  private def cp_lr(*args, **options); end
  private def cp_r(*args, **options); end
  private def install(*args, **options); end
  private def link(*args, **options); end
  private def ln(*args, **options); end
  private def ln_s(*args, **options); end
  private def ln_sf(*args, **options); end
  private def makedirs(*args, **options); end
  private def mkdir(*args, **options); end
  private def mkdir_p(*args, **options); end
  private def mkpath(*args, **options); end
  private def move(*args, **options); end
  private def mv(*args, **options); end
  private def remove(*args, **options); end
  private def rm(*args, **options); end
  private def rm_f(*args, **options); end
  private def rm_r(*args, **options); end
  private def rm_rf(*args, **options); end
  private def rmdir(*args, **options); end
  private def rmtree(*args, **options); end
  private def safe_unlink(*args, **options); end
  private def symlink(*args, **options); end
  private def touch(*args, **options); end
end

FileUtils::OPT_TABLE = T.let(T.unsafe(nil), Hash)

module FileUtils::StreamUtils_
  private def fu_blksize(st); end
  private def fu_copy_stream0(src, dest, blksize = T.unsafe(nil)); end
  private def fu_default_blksize; end
  private def fu_stream_blksize(*streams); end
  private def fu_windows?; end
end

FileUtils::VERSION = T.let(T.unsafe(nil), String)

module FileUtils::Verbose
  include ::FileUtils::StreamUtils_
  include ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils
  extend ::FileUtils::Verbose
  private def cd(*args, **options); end
  private def chdir(*args, **options); end
  private def chmod(*args, **options); end
  private def chmod_R(*args, **options); end
  private def chown(*args, **options); end
  private def chown_R(*args, **options); end
  private def copy(*args, **options); end
  private def cp(*args, **options); end
  private def cp_lr(*args, **options); end
  private def cp_r(*args, **options); end
  private def install(*args, **options); end
  private def link(*args, **options); end
  private def ln(*args, **options); end
  private def ln_s(*args, **options); end
  private def ln_sf(*args, **options); end
  private def makedirs(*args, **options); end
  private def mkdir(*args, **options); end
  private def mkdir_p(*args, **options); end
  private def mkpath(*args, **options); end
  private def move(*args, **options); end
  private def mv(*args, **options); end
  private def remove(*args, **options); end
  private def rm(*args, **options); end
  private def rm_f(*args, **options); end
  private def rm_r(*args, **options); end
  private def rm_rf(*args, **options); end
  private def rmdir(*args, **options); end
  private def rmtree(*args, **options); end
  private def safe_unlink(*args, **options); end
  private def symlink(*args, **options); end
  private def touch(*args, **options); end
end

CGI::CR = T.let(T.unsafe(nil), String)

class CGI::Cookie < ::Array
  def initialize(name = T.unsafe(nil), *value); end
  def domain; end
  def domain=(_arg0); end
  def expires; end
  def expires=(_arg0); end
  def httponly; end
  def httponly=(val); end
  def inspect; end
  def name; end
  def name=(_arg0); end
  def path; end
  def path=(_arg0); end
  def secure; end
  def secure=(val); end
  def to_s; end
  def value; end
  def value=(val); end
  def self.parse(raw_cookie); end
end

CGI::EOL = T.let(T.unsafe(nil), String)

module CGI::Escape
  def escape(_arg0); end
  def escapeHTML(_arg0); end
  def unescape(*_arg0); end
  def unescapeHTML(_arg0); end
end

class CGI::HTML3
  include ::CGI::TagMaker
  include ::CGI::Html3
  include ::CGI::HtmlExtension
end

class CGI::HTML4
  include ::CGI::TagMaker
  include ::CGI::Html4
  include ::CGI::HtmlExtension
end

class CGI::HTML4Fr
  include ::CGI::TagMaker
  include ::CGI::Html4Tr
  include ::CGI::Html4Fr
  include ::CGI::HtmlExtension
end

class CGI::HTML4Tr
  include ::CGI::TagMaker
  include ::CGI::Html4Tr
  include ::CGI::HtmlExtension
end

class CGI::HTML5
  include ::CGI::TagMaker
  include ::CGI::Html5
  include ::CGI::HtmlExtension
end

CGI::HTTP_STATUS = T.let(T.unsafe(nil), Hash)

module CGI::Html3
  include ::CGI::TagMaker
  def a(attributes = T.unsafe(nil), &block); end
  def address(attributes = T.unsafe(nil), &block); end
  def applet(attributes = T.unsafe(nil), &block); end
  def area(attributes = T.unsafe(nil), &block); end
  def b(attributes = T.unsafe(nil), &block); end
  def base(attributes = T.unsafe(nil), &block); end
  def basefont(attributes = T.unsafe(nil), &block); end
  def big(attributes = T.unsafe(nil), &block); end
  def blockquote(attributes = T.unsafe(nil), &block); end
  def body(attributes = T.unsafe(nil), &block); end
  def br(attributes = T.unsafe(nil), &block); end
  def caption(attributes = T.unsafe(nil), &block); end
  def center(attributes = T.unsafe(nil), &block); end
  def cite(attributes = T.unsafe(nil), &block); end
  def code(attributes = T.unsafe(nil), &block); end
  def dd(attributes = T.unsafe(nil), &block); end
  def dfn(attributes = T.unsafe(nil), &block); end
  def dir(attributes = T.unsafe(nil), &block); end
  def div(attributes = T.unsafe(nil), &block); end
  def dl(attributes = T.unsafe(nil), &block); end
  def doctype; end
  def dt(attributes = T.unsafe(nil), &block); end
  def em(attributes = T.unsafe(nil), &block); end
  def font(attributes = T.unsafe(nil), &block); end
  def form(attributes = T.unsafe(nil), &block); end
  def h1(attributes = T.unsafe(nil), &block); end
  def h2(attributes = T.unsafe(nil), &block); end
  def h3(attributes = T.unsafe(nil), &block); end
  def h4(attributes = T.unsafe(nil), &block); end
  def h5(attributes = T.unsafe(nil), &block); end
  def h6(attributes = T.unsafe(nil), &block); end
  def head(attributes = T.unsafe(nil), &block); end
  def hr(attributes = T.unsafe(nil), &block); end
  def html(attributes = T.unsafe(nil), &block); end
  def i(attributes = T.unsafe(nil), &block); end
  def img(attributes = T.unsafe(nil), &block); end
  def input(attributes = T.unsafe(nil), &block); end
  def isindex(attributes = T.unsafe(nil), &block); end
  def kbd(attributes = T.unsafe(nil), &block); end
  def li(attributes = T.unsafe(nil), &block); end
  def link(attributes = T.unsafe(nil), &block); end
  def listing(attributes = T.unsafe(nil), &block); end
  def map(attributes = T.unsafe(nil), &block); end
  def menu(attributes = T.unsafe(nil), &block); end
  def meta(attributes = T.unsafe(nil), &block); end
  def ol(attributes = T.unsafe(nil), &block); end
  def option(attributes = T.unsafe(nil), &block); end
  def p(attributes = T.unsafe(nil), &block); end
  def param(attributes = T.unsafe(nil), &block); end
  def plaintext(attributes = T.unsafe(nil), &block); end
  def pre(attributes = T.unsafe(nil), &block); end
  def samp(attributes = T.unsafe(nil), &block); end
  def script(attributes = T.unsafe(nil), &block); end
  def select(attributes = T.unsafe(nil), &block); end
  def small(attributes = T.unsafe(nil), &block); end
  def strike(attributes = T.unsafe(nil), &block); end
  def strong(attributes = T.unsafe(nil), &block); end
  def style(attributes = T.unsafe(nil), &block); end
  def sub(attributes = T.unsafe(nil), &block); end
  def sup(attributes = T.unsafe(nil), &block); end
  def table(attributes = T.unsafe(nil), &block); end
  def td(attributes = T.unsafe(nil), &block); end
  def textarea(attributes = T.unsafe(nil), &block); end
  def th(attributes = T.unsafe(nil), &block); end
  def title(attributes = T.unsafe(nil), &block); end
  def tr(attributes = T.unsafe(nil), &block); end
  def tt(attributes = T.unsafe(nil), &block); end
  def u(attributes = T.unsafe(nil), &block); end
  def ul(attributes = T.unsafe(nil), &block); end
  def var(attributes = T.unsafe(nil), &block); end
  def xmp(attributes = T.unsafe(nil), &block); end
end

module CGI::Html4
  include ::CGI::TagMaker
  def a(attributes = T.unsafe(nil), &block); end
  def abbr(attributes = T.unsafe(nil), &block); end
  def acronym(attributes = T.unsafe(nil), &block); end
  def address(attributes = T.unsafe(nil), &block); end
  def area(attributes = T.unsafe(nil), &block); end
  def b(attributes = T.unsafe(nil), &block); end
  def base(attributes = T.unsafe(nil), &block); end
  def bdo(attributes = T.unsafe(nil), &block); end
  def big(attributes = T.unsafe(nil), &block); end
  def blockquote(attributes = T.unsafe(nil), &block); end
  def body(attributes = T.unsafe(nil), &block); end
  def br(attributes = T.unsafe(nil), &block); end
  def button(attributes = T.unsafe(nil), &block); end
  def caption(attributes = T.unsafe(nil), &block); end
  def cite(attributes = T.unsafe(nil), &block); end
  def code(attributes = T.unsafe(nil), &block); end
  def col(attributes = T.unsafe(nil), &block); end
  def colgroup(attributes = T.unsafe(nil), &block); end
  def dd(attributes = T.unsafe(nil), &block); end
  def del(attributes = T.unsafe(nil), &block); end
  def dfn(attributes = T.unsafe(nil), &block); end
  def div(attributes = T.unsafe(nil), &block); end
  def dl(attributes = T.unsafe(nil), &block); end
  def doctype; end
  def dt(attributes = T.unsafe(nil), &block); end
  def em(attributes = T.unsafe(nil), &block); end
  def fieldset(attributes = T.unsafe(nil), &block); end
  def form(attributes = T.unsafe(nil), &block); end
  def h1(attributes = T.unsafe(nil), &block); end
  def h2(attributes = T.unsafe(nil), &block); end
  def h3(attributes = T.unsafe(nil), &block); end
  def h4(attributes = T.unsafe(nil), &block); end
  def h5(attributes = T.unsafe(nil), &block); end
  def h6(attributes = T.unsafe(nil), &block); end
  def head(attributes = T.unsafe(nil), &block); end
  def hr(attributes = T.unsafe(nil), &block); end
  def html(attributes = T.unsafe(nil), &block); end
  def i(attributes = T.unsafe(nil), &block); end
  def img(attributes = T.unsafe(nil), &block); end
  def input(attributes = T.unsafe(nil), &block); end
  def ins(attributes = T.unsafe(nil), &block); end
  def kbd(attributes = T.unsafe(nil), &block); end
  def label(attributes = T.unsafe(nil), &block); end
  def legend(attributes = T.unsafe(nil), &block); end
  def li(attributes = T.unsafe(nil), &block); end
  def link(attributes = T.unsafe(nil), &block); end
  def map(attributes = T.unsafe(nil), &block); end
  def meta(attributes = T.unsafe(nil), &block); end
  def noscript(attributes = T.unsafe(nil), &block); end
  def object(attributes = T.unsafe(nil), &block); end
  def ol(attributes = T.unsafe(nil), &block); end
  def optgroup(attributes = T.unsafe(nil), &block); end
  def option(attributes = T.unsafe(nil), &block); end
  def p(attributes = T.unsafe(nil), &block); end
  def param(attributes = T.unsafe(nil), &block); end
  def pre(attributes = T.unsafe(nil), &block); end
  def q(attributes = T.unsafe(nil), &block); end
  def samp(attributes = T.unsafe(nil), &block); end
  def script(attributes = T.unsafe(nil), &block); end
  def select(attributes = T.unsafe(nil), &block); end
  def small(attributes = T.unsafe(nil), &block); end
  def span(attributes = T.unsafe(nil), &block); end
  def strong(attributes = T.unsafe(nil), &block); end
  def style(attributes = T.unsafe(nil), &block); end
  def sub(attributes = T.unsafe(nil), &block); end
  def sup(attributes = T.unsafe(nil), &block); end
  def table(attributes = T.unsafe(nil), &block); end
  def tbody(attributes = T.unsafe(nil), &block); end
  def td(attributes = T.unsafe(nil), &block); end
  def textarea(attributes = T.unsafe(nil), &block); end
  def tfoot(attributes = T.unsafe(nil), &block); end
  def th(attributes = T.unsafe(nil), &block); end
  def thead(attributes = T.unsafe(nil), &block); end
  def title(attributes = T.unsafe(nil), &block); end
  def tr(attributes = T.unsafe(nil), &block); end
  def tt(attributes = T.unsafe(nil), &block); end
  def ul(attributes = T.unsafe(nil), &block); end
  def var(attributes = T.unsafe(nil), &block); end
end

module CGI::Html4Fr
  include ::CGI::TagMaker
  def doctype; end
  def frame(attributes = T.unsafe(nil), &block); end
  def frameset(attributes = T.unsafe(nil), &block); end
end

module CGI::Html4Tr
  include ::CGI::TagMaker
  def a(attributes = T.unsafe(nil), &block); end
  def abbr(attributes = T.unsafe(nil), &block); end
  def acronym(attributes = T.unsafe(nil), &block); end
  def address(attributes = T.unsafe(nil), &block); end
  def applet(attributes = T.unsafe(nil), &block); end
  def area(attributes = T.unsafe(nil), &block); end
  def b(attributes = T.unsafe(nil), &block); end
  def base(attributes = T.unsafe(nil), &block); end
  def basefont(attributes = T.unsafe(nil), &block); end
  def bdo(attributes = T.unsafe(nil), &block); end
  def big(attributes = T.unsafe(nil), &block); end
  def blockquote(attributes = T.unsafe(nil), &block); end
  def body(attributes = T.unsafe(nil), &block); end
  def br(attributes = T.unsafe(nil), &block); end
  def button(attributes = T.unsafe(nil), &block); end
  def caption(attributes = T.unsafe(nil), &block); end
  def center(attributes = T.unsafe(nil), &block); end
  def cite(attributes = T.unsafe(nil), &block); end
  def code(attributes = T.unsafe(nil), &block); end
  def col(attributes = T.unsafe(nil), &block); end
  def colgroup(attributes = T.unsafe(nil), &block); end
  def dd(attributes = T.unsafe(nil), &block); end
  def del(attributes = T.unsafe(nil), &block); end
  def dfn(attributes = T.unsafe(nil), &block); end
  def dir(attributes = T.unsafe(nil), &block); end
  def div(attributes = T.unsafe(nil), &block); end
  def dl(attributes = T.unsafe(nil), &block); end
  def doctype; end
  def dt(attributes = T.unsafe(nil), &block); end
  def em(attributes = T.unsafe(nil), &block); end
  def fieldset(attributes = T.unsafe(nil), &block); end
  def font(attributes = T.unsafe(nil), &block); end
  def form(attributes = T.unsafe(nil), &block); end
  def h1(attributes = T.unsafe(nil), &block); end
  def h2(attributes = T.unsafe(nil), &block); end
  def h3(attributes = T.unsafe(nil), &block); end
  def h4(attributes = T.unsafe(nil), &block); end
  def h5(attributes = T.unsafe(nil), &block); end
  def h6(attributes = T.unsafe(nil), &block); end
  def head(attributes = T.unsafe(nil), &block); end
  def hr(attributes = T.unsafe(nil), &block); end
  def html(attributes = T.unsafe(nil), &block); end
  def i(attributes = T.unsafe(nil), &block); end
  def iframe(attributes = T.unsafe(nil), &block); end
  def img(attributes = T.unsafe(nil), &block); end
  def input(attributes = T.unsafe(nil), &block); end
  def ins(attributes = T.unsafe(nil), &block); end
  def isindex(attributes = T.unsafe(nil), &block); end
  def kbd(attributes = T.unsafe(nil), &block); end
  def label(attributes = T.unsafe(nil), &block); end
  def legend(attributes = T.unsafe(nil), &block); end
  def li(attributes = T.unsafe(nil), &block); end
  def link(attributes = T.unsafe(nil), &block); end
  def map(attributes = T.unsafe(nil), &block); end
  def menu(attributes = T.unsafe(nil), &block); end
  def meta(attributes = T.unsafe(nil), &block); end
  def noframes(attributes = T.unsafe(nil), &block); end
  def noscript(attributes = T.unsafe(nil), &block); end
  def object(attributes = T.unsafe(nil), &block); end
  def ol(attributes = T.unsafe(nil), &block); end
  def optgroup(attributes = T.unsafe(nil), &block); end
  def option(attributes = T.unsafe(nil), &block); end
  def p(attributes = T.unsafe(nil), &block); end
  def param(attributes = T.unsafe(nil), &block); end
  def pre(attributes = T.unsafe(nil), &block); end
  def q(attributes = T.unsafe(nil), &block); end
  def s(attributes = T.unsafe(nil), &block); end
  def samp(attributes = T.unsafe(nil), &block); end
  def script(attributes = T.unsafe(nil), &block); end
  def select(attributes = T.unsafe(nil), &block); end
  def small(attributes = T.unsafe(nil), &block); end
  def span(attributes = T.unsafe(nil), &block); end
  def strike(attributes = T.unsafe(nil), &block); end
  def strong(attributes = T.unsafe(nil), &block); end
  def style(attributes = T.unsafe(nil), &block); end
  def sub(attributes = T.unsafe(nil), &block); end
  def sup(attributes = T.unsafe(nil), &block); end
  def table(attributes = T.unsafe(nil), &block); end
  def tbody(attributes = T.unsafe(nil), &block); end
  def td(attributes = T.unsafe(nil), &block); end
  def textarea(attributes = T.unsafe(nil), &block); end
  def tfoot(attributes = T.unsafe(nil), &block); end
  def th(attributes = T.unsafe(nil), &block); end
  def thead(attributes = T.unsafe(nil), &block); end
  def title(attributes = T.unsafe(nil), &block); end
  def tr(attributes = T.unsafe(nil), &block); end
  def tt(attributes = T.unsafe(nil), &block); end
  def u(attributes = T.unsafe(nil), &block); end
  def ul(attributes = T.unsafe(nil), &block); end
  def var(attributes = T.unsafe(nil), &block); end
end

module CGI::Html5
  include ::CGI::TagMaker
  def a(attributes = T.unsafe(nil), &block); end
  def abbr(attributes = T.unsafe(nil), &block); end
  def address(attributes = T.unsafe(nil), &block); end
  def area(attributes = T.unsafe(nil), &block); end
  def article(attributes = T.unsafe(nil), &block); end
  def aside(attributes = T.unsafe(nil), &block); end
  def audio(attributes = T.unsafe(nil), &block); end
  def b(attributes = T.unsafe(nil), &block); end
  def base(attributes = T.unsafe(nil), &block); end
  def bdi(attributes = T.unsafe(nil), &block); end
  def bdo(attributes = T.unsafe(nil), &block); end
  def blockquote(attributes = T.unsafe(nil), &block); end
  def body(attributes = T.unsafe(nil), &block); end
  def br(attributes = T.unsafe(nil), &block); end
  def button(attributes = T.unsafe(nil), &block); end
  def canvas(attributes = T.unsafe(nil), &block); end
  def caption(attributes = T.unsafe(nil), &block); end
  def cite(attributes = T.unsafe(nil), &block); end
  def code(attributes = T.unsafe(nil), &block); end
  def col(attributes = T.unsafe(nil), &block); end
  def colgroup(attributes = T.unsafe(nil), &block); end
  def command(attributes = T.unsafe(nil), &block); end
  def datalist(attributes = T.unsafe(nil), &block); end
  def dd(attributes = T.unsafe(nil), &block); end
  def del(attributes = T.unsafe(nil), &block); end
  def details(attributes = T.unsafe(nil), &block); end
  def dfn(attributes = T.unsafe(nil), &block); end
  def dialog(attributes = T.unsafe(nil), &block); end
  def div(attributes = T.unsafe(nil), &block); end
  def dl(attributes = T.unsafe(nil), &block); end
  def doctype; end
  def dt(attributes = T.unsafe(nil), &block); end
  def em(attributes = T.unsafe(nil), &block); end
  def embed(attributes = T.unsafe(nil), &block); end
  def fieldset(attributes = T.unsafe(nil), &block); end
  def figcaption(attributes = T.unsafe(nil), &block); end
  def figure(attributes = T.unsafe(nil), &block); end
  def footer(attributes = T.unsafe(nil), &block); end
  def form(attributes = T.unsafe(nil), &block); end
  def h1(attributes = T.unsafe(nil), &block); end
  def h2(attributes = T.unsafe(nil), &block); end
  def h3(attributes = T.unsafe(nil), &block); end
  def h4(attributes = T.unsafe(nil), &block); end
  def h5(attributes = T.unsafe(nil), &block); end
  def h6(attributes = T.unsafe(nil), &block); end
  def head(attributes = T.unsafe(nil), &block); end
  def header(attributes = T.unsafe(nil), &block); end
  def hgroup(attributes = T.unsafe(nil), &block); end
  def hr(attributes = T.unsafe(nil), &block); end
  def html(attributes = T.unsafe(nil), &block); end
  def i(attributes = T.unsafe(nil), &block); end
  def iframe(attributes = T.unsafe(nil), &block); end
  def img(attributes = T.unsafe(nil), &block); end
  def input(attributes = T.unsafe(nil), &block); end
  def ins(attributes = T.unsafe(nil), &block); end
  def kbd(attributes = T.unsafe(nil), &block); end
  def keygen(attributes = T.unsafe(nil), &block); end
  def label(attributes = T.unsafe(nil), &block); end
  def legend(attributes = T.unsafe(nil), &block); end
  def li(attributes = T.unsafe(nil), &block); end
  def link(attributes = T.unsafe(nil), &block); end
  def map(attributes = T.unsafe(nil), &block); end
  def mark(attributes = T.unsafe(nil), &block); end
  def menu(attributes = T.unsafe(nil), &block); end
  def meta(attributes = T.unsafe(nil), &block); end
  def meter(attributes = T.unsafe(nil), &block); end
  def nav(attributes = T.unsafe(nil), &block); end
  def noscript(attributes = T.unsafe(nil), &block); end
  def object(attributes = T.unsafe(nil), &block); end
  def ol(attributes = T.unsafe(nil), &block); end
  def optgroup(attributes = T.unsafe(nil), &block); end
  def option(attributes = T.unsafe(nil), &block); end
  def output(attributes = T.unsafe(nil), &block); end
  def p(attributes = T.unsafe(nil), &block); end
  def param(attributes = T.unsafe(nil), &block); end
  def pre(attributes = T.unsafe(nil), &block); end
  def progress(attributes = T.unsafe(nil), &block); end
  def q(attributes = T.unsafe(nil), &block); end
  def rp(attributes = T.unsafe(nil), &block); end
  def rt(attributes = T.unsafe(nil), &block); end
  def ruby(attributes = T.unsafe(nil), &block); end
  def s(attributes = T.unsafe(nil), &block); end
  def samp(attributes = T.unsafe(nil), &block); end
  def script(attributes = T.unsafe(nil), &block); end
  def section(attributes = T.unsafe(nil), &block); end
  def select(attributes = T.unsafe(nil), &block); end
  def small(attributes = T.unsafe(nil), &block); end
  def source(attributes = T.unsafe(nil), &block); end
  def span(attributes = T.unsafe(nil), &block); end
  def strong(attributes = T.unsafe(nil), &block); end
  def style(attributes = T.unsafe(nil), &block); end
  def sub(attributes = T.unsafe(nil), &block); end
  def summary(attributes = T.unsafe(nil), &block); end
  def sup(attributes = T.unsafe(nil), &block); end
  def table(attributes = T.unsafe(nil), &block); end
  def tbody(attributes = T.unsafe(nil), &block); end
  def td(attributes = T.unsafe(nil), &block); end
  def textarea(attributes = T.unsafe(nil), &block); end
  def tfoot(attributes = T.unsafe(nil), &block); end
  def th(attributes = T.unsafe(nil), &block); end
  def thead(attributes = T.unsafe(nil), &block); end
  def time(attributes = T.unsafe(nil), &block); end
  def title(attributes = T.unsafe(nil), &block); end
  def tr(attributes = T.unsafe(nil), &block); end
  def track(attributes = T.unsafe(nil), &block); end
  def u(attributes = T.unsafe(nil), &block); end
  def ul(attributes = T.unsafe(nil), &block); end
  def var(attributes = T.unsafe(nil), &block); end
  def video(attributes = T.unsafe(nil), &block); end
  def wbr(attributes = T.unsafe(nil), &block); end
end

module CGI::HtmlExtension
  def a(href = T.unsafe(nil)); end
  def base(href = T.unsafe(nil)); end
  def blockquote(cite = T.unsafe(nil)); end
  def caption(align = T.unsafe(nil)); end
  def checkbox(name = T.unsafe(nil), value = T.unsafe(nil), checked = T.unsafe(nil)); end
  def checkbox_group(name = T.unsafe(nil), *values); end
  def file_field(name = T.unsafe(nil), size = T.unsafe(nil), maxlength = T.unsafe(nil)); end
  def form(method = T.unsafe(nil), action = T.unsafe(nil), enctype = T.unsafe(nil)); end
  def hidden(name = T.unsafe(nil), value = T.unsafe(nil)); end
  def html(attributes = T.unsafe(nil)); end
  def image_button(src = T.unsafe(nil), name = T.unsafe(nil), alt = T.unsafe(nil)); end
  def img(src = T.unsafe(nil), alt = T.unsafe(nil), width = T.unsafe(nil), height = T.unsafe(nil)); end
  def multipart_form(action = T.unsafe(nil), enctype = T.unsafe(nil)); end
  def password_field(name = T.unsafe(nil), value = T.unsafe(nil), size = T.unsafe(nil), maxlength = T.unsafe(nil)); end
  def popup_menu(name = T.unsafe(nil), *values); end
  def radio_button(name = T.unsafe(nil), value = T.unsafe(nil), checked = T.unsafe(nil)); end
  def radio_group(name = T.unsafe(nil), *values); end
  def reset(value = T.unsafe(nil), name = T.unsafe(nil)); end
  def scrolling_list(name = T.unsafe(nil), *values); end
  def submit(value = T.unsafe(nil), name = T.unsafe(nil)); end
  def text_field(name = T.unsafe(nil), value = T.unsafe(nil), size = T.unsafe(nil), maxlength = T.unsafe(nil)); end
  def textarea(name = T.unsafe(nil), cols = T.unsafe(nil), rows = T.unsafe(nil)); end
end

class CGI::InvalidEncoding < ::Exception; end
CGI::LF = T.let(T.unsafe(nil), String)
CGI::MAX_MULTIPART_COUNT = T.let(T.unsafe(nil), Integer)
CGI::PATH_SEPARATOR = T.let(T.unsafe(nil), Hash)

module CGI::QueryExtension
  def [](key); end
  def accept; end
  def accept_charset; end
  def accept_encoding; end
  def accept_language; end
  def auth_type; end
  def cache_control; end
  def content_length; end
  def content_type; end
  def cookies; end
  def cookies=(_arg0); end
  def create_body(is_large); end
  def files; end
  def from; end
  def gateway_interface; end
  def has_key?(*args); end
  def host; end
  def include?(*args); end
  def key?(*args); end
  def keys(*args); end
  def multipart?; end
  def negotiate; end
  def params; end
  def params=(hash); end
  def path_info; end
  def path_translated; end
  def pragma; end
  def query_string; end
  def raw_cookie; end
  def raw_cookie2; end
  def referer; end
  def remote_addr; end
  def remote_host; end
  def remote_ident; end
  def remote_user; end
  def request_method; end
  def script_name; end
  def server_name; end
  def server_port; end
  def server_protocol; end
  def server_software; end
  def unescape_filename?; end
  def user_agent; end
  private def initialize_query; end
  private def read_from_cmdline; end
  private def read_multipart(boundary, content_length); end
end

CGI::REVISION = T.let(T.unsafe(nil), String)

class CGI::Session
  def initialize(request, option = T.unsafe(nil)); end
  def [](key); end
  def []=(key, val); end
  def close; end
  def delete; end
  def new_session; end
  def session_id; end
  def update; end
  private def create_new_id; end
  def self.callback(dbman); end
end

module CGI::TagMaker
  def nOE_element(element, attributes = T.unsafe(nil)); end
  def nOE_element_def(attributes = T.unsafe(nil), &block); end
  def nO_element(element, attributes = T.unsafe(nil)); end
  def nO_element_def(attributes = T.unsafe(nil), &block); end
  def nn_element(element, attributes = T.unsafe(nil)); end
  def nn_element_def(attributes = T.unsafe(nil), &block); end
end

module CGI::Util
  include ::CGI::Escape
  def escape(_arg0); end
  def escapeElement(string, *elements); end
  def escapeHTML(_arg0); end
  def escape_element(string, *elements); end
  def escape_html(_arg0); end
  def h(_arg0); end
  def pretty(string, shift = T.unsafe(nil)); end
  def rfc1123_date(time); end
  def unescape(*_arg0); end
  def unescapeElement(string, *elements); end
  def unescapeHTML(_arg0); end
  def unescape_element(string, *elements); end
  def unescape_html(_arg0); end
end

CGI::VERSION = T.let(T.unsafe(nil), String)

class Struct
  include ::Enumerable
  def initialize(*_arg0); end
  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def deconstruct; end
  def deconstruct_keys(_arg0); end
  def dig(*_arg0); end
  def each; end
  def each_pair; end
  def eql?(_arg0); end
  def filter(*_arg0); end
  def hash; end
  def inspect; end
  def length; end
  def members; end
  def select(*_arg0); end
  def size; end
  def to_a; end
  def to_h; end
  def to_s; end
  def values; end
  def values_at(*_arg0); end
  private def initialize_copy(_arg0); end
  def self.new(*_arg0); end
end

FileUtils::Entry_::DIRECTORY_TERM = T.let(T.unsafe(nil), String)
FileUtils::Entry_::S_IF_DOOR = T.let(T.unsafe(nil), Integer)

class Array
  include ::Enumerable
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def initialize(*_arg0); end
  def &(_arg0); end
  def *(_arg0); end
  def +(_arg0); end
  def -(_arg0); end
  def <<(_arg0); end
  def <=>(_arg0); end
  def ==(_arg0); end
  def [](*_arg0); end
  def []=(*_arg0); end
  def all?(*_arg0); end
  def any?(*_arg0); end
  def append(*_arg0); end
  def assoc(_arg0); end
  def at(_arg0); end
  def bsearch; end
  def bsearch_index; end
  def clear; end
  def collect; end
  def collect!; end
  def combination(_arg0); end
  def compact; end
  def compact!; end
  def concat(*_arg0); end
  def count(*_arg0); end
  def cycle(*_arg0); end
  def deconstruct; end
  def delete(_arg0); end
  def delete_at(_arg0); end
  def delete_if; end
  def difference(*_arg0); end
  def dig(*_arg0); end
  def drop(_arg0); end
  def drop_while; end
  def each; end
  def each_index; end
  def empty?; end
  def eql?(_arg0); end
  def fetch(*_arg0); end
  def fill(*_arg0); end
  def filter; end
  def filter!; end
  def find_index(*_arg0); end
  def first(*_arg0); end
  def flatten(*_arg0); end
  def flatten!(*_arg0); end
  def hash; end
  def include?(_arg0); end
  def index(*_arg0); end
  def insert(*_arg0); end
  def inspect; end
  def intersection(*_arg0); end
  def join(*_arg0); end
  def keep_if; end
  def last(*_arg0); end
  def length; end
  def map; end
  def map!; end
  def max(*_arg0); end
  def min(*_arg0); end
  def minmax; end
  def none?(*_arg0); end
  def one?(*_arg0); end
  def pack(fmt, buffer: T.unsafe(nil)); end
  def permutation(*_arg0); end
  def place(*values); end
  def pop(*_arg0); end
  def prepend(*_arg0); end
  def product(*_arg0); end
  def push(*_arg0); end
  def rassoc(_arg0); end
  def reject; end
  def reject!; end
  def repeated_combination(_arg0); end
  def repeated_permutation(_arg0); end
  def replace(_arg0); end
  def reverse; end
  def reverse!; end
  def reverse_each; end
  def rindex(*_arg0); end
  def rotate(*_arg0); end
  def rotate!(*_arg0); end
  def sample(n = T.unsafe(nil), random: T.unsafe(nil)); end
  def select; end
  def select!; end
  def shelljoin; end
  def shift(*_arg0); end
  def shuffle(random: T.unsafe(nil)); end
  def shuffle!(random: T.unsafe(nil)); end
  def size; end
  def slice(*_arg0); end
  def slice!(*_arg0); end
  def sort; end
  def sort!; end
  def sort_by!; end
  def sum(*_arg0); end
  def take(_arg0); end
  def take_while; end
  def to_a; end
  def to_ary; end
  def to_h; end
  def to_s; end
  def transpose; end
  def union(*_arg0); end
  def uniq; end
  def uniq!; end
  def unshift(*_arg0); end
  def values_at(*_arg0); end
  def zip(*_arg0); end
  def |(_arg0); end
  private def initialize_copy(_arg0); end
  def self.[](*_arg0); end
  def self.try_convert(_arg0); end
end

class Exception
  def initialize(*_arg0); end
  def ==(_arg0); end
  def backtrace; end
  def backtrace_locations; end
  def cause; end
  def exception(*_arg0); end
  def full_message(*_arg0); end
  def inspect; end
  def message; end
  def respond_to?(*_arg0); end
  def set_backtrace(_arg0); end
  def to_s; end
  private def method_missing(*_arg0); end
  private def respond_to_missing?(_arg0, _arg1); end
  def self.exception(*_arg0); end
  def self.to_tty?; end
end

class CGI::Session::FileStore
  def initialize(session, option = T.unsafe(nil)); end
  def close; end
  def delete; end
  def restore; end
  def update; end
end

class CGI::Session::MemoryStore
  def initialize(session, option = T.unsafe(nil)); end
  def close; end
  def delete; end
  def restore; end
  def update; end
end

class CGI::Session::NoSession < ::RuntimeError; end

class CGI::Session::NullStore
  def initialize(session, option = T.unsafe(nil)); end
  def close; end
  def delete; end
  def restore; end
  def update; end
end

CGI::Util::RFC822_DAYS = T.let(T.unsafe(nil), Array)
CGI::Util::RFC822_MONTHS = T.let(T.unsafe(nil), Array)
CGI::Util::TABLE_FOR_ESCAPE_HTML__ = T.let(T.unsafe(nil), Hash)

module Enumerable
  def all?(*_arg0); end
  def any?(*_arg0); end
  def chain(*_arg0); end
  def chunk; end
  def chunk_while; end
  def collect; end
  def collect_concat; end
  def count(*_arg0); end
  def cycle(*_arg0); end
  def detect(*_arg0); end
  def drop(_arg0); end
  def drop_while; end
  def each_cons(_arg0); end
  def each_entry(*_arg0); end
  def each_slice(_arg0); end
  def each_with_index(*_arg0); end
  def each_with_object(_arg0); end
  def entries(*_arg0); end
  def filter; end
  def filter_map; end
  def find(*_arg0); end
  def find_all; end
  def find_index(*_arg0); end
  def first(*_arg0); end
  def flat_map; end
  def grep(_arg0); end
  def grep_v(_arg0); end
  def group_by; end
  def include?(_arg0); end
  def inject(*_arg0); end
  def lazy; end
  def map; end
  def max(*_arg0); end
  def max_by(*_arg0); end
  def member?(_arg0); end
  def min(*_arg0); end
  def min_by(*_arg0); end
  def minmax; end
  def minmax_by; end
  def none?(*_arg0); end
  def one?(*_arg0); end
  def partition; end
  def reduce(*_arg0); end
  def reject; end
  def reverse_each(*_arg0); end
  def select; end
  def slice_after(*_arg0); end
  def slice_before(*_arg0); end
  def slice_when; end
  def sort; end
  def sort_by; end
  def sum(*_arg0); end
  def take(_arg0); end
  def take_while; end
  def tally; end
  def to_a(*_arg0); end
  def to_h(*_arg0); end
  def to_set(klass = T.unsafe(nil), *args, &block); end
  def uniq; end
  def zip(*_arg0); end
end

Struct::Group = Etc::Group
Struct::Passwd = Etc::Passwd
CGI::Session::MemoryStore::GLOBAL_HASH_TABLE = T.let(T.unsafe(nil), Hash)
class RuntimeError < ::StandardError; end

module JSON::Ext::Generator::GeneratorMethods::Array
  def to_json(*_arg0); end
end

class StandardError < ::Exception; end
class Continuation
  def [](*_arg0); end
  def call(*_arg0); end
end
module Coverage
  private def peek_result; end
  private def result(*_arg0); end
  private def running?; end
  private def start(*_arg0); end
  def self.line_stub(file); end
  def self.peek_result; end
  def self.result(*_arg0); end
  def self.running?; end
  def self.start(*_arg0); end
end
class DateTime < ::Date
  def hour; end
  def iso8601(*_arg0); end
  def jisx0301(*_arg0); end
  def min; end
  def minute; end
  def new_offset(*_arg0); end
  def offset; end
  def rfc3339(*_arg0); end
  def sec; end
  def sec_fraction; end
  def second; end
  def second_fraction; end
  def strftime(*_arg0); end
  def to_date; end
  def to_datetime; end
  def to_s; end
  def to_time; end
  def xmlschema(*_arg0); end
  def zone; end
  def self._strptime(*_arg0); end
  def self.civil(*_arg0); end
  def self.commercial(*_arg0); end
  def self.httpdate(*_arg0); end
  def self.iso8601(*_arg0); end
  def self.jd(*_arg0); end
  def self.jisx0301(*_arg0); end
  def self.new(*_arg0); end
  def self.now(*_arg0); end
  def self.ordinal(*_arg0); end
  def self.parse(*_arg0); end
  def self.rfc2822(*_arg0); end
  def self.rfc3339(*_arg0); end
  def self.rfc822(*_arg0); end
  def self.strptime(*_arg0); end
  def self.xmlschema(*_arg0); end
end

class Date
  include ::Comparable
  def initialize(*_arg0); end
  def +(_arg0); end
  def -(_arg0); end
  def <<(_arg0); end
  def <=>(_arg0); end
  def ===(_arg0); end
  def >>(_arg0); end
  def ajd; end
  def amjd; end
  def asctime; end
  def ctime; end
  def cwday; end
  def cweek; end
  def cwyear; end
  def day; end
  def day_fraction; end
  def downto(_arg0); end
  def england; end
  def eql?(_arg0); end
  def friday?; end
  def gregorian; end
  def gregorian?; end
  def hash; end
  def httpdate; end
  def infinite?; end
  def inspect; end
  def iso8601; end
  def italy; end
  def jd; end
  def jisx0301; end
  def julian; end
  def julian?; end
  def ld; end
  def leap?; end
  def marshal_dump; end
  def marshal_load(_arg0); end
  def mday; end
  def mjd; end
  def mon; end
  def monday?; end
  def month; end
  def new_start(*_arg0); end
  def next; end
  def next_day(*_arg0); end
  def next_month(*_arg0); end
  def next_year(*_arg0); end
  def prev_day(*_arg0); end
  def prev_month(*_arg0); end
  def prev_year(*_arg0); end
  def rfc2822; end
  def rfc3339; end
  def rfc822; end
  def saturday?; end
  def start; end
  def step(*_arg0); end
  def strftime(*_arg0); end
  def succ; end
  def sunday?; end
  def thursday?; end
  def to_date; end
  def to_datetime; end
  def to_s; end
  def to_time; end
  def tuesday?; end
  def upto(_arg0); end
  def wday; end
  def wednesday?; end
  def xmlschema; end
  def yday; end
  def year; end
  private def hour; end
  private def initialize_copy(_arg0); end
  private def min; end
  private def minute; end
  private def sec; end
  private def second; end
  def self._httpdate(_arg0); end
  def self._iso8601(_arg0); end
  def self._jisx0301(_arg0); end
  def self._load(_arg0); end
  def self._parse(*_arg0); end
  def self._rfc2822(_arg0); end
  def self._rfc3339(_arg0); end
  def self._rfc822(_arg0); end
  def self._strptime(*_arg0); end
  def self._xmlschema(_arg0); end
  def self.civil(*_arg0); end
  def self.commercial(*_arg0); end
  def self.gregorian_leap?(_arg0); end
  def self.httpdate(*_arg0); end
  def self.iso8601(*_arg0); end
  def self.jd(*_arg0); end
  def self.jisx0301(*_arg0); end
  def self.julian_leap?(_arg0); end
  def self.leap?(_arg0); end
  def self.ordinal(*_arg0); end
  def self.parse(*_arg0); end
  def self.rfc2822(*_arg0); end
  def self.rfc3339(*_arg0); end
  def self.rfc822(*_arg0); end
  def self.strptime(*_arg0); end
  def self.today(*_arg0); end
  def self.valid_civil?(*_arg0); end
  def self.valid_commercial?(*_arg0); end
  def self.valid_date?(*_arg0); end
  def self.valid_jd?(*_arg0); end
  def self.valid_ordinal?(*_arg0); end
  def self.xmlschema(*_arg0); end
end

Date::ABBR_DAYNAMES = T.let(T.unsafe(nil), Array)
Date::ABBR_MONTHNAMES = T.let(T.unsafe(nil), Array)
Date::DAYNAMES = T.let(T.unsafe(nil), Array)
Date::ENGLAND = T.let(T.unsafe(nil), Integer)
class Date::Error < ::ArgumentError; end
Date::GREGORIAN = T.let(T.unsafe(nil), Float)
Date::ITALY = T.let(T.unsafe(nil), Integer)

class Date::Infinity < ::Numeric
  def initialize(d = T.unsafe(nil)); end
  def +@; end
  def -@; end
  def <=>(other); end
  def abs; end
  def coerce(other); end
  def finite?; end
  def infinite?; end
  def nan?; end
  def to_f; end
  def zero?; end
  protected def d; end
end

Date::JULIAN = T.let(T.unsafe(nil), Float)
Date::MONTHNAMES = T.let(T.unsafe(nil), Array)

module Comparable
  def <(_arg0); end
  def <=(_arg0); end
  def ==(_arg0); end
  def >(_arg0); end
  def >=(_arg0); end
  def between?(_arg0, _arg1); end
  def clamp(*_arg0); end
end

class ArgumentError < ::StandardError; end

class Numeric
  include ::Comparable
  def %(_arg0); end
  def +@; end
  def -@; end
  def <=>(_arg0); end
  def abs; end
  def abs2; end
  def angle; end
  def arg; end
  def ceil(*_arg0); end
  def clone(*_arg0); end
  def coerce(_arg0); end
  def conj; end
  def conjugate; end
  def denominator; end
  def div(_arg0); end
  def divmod(_arg0); end
  def dup; end
  def eql?(_arg0); end
  def fdiv(_arg0); end
  def finite?; end
  def floor(*_arg0); end
  def i; end
  def imag; end
  def imaginary; end
  def infinite?; end
  def integer?; end
  def magnitude; end
  def modulo(_arg0); end
  def negative?; end
  def nonzero?; end
  def numerator; end
  def phase; end
  def polar; end
  def positive?; end
  def quo(_arg0); end
  def real; end
  def real?; end
  def rect; end
  def rectangular; end
  def remainder(_arg0); end
  def round(*_arg0); end
  def singleton_method_added(_arg0); end
  def step(*_arg0); end
  def to_c; end
  def to_int; end
  def truncate(*_arg0); end
  def zero?; end
end

class StandardError < ::Exception; end

class Exception
  def initialize(*_arg0); end
  def ==(_arg0); end
  def backtrace; end
  def backtrace_locations; end
  def cause; end
  def exception(*_arg0); end
  def full_message(*_arg0); end
  def inspect; end
  def message; end
  def respond_to?(*_arg0); end
  def set_backtrace(_arg0); end
  def to_s; end
  private def method_missing(*_arg0); end
  private def respond_to_missing?(_arg0, _arg1); end
  def self.exception(*_arg0); end
  def self.to_tty?; end
end
class DBM
  include ::Enumerable
  def initialize(*_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clear; end
  def close; end
  def closed?; end
  def delete(_arg0); end
  def delete_if; end
  def each; end
  def each_key; end
  def each_pair; end
  def each_value; end
  def empty?; end
  def fetch(*_arg0); end
  def has_key?(_arg0); end
  def has_value?(_arg0); end
  def include?(_arg0); end
  def index(_arg0); end
  def invert; end
  def key(_arg0); end
  def key?(_arg0); end
  def keys; end
  def length; end
  def member?(_arg0); end
  def reject; end
  def reject!; end
  def replace(_arg0); end
  def select; end
  def shift; end
  def size; end
  def store(_arg0, _arg1); end
  def to_a; end
  def to_hash; end
  def update(_arg0); end
  def value?(_arg0); end
  def values; end
  def values_at(*_arg0); end
  def self.open(*_arg0); end
end

class DBMError < ::StandardError; end
DBM::NEWDB = T.let(T.unsafe(nil), Integer)
DBM::READER = T.let(T.unsafe(nil), Integer)
DBM::VERSION = T.let(T.unsafe(nil), String)
DBM::WRCREAT = T.let(T.unsafe(nil), Integer)
DBM::WRITER = T.let(T.unsafe(nil), Integer)
class StandardError < ::Exception; end

module Enumerable
  def all?(*_arg0); end
  def any?(*_arg0); end
  def chain(*_arg0); end
  def chunk; end
  def chunk_while; end
  def collect; end
  def collect_concat; end
  def count(*_arg0); end
  def cycle(*_arg0); end
  def detect(*_arg0); end
  def drop(_arg0); end
  def drop_while; end
  def each_cons(_arg0); end
  def each_entry(*_arg0); end
  def each_slice(_arg0); end
  def each_with_index(*_arg0); end
  def each_with_object(_arg0); end
  def entries(*_arg0); end
  def filter; end
  def filter_map; end
  def find(*_arg0); end
  def find_all; end
  def find_index(*_arg0); end
  def first(*_arg0); end
  def flat_map; end
  def grep(_arg0); end
  def grep_v(_arg0); end
  def group_by; end
  def include?(_arg0); end
  def inject(*_arg0); end
  def lazy; end
  def map; end
  def max(*_arg0); end
  def max_by(*_arg0); end
  def member?(_arg0); end
  def min(*_arg0); end
  def min_by(*_arg0); end
  def minmax; end
  def minmax_by; end
  def none?(*_arg0); end
  def one?(*_arg0); end
  def partition; end
  def reduce(*_arg0); end
  def reject; end
  def reverse_each(*_arg0); end
  def select; end
  def slice_after(*_arg0); end
  def slice_before(*_arg0); end
  def slice_when; end
  def sort; end
  def sort_by; end
  def sum(*_arg0); end
  def take(_arg0); end
  def take_while; end
  def tally; end
  def to_a(*_arg0); end
  def to_h(*_arg0); end
  def to_set(klass = T.unsafe(nil), *args, &block); end
  def uniq; end
  def zip(*_arg0); end
end

class Exception
  def initialize(*_arg0); end
  def ==(_arg0); end
  def backtrace; end
  def backtrace_locations; end
  def cause; end
  def exception(*_arg0); end
  def full_message(*_arg0); end
  def inspect; end
  def message; end
  def respond_to?(*_arg0); end
  def set_backtrace(_arg0); end
  def to_s; end
  private def method_missing(*_arg0); end
  private def respond_to_missing?(_arg0, _arg1); end
  def self.exception(*_arg0); end
  def self.to_tty?; end
end
module Digest
  private def hexencode(_arg0); end
  def self.const_missing(name); end
  def self.hexencode(_arg0); end
end

class Digest::Base < ::Digest::Class
  def <<(_arg0); end
  def block_length; end
  def digest_length; end
  def reset; end
  def update(_arg0); end
  private def finish; end
  private def initialize_copy(_arg0); end
end

class Digest::Class
  include ::Digest::Instance
  def initialize; end
  def self.base64digest(str, *args); end
  def self.digest(*_arg0); end
  def self.file(name, *args); end
  def self.hexdigest(*_arg0); end
end

module Digest::Instance
  def <<(_arg0); end
  def ==(_arg0); end
  def base64digest(str = T.unsafe(nil)); end
  def base64digest!; end
  def block_length; end
  def digest(*_arg0); end
  def digest!; end
  def digest_length; end
  def file(name); end
  def hexdigest(*_arg0); end
  def hexdigest!; end
  def inspect; end
  def length; end
  def new; end
  def reset; end
  def size; end
  def to_s; end
  def update(_arg0); end
  private def finish; end
end

Digest::REQUIRE_MUTEX = T.let(T.unsafe(nil), Thread::Mutex)
class Digest::SHA1 < ::Digest::Base; end

class Digest::SHA2 < ::Digest::Class
  def initialize(bitlen = T.unsafe(nil)); end
  def <<(str); end
  def block_length; end
  def digest_length; end
  def inspect; end
  def reset; end
  def update(str); end
  private def finish; end
  private def initialize_copy(other); end
end

class Digest::SHA256 < ::Digest::Base; end
class Digest::SHA384 < ::Digest::Base; end
class Digest::SHA512 < ::Digest::Base; end
Digest::VERSION = T.let(T.unsafe(nil), String)

module Etc
  private def confstr(_arg0); end
  private def endgrent; end
  private def endpwent; end
  private def getgrent; end
  private def getgrgid(*_arg0); end
  private def getgrnam(_arg0); end
  private def getlogin; end
  private def getpwent; end
  private def getpwnam(_arg0); end
  private def getpwuid(*_arg0); end
  private def group; end
  private def nprocessors; end
  private def passwd; end
  private def setgrent; end
  private def setpwent; end
  private def sysconf(_arg0); end
  private def sysconfdir; end
  private def systmpdir; end
  private def uname; end
  def self.confstr(_arg0); end
  def self.endgrent; end
  def self.endpwent; end
  def self.getgrent; end
  def self.getgrgid(*_arg0); end
  def self.getgrnam(_arg0); end
  def self.getlogin; end
  def self.getpwent; end
  def self.getpwnam(_arg0); end
  def self.getpwuid(*_arg0); end
  def self.group; end
  def self.nprocessors; end
  def self.passwd; end
  def self.setgrent; end
  def self.setpwent; end
  def self.sysconf(_arg0); end
  def self.sysconfdir; end
  def self.systmpdir; end
  def self.uname; end
end

Etc::CS_PATH = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_ILP32_OFF32_CFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_ILP32_OFF32_LDFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_ILP32_OFF32_LIBS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_ILP32_OFFBIG_LIBS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_LP64_OFF64_CFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_LP64_OFF64_LDFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_LP64_OFF64_LIBS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_LPBIG_OFFBIG_LIBS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_WIDTH_RESTRICTED_ENVS = T.let(T.unsafe(nil), Integer)

class Etc::Group < ::Struct
  extend ::Enumerable
  def gid; end
  def gid=(_); end
  def mem; end
  def mem=(_); end
  def name; end
  def name=(_); end
  def passwd; end
  def passwd=(_); end
  def self.[](*_arg0); end
  def self.each; end
  def self.inspect; end
  def self.members; end
  def self.new(*_arg0); end
end

Etc::PC_2_SYMLINKS = T.let(T.unsafe(nil), Integer)
Etc::PC_ALLOC_SIZE_MIN = T.let(T.unsafe(nil), Integer)
Etc::PC_ASYNC_IO = T.let(T.unsafe(nil), Integer)
Etc::PC_CHOWN_RESTRICTED = T.let(T.unsafe(nil), Integer)
Etc::PC_FILESIZEBITS = T.let(T.unsafe(nil), Integer)
Etc::PC_LINK_MAX = T.let(T.unsafe(nil), Integer)
Etc::PC_MAX_CANON = T.let(T.unsafe(nil), Integer)
Etc::PC_MAX_INPUT = T.let(T.unsafe(nil), Integer)
Etc::PC_NAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::PC_NO_TRUNC = T.let(T.unsafe(nil), Integer)
Etc::PC_PATH_MAX = T.let(T.unsafe(nil), Integer)
Etc::PC_PIPE_BUF = T.let(T.unsafe(nil), Integer)
Etc::PC_PRIO_IO = T.let(T.unsafe(nil), Integer)
Etc::PC_REC_INCR_XFER_SIZE = T.let(T.unsafe(nil), Integer)
Etc::PC_REC_MAX_XFER_SIZE = T.let(T.unsafe(nil), Integer)
Etc::PC_REC_MIN_XFER_SIZE = T.let(T.unsafe(nil), Integer)
Etc::PC_REC_XFER_ALIGN = T.let(T.unsafe(nil), Integer)
Etc::PC_SYMLINK_MAX = T.let(T.unsafe(nil), Integer)
Etc::PC_SYNC_IO = T.let(T.unsafe(nil), Integer)
Etc::PC_VDISABLE = T.let(T.unsafe(nil), Integer)

class Etc::Passwd < ::Struct
  extend ::Enumerable
  def change; end
  def change=(_); end
  def dir; end
  def dir=(_); end
  def expire; end
  def expire=(_); end
  def gecos; end
  def gecos=(_); end
  def gid; end
  def gid=(_); end
  def name; end
  def name=(_); end
  def passwd; end
  def passwd=(_); end
  def shell; end
  def shell=(_); end
  def uclass; end
  def uclass=(_); end
  def uid; end
  def uid=(_); end
  def self.[](*_arg0); end
  def self.each; end
  def self.inspect; end
  def self.members; end
  def self.new(*_arg0); end
end

Etc::SC_2_CHAR_TERM = T.let(T.unsafe(nil), Integer)
Etc::SC_2_C_BIND = T.let(T.unsafe(nil), Integer)
Etc::SC_2_C_DEV = T.let(T.unsafe(nil), Integer)
Etc::SC_2_FORT_DEV = T.let(T.unsafe(nil), Integer)
Etc::SC_2_FORT_RUN = T.let(T.unsafe(nil), Integer)
Etc::SC_2_LOCALEDEF = T.let(T.unsafe(nil), Integer)
Etc::SC_2_PBS = T.let(T.unsafe(nil), Integer)
Etc::SC_2_PBS_ACCOUNTING = T.let(T.unsafe(nil), Integer)
Etc::SC_2_PBS_CHECKPOINT = T.let(T.unsafe(nil), Integer)
Etc::SC_2_PBS_LOCATE = T.let(T.unsafe(nil), Integer)
Etc::SC_2_PBS_MESSAGE = T.let(T.unsafe(nil), Integer)
Etc::SC_2_PBS_TRACK = T.let(T.unsafe(nil), Integer)
Etc::SC_2_SW_DEV = T.let(T.unsafe(nil), Integer)
Etc::SC_2_UPE = T.let(T.unsafe(nil), Integer)
Etc::SC_2_VERSION = T.let(T.unsafe(nil), Integer)
Etc::SC_ADVISORY_INFO = T.let(T.unsafe(nil), Integer)
Etc::SC_AIO_LISTIO_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_AIO_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_AIO_PRIO_DELTA_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_ARG_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_ASYNCHRONOUS_IO = T.let(T.unsafe(nil), Integer)
Etc::SC_ATEXIT_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_BARRIERS = T.let(T.unsafe(nil), Integer)
Etc::SC_BC_BASE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_BC_DIM_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_BC_SCALE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_BC_STRING_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_CHILD_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_CLK_TCK = T.let(T.unsafe(nil), Integer)
Etc::SC_CLOCK_SELECTION = T.let(T.unsafe(nil), Integer)
Etc::SC_COLL_WEIGHTS_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_CPUTIME = T.let(T.unsafe(nil), Integer)
Etc::SC_DELAYTIMER_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_EXPR_NEST_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_FSYNC = T.let(T.unsafe(nil), Integer)
Etc::SC_GETGR_R_SIZE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_GETPW_R_SIZE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_HOST_NAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_IOV_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_IPV6 = T.let(T.unsafe(nil), Integer)
Etc::SC_JOB_CONTROL = T.let(T.unsafe(nil), Integer)
Etc::SC_LINE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_LOGIN_NAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_MAPPED_FILES = T.let(T.unsafe(nil), Integer)
Etc::SC_MEMLOCK = T.let(T.unsafe(nil), Integer)
Etc::SC_MEMLOCK_RANGE = T.let(T.unsafe(nil), Integer)
Etc::SC_MEMORY_PROTECTION = T.let(T.unsafe(nil), Integer)
Etc::SC_MESSAGE_PASSING = T.let(T.unsafe(nil), Integer)
Etc::SC_MONOTONIC_CLOCK = T.let(T.unsafe(nil), Integer)
Etc::SC_MQ_OPEN_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_MQ_PRIO_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_NGROUPS_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_NPROCESSORS_CONF = T.let(T.unsafe(nil), Integer)
Etc::SC_NPROCESSORS_ONLN = T.let(T.unsafe(nil), Integer)
Etc::SC_OPEN_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_PAGESIZE = T.let(T.unsafe(nil), Integer)
Etc::SC_PAGE_SIZE = T.let(T.unsafe(nil), Integer)
Etc::SC_PHYS_PAGES = T.let(T.unsafe(nil), Integer)
Etc::SC_PRIORITIZED_IO = T.let(T.unsafe(nil), Integer)
Etc::SC_PRIORITY_SCHEDULING = T.let(T.unsafe(nil), Integer)
Etc::SC_RAW_SOCKETS = T.let(T.unsafe(nil), Integer)
Etc::SC_READER_WRITER_LOCKS = T.let(T.unsafe(nil), Integer)
Etc::SC_REALTIME_SIGNALS = T.let(T.unsafe(nil), Integer)
Etc::SC_REGEXP = T.let(T.unsafe(nil), Integer)
Etc::SC_RE_DUP_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_RTSIG_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_SAVED_IDS = T.let(T.unsafe(nil), Integer)
Etc::SC_SEMAPHORES = T.let(T.unsafe(nil), Integer)
Etc::SC_SEM_NSEMS_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_SEM_VALUE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_SHARED_MEMORY_OBJECTS = T.let(T.unsafe(nil), Integer)
Etc::SC_SHELL = T.let(T.unsafe(nil), Integer)
Etc::SC_SIGQUEUE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_SPAWN = T.let(T.unsafe(nil), Integer)
Etc::SC_SPIN_LOCKS = T.let(T.unsafe(nil), Integer)
Etc::SC_SPORADIC_SERVER = T.let(T.unsafe(nil), Integer)
Etc::SC_SS_REPL_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_STREAM_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_SYMLOOP_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_SYNCHRONIZED_IO = T.let(T.unsafe(nil), Integer)
Etc::SC_THREADS = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_ATTR_STACKADDR = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_ATTR_STACKSIZE = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_CPUTIME = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_DESTRUCTOR_ITERATIONS = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_KEYS_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_PRIORITY_SCHEDULING = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_PRIO_INHERIT = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_PRIO_PROTECT = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_PROCESS_SHARED = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_SAFE_FUNCTIONS = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_SPORADIC_SERVER = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_STACK_MIN = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_THREADS_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TIMEOUTS = T.let(T.unsafe(nil), Integer)
Etc::SC_TIMERS = T.let(T.unsafe(nil), Integer)
Etc::SC_TIMER_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_EVENT_FILTER = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_EVENT_NAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_INHERIT = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_LOG = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_NAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_SYS_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_USER_EVENT_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TTY_NAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TYPED_MEMORY_OBJECTS = T.let(T.unsafe(nil), Integer)
Etc::SC_TZNAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_V6_ILP32_OFF32 = T.let(T.unsafe(nil), Integer)
Etc::SC_V6_ILP32_OFFBIG = T.let(T.unsafe(nil), Integer)
Etc::SC_V6_LP64_OFF64 = T.let(T.unsafe(nil), Integer)
Etc::SC_V6_LPBIG_OFFBIG = T.let(T.unsafe(nil), Integer)
Etc::SC_VERSION = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_CRYPT = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_ENH_I18N = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_REALTIME = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_REALTIME_THREADS = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_SHM = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_STREAMS = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_UNIX = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_VERSION = T.let(T.unsafe(nil), Integer)
Etc::VERSION = T.let(T.unsafe(nil), String)

class Struct
  include ::Enumerable
  def initialize(*_arg0); end
  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def deconstruct; end
  def deconstruct_keys(_arg0); end
  def dig(*_arg0); end
  def each; end
  def each_pair; end
  def eql?(_arg0); end
  def filter(*_arg0); end
  def hash; end
  def inspect; end
  def length; end
  def members; end
  def select(*_arg0); end
  def size; end
  def to_a; end
  def to_h; end
  def to_s; end
  def values; end
  def values_at(*_arg0); end
  private def initialize_copy(_arg0); end
  def self.new(*_arg0); end
end

module Enumerable
  def all?(*_arg0); end
  def any?(*_arg0); end
  def chain(*_arg0); end
  def chunk; end
  def chunk_while; end
  def collect; end
  def collect_concat; end
  def count(*_arg0); end
  def cycle(*_arg0); end
  def detect(*_arg0); end
  def drop(_arg0); end
  def drop_while; end
  def each_cons(_arg0); end
  def each_entry(*_arg0); end
  def each_slice(_arg0); end
  def each_with_index(*_arg0); end
  def each_with_object(_arg0); end
  def entries(*_arg0); end
  def filter; end
  def filter_map; end
  def find(*_arg0); end
  def find_all; end
  def find_index(*_arg0); end
  def first(*_arg0); end
  def flat_map; end
  def grep(_arg0); end
  def grep_v(_arg0); end
  def group_by; end
  def include?(_arg0); end
  def inject(*_arg0); end
  def lazy; end
  def map; end
  def max(*_arg0); end
  def max_by(*_arg0); end
  def member?(_arg0); end
  def min(*_arg0); end
  def min_by(*_arg0); end
  def minmax; end
  def minmax_by; end
  def none?(*_arg0); end
  def one?(*_arg0); end
  def partition; end
  def reduce(*_arg0); end
  def reject; end
  def reverse_each(*_arg0); end
  def select; end
  def slice_after(*_arg0); end
  def slice_before(*_arg0); end
  def slice_when; end
  def sort; end
  def sort_by; end
  def sum(*_arg0); end
  def take(_arg0); end
  def take_while; end
  def tally; end
  def to_a(*_arg0); end
  def to_h(*_arg0); end
  def to_set(klass = T.unsafe(nil), *args, &block); end
  def uniq; end
  def zip(*_arg0); end
end

Struct::Group = Etc::Group
Struct::Passwd = Etc::Passwd
module Fcntl; end
Fcntl::FD_CLOEXEC = T.let(T.unsafe(nil), Integer)
Fcntl::F_DUPFD = T.let(T.unsafe(nil), Integer)
Fcntl::F_GETFD = T.let(T.unsafe(nil), Integer)
Fcntl::F_GETFL = T.let(T.unsafe(nil), Integer)
Fcntl::F_GETLK = T.let(T.unsafe(nil), Integer)
Fcntl::F_RDLCK = T.let(T.unsafe(nil), Integer)
Fcntl::F_SETFD = T.let(T.unsafe(nil), Integer)
Fcntl::F_SETFL = T.let(T.unsafe(nil), Integer)
Fcntl::F_SETLK = T.let(T.unsafe(nil), Integer)
Fcntl::F_SETLKW = T.let(T.unsafe(nil), Integer)
Fcntl::F_UNLCK = T.let(T.unsafe(nil), Integer)
Fcntl::F_WRLCK = T.let(T.unsafe(nil), Integer)
Fcntl::O_ACCMODE = T.let(T.unsafe(nil), Integer)
Fcntl::O_APPEND = T.let(T.unsafe(nil), Integer)
Fcntl::O_CREAT = T.let(T.unsafe(nil), Integer)
Fcntl::O_EXCL = T.let(T.unsafe(nil), Integer)
Fcntl::O_NDELAY = T.let(T.unsafe(nil), Integer)
Fcntl::O_NOCTTY = T.let(T.unsafe(nil), Integer)
Fcntl::O_NONBLOCK = T.let(T.unsafe(nil), Integer)
Fcntl::O_RDONLY = T.let(T.unsafe(nil), Integer)
Fcntl::O_RDWR = T.let(T.unsafe(nil), Integer)
Fcntl::O_TRUNC = T.let(T.unsafe(nil), Integer)
Fcntl::O_WRONLY = T.let(T.unsafe(nil), Integer)

module Fiddle
  private def dlopen(library); end
  private def dlunwrap(_arg0); end
  private def dlwrap(_arg0); end
  private def free(_arg0); end
  private def malloc(_arg0); end
  private def realloc(_arg0, _arg1); end
  def self.dlopen(library); end
  def self.dlunwrap(_arg0); end
  def self.dlwrap(_arg0); end
  def self.free(_arg0); end
  def self.last_error; end
  def self.last_error=(error); end
  def self.malloc(_arg0); end
  def self.realloc(_arg0, _arg1); end
end

Fiddle::ALIGN_CHAR = T.let(T.unsafe(nil), Integer)
Fiddle::ALIGN_DOUBLE = T.let(T.unsafe(nil), Integer)
Fiddle::ALIGN_FLOAT = T.let(T.unsafe(nil), Integer)
Fiddle::ALIGN_INT = T.let(T.unsafe(nil), Integer)
Fiddle::ALIGN_INT16_T = T.let(T.unsafe(nil), Integer)
Fiddle::ALIGN_INT32_T = T.let(T.unsafe(nil), Integer)
Fiddle::ALIGN_INT64_T = T.let(T.unsafe(nil), Integer)
Fiddle::ALIGN_INT8_T = T.let(T.unsafe(nil), Integer)
Fiddle::ALIGN_INTPTR_T = T.let(T.unsafe(nil), Integer)
Fiddle::ALIGN_LONG = T.let(T.unsafe(nil), Integer)
Fiddle::ALIGN_LONG_LONG = T.let(T.unsafe(nil), Integer)
Fiddle::ALIGN_PTRDIFF_T = T.let(T.unsafe(nil), Integer)
Fiddle::ALIGN_SHORT = T.let(T.unsafe(nil), Integer)
Fiddle::ALIGN_SIZE_T = T.let(T.unsafe(nil), Integer)
Fiddle::ALIGN_SSIZE_T = T.let(T.unsafe(nil), Integer)
Fiddle::ALIGN_UINTPTR_T = T.let(T.unsafe(nil), Integer)
Fiddle::ALIGN_VOIDP = T.let(T.unsafe(nil), Integer)
Fiddle::BUILD_RUBY_PLATFORM = T.let(T.unsafe(nil), String)

module Fiddle::BasicTypes
  private def included(m); end
  def self.included(m); end
end

module Fiddle::CParser
  def parse_ctype(ty, tymap = T.unsafe(nil)); end
  def parse_signature(signature, tymap = T.unsafe(nil)); end
  def parse_struct_signature(signature, tymap = T.unsafe(nil)); end
  private def compact(signature); end
  private def split_arguments(arguments, sep = T.unsafe(nil)); end
end

class Fiddle::CStruct
  include ::Enumerable
  def each; end
  def each_pair; end
  def replace(another); end
  def to_h; end
  private def unstruct(value); end
  def self.entity_class; end
end

module Fiddle::CStructBuilder
  private def create(klass, types, members); end
  def self.create(klass, types, members); end
end

class Fiddle::CStructEntity < ::Fiddle::Pointer
  include ::Fiddle::PackInfo
  include ::Fiddle::ValueUtil
  def initialize(addr, types, func = T.unsafe(nil)); end
  def [](*args); end
  def []=(*args); end
  def assign_names(members); end
  def set_ctypes(types); end
  def to_s; end
  def self.alignment(types); end
  def self.malloc(types, func = T.unsafe(nil), size = T.unsafe(nil), &block); end
  def self.size(types); end
end

class Fiddle::CUnion
  def self.entity_class; end
end

class Fiddle::CUnionEntity < ::Fiddle::CStructEntity
  def set_ctypes(types); end
  def self.size(types); end
end

class Fiddle::ClearedReferenceError < ::Fiddle::Error; end

class Fiddle::Closure
  def initialize(*_arg0); end
  def args; end
  def ctype; end
  def to_i; end
end

class Fiddle::CompositeHandler
  def initialize(handlers); end
  def [](symbol); end
  def handlers; end
  def sym(symbol); end
end

class Fiddle::DLError < ::Fiddle::Error; end
class Fiddle::Error < ::StandardError; end

class Fiddle::Function
  def initialize(*_arg0); end
  def abi; end
  def call(*_arg0); end
  def name; end
  def need_gvl?; end
  def ptr; end
  def to_i; end
end

class Fiddle::Handle
  def initialize(*_arg0); end
  def [](_arg0); end
  def close; end
  def close_enabled?; end
  def disable_close; end
  def enable_close; end
  def sym(_arg0); end
  def to_i; end
  def self.[](_arg0); end
  def self.sym(_arg0); end
end

module Fiddle::Importer
  include ::Fiddle
  include ::Fiddle::CParser
  extend ::Fiddle
  extend ::Fiddle::CParser
  extend ::Fiddle::Importer
  def [](name); end
  def bind(signature, *opts, &blk); end
  def bind_function(name, ctype, argtype, call_type = T.unsafe(nil), &block); end
  def create_value(ty, val = T.unsafe(nil)); end
  def dlload(*libs); end
  def extern(signature, *opts); end
  def handler; end
  def import_function(name, ctype, argtype, call_type = T.unsafe(nil)); end
  def import_symbol(name); end
  def import_value(ty, addr); end
  def sizeof(ty); end
  def struct(signature); end
  def typealias(alias_type, orig_type); end
  def union(signature); end
  def value(ty, val = T.unsafe(nil)); end
  private def parse_bind_options(opts); end
  private def type_alias; end
end

class Fiddle::MemoryView
  def initialize(_arg0); end
  def [](*_arg0); end
  def byte_size; end
  def format; end
  def item_size; end
  def ndim; end
  def obj; end
  def readonly?; end
  def shape; end
  def strides; end
  def sub_offsets; end
end

Fiddle::NULL = T.let(T.unsafe(nil), Fiddle::Pointer)

module Fiddle::PackInfo
  private def align(addr, align); end
  def self.align(addr, align); end
end

class Fiddle::Packer
  include ::Fiddle::PackInfo
  def initialize(types); end
  def pack(ary); end
  def size; end
  def unpack(ary); end
  private def parse_types(types); end
  def self.[](*types); end
end

class Fiddle::Pinned
  def initialize(_arg0); end
  def clear; end
  def cleared?; end
  def ref; end
end

class Fiddle::Pointer
  def initialize(*_arg0); end
  def +(_arg0); end
  def +@; end
  def -(_arg0); end
  def -@; end
  def <=>(_arg0); end
  def ==(_arg0); end
  def [](*_arg0); end
  def []=(*_arg0); end
  def call_free; end
  def eql?(_arg0); end
  def free; end
  def free=(_arg0); end
  def freed?; end
  def inspect; end
  def null?; end
  def ptr; end
  def ref; end
  def size; end
  def size=(_arg0); end
  def to_i; end
  def to_int; end
  def to_s(*_arg0); end
  def to_str(*_arg0); end
  def to_value; end
  def self.[](_arg0); end
  def self.malloc(*_arg0); end
  def self.to_ptr(_arg0); end
end

Fiddle::RTLD_GLOBAL = T.let(T.unsafe(nil), Integer)
Fiddle::RTLD_LAZY = T.let(T.unsafe(nil), Integer)
Fiddle::RTLD_NOW = T.let(T.unsafe(nil), Integer)
Fiddle::RUBY_FREE = T.let(T.unsafe(nil), Integer)
Fiddle::SIZEOF_CHAR = T.let(T.unsafe(nil), Integer)
Fiddle::SIZEOF_CONST_STRING = T.let(T.unsafe(nil), Integer)
Fiddle::SIZEOF_DOUBLE = T.let(T.unsafe(nil), Integer)
Fiddle::SIZEOF_FLOAT = T.let(T.unsafe(nil), Integer)
Fiddle::SIZEOF_INT = T.let(T.unsafe(nil), Integer)
Fiddle::SIZEOF_INT16_T = T.let(T.unsafe(nil), Integer)
Fiddle::SIZEOF_INT32_T = T.let(T.unsafe(nil), Integer)
Fiddle::SIZEOF_INT64_T = T.let(T.unsafe(nil), Integer)
Fiddle::SIZEOF_INT8_T = T.let(T.unsafe(nil), Integer)
Fiddle::SIZEOF_INTPTR_T = T.let(T.unsafe(nil), Integer)
Fiddle::SIZEOF_LONG = T.let(T.unsafe(nil), Integer)
Fiddle::SIZEOF_LONG_LONG = T.let(T.unsafe(nil), Integer)
Fiddle::SIZEOF_PTRDIFF_T = T.let(T.unsafe(nil), Integer)
Fiddle::SIZEOF_SHORT = T.let(T.unsafe(nil), Integer)
Fiddle::SIZEOF_SIZE_T = T.let(T.unsafe(nil), Integer)
Fiddle::SIZEOF_SSIZE_T = T.let(T.unsafe(nil), Integer)
Fiddle::SIZEOF_UINTPTR_T = T.let(T.unsafe(nil), Integer)
Fiddle::SIZEOF_VOIDP = T.let(T.unsafe(nil), Integer)

class Fiddle::StructArray < ::Array
  include ::Fiddle::ValueUtil
  def initialize(ptr, type, initial_values); end
  def []=(index, value); end
  def to_ptr; end
end

Fiddle::TYPE_CHAR = T.let(T.unsafe(nil), Integer)
Fiddle::TYPE_CONST_STRING = T.let(T.unsafe(nil), Integer)
Fiddle::TYPE_DOUBLE = T.let(T.unsafe(nil), Integer)
Fiddle::TYPE_FLOAT = T.let(T.unsafe(nil), Integer)
Fiddle::TYPE_INT = T.let(T.unsafe(nil), Integer)
Fiddle::TYPE_INT16_T = T.let(T.unsafe(nil), Integer)
Fiddle::TYPE_INT32_T = T.let(T.unsafe(nil), Integer)
Fiddle::TYPE_INT64_T = T.let(T.unsafe(nil), Integer)
Fiddle::TYPE_INT8_T = T.let(T.unsafe(nil), Integer)
Fiddle::TYPE_INTPTR_T = T.let(T.unsafe(nil), Integer)
Fiddle::TYPE_LONG = T.let(T.unsafe(nil), Integer)
Fiddle::TYPE_LONG_LONG = T.let(T.unsafe(nil), Integer)
Fiddle::TYPE_PTRDIFF_T = T.let(T.unsafe(nil), Integer)
Fiddle::TYPE_SHORT = T.let(T.unsafe(nil), Integer)
Fiddle::TYPE_SIZE_T = T.let(T.unsafe(nil), Integer)
Fiddle::TYPE_SSIZE_T = T.let(T.unsafe(nil), Integer)
Fiddle::TYPE_UINTPTR_T = T.let(T.unsafe(nil), Integer)
Fiddle::TYPE_VARIADIC = T.let(T.unsafe(nil), Integer)
Fiddle::TYPE_VOID = T.let(T.unsafe(nil), Integer)
Fiddle::TYPE_VOIDP = T.let(T.unsafe(nil), Integer)
Fiddle::VERSION = T.let(T.unsafe(nil), String)

module Fiddle::ValueUtil
  def signed_value(val, ty); end
  def unsigned_value(val, ty); end
  def wrap_arg(arg, ty, funcs = T.unsafe(nil), &block); end
  def wrap_args(args, tys, funcs, &block); end
end

module Fiddle::Win32Types
  private def included(m); end
  def self.included(m); end
end

class Fiddle::Closure::BlockCaller < ::Fiddle::Closure
  def initialize(ctype, args, abi = T.unsafe(nil), &block); end
  def call(*args); end
end

class StandardError < ::Exception; end
Fiddle::Function::DEFAULT = T.let(T.unsafe(nil), Integer)
Fiddle::Handle::DEFAULT = T.let(T.unsafe(nil), Fiddle::Handle)
Fiddle::Handle::NEXT = T.let(T.unsafe(nil), Fiddle::Handle)
Fiddle::Handle::RTLD_GLOBAL = T.let(T.unsafe(nil), Integer)
Fiddle::Handle::RTLD_LAZY = T.let(T.unsafe(nil), Integer)
Fiddle::Handle::RTLD_NOW = T.let(T.unsafe(nil), Integer)
Fiddle::PackInfo::ALIGN_MAP = T.let(T.unsafe(nil), Hash)
Fiddle::PackInfo::PACK_MAP = T.let(T.unsafe(nil), Hash)
Fiddle::PackInfo::SIZE_MAP = T.let(T.unsafe(nil), Hash)

class Array
  include ::Enumerable
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def initialize(*_arg0); end
  def &(_arg0); end
  def *(_arg0); end
  def +(_arg0); end
  def -(_arg0); end
  def <<(_arg0); end
  def <=>(_arg0); end
  def ==(_arg0); end
  def [](*_arg0); end
  def []=(*_arg0); end
  def all?(*_arg0); end
  def any?(*_arg0); end
  def append(*_arg0); end
  def assoc(_arg0); end
  def at(_arg0); end
  def bsearch; end
  def bsearch_index; end
  def clear; end
  def collect; end
  def collect!; end
  def combination(_arg0); end
  def compact; end
  def compact!; end
  def concat(*_arg0); end
  def count(*_arg0); end
  def cycle(*_arg0); end
  def deconstruct; end
  def delete(_arg0); end
  def delete_at(_arg0); end
  def delete_if; end
  def difference(*_arg0); end
  def dig(*_arg0); end
  def drop(_arg0); end
  def drop_while; end
  def each; end
  def each_index; end
  def empty?; end
  def eql?(_arg0); end
  def fetch(*_arg0); end
  def fill(*_arg0); end
  def filter; end
  def filter!; end
  def find_index(*_arg0); end
  def first(*_arg0); end
  def flatten(*_arg0); end
  def flatten!(*_arg0); end
  def hash; end
  def include?(_arg0); end
  def index(*_arg0); end
  def insert(*_arg0); end
  def inspect; end
  def intersection(*_arg0); end
  def join(*_arg0); end
  def keep_if; end
  def last(*_arg0); end
  def length; end
  def map; end
  def map!; end
  def max(*_arg0); end
  def min(*_arg0); end
  def minmax; end
  def none?(*_arg0); end
  def one?(*_arg0); end
  def pack(fmt, buffer: T.unsafe(nil)); end
  def permutation(*_arg0); end
  def place(*values); end
  def pop(*_arg0); end
  def prepend(*_arg0); end
  def product(*_arg0); end
  def push(*_arg0); end
  def rassoc(_arg0); end
  def reject; end
  def reject!; end
  def repeated_combination(_arg0); end
  def repeated_permutation(_arg0); end
  def replace(_arg0); end
  def reverse; end
  def reverse!; end
  def reverse_each; end
  def rindex(*_arg0); end
  def rotate(*_arg0); end
  def rotate!(*_arg0); end
  def sample(n = T.unsafe(nil), random: T.unsafe(nil)); end
  def select; end
  def select!; end
  def shelljoin; end
  def shift(*_arg0); end
  def shuffle(random: T.unsafe(nil)); end
  def shuffle!(random: T.unsafe(nil)); end
  def size; end
  def slice(*_arg0); end
  def slice!(*_arg0); end
  def sort; end
  def sort!; end
  def sort_by!; end
  def sum(*_arg0); end
  def take(_arg0); end
  def take_while; end
  def to_a; end
  def to_ary; end
  def to_h; end
  def to_s; end
  def transpose; end
  def union(*_arg0); end
  def uniq; end
  def uniq!; end
  def unshift(*_arg0); end
  def values_at(*_arg0); end
  def zip(*_arg0); end
  def |(_arg0); end
  private def initialize_copy(_arg0); end
  def self.[](*_arg0); end
  def self.try_convert(_arg0); end
end

module Enumerable
  def all?(*_arg0); end
  def any?(*_arg0); end
  def chain(*_arg0); end
  def chunk; end
  def chunk_while; end
  def collect; end
  def collect_concat; end
  def count(*_arg0); end
  def cycle(*_arg0); end
  def detect(*_arg0); end
  def drop(_arg0); end
  def drop_while; end
  def each_cons(_arg0); end
  def each_entry(*_arg0); end
  def each_slice(_arg0); end
  def each_with_index(*_arg0); end
  def each_with_object(_arg0); end
  def entries(*_arg0); end
  def filter; end
  def filter_map; end
  def find(*_arg0); end
  def find_all; end
  def find_index(*_arg0); end
  def first(*_arg0); end
  def flat_map; end
  def grep(_arg0); end
  def grep_v(_arg0); end
  def group_by; end
  def include?(_arg0); end
  def inject(*_arg0); end
  def lazy; end
  def map; end
  def max(*_arg0); end
  def max_by(*_arg0); end
  def member?(_arg0); end
  def min(*_arg0); end
  def min_by(*_arg0); end
  def minmax; end
  def minmax_by; end
  def none?(*_arg0); end
  def one?(*_arg0); end
  def partition; end
  def reduce(*_arg0); end
  def reject; end
  def reverse_each(*_arg0); end
  def select; end
  def slice_after(*_arg0); end
  def slice_before(*_arg0); end
  def slice_when; end
  def sort; end
  def sort_by; end
  def sum(*_arg0); end
  def take(_arg0); end
  def take_while; end
  def tally; end
  def to_a(*_arg0); end
  def to_h(*_arg0); end
  def to_set(klass = T.unsafe(nil), *args, &block); end
  def uniq; end
  def zip(*_arg0); end
end

class Exception
  def initialize(*_arg0); end
  def ==(_arg0); end
  def backtrace; end
  def backtrace_locations; end
  def cause; end
  def exception(*_arg0); end
  def full_message(*_arg0); end
  def inspect; end
  def message; end
  def respond_to?(*_arg0); end
  def set_backtrace(_arg0); end
  def to_s; end
  private def method_missing(*_arg0); end
  private def respond_to_missing?(_arg0, _arg1); end
  def self.exception(*_arg0); end
  def self.to_tty?; end
end

module JSON::Ext::Generator::GeneratorMethods::Array
  def to_json(*_arg0); end
end
class GDBM
  include ::Enumerable
  def initialize(*_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def cachesize=(_arg0); end
  def clear; end
  def close; end
  def closed?; end
  def delete(_arg0); end
  def delete_if; end
  def each; end
  def each_key; end
  def each_pair; end
  def each_value; end
  def empty?; end
  def fastmode=(_arg0); end
  def fetch(*_arg0); end
  def has_key?(_arg0); end
  def has_value?(_arg0); end
  def include?(_arg0); end
  def index(_arg0); end
  def invert; end
  def key(_arg0); end
  def key?(_arg0); end
  def keys; end
  def length; end
  def member?(_arg0); end
  def reject; end
  def reject!; end
  def reorganize; end
  def replace(_arg0); end
  def select; end
  def shift; end
  def size; end
  def store(_arg0, _arg1); end
  def sync; end
  def syncmode=(_arg0); end
  def to_a; end
  def to_hash; end
  def update(_arg0); end
  def value?(_arg0); end
  def values; end
  def values_at(*_arg0); end
  def self.open(*_arg0); end
end

class GDBMError < ::StandardError; end
class GDBMFatalError < ::Exception; end
GDBM::FAST = T.let(T.unsafe(nil), Integer)
GDBM::NEWDB = T.let(T.unsafe(nil), Integer)
GDBM::NOLOCK = T.let(T.unsafe(nil), Integer)
GDBM::READER = T.let(T.unsafe(nil), Integer)
GDBM::SYNC = T.let(T.unsafe(nil), Integer)
GDBM::VERSION = T.let(T.unsafe(nil), String)
GDBM::WRCREAT = T.let(T.unsafe(nil), Integer)
GDBM::WRITER = T.let(T.unsafe(nil), Integer)
class StandardError < ::Exception; end

class Exception
  def initialize(*_arg0); end
  def ==(_arg0); end
  def backtrace; end
  def backtrace_locations; end
  def cause; end
  def exception(*_arg0); end
  def full_message(*_arg0); end
  def inspect; end
  def message; end
  def respond_to?(*_arg0); end
  def set_backtrace(_arg0); end
  def to_s; end
  private def method_missing(*_arg0); end
  private def respond_to_missing?(_arg0, _arg1); end
  def self.exception(*_arg0); end
  def self.to_tty?; end
end

module Enumerable
  def all?(*_arg0); end
  def any?(*_arg0); end
  def chain(*_arg0); end
  def chunk; end
  def chunk_while; end
  def collect; end
  def collect_concat; end
  def count(*_arg0); end
  def cycle(*_arg0); end
  def detect(*_arg0); end
  def drop(_arg0); end
  def drop_while; end
  def each_cons(_arg0); end
  def each_entry(*_arg0); end
  def each_slice(_arg0); end
  def each_with_index(*_arg0); end
  def each_with_object(_arg0); end
  def entries(*_arg0); end
  def filter; end
  def filter_map; end
  def find(*_arg0); end
  def find_all; end
  def find_index(*_arg0); end
  def first(*_arg0); end
  def flat_map; end
  def grep(_arg0); end
  def grep_v(_arg0); end
  def group_by; end
  def include?(_arg0); end
  def inject(*_arg0); end
  def lazy; end
  def map; end
  def max(*_arg0); end
  def max_by(*_arg0); end
  def member?(_arg0); end
  def min(*_arg0); end
  def min_by(*_arg0); end
  def minmax; end
  def minmax_by; end
  def none?(*_arg0); end
  def one?(*_arg0); end
  def partition; end
  def reduce(*_arg0); end
  def reject; end
  def reverse_each(*_arg0); end
  def select; end
  def slice_after(*_arg0); end
  def slice_before(*_arg0); end
  def slice_when; end
  def sort; end
  def sort_by; end
  def sum(*_arg0); end
  def take(_arg0); end
  def take_while; end
  def tally; end
  def to_a(*_arg0); end
  def to_h(*_arg0); end
  def to_set(klass = T.unsafe(nil), *args, &block); end
  def uniq; end
  def zip(*_arg0); end
end



module NKF
  private def guess(_arg0); end
  private def nkf(_arg0, _arg1); end
  def self.guess(_arg0); end
  def self.nkf(_arg0, _arg1); end
end

NKF::ASCII = T.let(T.unsafe(nil), Encoding)
NKF::BINARY = T.let(T.unsafe(nil), Encoding)
NKF::EUC = T.let(T.unsafe(nil), Encoding)
NKF::JIS = T.let(T.unsafe(nil), Encoding)
NKF::NKF_RELEASE_DATE = T.let(T.unsafe(nil), String)
NKF::NKF_VERSION = T.let(T.unsafe(nil), String)
NKF::SJIS = T.let(T.unsafe(nil), Encoding)
NKF::UTF16 = T.let(T.unsafe(nil), Encoding)
NKF::UTF32 = T.let(T.unsafe(nil), Encoding)
NKF::UTF8 = T.let(T.unsafe(nil), Encoding)
NKF::VERSION = T.let(T.unsafe(nil), String)


class Pathname
  def initialize(_arg0); end
  def +(other); end
  def /(other); end
  def <=>(_arg0); end
  def ==(_arg0); end
  def ===(_arg0); end
  def absolute?; end
  def ascend; end
  def atime; end
  def basename(*_arg0); end
  def binread(*_arg0); end
  def binwrite(*_arg0); end
  def birthtime; end
  def blockdev?; end
  def chardev?; end
  def children(with_directory = T.unsafe(nil)); end
  def chmod(_arg0); end
  def chown(_arg0, _arg1); end
  def cleanpath(consider_symlink = T.unsafe(nil)); end
  def ctime; end
  def delete; end
  def descend; end
  def directory?; end
  def dirname; end
  def each_child(with_directory = T.unsafe(nil), &b); end
  def each_entry; end
  def each_filename; end
  def each_line(*_arg0); end
  def empty?; end
  def entries; end
  def eql?(_arg0); end
  def executable?; end
  def executable_real?; end
  def exist?; end
  def expand_path(*_arg0); end
  def extname; end
  def file?; end
  def find(ignore_error: T.unsafe(nil)); end
  def fnmatch(*_arg0); end
  def fnmatch?(*_arg0); end
  def freeze; end
  def ftype; end
  def glob(*_arg0); end
  def grpowned?; end
  def hash; end
  def inspect; end
  def join(*args); end
  def lchmod(_arg0); end
  def lchown(_arg0, _arg1); end
  def lstat; end
  def make_link(_arg0); end
  def make_symlink(_arg0); end
  def mkdir(*_arg0); end
  def mkpath; end
  def mountpoint?; end
  def mtime; end
  def open(*_arg0); end
  def opendir; end
  def owned?; end
  def parent; end
  def pipe?; end
  def read(*_arg0); end
  def readable?; end
  def readable_real?; end
  def readlines(*_arg0); end
  def readlink; end
  def realdirpath(*_arg0); end
  def realpath(*_arg0); end
  def relative?; end
  def relative_path_from(base_directory); end
  def rename(_arg0); end
  def rmdir; end
  def rmtree; end
  def root?; end
  def setgid?; end
  def setuid?; end
  def size; end
  def size?; end
  def socket?; end
  def split; end
  def stat; end
  def sticky?; end
  def sub(*_arg0); end
  def sub_ext(_arg0); end
  def symlink?; end
  def sysopen(*_arg0); end
  def taint; end
  def to_path; end
  def to_s; end
  def truncate(_arg0); end
  def unlink; end
  def untaint; end
  def utime(_arg0, _arg1); end
  def world_readable?; end
  def world_writable?; end
  def writable?; end
  def writable_real?; end
  def write(*_arg0); end
  def zero?; end
  private def add_trailing_separator(path); end
  private def chop_basename(path); end
  private def cleanpath_aggressive; end
  private def cleanpath_conservative; end
  private def del_trailing_separator(path); end
  private def has_trailing_separator?(path); end
  private def plus(path1, path2); end
  private def prepend_prefix(prefix, relpath); end
  private def split_names(path); end
  def self.getwd; end
  def self.glob(*_arg0); end
  def self.pwd; end
end

Pathname::SAME_PATHS = T.let(T.unsafe(nil), Proc)
Pathname::SEPARATOR_LIST = T.let(T.unsafe(nil), String)
Pathname::SEPARATOR_PAT = T.let(T.unsafe(nil), Regexp)
Pathname::TO_PATH = T.let(T.unsafe(nil), Symbol)

module PTY
  private def getpty(*_arg0); end
  private def spawn(*_arg0); end
  def self.check(*_arg0); end
  def self.getpty(*_arg0); end
  def self.open; end
  def self.spawn(*_arg0); end
end

class PTY::ChildExited < ::RuntimeError
  def status; end
end

class RuntimeError < ::StandardError; end
class StandardError < ::Exception; end

class Exception
  def initialize(*_arg0); end
  def ==(_arg0); end
  def backtrace; end
  def backtrace_locations; end
  def cause; end
  def exception(*_arg0); end
  def full_message(*_arg0); end
  def inspect; end
  def message; end
  def respond_to?(*_arg0); end
  def set_backtrace(_arg0); end
  def to_s; end
  private def method_missing(*_arg0); end
  private def respond_to_missing?(_arg0, _arg1); end
  def self.exception(*_arg0); end
  def self.to_tty?; end
end


module Readline
  private def readline(*_arg0); end
  def self.basic_quote_characters; end
  def self.basic_quote_characters=(_arg0); end
  def self.basic_word_break_characters; end
  def self.basic_word_break_characters=(_arg0); end
  def self.completer_quote_characters; end
  def self.completer_quote_characters=(_arg0); end
  def self.completer_word_break_characters; end
  def self.completer_word_break_characters=(_arg0); end
  def self.completion_append_character; end
  def self.completion_append_character=(_arg0); end
  def self.completion_case_fold; end
  def self.completion_case_fold=(_arg0); end
  def self.completion_proc; end
  def self.completion_proc=(_arg0); end
  def self.completion_quote_character; end
  def self.delete_text(*_arg0); end
  def self.emacs_editing_mode; end
  def self.emacs_editing_mode?; end
  def self.filename_quote_characters; end
  def self.filename_quote_characters=(_arg0); end
  def self.get_screen_size; end
  def self.input=(_arg0); end
  def self.insert_text(_arg0); end
  def self.line_buffer; end
  def self.output=(_arg0); end
  def self.point; end
  def self.point=(_arg0); end
  def self.pre_input_hook; end
  def self.pre_input_hook=(_arg0); end
  def self.quoting_detection_proc; end
  def self.quoting_detection_proc=(_arg0); end
  def self.readline(*_arg0); end
  def self.redisplay; end
  def self.refresh_line; end
  def self.set_screen_size(_arg0, _arg1); end
  def self.special_prefixes; end
  def self.special_prefixes=(_arg0); end
  def self.vi_editing_mode; end
  def self.vi_editing_mode?; end
end

Readline::FILENAME_COMPLETION_PROC = T.let(T.unsafe(nil), Object)
Readline::HISTORY = T.let(T.unsafe(nil), Object)
Readline::USERNAME_COMPLETION_PROC = T.let(T.unsafe(nil), Object)
Readline::VERSION = T.let(T.unsafe(nil), String)
class Ripper
  def initialize(*_arg0); end
  def column; end
  def debug_output; end
  def debug_output=(_arg0); end
  def encoding; end
  def end_seen?; end
  def error?; end
  def filename; end
  def lineno; end
  def parse; end
  def state; end
  def token; end
  def yydebug; end
  def yydebug=(_arg0); end
  private def _dispatch_0; end
  private def _dispatch_1(a); end
  private def _dispatch_2(a, b); end
  private def _dispatch_3(a, b, c); end
  private def _dispatch_4(a, b, c, d); end
  private def _dispatch_5(a, b, c, d, e); end
  private def _dispatch_6(a, b, c, d, e, f); end
  private def _dispatch_7(a, b, c, d, e, f, g); end
  private def compile_error(msg); end
  private def dedent_string(_arg0, _arg1); end
  private def on_BEGIN(a); end
  private def on_CHAR(a); end
  private def on_END(a); end
  private def on___end__(a); end
  private def on_alias(a, b); end
  private def on_alias_error(a, b); end
  private def on_aref(a, b); end
  private def on_aref_field(a, b); end
  private def on_arg_ambiguous(a); end
  private def on_arg_paren(a); end
  private def on_args_add(a, b); end
  private def on_args_add_block(a, b); end
  private def on_args_add_star(a, b); end
  private def on_args_forward; end
  private def on_args_new; end
  private def on_array(a); end
  private def on_aryptn(a, b, c, d); end
  private def on_assign(a, b); end
  private def on_assign_error(a, b); end
  private def on_assoc_new(a, b); end
  private def on_assoc_splat(a); end
  private def on_assoclist_from_args(a); end
  private def on_backref(a); end
  private def on_backtick(a); end
  private def on_bare_assoc_hash(a); end
  private def on_begin(a); end
  private def on_binary(a, b, c); end
  private def on_block_var(a, b); end
  private def on_blockarg(a); end
  private def on_bodystmt(a, b, c, d); end
  private def on_brace_block(a, b); end
  private def on_break(a); end
  private def on_call(a, b, c); end
  private def on_case(a, b); end
  private def on_class(a, b, c); end
  private def on_class_name_error(a, b); end
  private def on_comma(a); end
  private def on_command(a, b); end
  private def on_command_call(a, b, c, d); end
  private def on_comment(a); end
  private def on_const(a); end
  private def on_const_path_field(a, b); end
  private def on_const_path_ref(a, b); end
  private def on_const_ref(a); end
  private def on_cvar(a); end
  private def on_def(a, b, c); end
  private def on_defined(a); end
  private def on_defs(a, b, c, d, e); end
  private def on_do_block(a, b); end
  private def on_dot2(a, b); end
  private def on_dot3(a, b); end
  private def on_dyna_symbol(a); end
  private def on_else(a); end
  private def on_elsif(a, b, c); end
  private def on_embdoc(a); end
  private def on_embdoc_beg(a); end
  private def on_embdoc_end(a); end
  private def on_embexpr_beg(a); end
  private def on_embexpr_end(a); end
  private def on_embvar(a); end
  private def on_ensure(a); end
  private def on_excessed_comma; end
  private def on_fcall(a); end
  private def on_field(a, b, c); end
  private def on_float(a); end
  private def on_fndptn(a, b, c, d); end
  private def on_for(a, b, c); end
  private def on_gvar(a); end
  private def on_hash(a); end
  private def on_heredoc_beg(a); end
  private def on_heredoc_dedent(a, b); end
  private def on_heredoc_end(a); end
  private def on_hshptn(a, b, c); end
  private def on_ident(a); end
  private def on_if(a, b, c); end
  private def on_if_mod(a, b); end
  private def on_ifop(a, b, c); end
  private def on_ignored_nl(a); end
  private def on_imaginary(a); end
  private def on_in(a, b, c); end
  private def on_int(a); end
  private def on_ivar(a); end
  private def on_kw(a); end
  private def on_kwrest_param(a); end
  private def on_label(a); end
  private def on_label_end(a); end
  private def on_lambda(a, b); end
  private def on_lbrace(a); end
  private def on_lbracket(a); end
  private def on_lparen(a); end
  private def on_magic_comment(a, b); end
  private def on_massign(a, b); end
  private def on_method_add_arg(a, b); end
  private def on_method_add_block(a, b); end
  private def on_mlhs_add(a, b); end
  private def on_mlhs_add_post(a, b); end
  private def on_mlhs_add_star(a, b); end
  private def on_mlhs_new; end
  private def on_mlhs_paren(a); end
  private def on_module(a, b); end
  private def on_mrhs_add(a, b); end
  private def on_mrhs_add_star(a, b); end
  private def on_mrhs_new; end
  private def on_mrhs_new_from_args(a); end
  private def on_next(a); end
  private def on_nl(a); end
  private def on_nokw_param(a); end
  private def on_op(a); end
  private def on_opassign(a, b, c); end
  private def on_operator_ambiguous(a, b); end
  private def on_param_error(a, b); end
  private def on_params(a, b, c, d, e, f, g); end
  private def on_paren(a); end
  private def on_parse_error(a); end
  private def on_period(a); end
  private def on_program(a); end
  private def on_qsymbols_add(a, b); end
  private def on_qsymbols_beg(a); end
  private def on_qsymbols_new; end
  private def on_qwords_add(a, b); end
  private def on_qwords_beg(a); end
  private def on_qwords_new; end
  private def on_rational(a); end
  private def on_rbrace(a); end
  private def on_rbracket(a); end
  private def on_redo; end
  private def on_regexp_add(a, b); end
  private def on_regexp_beg(a); end
  private def on_regexp_end(a); end
  private def on_regexp_literal(a, b); end
  private def on_regexp_new; end
  private def on_rescue(a, b, c, d); end
  private def on_rescue_mod(a, b); end
  private def on_rest_param(a); end
  private def on_retry; end
  private def on_return(a); end
  private def on_return0; end
  private def on_rparen(a); end
  private def on_sclass(a, b); end
  private def on_semicolon(a); end
  private def on_sp(a); end
  private def on_stmts_add(a, b); end
  private def on_stmts_new; end
  private def on_string_add(a, b); end
  private def on_string_concat(a, b); end
  private def on_string_content; end
  private def on_string_dvar(a); end
  private def on_string_embexpr(a); end
  private def on_string_literal(a); end
  private def on_super(a); end
  private def on_symbeg(a); end
  private def on_symbol(a); end
  private def on_symbol_literal(a); end
  private def on_symbols_add(a, b); end
  private def on_symbols_beg(a); end
  private def on_symbols_new; end
  private def on_tlambda(a); end
  private def on_tlambeg(a); end
  private def on_top_const_field(a); end
  private def on_top_const_ref(a); end
  private def on_tstring_beg(a); end
  private def on_tstring_content(a); end
  private def on_tstring_end(a); end
  private def on_unary(a, b); end
  private def on_undef(a); end
  private def on_unless(a, b, c); end
  private def on_unless_mod(a, b); end
  private def on_until(a, b); end
  private def on_until_mod(a, b); end
  private def on_var_alias(a, b); end
  private def on_var_field(a); end
  private def on_var_ref(a); end
  private def on_vcall(a); end
  private def on_void_stmt; end
  private def on_when(a, b, c); end
  private def on_while(a, b); end
  private def on_while_mod(a, b); end
  private def on_word_add(a, b); end
  private def on_word_new; end
  private def on_words_add(a, b); end
  private def on_words_beg(a); end
  private def on_words_new; end
  private def on_words_sep(a); end
  private def on_xstring_add(a, b); end
  private def on_xstring_literal(a); end
  private def on_xstring_new; end
  private def on_yield(a); end
  private def on_yield0; end
  private def on_zsuper; end
  private def warn(fmt, *args); end
  private def warning(fmt, *args); end
  def self.dedent_string(_arg0, _arg1); end
  def self.lex(src, filename = T.unsafe(nil), lineno = T.unsafe(nil), **kw); end
  def self.lex_state_name(_arg0); end
  def self.parse(src, filename = T.unsafe(nil), lineno = T.unsafe(nil)); end
  def self.sexp(src, filename = T.unsafe(nil), lineno = T.unsafe(nil), raise_errors: T.unsafe(nil)); end
  def self.sexp_raw(src, filename = T.unsafe(nil), lineno = T.unsafe(nil), raise_errors: T.unsafe(nil)); end
  def self.slice(src, pattern, n = T.unsafe(nil)); end
  def self.token_match(src, pattern); end
  def self.tokenize(src, filename = T.unsafe(nil), lineno = T.unsafe(nil), **kw); end
end

Ripper::EVENTS = T.let(T.unsafe(nil), Array)
Ripper::EXPR_ARG = T.let(T.unsafe(nil), Integer)
Ripper::EXPR_ARG_ANY = T.let(T.unsafe(nil), Integer)
Ripper::EXPR_BEG = T.let(T.unsafe(nil), Integer)
Ripper::EXPR_BEG_ANY = T.let(T.unsafe(nil), Integer)
Ripper::EXPR_CLASS = T.let(T.unsafe(nil), Integer)
Ripper::EXPR_CMDARG = T.let(T.unsafe(nil), Integer)
Ripper::EXPR_DOT = T.let(T.unsafe(nil), Integer)
Ripper::EXPR_END = T.let(T.unsafe(nil), Integer)
Ripper::EXPR_ENDARG = T.let(T.unsafe(nil), Integer)
Ripper::EXPR_ENDFN = T.let(T.unsafe(nil), Integer)
Ripper::EXPR_END_ANY = T.let(T.unsafe(nil), Integer)
Ripper::EXPR_FITEM = T.let(T.unsafe(nil), Integer)
Ripper::EXPR_FNAME = T.let(T.unsafe(nil), Integer)
Ripper::EXPR_LABEL = T.let(T.unsafe(nil), Integer)
Ripper::EXPR_LABELED = T.let(T.unsafe(nil), Integer)
Ripper::EXPR_MID = T.let(T.unsafe(nil), Integer)
Ripper::EXPR_NONE = T.let(T.unsafe(nil), Integer)
Ripper::EXPR_VALUE = T.let(T.unsafe(nil), Integer)

class Ripper::Filter
  def initialize(src, filename = T.unsafe(nil), lineno = T.unsafe(nil)); end
  def column; end
  def filename; end
  def lineno; end
  def parse(init = T.unsafe(nil)); end
  def state; end
  private def on_default(event, token, data); end
end

class Ripper::Lexer < ::Ripper
  def errors; end
  def lex(**kw); end
  def parse(raise_errors: T.unsafe(nil)); end
  def scan(**kw); end
  def tokenize(**kw); end
  private def _push_token(tok); end
  private def compile_error(mesg); end
  private def on_CHAR(tok); end
  private def on___end__(tok); end
  private def on_alias_error(mesg, elem); end
  private def on_assign_error(mesg, elem); end
  private def on_backref(tok); end
  private def on_backtick(tok); end
  private def on_class_name_error(mesg, elem); end
  private def on_comma(tok); end
  private def on_comment(tok); end
  private def on_const(tok); end
  private def on_cvar(tok); end
  private def on_embdoc(tok); end
  private def on_embdoc_beg(tok); end
  private def on_embdoc_end(tok); end
  private def on_embexpr_beg(tok); end
  private def on_embexpr_end(tok); end
  private def on_embvar(tok); end
  private def on_error1(mesg); end
  private def on_error2(mesg, elem); end
  private def on_float(tok); end
  private def on_gvar(tok); end
  private def on_heredoc_beg(tok); end
  private def on_heredoc_dedent(v, w); end
  private def on_heredoc_end(tok); end
  private def on_ident(tok); end
  private def on_ignored_nl(tok); end
  private def on_ignored_sp(tok); end
  private def on_imaginary(tok); end
  private def on_int(tok); end
  private def on_ivar(tok); end
  private def on_kw(tok); end
  private def on_label(tok); end
  private def on_label_end(tok); end
  private def on_lbrace(tok); end
  private def on_lbracket(tok); end
  private def on_lparen(tok); end
  private def on_nl(tok); end
  private def on_op(tok); end
  private def on_param_error(mesg, elem); end
  private def on_parse_error(mesg); end
  private def on_period(tok); end
  private def on_qsymbols_beg(tok); end
  private def on_qwords_beg(tok); end
  private def on_rational(tok); end
  private def on_rbrace(tok); end
  private def on_rbracket(tok); end
  private def on_regexp_beg(tok); end
  private def on_regexp_end(tok); end
  private def on_rparen(tok); end
  private def on_semicolon(tok); end
  private def on_sp(tok); end
  private def on_symbeg(tok); end
  private def on_symbols_beg(tok); end
  private def on_tlambda(tok); end
  private def on_tlambeg(tok); end
  private def on_tstring_beg(tok); end
  private def on_tstring_content(tok); end
  private def on_tstring_end(tok); end
  private def on_words_beg(tok); end
  private def on_words_sep(tok); end
end

Ripper::PARSER_EVENTS = T.let(T.unsafe(nil), Array)
Ripper::PARSER_EVENT_TABLE = T.let(T.unsafe(nil), Hash)
Ripper::SCANNER_EVENTS = T.let(T.unsafe(nil), Array)
Ripper::SCANNER_EVENT_TABLE = T.let(T.unsafe(nil), Hash)

class Ripper::SexpBuilder < ::Ripper
  def error; end
  def on_BEGIN(*args); end
  def on_CHAR(tok); end
  def on_END(*args); end
  def on___end__(tok); end
  def on_alias(*args); end
  def on_alias_error(*args); end
  def on_aref(*args); end
  def on_aref_field(*args); end
  def on_arg_ambiguous(*args); end
  def on_arg_paren(*args); end
  def on_args_add(*args); end
  def on_args_add_block(*args); end
  def on_args_add_star(*args); end
  def on_args_forward(*args); end
  def on_args_new(*args); end
  def on_array(*args); end
  def on_aryptn(*args); end
  def on_assign(*args); end
  def on_assign_error(*args); end
  def on_assoc_new(*args); end
  def on_assoc_splat(*args); end
  def on_assoclist_from_args(*args); end
  def on_backref(tok); end
  def on_backtick(tok); end
  def on_bare_assoc_hash(*args); end
  def on_begin(*args); end
  def on_binary(*args); end
  def on_block_var(*args); end
  def on_blockarg(*args); end
  def on_bodystmt(*args); end
  def on_brace_block(*args); end
  def on_break(*args); end
  def on_call(*args); end
  def on_case(*args); end
  def on_class(*args); end
  def on_class_name_error(*args); end
  def on_comma(tok); end
  def on_command(*args); end
  def on_command_call(*args); end
  def on_comment(tok); end
  def on_const(tok); end
  def on_const_path_field(*args); end
  def on_const_path_ref(*args); end
  def on_const_ref(*args); end
  def on_cvar(tok); end
  def on_def(*args); end
  def on_defined(*args); end
  def on_defs(*args); end
  def on_do_block(*args); end
  def on_dot2(*args); end
  def on_dot3(*args); end
  def on_dyna_symbol(*args); end
  def on_else(*args); end
  def on_elsif(*args); end
  def on_embdoc(tok); end
  def on_embdoc_beg(tok); end
  def on_embdoc_end(tok); end
  def on_embexpr_beg(tok); end
  def on_embexpr_end(tok); end
  def on_embvar(tok); end
  def on_ensure(*args); end
  def on_excessed_comma(*args); end
  def on_fcall(*args); end
  def on_field(*args); end
  def on_float(tok); end
  def on_fndptn(*args); end
  def on_for(*args); end
  def on_gvar(tok); end
  def on_hash(*args); end
  def on_heredoc_beg(tok); end
  def on_heredoc_end(tok); end
  def on_hshptn(*args); end
  def on_ident(tok); end
  def on_if(*args); end
  def on_if_mod(*args); end
  def on_ifop(*args); end
  def on_ignored_nl(tok); end
  def on_ignored_sp(tok); end
  def on_imaginary(tok); end
  def on_in(*args); end
  def on_int(tok); end
  def on_ivar(tok); end
  def on_kw(tok); end
  def on_kwrest_param(*args); end
  def on_label(tok); end
  def on_label_end(tok); end
  def on_lambda(*args); end
  def on_lbrace(tok); end
  def on_lbracket(tok); end
  def on_lparen(tok); end
  def on_magic_comment(*args); end
  def on_massign(*args); end
  def on_method_add_arg(*args); end
  def on_method_add_block(*args); end
  def on_mlhs_add(*args); end
  def on_mlhs_add_post(*args); end
  def on_mlhs_add_star(*args); end
  def on_mlhs_new(*args); end
  def on_mlhs_paren(*args); end
  def on_module(*args); end
  def on_mrhs_add(*args); end
  def on_mrhs_add_star(*args); end
  def on_mrhs_new(*args); end
  def on_mrhs_new_from_args(*args); end
  def on_next(*args); end
  def on_nl(tok); end
  def on_nokw_param(*args); end
  def on_op(tok); end
  def on_opassign(*args); end
  def on_operator_ambiguous(*args); end
  def on_param_error(*args); end
  def on_params(*args); end
  def on_paren(*args); end
  def on_period(tok); end
  def on_program(*args); end
  def on_qsymbols_add(*args); end
  def on_qsymbols_beg(tok); end
  def on_qsymbols_new(*args); end
  def on_qwords_add(*args); end
  def on_qwords_beg(tok); end
  def on_qwords_new(*args); end
  def on_rational(tok); end
  def on_rbrace(tok); end
  def on_rbracket(tok); end
  def on_redo(*args); end
  def on_regexp_add(*args); end
  def on_regexp_beg(tok); end
  def on_regexp_end(tok); end
  def on_regexp_literal(*args); end
  def on_regexp_new(*args); end
  def on_rescue(*args); end
  def on_rescue_mod(*args); end
  def on_rest_param(*args); end
  def on_retry(*args); end
  def on_return(*args); end
  def on_return0(*args); end
  def on_rparen(tok); end
  def on_sclass(*args); end
  def on_semicolon(tok); end
  def on_sp(tok); end
  def on_stmts_add(*args); end
  def on_stmts_new(*args); end
  def on_string_add(*args); end
  def on_string_concat(*args); end
  def on_string_content(*args); end
  def on_string_dvar(*args); end
  def on_string_embexpr(*args); end
  def on_string_literal(*args); end
  def on_super(*args); end
  def on_symbeg(tok); end
  def on_symbol(*args); end
  def on_symbol_literal(*args); end
  def on_symbols_add(*args); end
  def on_symbols_beg(tok); end
  def on_symbols_new(*args); end
  def on_tlambda(tok); end
  def on_tlambeg(tok); end
  def on_top_const_field(*args); end
  def on_top_const_ref(*args); end
  def on_tstring_beg(tok); end
  def on_tstring_content(tok); end
  def on_tstring_end(tok); end
  def on_unary(*args); end
  def on_undef(*args); end
  def on_unless(*args); end
  def on_unless_mod(*args); end
  def on_until(*args); end
  def on_until_mod(*args); end
  def on_var_alias(*args); end
  def on_var_field(*args); end
  def on_var_ref(*args); end
  def on_vcall(*args); end
  def on_void_stmt(*args); end
  def on_when(*args); end
  def on_while(*args); end
  def on_while_mod(*args); end
  def on_word_add(*args); end
  def on_word_new(*args); end
  def on_words_add(*args); end
  def on_words_beg(tok); end
  def on_words_new(*args); end
  def on_words_sep(tok); end
  def on_xstring_add(*args); end
  def on_xstring_literal(*args); end
  def on_xstring_new(*args); end
  def on_yield(*args); end
  def on_yield0(*args); end
  def on_zsuper(*args); end
  private def compile_error(mesg); end
  private def dedent_element(e, width); end
  private def on_error(mesg); end
  private def on_heredoc_dedent(val, width); end
  private def on_parse_error(mesg); end
end

class Ripper::SexpBuilderPP < ::Ripper::SexpBuilder
  private def _dispatch_event_new; end
  private def _dispatch_event_push(list, item); end
  private def on_args_add(list, item); end
  private def on_args_new; end
  private def on_heredoc_dedent(val, width); end
  private def on_mlhs_add(list, item); end
  private def on_mlhs_add_post(list, post); end
  private def on_mlhs_add_star(list, star); end
  private def on_mlhs_new; end
  private def on_mlhs_paren(list); end
  private def on_mrhs_add(list, item); end
  private def on_mrhs_new; end
  private def on_qsymbols_add(list, item); end
  private def on_qsymbols_new; end
  private def on_qwords_add(list, item); end
  private def on_qwords_new; end
  private def on_regexp_add(list, item); end
  private def on_regexp_new; end
  private def on_stmts_add(list, item); end
  private def on_stmts_new; end
  private def on_string_add(list, item); end
  private def on_symbols_add(list, item); end
  private def on_symbols_new; end
  private def on_word_add(list, item); end
  private def on_word_new; end
  private def on_words_add(list, item); end
  private def on_words_new; end
  private def on_xstring_add(list, item); end
  private def on_xstring_new; end
end

class Ripper::TokenPattern
  def initialize(pattern); end
  def match(str); end
  def match_list(tokens); end
  private def compile(pattern); end
  private def map_token(tok); end
  private def map_tokens(tokens); end
  def self.compile(*_arg0); end
end

Ripper::Version = T.let(T.unsafe(nil), String)

class Ripper::Lexer::Elem < ::Struct
  def initialize(pos, event, tok, state, message = T.unsafe(nil)); end
  def event; end
  def event=(_); end
  def inspect; end
  def message; end
  def message=(_); end
  def pos; end
  def pos=(_); end
  def pretty_print(q); end
  def state; end
  def state=(_); end
  def to_a; end
  def tok; end
  def tok=(_); end
  def self.[](*_arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*_arg0); end
end

class Ripper::Lexer::State < ::Struct
  def initialize(i); end
  def &(i); end
  def ==(i); end
  def allbits?(i); end
  def anybits?(i); end
  def inspect; end
  def nobits?(i); end
  def pretty_print(q); end
  def to_i; end
  def to_int; end
  def to_int=(_); end
  def to_s; end
  def to_s=(_); end
  def |(i); end
  def self.[](*_arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*_arg0); end
end

class Ripper::TokenPattern::CompileError < ::Ripper::TokenPattern::Error; end
class Ripper::TokenPattern::Error < ::StandardError; end
Ripper::TokenPattern::MAP = T.let(T.unsafe(nil), Hash)

class Ripper::TokenPattern::MatchData
  def initialize(tokens, match); end
  def string(n = T.unsafe(nil)); end
  private def match(n = T.unsafe(nil)); end
end

class Ripper::TokenPattern::MatchError < ::Ripper::TokenPattern::Error; end

class Struct
  include ::Enumerable
  def initialize(*_arg0); end
  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def deconstruct; end
  def deconstruct_keys(_arg0); end
  def dig(*_arg0); end
  def each; end
  def each_pair; end
  def eql?(_arg0); end
  def filter(*_arg0); end
  def hash; end
  def inspect; end
  def length; end
  def members; end
  def select(*_arg0); end
  def size; end
  def to_a; end
  def to_h; end
  def to_s; end
  def values; end
  def values_at(*_arg0); end
  private def initialize_copy(_arg0); end
  def self.new(*_arg0); end
end

class StandardError < ::Exception; end
Struct::Group = Etc::Group
Struct::Passwd = Etc::Passwd

class Exception
  def initialize(*_arg0); end
  def ==(_arg0); end
  def backtrace; end
  def backtrace_locations; end
  def cause; end
  def exception(*_arg0); end
  def full_message(*_arg0); end
  def inspect; end
  def message; end
  def respond_to?(*_arg0); end
  def set_backtrace(_arg0); end
  def to_s; end
  private def method_missing(*_arg0); end
  private def respond_to_missing?(_arg0, _arg1); end
  def self.exception(*_arg0); end
  def self.to_tty?; end
end

module Enumerable
  def all?(*_arg0); end
  def any?(*_arg0); end
  def chain(*_arg0); end
  def chunk; end
  def chunk_while; end
  def collect; end
  def collect_concat; end
  def count(*_arg0); end
  def cycle(*_arg0); end
  def detect(*_arg0); end
  def drop(_arg0); end
  def drop_while; end
  def each_cons(_arg0); end
  def each_entry(*_arg0); end
  def each_slice(_arg0); end
  def each_with_index(*_arg0); end
  def each_with_object(_arg0); end
  def entries(*_arg0); end
  def filter; end
  def filter_map; end
  def find(*_arg0); end
  def find_all; end
  def find_index(*_arg0); end
  def first(*_arg0); end
  def flat_map; end
  def grep(_arg0); end
  def grep_v(_arg0); end
  def group_by; end
  def include?(_arg0); end
  def inject(*_arg0); end
  def lazy; end
  def map; end
  def max(*_arg0); end
  def max_by(*_arg0); end
  def member?(_arg0); end
  def min(*_arg0); end
  def min_by(*_arg0); end
  def minmax; end
  def minmax_by; end
  def none?(*_arg0); end
  def one?(*_arg0); end
  def partition; end
  def reduce(*_arg0); end
  def reject; end
  def reverse_each(*_arg0); end
  def select; end
  def slice_after(*_arg0); end
  def slice_before(*_arg0); end
  def slice_when; end
  def sort; end
  def sort_by; end
  def sum(*_arg0); end
  def take(_arg0); end
  def take_while; end
  def tally; end
  def to_a(*_arg0); end
  def to_h(*_arg0); end
  def to_set(klass = T.unsafe(nil), *args, &block); end
  def uniq; end
  def zip(*_arg0); end
end
class UNIXServer < ::UNIXSocket
  def initialize(_arg0); end
  def accept; end
  def accept_nonblock(exception: T.unsafe(nil)); end
  def listen(_arg0); end
  def sysaccept; end
  private def __accept_nonblock(_arg0); end
end

class TCPServer < ::TCPSocket
  def initialize(*_arg0); end
  def accept; end
  def accept_nonblock(exception: T.unsafe(nil)); end
  def listen(_arg0); end
  def sysaccept; end
  private def __accept_nonblock(_arg0); end
end

class TCPSocket < ::IPSocket
  def initialize(*_arg0); end
  def self.gethostbyname(_arg0); end
end

class IPSocket < ::BasicSocket
  def addr(*_arg0); end
  def inspect; end
  def peeraddr(*_arg0); end
  def recvfrom(*_arg0); end
  def self.getaddress(_arg0); end
end

class UNIXSocket < ::BasicSocket
  def initialize(_arg0); end
  def addr; end
  def path; end
  def peeraddr; end
  def recv_io(*_arg0); end
  def recvfrom(*_arg0); end
  def send_io(_arg0); end
  def self.pair(*_arg0); end
  def self.socketpair(*_arg0); end
end

class UDPSocket < ::IPSocket
  def initialize(*_arg0); end
  def bind(_arg0, _arg1); end
  def connect(_arg0, _arg1); end
  def recvfrom_nonblock(len, flag = T.unsafe(nil), outbuf = T.unsafe(nil), exception: T.unsafe(nil)); end
  def send(*_arg0); end
  private def __recvfrom_nonblock(_arg0, _arg1, _arg2, _arg3); end
end

class Addrinfo
  def initialize(*_arg0); end
  def afamily; end
  def bind; end
  def canonname; end
  def connect(timeout: T.unsafe(nil), &block); end
  def connect_from(*args, timeout: T.unsafe(nil), &block); end
  def connect_to(*args, timeout: T.unsafe(nil), &block); end
  def family_addrinfo(*args); end
  def getnameinfo(*_arg0); end
  def inspect; end
  def inspect_sockaddr; end
  def ip?; end
  def ip_address; end
  def ip_port; end
  def ip_unpack; end
  def ipv4?; end
  def ipv4_loopback?; end
  def ipv4_multicast?; end
  def ipv4_private?; end
  def ipv6?; end
  def ipv6_linklocal?; end
  def ipv6_loopback?; end
  def ipv6_mc_global?; end
  def ipv6_mc_linklocal?; end
  def ipv6_mc_nodelocal?; end
  def ipv6_mc_orglocal?; end
  def ipv6_mc_sitelocal?; end
  def ipv6_multicast?; end
  def ipv6_sitelocal?; end
  def ipv6_to_ipv4; end
  def ipv6_unique_local?; end
  def ipv6_unspecified?; end
  def ipv6_v4compat?; end
  def ipv6_v4mapped?; end
  def listen(backlog = T.unsafe(nil)); end
  def marshal_dump; end
  def marshal_load(_arg0); end
  def pfamily; end
  def protocol; end
  def socktype; end
  def to_s; end
  def to_sockaddr; end
  def unix?; end
  def unix_path; end
  protected def connect_internal(local_addrinfo, timeout = T.unsafe(nil)); end
  def self.foreach(nodename, service, family = T.unsafe(nil), socktype = T.unsafe(nil), protocol = T.unsafe(nil), flags = T.unsafe(nil), timeout: T.unsafe(nil), &block); end
  def self.getaddrinfo(*_arg0); end
  def self.ip(_arg0); end
  def self.tcp(_arg0, _arg1); end
  def self.udp(_arg0, _arg1); end
  def self.unix(*_arg0); end
end

class Socket < ::BasicSocket
  def initialize(*_arg0); end
  def accept; end
  def accept_nonblock(exception: T.unsafe(nil)); end
  def bind(_arg0); end
  def connect(_arg0); end
  def connect_nonblock(addr, exception: T.unsafe(nil)); end
  def ipv6only!; end
  def listen(_arg0); end
  def recvfrom(*_arg0); end
  def recvfrom_nonblock(len, flag = T.unsafe(nil), str = T.unsafe(nil), exception: T.unsafe(nil)); end
  def sysaccept; end
  private def __accept_nonblock(_arg0); end
  private def __connect_nonblock(_arg0, _arg1); end
  private def __recvfrom_nonblock(_arg0, _arg1, _arg2, _arg3); end
  def self.accept_loop(*sockets); end
  def self.getaddrinfo(*_arg0); end
  def self.gethostbyaddr(*_arg0); end
  def self.gethostbyname(_arg0); end
  def self.gethostname; end
  def self.getifaddrs; end
  def self.getnameinfo(*_arg0); end
  def self.getservbyname(*_arg0); end
  def self.getservbyport(*_arg0); end
  def self.ip_address_list; end
  def self.pack_sockaddr_in(_arg0, _arg1); end
  def self.pack_sockaddr_un(_arg0); end
  def self.pair(*_arg0); end
  def self.sockaddr_in(_arg0, _arg1); end
  def self.sockaddr_un(_arg0); end
  def self.socketpair(*_arg0); end
  def self.tcp(host, port, local_host = T.unsafe(nil), local_port = T.unsafe(nil), connect_timeout: T.unsafe(nil), resolv_timeout: T.unsafe(nil)); end
  def self.tcp_server_loop(host = T.unsafe(nil), port, &b); end
  def self.tcp_server_sockets(host = T.unsafe(nil), port); end
  def self.udp_server_loop(host = T.unsafe(nil), port, &b); end
  def self.udp_server_loop_on(sockets, &b); end
  def self.udp_server_recv(sockets); end
  def self.udp_server_sockets(host = T.unsafe(nil), port); end
  def self.unix(path); end
  def self.unix_server_loop(path, &b); end
  def self.unix_server_socket(path); end
  def self.unpack_sockaddr_in(_arg0); end
  def self.unpack_sockaddr_un(_arg0); end
  private def self.ip_sockets_port0(ai_list, reuseaddr); end
  private def self.tcp_server_sockets_port0(host); end
  private def self.unix_socket_abstract_name?(path); end
end

class BasicSocket < ::IO
  def close_read; end
  def close_write; end
  def connect_address; end
  def do_not_reverse_lookup; end
  def do_not_reverse_lookup=(_arg0); end
  def getpeereid; end
  def getpeername; end
  def getsockname; end
  def getsockopt(_arg0, _arg1); end
  def local_address; end
  def recv(*_arg0); end
  def recv_nonblock(len, flag = T.unsafe(nil), str = T.unsafe(nil), exception: T.unsafe(nil)); end
  def recvmsg(dlen = T.unsafe(nil), flags = T.unsafe(nil), clen = T.unsafe(nil), scm_rights: T.unsafe(nil)); end
  def recvmsg_nonblock(dlen = T.unsafe(nil), flags = T.unsafe(nil), clen = T.unsafe(nil), scm_rights: T.unsafe(nil), exception: T.unsafe(nil)); end
  def remote_address; end
  def send(*_arg0); end
  def sendmsg(mesg, flags = T.unsafe(nil), dest_sockaddr = T.unsafe(nil), *controls); end
  def sendmsg_nonblock(mesg, flags = T.unsafe(nil), dest_sockaddr = T.unsafe(nil), *controls, exception: T.unsafe(nil)); end
  def setsockopt(*_arg0); end
  def shutdown(*_arg0); end
  private def __recv_nonblock(_arg0, _arg1, _arg2, _arg3); end
  private def __recvmsg(_arg0, _arg1, _arg2, _arg3); end
  private def __recvmsg_nonblock(_arg0, _arg1, _arg2, _arg3, _arg4); end
  private def __sendmsg(_arg0, _arg1, _arg2, _arg3); end
  private def __sendmsg_nonblock(_arg0, _arg1, _arg2, _arg3, _arg4); end
  def self.do_not_reverse_lookup; end
  def self.do_not_reverse_lookup=(_arg0); end
  def self.for_fd(_arg0); end
end

class SocketError < ::StandardError; end
Socket::AF_APPLETALK = T.let(T.unsafe(nil), Integer)
Socket::AF_CCITT = T.let(T.unsafe(nil), Integer)
Socket::AF_CHAOS = T.let(T.unsafe(nil), Integer)
Socket::AF_CNT = T.let(T.unsafe(nil), Integer)
Socket::AF_COIP = T.let(T.unsafe(nil), Integer)
Socket::AF_DATAKIT = T.let(T.unsafe(nil), Integer)
Socket::AF_DLI = T.let(T.unsafe(nil), Integer)
Socket::AF_E164 = T.let(T.unsafe(nil), Integer)
Socket::AF_ECMA = T.let(T.unsafe(nil), Integer)
Socket::AF_HYLINK = T.let(T.unsafe(nil), Integer)
Socket::AF_IMPLINK = T.let(T.unsafe(nil), Integer)
Socket::AF_INET = T.let(T.unsafe(nil), Integer)
Socket::AF_INET6 = T.let(T.unsafe(nil), Integer)
Socket::AF_IPX = T.let(T.unsafe(nil), Integer)
Socket::AF_ISDN = T.let(T.unsafe(nil), Integer)
Socket::AF_ISO = T.let(T.unsafe(nil), Integer)
Socket::AF_LAT = T.let(T.unsafe(nil), Integer)
Socket::AF_LINK = T.let(T.unsafe(nil), Integer)
Socket::AF_LOCAL = T.let(T.unsafe(nil), Integer)
Socket::AF_MAX = T.let(T.unsafe(nil), Integer)
Socket::AF_NATM = T.let(T.unsafe(nil), Integer)
Socket::AF_NDRV = T.let(T.unsafe(nil), Integer)
Socket::AF_NETBIOS = T.let(T.unsafe(nil), Integer)
Socket::AF_NS = T.let(T.unsafe(nil), Integer)
Socket::AF_OSI = T.let(T.unsafe(nil), Integer)
Socket::AF_PPP = T.let(T.unsafe(nil), Integer)
Socket::AF_PUP = T.let(T.unsafe(nil), Integer)
Socket::AF_ROUTE = T.let(T.unsafe(nil), Integer)
Socket::AF_SIP = T.let(T.unsafe(nil), Integer)
Socket::AF_SNA = T.let(T.unsafe(nil), Integer)
Socket::AF_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::AF_UNIX = T.let(T.unsafe(nil), Integer)
Socket::AF_UNSPEC = T.let(T.unsafe(nil), Integer)
Socket::AI_ADDRCONFIG = T.let(T.unsafe(nil), Integer)
Socket::AI_ALL = T.let(T.unsafe(nil), Integer)
Socket::AI_CANONNAME = T.let(T.unsafe(nil), Integer)
Socket::AI_DEFAULT = T.let(T.unsafe(nil), Integer)
Socket::AI_MASK = T.let(T.unsafe(nil), Integer)
Socket::AI_NUMERICHOST = T.let(T.unsafe(nil), Integer)
Socket::AI_NUMERICSERV = T.let(T.unsafe(nil), Integer)
Socket::AI_PASSIVE = T.let(T.unsafe(nil), Integer)
Socket::AI_V4MAPPED = T.let(T.unsafe(nil), Integer)
Socket::AI_V4MAPPED_CFG = T.let(T.unsafe(nil), Integer)

class Socket::AncillaryData
  def initialize(_arg0, _arg1, _arg2, _arg3); end
  def cmsg_is?(_arg0, _arg1); end
  def data; end
  def family; end
  def inspect; end
  def int; end
  def ip_pktinfo; end
  def ipv6_pktinfo; end
  def ipv6_pktinfo_addr; end
  def ipv6_pktinfo_ifindex; end
  def level; end
  def timestamp; end
  def type; end
  def unix_rights; end
  def self.int(_arg0, _arg1, _arg2, _arg3); end
  def self.ip_pktinfo(*_arg0); end
  def self.ipv6_pktinfo(_arg0, _arg1); end
  def self.unix_rights(*_arg0); end
end

module Socket::Constants; end
Socket::EAI_ADDRFAMILY = T.let(T.unsafe(nil), Integer)
Socket::EAI_AGAIN = T.let(T.unsafe(nil), Integer)
Socket::EAI_BADFLAGS = T.let(T.unsafe(nil), Integer)
Socket::EAI_BADHINTS = T.let(T.unsafe(nil), Integer)
Socket::EAI_FAIL = T.let(T.unsafe(nil), Integer)
Socket::EAI_FAMILY = T.let(T.unsafe(nil), Integer)
Socket::EAI_MAX = T.let(T.unsafe(nil), Integer)
Socket::EAI_MEMORY = T.let(T.unsafe(nil), Integer)
Socket::EAI_NODATA = T.let(T.unsafe(nil), Integer)
Socket::EAI_NONAME = T.let(T.unsafe(nil), Integer)
Socket::EAI_OVERFLOW = T.let(T.unsafe(nil), Integer)
Socket::EAI_PROTOCOL = T.let(T.unsafe(nil), Integer)
Socket::EAI_SERVICE = T.let(T.unsafe(nil), Integer)
Socket::EAI_SOCKTYPE = T.let(T.unsafe(nil), Integer)
Socket::EAI_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::IFF_ALLMULTI = T.let(T.unsafe(nil), Integer)
Socket::IFF_ALTPHYS = T.let(T.unsafe(nil), Integer)
Socket::IFF_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::IFF_DEBUG = T.let(T.unsafe(nil), Integer)
Socket::IFF_LINK0 = T.let(T.unsafe(nil), Integer)
Socket::IFF_LINK1 = T.let(T.unsafe(nil), Integer)
Socket::IFF_LINK2 = T.let(T.unsafe(nil), Integer)
Socket::IFF_LOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::IFF_MULTICAST = T.let(T.unsafe(nil), Integer)
Socket::IFF_NOARP = T.let(T.unsafe(nil), Integer)
Socket::IFF_NOTRAILERS = T.let(T.unsafe(nil), Integer)
Socket::IFF_OACTIVE = T.let(T.unsafe(nil), Integer)
Socket::IFF_POINTOPOINT = T.let(T.unsafe(nil), Integer)
Socket::IFF_PROMISC = T.let(T.unsafe(nil), Integer)
Socket::IFF_RUNNING = T.let(T.unsafe(nil), Integer)
Socket::IFF_SIMPLEX = T.let(T.unsafe(nil), Integer)
Socket::IFF_UP = T.let(T.unsafe(nil), Integer)
Socket::IFNAMSIZ = T.let(T.unsafe(nil), Integer)
Socket::IF_NAMESIZE = T.let(T.unsafe(nil), Integer)
Socket::INADDR_ALLHOSTS_GROUP = T.let(T.unsafe(nil), Integer)
Socket::INADDR_ANY = T.let(T.unsafe(nil), Integer)
Socket::INADDR_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::INADDR_LOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::INADDR_MAX_LOCAL_GROUP = T.let(T.unsafe(nil), Integer)
Socket::INADDR_NONE = T.let(T.unsafe(nil), Integer)
Socket::INADDR_UNSPEC_GROUP = T.let(T.unsafe(nil), Integer)
Socket::INET6_ADDRSTRLEN = T.let(T.unsafe(nil), Integer)
Socket::INET_ADDRSTRLEN = T.let(T.unsafe(nil), Integer)
Socket::IPPORT_RESERVED = T.let(T.unsafe(nil), Integer)
Socket::IPPORT_USERRESERVED = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_AH = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_DSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_EGP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_EON = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ESP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_FRAGMENT = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_GGP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_HELLO = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_HOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ICMP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ICMPV6 = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_IDP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_IGMP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_IP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_IPV6 = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_MAX = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ND = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_NONE = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_PUP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_RAW = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ROUTING = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_TCP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_TP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_UDP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_XTP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_CHECKSUM = T.let(T.unsafe(nil), Integer)
Socket::IPV6_DONTFRAG = T.let(T.unsafe(nil), Integer)
Socket::IPV6_DSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_HOPLIMIT = T.let(T.unsafe(nil), Integer)
Socket::IPV6_HOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_JOIN_GROUP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_LEAVE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_MULTICAST_HOPS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_MULTICAST_IF = T.let(T.unsafe(nil), Integer)
Socket::IPV6_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_NEXTHOP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_PATHMTU = T.let(T.unsafe(nil), Integer)
Socket::IPV6_PKTINFO = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVDSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVHOPLIMIT = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVHOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVPATHMTU = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVPKTINFO = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVRTHDR = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVTCLASS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RTHDR = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RTHDRDSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RTHDR_TYPE_0 = T.let(T.unsafe(nil), Integer)
Socket::IPV6_TCLASS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_UNICAST_HOPS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_USE_MIN_MTU = T.let(T.unsafe(nil), Integer)
Socket::IPV6_V6ONLY = T.let(T.unsafe(nil), Integer)
Socket::IP_ADD_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::IP_ADD_SOURCE_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::IP_BLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::IP_DEFAULT_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::IP_DEFAULT_MULTICAST_TTL = T.let(T.unsafe(nil), Integer)
Socket::IP_DONTFRAG = T.let(T.unsafe(nil), Integer)
Socket::IP_DROP_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::IP_DROP_SOURCE_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::IP_HDRINCL = T.let(T.unsafe(nil), Integer)
Socket::IP_IPSEC_POLICY = T.let(T.unsafe(nil), Integer)
Socket::IP_MAX_MEMBERSHIPS = T.let(T.unsafe(nil), Integer)
Socket::IP_MSFILTER = T.let(T.unsafe(nil), Integer)
Socket::IP_MULTICAST_IF = T.let(T.unsafe(nil), Integer)
Socket::IP_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::IP_MULTICAST_TTL = T.let(T.unsafe(nil), Integer)
Socket::IP_OPTIONS = T.let(T.unsafe(nil), Integer)
Socket::IP_PKTINFO = T.let(T.unsafe(nil), Integer)
Socket::IP_PORTRANGE = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVDSTADDR = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVIF = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVOPTS = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVRETOPTS = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVTOS = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVTTL = T.let(T.unsafe(nil), Integer)
Socket::IP_RETOPTS = T.let(T.unsafe(nil), Integer)
Socket::IP_TOS = T.let(T.unsafe(nil), Integer)
Socket::IP_TTL = T.let(T.unsafe(nil), Integer)
Socket::IP_UNBLOCK_SOURCE = T.let(T.unsafe(nil), Integer)

class Socket::Ifaddr
  def addr; end
  def broadaddr; end
  def dstaddr; end
  def flags; end
  def ifindex; end
  def inspect; end
  def name; end
  def netmask; end
end

Socket::LOCAL_PEERCRED = T.let(T.unsafe(nil), Integer)
Socket::MCAST_BLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::MCAST_EXCLUDE = T.let(T.unsafe(nil), Integer)
Socket::MCAST_INCLUDE = T.let(T.unsafe(nil), Integer)
Socket::MCAST_JOIN_GROUP = T.let(T.unsafe(nil), Integer)
Socket::MCAST_JOIN_SOURCE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::MCAST_LEAVE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::MCAST_LEAVE_SOURCE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::MCAST_UNBLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::MSG_CTRUNC = T.let(T.unsafe(nil), Integer)
Socket::MSG_DONTROUTE = T.let(T.unsafe(nil), Integer)
Socket::MSG_DONTWAIT = T.let(T.unsafe(nil), Integer)
Socket::MSG_EOF = T.let(T.unsafe(nil), Integer)
Socket::MSG_EOR = T.let(T.unsafe(nil), Integer)
Socket::MSG_FLUSH = T.let(T.unsafe(nil), Integer)
Socket::MSG_HAVEMORE = T.let(T.unsafe(nil), Integer)
Socket::MSG_HOLD = T.let(T.unsafe(nil), Integer)
Socket::MSG_NOSIGNAL = T.let(T.unsafe(nil), Integer)
Socket::MSG_OOB = T.let(T.unsafe(nil), Integer)
Socket::MSG_PEEK = T.let(T.unsafe(nil), Integer)
Socket::MSG_RCVMORE = T.let(T.unsafe(nil), Integer)
Socket::MSG_SEND = T.let(T.unsafe(nil), Integer)
Socket::MSG_TRUNC = T.let(T.unsafe(nil), Integer)
Socket::MSG_WAITALL = T.let(T.unsafe(nil), Integer)
Socket::NI_DGRAM = T.let(T.unsafe(nil), Integer)
Socket::NI_MAXHOST = T.let(T.unsafe(nil), Integer)
Socket::NI_MAXSERV = T.let(T.unsafe(nil), Integer)
Socket::NI_NAMEREQD = T.let(T.unsafe(nil), Integer)
Socket::NI_NOFQDN = T.let(T.unsafe(nil), Integer)
Socket::NI_NUMERICHOST = T.let(T.unsafe(nil), Integer)
Socket::NI_NUMERICSERV = T.let(T.unsafe(nil), Integer)

class Socket::Option
  def initialize(_arg0, _arg1, _arg2, _arg3); end
  def bool; end
  def byte; end
  def data; end
  def family; end
  def inspect; end
  def int; end
  def ipv4_multicast_loop; end
  def ipv4_multicast_ttl; end
  def level; end
  def linger; end
  def optname; end
  def to_s; end
  def unpack(_arg0); end
  def self.bool(_arg0, _arg1, _arg2, _arg3); end
  def self.byte(_arg0, _arg1, _arg2, _arg3); end
  def self.int(_arg0, _arg1, _arg2, _arg3); end
  def self.ipv4_multicast_loop(_arg0); end
  def self.ipv4_multicast_ttl(_arg0); end
  def self.linger(_arg0, _arg1); end
end

Socket::PF_APPLETALK = T.let(T.unsafe(nil), Integer)
Socket::PF_CCITT = T.let(T.unsafe(nil), Integer)
Socket::PF_CHAOS = T.let(T.unsafe(nil), Integer)
Socket::PF_CNT = T.let(T.unsafe(nil), Integer)
Socket::PF_COIP = T.let(T.unsafe(nil), Integer)
Socket::PF_DATAKIT = T.let(T.unsafe(nil), Integer)
Socket::PF_DLI = T.let(T.unsafe(nil), Integer)
Socket::PF_ECMA = T.let(T.unsafe(nil), Integer)
Socket::PF_HYLINK = T.let(T.unsafe(nil), Integer)
Socket::PF_IMPLINK = T.let(T.unsafe(nil), Integer)
Socket::PF_INET = T.let(T.unsafe(nil), Integer)
Socket::PF_INET6 = T.let(T.unsafe(nil), Integer)
Socket::PF_IPX = T.let(T.unsafe(nil), Integer)
Socket::PF_ISDN = T.let(T.unsafe(nil), Integer)
Socket::PF_ISO = T.let(T.unsafe(nil), Integer)
Socket::PF_KEY = T.let(T.unsafe(nil), Integer)
Socket::PF_LAT = T.let(T.unsafe(nil), Integer)
Socket::PF_LINK = T.let(T.unsafe(nil), Integer)
Socket::PF_LOCAL = T.let(T.unsafe(nil), Integer)
Socket::PF_MAX = T.let(T.unsafe(nil), Integer)
Socket::PF_NATM = T.let(T.unsafe(nil), Integer)
Socket::PF_NDRV = T.let(T.unsafe(nil), Integer)
Socket::PF_NETBIOS = T.let(T.unsafe(nil), Integer)
Socket::PF_NS = T.let(T.unsafe(nil), Integer)
Socket::PF_OSI = T.let(T.unsafe(nil), Integer)
Socket::PF_PIP = T.let(T.unsafe(nil), Integer)
Socket::PF_PPP = T.let(T.unsafe(nil), Integer)
Socket::PF_PUP = T.let(T.unsafe(nil), Integer)
Socket::PF_ROUTE = T.let(T.unsafe(nil), Integer)
Socket::PF_RTIP = T.let(T.unsafe(nil), Integer)
Socket::PF_SIP = T.let(T.unsafe(nil), Integer)
Socket::PF_SNA = T.let(T.unsafe(nil), Integer)
Socket::PF_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::PF_UNIX = T.let(T.unsafe(nil), Integer)
Socket::PF_UNSPEC = T.let(T.unsafe(nil), Integer)
Socket::PF_XTP = T.let(T.unsafe(nil), Integer)
Socket::SCM_CREDS = T.let(T.unsafe(nil), Integer)
Socket::SCM_RIGHTS = T.let(T.unsafe(nil), Integer)
Socket::SCM_TIMESTAMP = T.let(T.unsafe(nil), Integer)
Socket::SHUT_RD = T.let(T.unsafe(nil), Integer)
Socket::SHUT_RDWR = T.let(T.unsafe(nil), Integer)
Socket::SHUT_WR = T.let(T.unsafe(nil), Integer)
Socket::SOCK_DGRAM = T.let(T.unsafe(nil), Integer)
Socket::SOCK_RAW = T.let(T.unsafe(nil), Integer)
Socket::SOCK_RDM = T.let(T.unsafe(nil), Integer)
Socket::SOCK_SEQPACKET = T.let(T.unsafe(nil), Integer)
Socket::SOCK_STREAM = T.let(T.unsafe(nil), Integer)
Socket::SOL_SOCKET = T.let(T.unsafe(nil), Integer)
Socket::SOMAXCONN = T.let(T.unsafe(nil), Integer)
Socket::SO_ACCEPTCONN = T.let(T.unsafe(nil), Integer)
Socket::SO_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::SO_DEBUG = T.let(T.unsafe(nil), Integer)
Socket::SO_DONTROUTE = T.let(T.unsafe(nil), Integer)
Socket::SO_DONTTRUNC = T.let(T.unsafe(nil), Integer)
Socket::SO_ERROR = T.let(T.unsafe(nil), Integer)
Socket::SO_KEEPALIVE = T.let(T.unsafe(nil), Integer)
Socket::SO_LINGER = T.let(T.unsafe(nil), Integer)
Socket::SO_NKE = T.let(T.unsafe(nil), Integer)
Socket::SO_NOSIGPIPE = T.let(T.unsafe(nil), Integer)
Socket::SO_NREAD = T.let(T.unsafe(nil), Integer)
Socket::SO_OOBINLINE = T.let(T.unsafe(nil), Integer)
Socket::SO_RCVBUF = T.let(T.unsafe(nil), Integer)
Socket::SO_RCVLOWAT = T.let(T.unsafe(nil), Integer)
Socket::SO_RCVTIMEO = T.let(T.unsafe(nil), Integer)
Socket::SO_REUSEADDR = T.let(T.unsafe(nil), Integer)
Socket::SO_REUSEPORT = T.let(T.unsafe(nil), Integer)
Socket::SO_SNDBUF = T.let(T.unsafe(nil), Integer)
Socket::SO_SNDLOWAT = T.let(T.unsafe(nil), Integer)
Socket::SO_SNDTIMEO = T.let(T.unsafe(nil), Integer)
Socket::SO_TIMESTAMP = T.let(T.unsafe(nil), Integer)
Socket::SO_TYPE = T.let(T.unsafe(nil), Integer)
Socket::SO_USELOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::SO_WANTMORE = T.let(T.unsafe(nil), Integer)
Socket::SO_WANTOOBFLAG = T.let(T.unsafe(nil), Integer)
Socket::TCP_FASTOPEN = T.let(T.unsafe(nil), Integer)
Socket::TCP_KEEPCNT = T.let(T.unsafe(nil), Integer)
Socket::TCP_KEEPINTVL = T.let(T.unsafe(nil), Integer)
Socket::TCP_MAXSEG = T.let(T.unsafe(nil), Integer)
Socket::TCP_NODELAY = T.let(T.unsafe(nil), Integer)
Socket::TCP_NOOPT = T.let(T.unsafe(nil), Integer)
Socket::TCP_NOPUSH = T.let(T.unsafe(nil), Integer)

class Socket::UDPSource
  def initialize(remote_address, local_address, &reply_proc); end
  def inspect; end
  def local_address; end
  def remote_address; end
  def reply(msg); end
end

class IO
  include ::Enumerable
  include ::File::Constants
  def initialize(*_arg0); end
  def <<(_arg0); end
  def advise(*_arg0); end
  def autoclose=(_arg0); end
  def autoclose?; end
  def beep; end
  def binmode; end
  def binmode?; end
  def check_winsize_changed; end
  def clear_screen; end
  def close; end
  def close_on_exec=(_arg0); end
  def close_on_exec?; end
  def close_read; end
  def close_write; end
  def closed?; end
  def console_mode; end
  def console_mode=(_arg0); end
  def cooked; end
  def cooked!; end
  def cursor; end
  def cursor=(_arg0); end
  def cursor_down(_arg0); end
  def cursor_left(_arg0); end
  def cursor_right(_arg0); end
  def cursor_up(_arg0); end
  def each(*_arg0); end
  def each_byte; end
  def each_char; end
  def each_codepoint; end
  def each_line(*_arg0); end
  def echo=(_arg0); end
  def echo?; end
  def eof; end
  def eof?; end
  def erase_line(_arg0); end
  def erase_screen(_arg0); end
  def external_encoding; end
  def fcntl(*_arg0); end
  def fdatasync; end
  def fileno; end
  def flush; end
  def fsync; end
  def getbyte; end
  def getc; end
  def getch(*_arg0); end
  def getpass(*_arg0); end
  def gets(*_arg0); end
  def goto(_arg0, _arg1); end
  def goto_column(_arg0); end
  def iflush; end
  def inspect; end
  def internal_encoding; end
  def ioctl(*_arg0); end
  def ioflush; end
  def isatty; end
  def lineno; end
  def lineno=(_arg0); end
  def noecho; end
  def nonblock(*_arg0); end
  def nonblock=(_arg0); end
  def nonblock?; end
  def nread; end
  def oflush; end
  def pathconf(_arg0); end
  def pid; end
  def pos; end
  def pos=(_arg0); end
  def pread(*_arg0); end
  def pressed?; end
  def print(*_arg0); end
  def printf(*_arg0); end
  def putc(_arg0); end
  def puts(*_arg0); end
  def pwrite(_arg0, _arg1); end
  def raw(*_arg0); end
  def raw!(*_arg0); end
  def read(*_arg0); end
  def read_nonblock(len, buf = T.unsafe(nil), exception: T.unsafe(nil)); end
  def readbyte; end
  def readchar; end
  def readline(*_arg0); end
  def readlines(*_arg0); end
  def readpartial(*_arg0); end
  def ready?; end
  def reopen(*_arg0); end
  def rewind; end
  def scroll_backward(_arg0); end
  def scroll_forward(_arg0); end
  def seek(*_arg0); end
  def set_encoding(*_arg0); end
  def set_encoding_by_bom; end
  def stat; end
  def sync; end
  def sync=(_arg0); end
  def sysread(*_arg0); end
  def sysseek(*_arg0); end
  def syswrite(_arg0); end
  def tell; end
  def to_i; end
  def to_io; end
  def tty?; end
  def ungetbyte(_arg0); end
  def ungetc(_arg0); end
  def wait(*_arg0); end
  def wait_priority(*_arg0); end
  def wait_readable(*_arg0); end
  def wait_writable(*_arg0); end
  def winsize; end
  def winsize=(_arg0); end
  def write(*_arg0); end
  def write_nonblock(buf, exception: T.unsafe(nil)); end
  private def initialize_copy(_arg0); end
  def self.binread(*_arg0); end
  def self.binwrite(*_arg0); end
  def self.console(*_arg0); end
  def self.copy_stream(*_arg0); end
  def self.for_fd(*_arg0); end
  def self.foreach(*_arg0); end
  def self.new(*_arg0); end
  def self.open(*_arg0); end
  def self.pipe(*_arg0); end
  def self.popen(*_arg0); end
  def self.read(*_arg0); end
  def self.readlines(*_arg0); end
  def self.select(*_arg0); end
  def self.sysopen(*_arg0); end
  def self.try_convert(_arg0); end
  def self.write(*_arg0); end
end

class StandardError < ::Exception; end
Socket::Constants::AF_APPLETALK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_CCITT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_CHAOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_CNT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_COIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_DATAKIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_DLI = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_E164 = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_ECMA = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_HYLINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_IMPLINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_INET = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_INET6 = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_IPX = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_ISDN = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_ISO = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_LAT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_LINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_LOCAL = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_MAX = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_NATM = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_NDRV = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_NETBIOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_NS = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_OSI = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_PPP = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_PUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_ROUTE = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_SIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_SNA = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_UNIX = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_UNSPEC = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_ADDRCONFIG = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_ALL = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_CANONNAME = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_DEFAULT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_MASK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_NUMERICHOST = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_NUMERICSERV = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_PASSIVE = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_V4MAPPED = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_V4MAPPED_CFG = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_ADDRFAMILY = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_AGAIN = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_BADFLAGS = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_BADHINTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_FAIL = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_FAMILY = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_MAX = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_MEMORY = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_NODATA = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_NONAME = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_OVERFLOW = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_PROTOCOL = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_SERVICE = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_SOCKTYPE = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_ALLMULTI = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_ALTPHYS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_DEBUG = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_LINK0 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_LINK1 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_LINK2 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_LOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_MULTICAST = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_NOARP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_NOTRAILERS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_OACTIVE = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_POINTOPOINT = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_PROMISC = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_RUNNING = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_SIMPLEX = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_UP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFNAMSIZ = T.let(T.unsafe(nil), Integer)
Socket::Constants::IF_NAMESIZE = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_ALLHOSTS_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_ANY = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_LOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_MAX_LOCAL_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_NONE = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_UNSPEC_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::INET6_ADDRSTRLEN = T.let(T.unsafe(nil), Integer)
Socket::Constants::INET_ADDRSTRLEN = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPORT_RESERVED = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPORT_USERRESERVED = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_AH = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_DSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_EGP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_EON = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ESP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_FRAGMENT = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_GGP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_HELLO = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_HOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ICMP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ICMPV6 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_IDP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_IGMP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_IP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_IPV6 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_MAX = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ND = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_NONE = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_PUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_RAW = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ROUTING = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_TCP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_TP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_UDP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_XTP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_CHECKSUM = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_DONTFRAG = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_DSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_HOPLIMIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_HOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_JOIN_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_LEAVE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_MULTICAST_HOPS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_MULTICAST_IF = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_NEXTHOP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_PATHMTU = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_PKTINFO = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVDSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVHOPLIMIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVHOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVPATHMTU = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVPKTINFO = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVRTHDR = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVTCLASS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RTHDR = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RTHDRDSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RTHDR_TYPE_0 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_TCLASS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_UNICAST_HOPS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_USE_MIN_MTU = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_V6ONLY = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_ADD_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_ADD_SOURCE_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_BLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DEFAULT_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DEFAULT_MULTICAST_TTL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DONTFRAG = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DROP_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DROP_SOURCE_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_HDRINCL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_IPSEC_POLICY = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MAX_MEMBERSHIPS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MSFILTER = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MULTICAST_IF = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MULTICAST_TTL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_OPTIONS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_PKTINFO = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_PORTRANGE = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVDSTADDR = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVIF = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVRETOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVTOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVTTL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RETOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_TOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_TTL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_UNBLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::Constants::LOCAL_PEERCRED = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_BLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_EXCLUDE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_INCLUDE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_JOIN_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_JOIN_SOURCE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_LEAVE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_LEAVE_SOURCE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_UNBLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_CTRUNC = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_DONTROUTE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_DONTWAIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_EOF = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_EOR = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_FLUSH = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_HAVEMORE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_HOLD = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_NOSIGNAL = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_OOB = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_PEEK = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_RCVMORE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_SEND = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_TRUNC = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_WAITALL = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_DGRAM = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_MAXHOST = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_MAXSERV = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_NAMEREQD = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_NOFQDN = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_NUMERICHOST = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_NUMERICSERV = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_APPLETALK = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_CCITT = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_CHAOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_CNT = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_COIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_DATAKIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_DLI = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_ECMA = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_HYLINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_IMPLINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_INET = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_INET6 = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_IPX = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_ISDN = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_ISO = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_KEY = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_LAT = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_LINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_LOCAL = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_MAX = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_NATM = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_NDRV = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_NETBIOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_NS = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_OSI = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_PIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_PPP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_PUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_ROUTE = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_RTIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_SIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_SNA = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_UNIX = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_UNSPEC = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_XTP = T.let(T.unsafe(nil), Integer)
Socket::Constants::SCM_CREDS = T.let(T.unsafe(nil), Integer)
Socket::Constants::SCM_RIGHTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::SCM_TIMESTAMP = T.let(T.unsafe(nil), Integer)
Socket::Constants::SHUT_RD = T.let(T.unsafe(nil), Integer)
Socket::Constants::SHUT_RDWR = T.let(T.unsafe(nil), Integer)
Socket::Constants::SHUT_WR = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_DGRAM = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_RAW = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_RDM = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_SEQPACKET = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_STREAM = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOL_SOCKET = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOMAXCONN = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_ACCEPTCONN = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_DEBUG = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_DONTROUTE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_DONTTRUNC = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_ERROR = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_KEEPALIVE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_LINGER = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_NKE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_NOSIGPIPE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_NREAD = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_OOBINLINE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_RCVBUF = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_RCVLOWAT = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_RCVTIMEO = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_REUSEADDR = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_REUSEPORT = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_SNDBUF = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_SNDLOWAT = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_SNDTIMEO = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_TIMESTAMP = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_TYPE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_USELOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_WANTMORE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_WANTOOBFLAG = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_FASTOPEN = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_KEEPCNT = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_KEEPINTVL = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_MAXSEG = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_NODELAY = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_NOOPT = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_NOPUSH = T.let(T.unsafe(nil), Integer)

class IO::ConsoleMode
  def echo=(_arg0); end
  def raw(*_arg0); end
  def raw!(*_arg0); end
  private def initialize_copy(_arg0); end
end

class IO::EAGAINWaitReadable < ::Errno::EAGAIN
  include ::IO::WaitReadable
end

class IO::EAGAINWaitWritable < ::Errno::EAGAIN
  include ::IO::WaitWritable
end

class IO::EINPROGRESSWaitReadable < ::Errno::EINPROGRESS
  include ::IO::WaitReadable
end

class IO::EINPROGRESSWaitWritable < ::Errno::EINPROGRESS
  include ::IO::WaitWritable
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable
IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable
IO::PRIORITY = T.let(T.unsafe(nil), Integer)
IO::READABLE = T.let(T.unsafe(nil), Integer)
IO::SEEK_CUR = T.let(T.unsafe(nil), Integer)
IO::SEEK_DATA = T.let(T.unsafe(nil), Integer)
IO::SEEK_END = T.let(T.unsafe(nil), Integer)
IO::SEEK_HOLE = T.let(T.unsafe(nil), Integer)
IO::SEEK_SET = T.let(T.unsafe(nil), Integer)
IO::WRITABLE = T.let(T.unsafe(nil), Integer)
module IO::WaitReadable; end
module IO::WaitWritable; end

class Exception
  def initialize(*_arg0); end
  def ==(_arg0); end
  def backtrace; end
  def backtrace_locations; end
  def cause; end
  def exception(*_arg0); end
  def full_message(*_arg0); end
  def inspect; end
  def message; end
  def respond_to?(*_arg0); end
  def set_backtrace(_arg0); end
  def to_s; end
  private def method_missing(*_arg0); end
  private def respond_to_missing?(_arg0, _arg1); end
  def self.exception(*_arg0); end
  def self.to_tty?; end
end

module Enumerable
  def all?(*_arg0); end
  def any?(*_arg0); end
  def chain(*_arg0); end
  def chunk; end
  def chunk_while; end
  def collect; end
  def collect_concat; end
  def count(*_arg0); end
  def cycle(*_arg0); end
  def detect(*_arg0); end
  def drop(_arg0); end
  def drop_while; end
  def each_cons(_arg0); end
  def each_entry(*_arg0); end
  def each_slice(_arg0); end
  def each_with_index(*_arg0); end
  def each_with_object(_arg0); end
  def entries(*_arg0); end
  def filter; end
  def filter_map; end
  def find(*_arg0); end
  def find_all; end
  def find_index(*_arg0); end
  def first(*_arg0); end
  def flat_map; end
  def grep(_arg0); end
  def grep_v(_arg0); end
  def group_by; end
  def include?(_arg0); end
  def inject(*_arg0); end
  def lazy; end
  def map; end
  def max(*_arg0); end
  def max_by(*_arg0); end
  def member?(_arg0); end
  def min(*_arg0); end
  def min_by(*_arg0); end
  def minmax; end
  def minmax_by; end
  def none?(*_arg0); end
  def one?(*_arg0); end
  def partition; end
  def reduce(*_arg0); end
  def reject; end
  def reverse_each(*_arg0); end
  def select; end
  def slice_after(*_arg0); end
  def slice_before(*_arg0); end
  def slice_when; end
  def sort; end
  def sort_by; end
  def sum(*_arg0); end
  def take(_arg0); end
  def take_while; end
  def tally; end
  def to_a(*_arg0); end
  def to_h(*_arg0); end
  def to_set(klass = T.unsafe(nil), *args, &block); end
  def uniq; end
  def zip(*_arg0); end
end

module File::Constants; end
class Errno::EAGAIN < ::SystemCallError; end
class Errno::EINPROGRESS < ::SystemCallError; end
File::Constants::APPEND = T.let(T.unsafe(nil), Integer)
File::Constants::BINARY = T.let(T.unsafe(nil), Integer)
File::Constants::CREAT = T.let(T.unsafe(nil), Integer)
File::Constants::DSYNC = T.let(T.unsafe(nil), Integer)
File::Constants::EXCL = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_CASEFOLD = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_DOTMATCH = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_EXTGLOB = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_NOESCAPE = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_PATHNAME = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_SHORTNAME = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_SYSCASE = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_EX = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_NB = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_SH = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_UN = T.let(T.unsafe(nil), Integer)
File::Constants::NOCTTY = T.let(T.unsafe(nil), Integer)
File::Constants::NOFOLLOW = T.let(T.unsafe(nil), Integer)
File::Constants::NONBLOCK = T.let(T.unsafe(nil), Integer)
File::Constants::NULL = T.let(T.unsafe(nil), String)
File::Constants::RDONLY = T.let(T.unsafe(nil), Integer)
File::Constants::RDWR = T.let(T.unsafe(nil), Integer)
File::Constants::SHARE_DELETE = T.let(T.unsafe(nil), Integer)
File::Constants::SYNC = T.let(T.unsafe(nil), Integer)
File::Constants::TRUNC = T.let(T.unsafe(nil), Integer)
File::Constants::WRONLY = T.let(T.unsafe(nil), Integer)

class SystemCallError < ::StandardError
  def initialize(*_arg0); end
  def errno; end
  def self.===(_arg0); end
end

Errno::EAGAIN::Errno = T.let(T.unsafe(nil), Integer)
Errno::EINPROGRESS::Errno = T.let(T.unsafe(nil), Integer)
class StringIO
  include ::Enumerable
  def initialize(*_arg0); end
  def binmode; end
  def close; end
  def close_read; end
  def close_write; end
  def closed?; end
  def closed_read?; end
  def closed_write?; end
  def each(*_arg0); end
  def each_byte; end
  def each_char; end
  def each_codepoint; end
  def each_line(*_arg0); end
  def eof; end
  def eof?; end
  def external_encoding; end
  def fcntl(*_arg0); end
  def fileno; end
  def flush; end
  def fsync; end
  def getbyte; end
  def getc; end
  def gets(*_arg0); end
  def internal_encoding; end
  def isatty; end
  def length; end
  def lineno; end
  def lineno=(_arg0); end
  def pid; end
  def pos; end
  def pos=(_arg0); end
  def putc(_arg0); end
  def read(*_arg0); end
  def readlines(*_arg0); end
  def reopen(*_arg0); end
  def rewind; end
  def seek(*_arg0); end
  def set_encoding(*_arg0); end
  def set_encoding_by_bom; end
  def size; end
  def string; end
  def string=(_arg0); end
  def sync; end
  def sync=(_arg0); end
  def tell; end
  def truncate(_arg0); end
  def tty?; end
  def ungetbyte(_arg0); end
  def ungetc(_arg0); end
  def write(*_arg0); end
  private def initialize_copy(_arg0); end
  def self.new(*_arg0); end
  def self.open(*_arg0); end
end

StringIO::VERSION = T.let(T.unsafe(nil), String)

module Enumerable
  def all?(*_arg0); end
  def any?(*_arg0); end
  def chain(*_arg0); end
  def chunk; end
  def chunk_while; end
  def collect; end
  def collect_concat; end
  def count(*_arg0); end
  def cycle(*_arg0); end
  def detect(*_arg0); end
  def drop(_arg0); end
  def drop_while; end
  def each_cons(_arg0); end
  def each_entry(*_arg0); end
  def each_slice(_arg0); end
  def each_with_index(*_arg0); end
  def each_with_object(_arg0); end
  def entries(*_arg0); end
  def filter; end
  def filter_map; end
  def find(*_arg0); end
  def find_all; end
  def find_index(*_arg0); end
  def first(*_arg0); end
  def flat_map; end
  def grep(_arg0); end
  def grep_v(_arg0); end
  def group_by; end
  def include?(_arg0); end
  def inject(*_arg0); end
  def lazy; end
  def map; end
  def max(*_arg0); end
  def max_by(*_arg0); end
  def member?(_arg0); end
  def min(*_arg0); end
  def min_by(*_arg0); end
  def minmax; end
  def minmax_by; end
  def none?(*_arg0); end
  def one?(*_arg0); end
  def partition; end
  def reduce(*_arg0); end
  def reject; end
  def reverse_each(*_arg0); end
  def select; end
  def slice_after(*_arg0); end
  def slice_before(*_arg0); end
  def slice_when; end
  def sort; end
  def sort_by; end
  def sum(*_arg0); end
  def take(_arg0); end
  def take_while; end
  def tally; end
  def to_a(*_arg0); end
  def to_h(*_arg0); end
  def to_set(klass = T.unsafe(nil), *args, &block); end
  def uniq; end
  def zip(*_arg0); end
end
class StringScanner
  def initialize(*_arg0); end
  def <<(_arg0); end
  def [](_arg0); end
  def beginning_of_line?; end
  def bol?; end
  def captures; end
  def charpos; end
  def check(_arg0); end
  def check_until(_arg0); end
  def clear; end
  def concat(_arg0); end
  def empty?; end
  def eos?; end
  def exist?(_arg0); end
  def fixed_anchor?; end
  def get_byte; end
  def getbyte; end
  def getch; end
  def inspect; end
  def match?(_arg0); end
  def matched; end
  def matched?; end
  def matched_size; end
  def peek(_arg0); end
  def peep(_arg0); end
  def pointer; end
  def pointer=(_arg0); end
  def pos; end
  def pos=(_arg0); end
  def post_match; end
  def pre_match; end
  def reset; end
  def rest; end
  def rest?; end
  def rest_size; end
  def restsize; end
  def scan(_arg0); end
  def scan_full(_arg0, _arg1, _arg2); end
  def scan_until(_arg0); end
  def search_full(_arg0, _arg1, _arg2); end
  def size; end
  def skip(_arg0); end
  def skip_until(_arg0); end
  def string; end
  def string=(_arg0); end
  def terminate; end
  def unscan; end
  def values_at(*_arg0); end
  private def initialize_copy(_arg0); end
  def self.must_C_version; end
end

ScanError = StringScanner::Error
class StringScanner::Error < ::StandardError; end
StringScanner::Id = T.let(T.unsafe(nil), String)
StringScanner::Version = T.let(T.unsafe(nil), String)
class StandardError < ::Exception; end

class Exception
  def initialize(*_arg0); end
  def ==(_arg0); end
  def backtrace; end
  def backtrace_locations; end
  def cause; end
  def exception(*_arg0); end
  def full_message(*_arg0); end
  def inspect; end
  def message; end
  def respond_to?(*_arg0); end
  def set_backtrace(_arg0); end
  def to_s; end
  private def method_missing(*_arg0); end
  private def respond_to_missing?(_arg0, _arg1); end
  def self.exception(*_arg0); end
  def self.to_tty?; end
end
module Syslog
  include ::Syslog::Option
  include ::Syslog::Facility
  include ::Syslog::Level
  include ::Syslog::Macros
  include ::Syslog::Constants
  extend ::Syslog::Macros
  private def alert(*_arg0); end
  private def close; end
  private def crit(*_arg0); end
  private def debug(*_arg0); end
  private def emerg(*_arg0); end
  private def err(*_arg0); end
  private def facility; end
  private def ident; end
  private def info(*_arg0); end
  private def instance; end
  private def log(*_arg0); end
  private def mask; end
  private def mask=(_arg0); end
  private def notice(*_arg0); end
  private def open(*_arg0); end
  private def open!(*_arg0); end
  private def opened?; end
  private def options; end
  private def reopen(*_arg0); end
  private def warning(*_arg0); end
  def self.alert(*_arg0); end
  def self.close; end
  def self.crit(*_arg0); end
  def self.debug(*_arg0); end
  def self.emerg(*_arg0); end
  def self.err(*_arg0); end
  def self.facility; end
  def self.ident; end
  def self.info(*_arg0); end
  def self.inspect; end
  def self.instance; end
  def self.log(*_arg0); end
  def self.mask; end
  def self.mask=(_arg0); end
  def self.notice(*_arg0); end
  def self.open(*_arg0); end
  def self.open!(*_arg0); end
  def self.opened?; end
  def self.options; end
  def self.reopen(*_arg0); end
  def self.warning(*_arg0); end
end

class Logger
  include ::Logger::Severity
  def initialize(logdev, shift_age = T.unsafe(nil), shift_size = T.unsafe(nil), level: T.unsafe(nil), progname: T.unsafe(nil), formatter: T.unsafe(nil), datetime_format: T.unsafe(nil), binmode: T.unsafe(nil), shift_period_suffix: T.unsafe(nil)); end
  def <<(msg); end
  def add(severity, message = T.unsafe(nil), progname = T.unsafe(nil)); end
  def close; end
  def datetime_format; end
  def datetime_format=(datetime_format); end
  def debug(progname = T.unsafe(nil), &block); end
  def debug!; end
  def debug?; end
  def error(progname = T.unsafe(nil), &block); end
  def error!; end
  def error?; end
  def fatal(progname = T.unsafe(nil), &block); end
  def fatal!; end
  def fatal?; end
  def formatter; end
  def formatter=(_arg0); end
  def info(progname = T.unsafe(nil), &block); end
  def info!; end
  def info?; end
  def level; end
  def level=(severity); end
  def log(severity, message = T.unsafe(nil), progname = T.unsafe(nil)); end
  def progname; end
  def progname=(_arg0); end
  def reopen(logdev = T.unsafe(nil)); end
  def sev_threshold; end
  def sev_threshold=(severity); end
  def unknown(progname = T.unsafe(nil), &block); end
  def warn(progname = T.unsafe(nil), &block); end
  def warn!; end
  def warn?; end
  private def format_message(severity, datetime, progname, msg); end
  private def format_severity(severity); end
end

module Syslog::Constants
  include ::Syslog::Option
  include ::Syslog::Facility
  include ::Syslog::Level
  include ::Syslog::Macros
  extend ::Syslog::Macros
  mixes_in_class_methods ::Syslog::Macros
  def self.included(_arg0); end
end

module Syslog::Facility; end
module Syslog::Level; end

class Syslog::Logger
  def initialize(program_name = T.unsafe(nil), facility = T.unsafe(nil)); end
  def add(severity, message = T.unsafe(nil), progname = T.unsafe(nil), &block); end
  def debug(message = T.unsafe(nil), &block); end
  def debug?; end
  def error(message = T.unsafe(nil), &block); end
  def error?; end
  def facility; end
  def facility=(_arg0); end
  def fatal(message = T.unsafe(nil), &block); end
  def fatal?; end
  def formatter; end
  def formatter=(_arg0); end
  def info(message = T.unsafe(nil), &block); end
  def info?; end
  def level; end
  def level=(_arg0); end
  def unknown(message = T.unsafe(nil), &block); end
  def unknown?; end
  def warn(message = T.unsafe(nil), &block); end
  def warn?; end
  def self.make_methods(meth); end
  def self.syslog; end
  def self.syslog=(syslog); end
end

module Syslog::Macros
  def LOG_MASK(_arg0); end
  def LOG_UPTO(_arg0); end
  def self.included(_arg0); end
end

module Syslog::Option; end
class Logger::Error < ::RuntimeError; end

class Logger::Formatter
  def initialize; end
  def call(severity, time, progname, msg); end
  def datetime_format; end
  def datetime_format=(_arg0); end
  private def format_datetime(time); end
  private def msg2str(msg); end
end

class Logger::LogDevice
  include ::Logger::Period
  include ::MonitorMixin
  def initialize(log = T.unsafe(nil), shift_age: T.unsafe(nil), shift_size: T.unsafe(nil), shift_period_suffix: T.unsafe(nil), binmode: T.unsafe(nil)); end
  def close; end
  def dev; end
  def filename; end
  def reopen(log = T.unsafe(nil)); end
  def write(message); end
  private def add_log_header(file); end
  private def check_shift_log; end
  private def create_logfile(filename); end
  private def lock_shift_log; end
  private def open_logfile(filename); end
  private def set_dev(log); end
  private def shift_log_age; end
  private def shift_log_period(period_end); end
end

module Logger::Period
  private def next_rotate_time(now, shift_age); end
  private def previous_period_end(now, shift_age); end
  def self.next_rotate_time(now, shift_age); end
  def self.previous_period_end(now, shift_age); end
end

Logger::ProgName = T.let(T.unsafe(nil), String)
Logger::SEV_LABEL = T.let(T.unsafe(nil), Array)
module Logger::Severity; end
class Logger::ShiftingError < ::Logger::Error; end
Logger::VERSION = T.let(T.unsafe(nil), String)
Syslog::Facility::LOG_AUTH = T.let(T.unsafe(nil), Integer)
Syslog::Facility::LOG_AUTHPRIV = T.let(T.unsafe(nil), Integer)
Syslog::Facility::LOG_CRON = T.let(T.unsafe(nil), Integer)
Syslog::Facility::LOG_DAEMON = T.let(T.unsafe(nil), Integer)
Syslog::Facility::LOG_FTP = T.let(T.unsafe(nil), Integer)
Syslog::Facility::LOG_KERN = T.let(T.unsafe(nil), Integer)
Syslog::Facility::LOG_LOCAL0 = T.let(T.unsafe(nil), Integer)
Syslog::Facility::LOG_LOCAL1 = T.let(T.unsafe(nil), Integer)
Syslog::Facility::LOG_LOCAL2 = T.let(T.unsafe(nil), Integer)
Syslog::Facility::LOG_LOCAL3 = T.let(T.unsafe(nil), Integer)
Syslog::Facility::LOG_LOCAL4 = T.let(T.unsafe(nil), Integer)
Syslog::Facility::LOG_LOCAL5 = T.let(T.unsafe(nil), Integer)
Syslog::Facility::LOG_LOCAL6 = T.let(T.unsafe(nil), Integer)
Syslog::Facility::LOG_LOCAL7 = T.let(T.unsafe(nil), Integer)
Syslog::Facility::LOG_LPR = T.let(T.unsafe(nil), Integer)
Syslog::Facility::LOG_MAIL = T.let(T.unsafe(nil), Integer)
Syslog::Facility::LOG_NEWS = T.let(T.unsafe(nil), Integer)
Syslog::Facility::LOG_SYSLOG = T.let(T.unsafe(nil), Integer)
Syslog::Facility::LOG_USER = T.let(T.unsafe(nil), Integer)
Syslog::Facility::LOG_UUCP = T.let(T.unsafe(nil), Integer)
Syslog::Level::LOG_ALERT = T.let(T.unsafe(nil), Integer)
Syslog::Level::LOG_CRIT = T.let(T.unsafe(nil), Integer)
Syslog::Level::LOG_DEBUG = T.let(T.unsafe(nil), Integer)
Syslog::Level::LOG_EMERG = T.let(T.unsafe(nil), Integer)
Syslog::Level::LOG_ERR = T.let(T.unsafe(nil), Integer)
Syslog::Level::LOG_INFO = T.let(T.unsafe(nil), Integer)
Syslog::Level::LOG_NOTICE = T.let(T.unsafe(nil), Integer)
Syslog::Level::LOG_WARNING = T.let(T.unsafe(nil), Integer)

class Syslog::Logger::Formatter
  def call(severity, time, progname, msg); end
  private def clean(message); end
end

Syslog::Logger::LEVEL_MAP = T.let(T.unsafe(nil), Hash)
Syslog::Logger::VERSION = T.let(T.unsafe(nil), String)
Syslog::Option::LOG_CONS = T.let(T.unsafe(nil), Integer)
Syslog::Option::LOG_NDELAY = T.let(T.unsafe(nil), Integer)
Syslog::Option::LOG_NOWAIT = T.let(T.unsafe(nil), Integer)
Syslog::Option::LOG_ODELAY = T.let(T.unsafe(nil), Integer)
Syslog::Option::LOG_PERROR = T.let(T.unsafe(nil), Integer)
Syslog::Option::LOG_PID = T.let(T.unsafe(nil), Integer)
class RuntimeError < ::StandardError; end
Logger::Formatter::Format = T.let(T.unsafe(nil), String)
Logger::Period::SiD = T.let(T.unsafe(nil), Integer)
Logger::Severity::DEBUG = T.let(T.unsafe(nil), Integer)
Logger::Severity::ERROR = T.let(T.unsafe(nil), Integer)
Logger::Severity::FATAL = T.let(T.unsafe(nil), Integer)
Logger::Severity::INFO = T.let(T.unsafe(nil), Integer)
Logger::Severity::UNKNOWN = T.let(T.unsafe(nil), Integer)
Logger::Severity::WARN = T.let(T.unsafe(nil), Integer)

module MonitorMixin
  def initialize(*_arg0, &_arg1); end
  def mon_enter; end
  def mon_exit; end
  def mon_locked?; end
  def mon_owned?; end
  def mon_synchronize(&b); end
  def mon_try_enter; end
  def new_cond; end
  def synchronize(&b); end
  def try_mon_enter; end
  private def mon_check_owner; end
  private def mon_initialize; end
  def self.extend_object(obj); end
end

class StandardError < ::Exception; end

class MonitorMixin::ConditionVariable
  def initialize(monitor); end
  def broadcast; end
  def signal; end
  def wait(timeout = T.unsafe(nil)); end
  def wait_until; end
  def wait_while; end
end

class Exception
  def initialize(*_arg0); end
  def ==(_arg0); end
  def backtrace; end
  def backtrace_locations; end
  def cause; end
  def exception(*_arg0); end
  def full_message(*_arg0); end
  def inspect; end
  def message; end
  def respond_to?(*_arg0); end
  def set_backtrace(_arg0); end
  def to_s; end
  private def method_missing(*_arg0); end
  private def respond_to_missing?(_arg0, _arg1); end
  def self.exception(*_arg0); end
  def self.to_tty?; end
end
module Zlib
  private def adler32(*_arg0); end
  private def adler32_combine(_arg0, _arg1, _arg2); end
  private def crc32(*_arg0); end
  private def crc32_combine(_arg0, _arg1, _arg2); end
  private def crc_table; end
  private def zlib_version; end
  def self.adler32(*_arg0); end
  def self.adler32_combine(_arg0, _arg1, _arg2); end
  def self.crc32(*_arg0); end
  def self.crc32_combine(_arg0, _arg1, _arg2); end
  def self.crc_table; end
  def self.deflate(*_arg0); end
  def self.gunzip(_arg0); end
  def self.gzip(*_arg0); end
  def self.inflate(_arg0); end
  def self.zlib_version; end
end

Zlib::ASCII = T.let(T.unsafe(nil), Integer)
Zlib::BEST_COMPRESSION = T.let(T.unsafe(nil), Integer)
Zlib::BEST_SPEED = T.let(T.unsafe(nil), Integer)
Zlib::BINARY = T.let(T.unsafe(nil), Integer)
class Zlib::BufError < ::Zlib::Error; end
Zlib::DEFAULT_COMPRESSION = T.let(T.unsafe(nil), Integer)
Zlib::DEFAULT_STRATEGY = T.let(T.unsafe(nil), Integer)
Zlib::DEF_MEM_LEVEL = T.let(T.unsafe(nil), Integer)
class Zlib::DataError < ::Zlib::Error; end

class Zlib::Deflate < ::Zlib::ZStream
  def initialize(*_arg0); end
  def <<(_arg0); end
  def deflate(*_arg0); end
  def flush(*_arg0); end
  def params(_arg0, _arg1); end
  def set_dictionary(_arg0); end
  private def initialize_copy(_arg0); end
  def self.deflate(*_arg0); end
end

class Zlib::Error < ::StandardError; end
Zlib::FILTERED = T.let(T.unsafe(nil), Integer)
Zlib::FINISH = T.let(T.unsafe(nil), Integer)
Zlib::FIXED = T.let(T.unsafe(nil), Integer)
Zlib::FULL_FLUSH = T.let(T.unsafe(nil), Integer)

class Zlib::GzipFile
  def close; end
  def closed?; end
  def comment; end
  def crc; end
  def finish; end
  def level; end
  def mtime; end
  def orig_name; end
  def os_code; end
  def sync; end
  def sync=(_arg0); end
  def to_io; end
  def self.wrap(*_arg0); end
end

class Zlib::GzipReader < ::Zlib::GzipFile
  include ::Enumerable
  def initialize(*_arg0); end
  def each(*_arg0); end
  def each_byte; end
  def each_char; end
  def each_line(*_arg0); end
  def eof; end
  def eof?; end
  def external_encoding; end
  def getbyte; end
  def getc; end
  def gets(*_arg0); end
  def lineno; end
  def lineno=(_arg0); end
  def pos; end
  def read(*_arg0); end
  def readbyte; end
  def readchar; end
  def readline(*_arg0); end
  def readlines(*_arg0); end
  def readpartial(*_arg0); end
  def rewind; end
  def tell; end
  def ungetbyte(_arg0); end
  def ungetc(_arg0); end
  def unused; end
  def self.open(*_arg0); end
  def self.zcat(*_arg0); end
end

class Zlib::GzipWriter < ::Zlib::GzipFile
  def initialize(*_arg0); end
  def <<(_arg0); end
  def comment=(_arg0); end
  def flush(*_arg0); end
  def mtime=(_arg0); end
  def orig_name=(_arg0); end
  def pos; end
  def print(*_arg0); end
  def printf(*_arg0); end
  def putc(_arg0); end
  def puts(*_arg0); end
  def tell; end
  def write(*_arg0); end
  def self.open(*_arg0); end
end

Zlib::HUFFMAN_ONLY = T.let(T.unsafe(nil), Integer)

class Zlib::Inflate < ::Zlib::ZStream
  def initialize(*_arg0); end
  def <<(_arg0); end
  def add_dictionary(_arg0); end
  def inflate(*_arg0); end
  def set_dictionary(_arg0); end
  def sync(_arg0); end
  def sync_point?; end
  def self.inflate(_arg0); end
end

Zlib::MAX_MEM_LEVEL = T.let(T.unsafe(nil), Integer)
Zlib::MAX_WBITS = T.let(T.unsafe(nil), Integer)
class Zlib::MemError < ::Zlib::Error; end
Zlib::NO_COMPRESSION = T.let(T.unsafe(nil), Integer)
Zlib::NO_FLUSH = T.let(T.unsafe(nil), Integer)
class Zlib::NeedDict < ::Zlib::Error; end
Zlib::OS_AMIGA = T.let(T.unsafe(nil), Integer)
Zlib::OS_ATARI = T.let(T.unsafe(nil), Integer)
Zlib::OS_CODE = T.let(T.unsafe(nil), Integer)
Zlib::OS_CPM = T.let(T.unsafe(nil), Integer)
Zlib::OS_MACOS = T.let(T.unsafe(nil), Integer)
Zlib::OS_MSDOS = T.let(T.unsafe(nil), Integer)
Zlib::OS_OS2 = T.let(T.unsafe(nil), Integer)
Zlib::OS_QDOS = T.let(T.unsafe(nil), Integer)
Zlib::OS_RISCOS = T.let(T.unsafe(nil), Integer)
Zlib::OS_TOPS20 = T.let(T.unsafe(nil), Integer)
Zlib::OS_UNIX = T.let(T.unsafe(nil), Integer)
Zlib::OS_UNKNOWN = T.let(T.unsafe(nil), Integer)
Zlib::OS_VMCMS = T.let(T.unsafe(nil), Integer)
Zlib::OS_VMS = T.let(T.unsafe(nil), Integer)
Zlib::OS_WIN32 = T.let(T.unsafe(nil), Integer)
Zlib::OS_ZSYSTEM = T.let(T.unsafe(nil), Integer)
Zlib::RLE = T.let(T.unsafe(nil), Integer)
Zlib::SYNC_FLUSH = T.let(T.unsafe(nil), Integer)
class Zlib::StreamEnd < ::Zlib::Error; end
class Zlib::StreamError < ::Zlib::Error; end
Zlib::TEXT = T.let(T.unsafe(nil), Integer)
Zlib::UNKNOWN = T.let(T.unsafe(nil), Integer)
Zlib::VERSION = T.let(T.unsafe(nil), String)
class Zlib::VersionError < ::Zlib::Error; end
Zlib::ZLIB_VERSION = T.let(T.unsafe(nil), String)

class Zlib::ZStream
  def adler; end
  def avail_in; end
  def avail_out; end
  def avail_out=(_arg0); end
  def close; end
  def closed?; end
  def data_type; end
  def end; end
  def ended?; end
  def finish; end
  def finished?; end
  def flush_next_in; end
  def flush_next_out; end
  def reset; end
  def stream_end?; end
  def total_in; end
  def total_out; end
end

class StandardError < ::Exception; end
class Zlib::GzipFile::CRCError < ::Zlib::GzipFile::Error; end

class Zlib::GzipFile::Error < ::Zlib::Error
  def input; end
  def inspect; end
end

class Zlib::GzipFile::LengthError < ::Zlib::GzipFile::Error; end
class Zlib::GzipFile::NoFooter < ::Zlib::GzipFile::Error; end

module Enumerable
  def all?(*_arg0); end
  def any?(*_arg0); end
  def chain(*_arg0); end
  def chunk; end
  def chunk_while; end
  def collect; end
  def collect_concat; end
  def count(*_arg0); end
  def cycle(*_arg0); end
  def detect(*_arg0); end
  def drop(_arg0); end
  def drop_while; end
  def each_cons(_arg0); end
  def each_entry(*_arg0); end
  def each_slice(_arg0); end
  def each_with_index(*_arg0); end
  def each_with_object(_arg0); end
  def entries(*_arg0); end
  def filter; end
  def filter_map; end
  def find(*_arg0); end
  def find_all; end
  def find_index(*_arg0); end
  def first(*_arg0); end
  def flat_map; end
  def grep(_arg0); end
  def grep_v(_arg0); end
  def group_by; end
  def include?(_arg0); end
  def inject(*_arg0); end
  def lazy; end
  def map; end
  def max(*_arg0); end
  def max_by(*_arg0); end
  def member?(_arg0); end
  def min(*_arg0); end
  def min_by(*_arg0); end
  def minmax; end
  def minmax_by; end
  def none?(*_arg0); end
  def one?(*_arg0); end
  def partition; end
  def reduce(*_arg0); end
  def reject; end
  def reverse_each(*_arg0); end
  def select; end
  def slice_after(*_arg0); end
  def slice_before(*_arg0); end
  def slice_when; end
  def sort; end
  def sort_by; end
  def sum(*_arg0); end
  def take(_arg0); end
  def take_while; end
  def tally; end
  def to_a(*_arg0); end
  def to_h(*_arg0); end
  def to_set(klass = T.unsafe(nil), *args, &block); end
  def uniq; end
  def zip(*_arg0); end
end

class Exception
  def initialize(*_arg0); end
  def ==(_arg0); end
  def backtrace; end
  def backtrace_locations; end
  def cause; end
  def exception(*_arg0); end
  def full_message(*_arg0); end
  def inspect; end
  def message; end
  def respond_to?(*_arg0); end
  def set_backtrace(_arg0); end
  def to_s; end
  private def method_missing(*_arg0); end
  private def respond_to_missing?(_arg0, _arg1); end
  def self.exception(*_arg0); end
  def self.to_tty?; end
end

module Abbrev
  private def abbrev(words, pattern = T.unsafe(nil)); end
  def self.abbrev(words, pattern = T.unsafe(nil)); end
end

module Base64
  private def decode64(str); end
  private def encode64(bin); end
  private def strict_decode64(str); end
  private def strict_encode64(bin); end
  private def urlsafe_decode64(str); end
  private def urlsafe_encode64(bin, padding: T.unsafe(nil)); end
  def self.decode64(str); end
  def self.encode64(bin); end
  def self.strict_decode64(str); end
  def self.strict_encode64(bin); end
  def self.urlsafe_decode64(str); end
  def self.urlsafe_encode64(bin, padding: T.unsafe(nil)); end
end
module Benchmark
  private def benchmark(caption = T.unsafe(nil), label_width = T.unsafe(nil), format = T.unsafe(nil), *labels); end
  private def bm(label_width = T.unsafe(nil), *labels, &blk); end
  private def bmbm(width = T.unsafe(nil)); end
  private def measure(label = T.unsafe(nil)); end
  private def realtime; end
  def self.benchmark(caption = T.unsafe(nil), label_width = T.unsafe(nil), format = T.unsafe(nil), *labels); end
  def self.bm(label_width = T.unsafe(nil), *labels, &blk); end
  def self.bmbm(width = T.unsafe(nil)); end
  def self.measure(label = T.unsafe(nil)); end
  def self.realtime; end
end

Benchmark::BENCHMARK_VERSION = T.let(T.unsafe(nil), String)
Benchmark::CAPTION = T.let(T.unsafe(nil), String)
Benchmark::FORMAT = T.let(T.unsafe(nil), String)

class Benchmark::Job
  def initialize(width); end
  def item(label = T.unsafe(nil), &blk); end
  def list; end
  def report(label = T.unsafe(nil), &blk); end
  def width; end
end

class Benchmark::Report
  def initialize(width = T.unsafe(nil), format = T.unsafe(nil)); end
  def item(label = T.unsafe(nil), *format, &blk); end
  def list; end
  def report(label = T.unsafe(nil), *format, &blk); end
end

class Benchmark::Tms
  def initialize(utime = T.unsafe(nil), stime = T.unsafe(nil), cutime = T.unsafe(nil), cstime = T.unsafe(nil), real = T.unsafe(nil), label = T.unsafe(nil)); end
  def *(x); end
  def +(other); end
  def -(other); end
  def /(x); end
  def add(&blk); end
  def add!(&blk); end
  def cstime; end
  def cutime; end
  def format(format = T.unsafe(nil), *args); end
  def label; end
  def real; end
  def stime; end
  def to_a; end
  def to_s; end
  def total; end
  def utime; end
  protected def memberwise(op, x); end
end

Benchmark::VERSION = T.let(T.unsafe(nil), String)
Benchmark::Tms::CAPTION = T.let(T.unsafe(nil), String)
Benchmark::Tms::FORMAT = T.let(T.unsafe(nil), String)


class DateTime < ::Date
  def hour; end
  def iso8601(*_arg0); end
  def jisx0301(*_arg0); end
  def min; end
  def minute; end
  def new_offset(*_arg0); end
  def offset; end
  def rfc3339(*_arg0); end
  def sec; end
  def sec_fraction; end
  def second; end
  def second_fraction; end
  def strftime(*_arg0); end
  def to_date; end
  def to_datetime; end
  def to_s; end
  def to_time; end
  def xmlschema(*_arg0); end
  def zone; end
  def self._strptime(*_arg0); end
  def self.civil(*_arg0); end
  def self.commercial(*_arg0); end
  def self.httpdate(*_arg0); end
  def self.iso8601(*_arg0); end
  def self.jd(*_arg0); end
  def self.jisx0301(*_arg0); end
  def self.new(*_arg0); end
  def self.now(*_arg0); end
  def self.ordinal(*_arg0); end
  def self.parse(*_arg0); end
  def self.rfc2822(*_arg0); end
  def self.rfc3339(*_arg0); end
  def self.rfc822(*_arg0); end
  def self.strptime(*_arg0); end
  def self.xmlschema(*_arg0); end
end

class Date
  include ::Comparable
  def initialize(*_arg0); end
  def +(_arg0); end
  def -(_arg0); end
  def <<(_arg0); end
  def <=>(_arg0); end
  def ===(_arg0); end
  def >>(_arg0); end
  def ajd; end
  def amjd; end
  def asctime; end
  def ctime; end
  def cwday; end
  def cweek; end
  def cwyear; end
  def day; end
  def day_fraction; end
  def downto(_arg0); end
  def england; end
  def eql?(_arg0); end
  def friday?; end
  def gregorian; end
  def gregorian?; end
  def hash; end
  def httpdate; end
  def infinite?; end
  def inspect; end
  def iso8601; end
  def italy; end
  def jd; end
  def jisx0301; end
  def julian; end
  def julian?; end
  def ld; end
  def leap?; end
  def marshal_dump; end
  def marshal_load(_arg0); end
  def mday; end
  def mjd; end
  def mon; end
  def monday?; end
  def month; end
  def new_start(*_arg0); end
  def next; end
  def next_day(*_arg0); end
  def next_month(*_arg0); end
  def next_year(*_arg0); end
  def prev_day(*_arg0); end
  def prev_month(*_arg0); end
  def prev_year(*_arg0); end
  def rfc2822; end
  def rfc3339; end
  def rfc822; end
  def saturday?; end
  def start; end
  def step(*_arg0); end
  def strftime(*_arg0); end
  def succ; end
  def sunday?; end
  def thursday?; end
  def to_date; end
  def to_datetime; end
  def to_s; end
  def to_time; end
  def tuesday?; end
  def upto(_arg0); end
  def wday; end
  def wednesday?; end
  def xmlschema; end
  def yday; end
  def year; end
  private def hour; end
  private def initialize_copy(_arg0); end
  private def min; end
  private def minute; end
  private def sec; end
  private def second; end
  def self._httpdate(_arg0); end
  def self._iso8601(_arg0); end
  def self._jisx0301(_arg0); end
  def self._load(_arg0); end
  def self._parse(*_arg0); end
  def self._rfc2822(_arg0); end
  def self._rfc3339(_arg0); end
  def self._rfc822(_arg0); end
  def self._strptime(*_arg0); end
  def self._xmlschema(_arg0); end
  def self.civil(*_arg0); end
  def self.commercial(*_arg0); end
  def self.gregorian_leap?(_arg0); end
  def self.httpdate(*_arg0); end
  def self.iso8601(*_arg0); end
  def self.jd(*_arg0); end
  def self.jisx0301(*_arg0); end
  def self.julian_leap?(_arg0); end
  def self.leap?(_arg0); end
  def self.ordinal(*_arg0); end
  def self.parse(*_arg0); end
  def self.rfc2822(*_arg0); end
  def self.rfc3339(*_arg0); end
  def self.rfc822(*_arg0); end
  def self.strptime(*_arg0); end
  def self.today(*_arg0); end
  def self.valid_civil?(*_arg0); end
  def self.valid_commercial?(*_arg0); end
  def self.valid_date?(*_arg0); end
  def self.valid_jd?(*_arg0); end
  def self.valid_ordinal?(*_arg0); end
  def self.xmlschema(*_arg0); end
end

Date::ABBR_DAYNAMES = T.let(T.unsafe(nil), Array)
Date::ABBR_MONTHNAMES = T.let(T.unsafe(nil), Array)
Date::DAYNAMES = T.let(T.unsafe(nil), Array)
Date::ENGLAND = T.let(T.unsafe(nil), Integer)
class Date::Error < ::ArgumentError; end
Date::GREGORIAN = T.let(T.unsafe(nil), Float)
Date::ITALY = T.let(T.unsafe(nil), Integer)

class Date::Infinity < ::Numeric
  def initialize(d = T.unsafe(nil)); end
  def +@; end
  def -@; end
  def <=>(other); end
  def abs; end
  def coerce(other); end
  def finite?; end
  def infinite?; end
  def nan?; end
  def to_f; end
  def zero?; end
  protected def d; end
end

Date::JULIAN = T.let(T.unsafe(nil), Float)
Date::MONTHNAMES = T.let(T.unsafe(nil), Array)

module Comparable
  def <(_arg0); end
  def <=(_arg0); end
  def ==(_arg0); end
  def >(_arg0); end
  def >=(_arg0); end
  def between?(_arg0, _arg1); end
  def clamp(*_arg0); end
end

class ArgumentError < ::StandardError; end

class Numeric
  include ::Comparable
  def %(_arg0); end
  def +@; end
  def -@; end
  def <=>(_arg0); end
  def abs; end
  def abs2; end
  def angle; end
  def arg; end
  def ceil(*_arg0); end
  def clone(*_arg0); end
  def coerce(_arg0); end
  def conj; end
  def conjugate; end
  def denominator; end
  def div(_arg0); end
  def divmod(_arg0); end
  def dup; end
  def eql?(_arg0); end
  def fdiv(_arg0); end
  def finite?; end
  def floor(*_arg0); end
  def i; end
  def imag; end
  def imaginary; end
  def infinite?; end
  def integer?; end
  def magnitude; end
  def modulo(_arg0); end
  def negative?; end
  def nonzero?; end
  def numerator; end
  def phase; end
  def polar; end
  def positive?; end
  def quo(_arg0); end
  def real; end
  def real?; end
  def rect; end
  def rectangular; end
  def remainder(_arg0); end
  def round(*_arg0); end
  def singleton_method_added(_arg0); end
  def step(*_arg0); end
  def to_c; end
  def to_int; end
  def truncate(*_arg0); end
  def zero?; end
end

class StandardError < ::Exception; end

class Exception
  def initialize(*_arg0); end
  def ==(_arg0); end
  def backtrace; end
  def backtrace_locations; end
  def cause; end
  def exception(*_arg0); end
  def full_message(*_arg0); end
  def inspect; end
  def message; end
  def respond_to?(*_arg0); end
  def set_backtrace(_arg0); end
  def to_s; end
  private def method_missing(*_arg0); end
  private def respond_to_missing?(_arg0, _arg1); end
  def self.exception(*_arg0); end
  def self.to_tty?; end
end
class Delegator < ::BasicObject
  def initialize(obj); end
  def !; end
  def !=(obj); end
  def ==(obj); end
  def __getobj__; end
  def __setobj__(obj); end
  def eql?(obj); end
  def freeze; end
  def marshal_dump; end
  def marshal_load(data); end
  def method_missing(m, *args, &block); end
  def methods(all = T.unsafe(nil)); end
  def protected_methods(all = T.unsafe(nil)); end
  def public_methods(all = T.unsafe(nil)); end
  private def initialize_clone(obj, freeze: T.unsafe(nil)); end
  private def initialize_dup(obj); end
  private def respond_to_missing?(m, include_private); end
  private def target_respond_to?(target, m, include_private); end
  def self.const_missing(n); end
  def self.delegating_block(mid); end
  def self.public_api; end
end

class SimpleDelegator
  def __getobj__; end
  def __setobj__(obj); end
end

class BasicObject
  def initialize; end
  def !; end
  def !=(_arg0); end
  def ==(_arg0); end
  def __id__; end
  def __send__(*_arg0); end
  def equal?(_arg0); end
  def instance_eval(*_arg0); end
  def instance_exec(*_arg0); end
  private def method_missing(*_arg0); end
  private def singleton_method_added(_arg0); end
  private def singleton_method_removed(_arg0); end
  private def singleton_method_undefined(_arg0); end
end

Delegator::VERSION = T.let(T.unsafe(nil), String)

class Addrinfo
  def initialize(*_arg0); end
  def afamily; end
  def bind; end
  def canonname; end
  def connect(timeout: T.unsafe(nil), &block); end
  def connect_from(*args, timeout: T.unsafe(nil), &block); end
  def connect_to(*args, timeout: T.unsafe(nil), &block); end
  def family_addrinfo(*args); end
  def getnameinfo(*_arg0); end
  def inspect; end
  def inspect_sockaddr; end
  def ip?; end
  def ip_address; end
  def ip_port; end
  def ip_unpack; end
  def ipv4?; end
  def ipv4_loopback?; end
  def ipv4_multicast?; end
  def ipv4_private?; end
  def ipv6?; end
  def ipv6_linklocal?; end
  def ipv6_loopback?; end
  def ipv6_mc_global?; end
  def ipv6_mc_linklocal?; end
  def ipv6_mc_nodelocal?; end
  def ipv6_mc_orglocal?; end
  def ipv6_mc_sitelocal?; end
  def ipv6_multicast?; end
  def ipv6_sitelocal?; end
  def ipv6_to_ipv4; end
  def ipv6_unique_local?; end
  def ipv6_unspecified?; end
  def ipv6_v4compat?; end
  def ipv6_v4mapped?; end
  def listen(backlog = T.unsafe(nil)); end
  def marshal_dump; end
  def marshal_load(_arg0); end
  def pfamily; end
  def protocol; end
  def socktype; end
  def to_s; end
  def to_sockaddr; end
  def unix?; end
  def unix_path; end
  protected def connect_internal(local_addrinfo, timeout = T.unsafe(nil)); end
  def self.foreach(nodename, service, family = T.unsafe(nil), socktype = T.unsafe(nil), protocol = T.unsafe(nil), flags = T.unsafe(nil), timeout: T.unsafe(nil), &block); end
  def self.getaddrinfo(*_arg0); end
  def self.ip(_arg0); end
  def self.tcp(_arg0, _arg1); end
  def self.udp(_arg0, _arg1); end
  def self.unix(*_arg0); end
end

class IPSocket < ::BasicSocket
  def addr(*_arg0); end
  def inspect; end
  def peeraddr(*_arg0); end
  def recvfrom(*_arg0); end
  def self.getaddress(_arg0); end
end

class BasicSocket < ::IO
  def close_read; end
  def close_write; end
  def connect_address; end
  def do_not_reverse_lookup; end
  def do_not_reverse_lookup=(_arg0); end
  def getpeereid; end
  def getpeername; end
  def getsockname; end
  def getsockopt(_arg0, _arg1); end
  def local_address; end
  def recv(*_arg0); end
  def recv_nonblock(len, flag = T.unsafe(nil), str = T.unsafe(nil), exception: T.unsafe(nil)); end
  def recvmsg(dlen = T.unsafe(nil), flags = T.unsafe(nil), clen = T.unsafe(nil), scm_rights: T.unsafe(nil)); end
  def recvmsg_nonblock(dlen = T.unsafe(nil), flags = T.unsafe(nil), clen = T.unsafe(nil), scm_rights: T.unsafe(nil), exception: T.unsafe(nil)); end
  def remote_address; end
  def send(*_arg0); end
  def sendmsg(mesg, flags = T.unsafe(nil), dest_sockaddr = T.unsafe(nil), *controls); end
  def sendmsg_nonblock(mesg, flags = T.unsafe(nil), dest_sockaddr = T.unsafe(nil), *controls, exception: T.unsafe(nil)); end
  def setsockopt(*_arg0); end
  def shutdown(*_arg0); end
  private def __recv_nonblock(_arg0, _arg1, _arg2, _arg3); end
  private def __recvmsg(_arg0, _arg1, _arg2, _arg3); end
  private def __recvmsg_nonblock(_arg0, _arg1, _arg2, _arg3, _arg4); end
  private def __sendmsg(_arg0, _arg1, _arg2, _arg3); end
  private def __sendmsg_nonblock(_arg0, _arg1, _arg2, _arg3, _arg4); end
  def self.do_not_reverse_lookup; end
  def self.do_not_reverse_lookup=(_arg0); end
  def self.for_fd(_arg0); end
end

module Observable
  def add_observer(observer, func = T.unsafe(nil)); end
  def changed(state = T.unsafe(nil)); end
  def changed?; end
  def count_observers; end
  def delete_observer(observer); end
  def delete_observers; end
  def notify_observers(*arg); end
end

class SocketError < ::StandardError; end

module OpenSSL
  private def Digest(name); end
  private def debug; end
  private def debug=(_arg0); end
  private def errors; end
  private def fips_mode; end
  private def fips_mode=(_arg0); end
  def self.Digest(name); end
  def self.debug; end
  def self.debug=(_arg0); end
  def self.errors; end
  def self.fips_mode; end
  def self.fips_mode=(_arg0); end
  def self.fixed_length_secure_compare(_arg0, _arg1); end
  def self.secure_compare(a, b); end
end

module Singleton
  mixes_in_class_methods ::Singleton::SingletonClassMethods
  def _dump(depth = T.unsafe(nil)); end
  def clone; end
  def dup; end
  def self.__init__(klass); end
  private def self.append_features(mod); end
  private def self.included(klass); end
end

module Etc
  private def confstr(_arg0); end
  private def endgrent; end
  private def endpwent; end
  private def getgrent; end
  private def getgrgid(*_arg0); end
  private def getgrnam(_arg0); end
  private def getlogin; end
  private def getpwent; end
  private def getpwnam(_arg0); end
  private def getpwuid(*_arg0); end
  private def group; end
  private def nprocessors; end
  private def passwd; end
  private def setgrent; end
  private def setpwent; end
  private def sysconf(_arg0); end
  private def sysconfdir; end
  private def systmpdir; end
  private def uname; end
  def self.confstr(_arg0); end
  def self.endgrent; end
  def self.endpwent; end
  def self.getgrent; end
  def self.getgrgid(*_arg0); end
  def self.getgrnam(_arg0); end
  def self.getlogin; end
  def self.getpwent; end
  def self.getpwnam(_arg0); end
  def self.getpwuid(*_arg0); end
  def self.group; end
  def self.nprocessors; end
  def self.passwd; end
  def self.setgrent; end
  def self.setpwent; end
  def self.sysconf(_arg0); end
  def self.sysconfdir; end
  def self.systmpdir; end
  def self.uname; end
end

module FileUtils
  include ::FileUtils::StreamUtils_
  extend ::FileUtils::StreamUtils_
  private def apply_mask(mode, user_mask, op, mode_mask); end
  private def cd(dir, verbose: T.unsafe(nil), &block); end
  private def chdir(dir, verbose: T.unsafe(nil), &block); end
  private def chmod(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def chmod_R(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end
  private def chown(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def chown_R(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end
  private def cmp(a, b); end
  private def compare_file(a, b); end
  private def compare_stream(a, b); end
  private def copy(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def copy_entry(src, dest, preserve = T.unsafe(nil), dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end
  private def copy_file(src, dest, preserve = T.unsafe(nil), dereference = T.unsafe(nil)); end
  private def copy_stream(src, dest); end
  private def cp(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end
  private def cp_r(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end
  private def fu_each_src_dest(src, dest); end
  private def fu_each_src_dest0(src, dest); end
  private def fu_get_gid(group); end
  private def fu_get_uid(user); end
  private def fu_have_symlink?; end
  private def fu_list(arg); end
  private def fu_mkdir(path, mode); end
  private def fu_mode(mode, path); end
  private def fu_output_message(msg); end
  private def fu_same?(a, b); end
  private def fu_stat_identical_entry?(a, b); end
  private def getwd; end
  private def identical?(a, b); end
  private def install(src, dest, mode: T.unsafe(nil), owner: T.unsafe(nil), group: T.unsafe(nil), preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def link(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def link_entry(src, dest, dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end
  private def ln(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def ln_s(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def ln_sf(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def makedirs(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def mkdir(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def mkdir_p(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def mkpath(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def mode_to_s(mode); end
  private def move(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def mv(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def pwd; end
  private def remove(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def remove_dir(path, force = T.unsafe(nil)); end
  private def remove_entry(path, force = T.unsafe(nil)); end
  private def remove_entry_secure(path, force = T.unsafe(nil)); end
  private def remove_file(path, force = T.unsafe(nil)); end
  private def remove_trailing_slash(dir); end
  private def rm(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def rm_f(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def rm_r(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def rm_rf(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def rmdir(list, parents: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def rmtree(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def safe_unlink(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def symbolic_modes_to_i(mode_sym, path); end
  private def symlink(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def touch(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), mtime: T.unsafe(nil), nocreate: T.unsafe(nil)); end
  private def uptodate?(new, old_list); end
  private def user_mask(target); end
  def self.cd(dir, verbose: T.unsafe(nil), &block); end
  def self.chdir(dir, verbose: T.unsafe(nil), &block); end
  def self.chmod(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.chmod_R(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end
  def self.chown(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.chown_R(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end
  def self.cmp(a, b); end
  def self.collect_method(opt); end
  def self.commands; end
  def self.compare_file(a, b); end
  def self.compare_stream(a, b); end
  def self.copy(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.copy_entry(src, dest, preserve = T.unsafe(nil), dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end
  def self.copy_file(src, dest, preserve = T.unsafe(nil), dereference = T.unsafe(nil)); end
  def self.copy_stream(src, dest); end
  def self.cp(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end
  def self.cp_r(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end
  def self.getwd; end
  def self.have_option?(mid, opt); end
  def self.identical?(a, b); end
  def self.install(src, dest, mode: T.unsafe(nil), owner: T.unsafe(nil), group: T.unsafe(nil), preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.link(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.link_entry(src, dest, dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end
  def self.ln(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.ln_s(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.ln_sf(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.makedirs(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.mkdir(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.mkdir_p(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.mkpath(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.move(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.mv(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.options; end
  def self.options_of(mid); end
  def self.private_module_function(name); end
  def self.pwd; end
  def self.remove(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.remove_dir(path, force = T.unsafe(nil)); end
  def self.remove_entry(path, force = T.unsafe(nil)); end
  def self.remove_entry_secure(path, force = T.unsafe(nil)); end
  def self.remove_file(path, force = T.unsafe(nil)); end
  def self.rm(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.rm_f(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.rm_r(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.rm_rf(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.rmdir(list, parents: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.rmtree(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.safe_unlink(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.symlink(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.touch(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), mtime: T.unsafe(nil), nocreate: T.unsafe(nil)); end
  def self.uptodate?(new, old_list); end
  private def self.apply_mask(mode, user_mask, op, mode_mask); end
  private def self.fu_each_src_dest(src, dest); end
  private def self.fu_each_src_dest0(src, dest); end
  private def self.fu_get_gid(group); end
  private def self.fu_get_uid(user); end
  private def self.fu_have_symlink?; end
  private def self.fu_list(arg); end
  private def self.fu_mkdir(path, mode); end
  private def self.fu_mode(mode, path); end
  private def self.fu_output_message(msg); end
  private def self.fu_same?(a, b); end
  private def self.fu_stat_identical_entry?(a, b); end
  private def self.mode_to_s(mode); end
  private def self.remove_trailing_slash(dir); end
  private def self.symbolic_modes_to_i(mode_sym, path); end
  private def self.user_mask(target); end
end

module DRb
  private def config; end
  private def current_server; end
  private def fetch_server(uri); end
  private def front; end
  private def here?(uri); end
  private def install_acl(acl); end
  private def install_id_conv(idconv); end
  private def mutex; end
  private def primary_server; end
  private def primary_server=(_arg0); end
  private def regist_server(server); end
  private def remove_server(server); end
  private def start_service(uri = T.unsafe(nil), front = T.unsafe(nil), config = T.unsafe(nil)); end
  private def stop_service; end
  private def thread; end
  private def to_id(obj); end
  private def to_obj(ref); end
  private def uri; end
  def self.config; end
  def self.current_server; end
  def self.fetch_server(uri); end
  def self.front; end
  def self.here?(uri); end
  def self.install_acl(acl); end
  def self.install_id_conv(idconv); end
  def self.mutex; end
  def self.primary_server; end
  def self.primary_server=(_arg0); end
  def self.regist_server(server); end
  def self.remove_server(server); end
  def self.start_service(uri = T.unsafe(nil), front = T.unsafe(nil), config = T.unsafe(nil)); end
  def self.stop_service; end
  def self.thread; end
  def self.to_id(obj); end
  def self.to_obj(ref); end
  def self.uri; end
end

DRbIdConv = DRb::DRbIdConv
DRbUndumped = DRb::DRbUndumped
DRbObject = DRb::DRbObject

module Digest
  private def hexencode(_arg0); end
  def self.const_missing(name); end
  def self.hexencode(_arg0); end
end

class UDPSocket < ::IPSocket
  def initialize(*_arg0); end
  def bind(_arg0, _arg1); end
  def connect(_arg0, _arg1); end
  def recvfrom_nonblock(len, flag = T.unsafe(nil), outbuf = T.unsafe(nil), exception: T.unsafe(nil)); end
  def send(*_arg0); end
  private def __recvfrom_nonblock(_arg0, _arg1, _arg2, _arg3); end
end

class TCPServer < ::TCPSocket
  def initialize(*_arg0); end
  def accept; end
  def accept_nonblock(exception: T.unsafe(nil)); end
  def listen(_arg0); end
  def sysaccept; end
  private def __accept_nonblock(_arg0); end
end

class TCPSocket < ::IPSocket
  def initialize(*_arg0); end
  def self.gethostbyname(_arg0); end
end

class UNIXServer < ::UNIXSocket
  def initialize(_arg0); end
  def accept; end
  def accept_nonblock(exception: T.unsafe(nil)); end
  def listen(_arg0); end
  def sysaccept; end
  private def __accept_nonblock(_arg0); end
end

class UNIXSocket < ::BasicSocket
  def initialize(_arg0); end
  def addr; end
  def path; end
  def peeraddr; end
  def recv_io(*_arg0); end
  def recvfrom(*_arg0); end
  def send_io(_arg0); end
  def self.pair(*_arg0); end
  def self.socketpair(*_arg0); end
end

class ACL
  def initialize(list = T.unsafe(nil), order = T.unsafe(nil)); end
  def allow_addr?(addr); end
  def allow_socket?(soc); end
  def install_list(list); end
end

class IPAddr
  include ::Comparable
  def initialize(addr = T.unsafe(nil), family = T.unsafe(nil)); end
  def &(other); end
  def <<(num); end
  def <=>(other); end
  def ==(other); end
  def ===(other); end
  def >>(num); end
  def eql?(other); end
  def family; end
  def hash; end
  def hton; end
  def include?(other); end
  def inspect; end
  def ip6_arpa; end
  def ip6_int; end
  def ipv4?; end
  def ipv4_compat; end
  def ipv4_compat?; end
  def ipv4_mapped; end
  def ipv4_mapped?; end
  def ipv6?; end
  def link_local?; end
  def loopback?; end
  def mask(prefixlen); end
  def native; end
  def prefix; end
  def prefix=(prefix); end
  def private?; end
  def reverse; end
  def succ; end
  def to_i; end
  def to_range; end
  def to_s; end
  def to_string; end
  def |(other); end
  def ~; end
  protected def mask!(mask); end
  protected def set(addr, *family); end
  private def _ipv4_compat?; end
  private def _reverse; end
  private def _to_string(addr); end
  private def addr_mask(addr); end
  private def coerce_other(other); end
  private def in6_addr(left); end
  private def in_addr(addr); end
  def self.new_ntoh(addr); end
  def self.ntop(addr); end
end

class StringIO
  include ::Enumerable
  def initialize(*_arg0); end
  def binmode; end
  def close; end
  def close_read; end
  def close_write; end
  def closed?; end
  def closed_read?; end
  def closed_write?; end
  def each(*_arg0); end
  def each_byte; end
  def each_char; end
  def each_codepoint; end
  def each_line(*_arg0); end
  def eof; end
  def eof?; end
  def external_encoding; end
  def fcntl(*_arg0); end
  def fileno; end
  def flush; end
  def fsync; end
  def getbyte; end
  def getc; end
  def gets(*_arg0); end
  def internal_encoding; end
  def isatty; end
  def length; end
  def lineno; end
  def lineno=(_arg0); end
  def pid; end
  def pos; end
  def pos=(_arg0); end
  def putc(_arg0); end
  def read(*_arg0); end
  def readlines(*_arg0); end
  def reopen(*_arg0); end
  def rewind; end
  def seek(*_arg0); end
  def set_encoding(*_arg0); end
  def set_encoding_by_bom; end
  def size; end
  def string; end
  def string=(_arg0); end
  def sync; end
  def sync=(_arg0); end
  def tell; end
  def truncate(_arg0); end
  def tty?; end
  def ungetbyte(_arg0); end
  def ungetc(_arg0); end
  def write(*_arg0); end
  private def initialize_copy(_arg0); end
  def self.new(*_arg0); end
  def self.open(*_arg0); end
end

class Socket < ::BasicSocket
  def initialize(*_arg0); end
  def accept; end
  def accept_nonblock(exception: T.unsafe(nil)); end
  def bind(_arg0); end
  def connect(_arg0); end
  def connect_nonblock(addr, exception: T.unsafe(nil)); end
  def ipv6only!; end
  def listen(_arg0); end
  def recvfrom(*_arg0); end
  def recvfrom_nonblock(len, flag = T.unsafe(nil), str = T.unsafe(nil), exception: T.unsafe(nil)); end
  def sysaccept; end
  private def __accept_nonblock(_arg0); end
  private def __connect_nonblock(_arg0, _arg1); end
  private def __recvfrom_nonblock(_arg0, _arg1, _arg2, _arg3); end
  def self.accept_loop(*sockets); end
  def self.getaddrinfo(*_arg0); end
  def self.gethostbyaddr(*_arg0); end
  def self.gethostbyname(_arg0); end
  def self.gethostname; end
  def self.getifaddrs; end
  def self.getnameinfo(*_arg0); end
  def self.getservbyname(*_arg0); end
  def self.getservbyport(*_arg0); end
  def self.ip_address_list; end
  def self.pack_sockaddr_in(_arg0, _arg1); end
  def self.pack_sockaddr_un(_arg0); end
  def self.pair(*_arg0); end
  def self.sockaddr_in(_arg0, _arg1); end
  def self.sockaddr_un(_arg0); end
  def self.socketpair(*_arg0); end
  def self.tcp(host, port, local_host = T.unsafe(nil), local_port = T.unsafe(nil), connect_timeout: T.unsafe(nil), resolv_timeout: T.unsafe(nil)); end
  def self.tcp_server_loop(host = T.unsafe(nil), port, &b); end
  def self.tcp_server_sockets(host = T.unsafe(nil), port); end
  def self.udp_server_loop(host = T.unsafe(nil), port, &b); end
  def self.udp_server_loop_on(sockets, &b); end
  def self.udp_server_recv(sockets); end
  def self.udp_server_sockets(host = T.unsafe(nil), port); end
  def self.unix(path); end
  def self.unix_server_loop(path, &b); end
  def self.unix_server_socket(path); end
  def self.unpack_sockaddr_in(_arg0); end
  def self.unpack_sockaddr_un(_arg0); end
  private def self.ip_sockets_port0(ai_list, reuseaddr); end
  private def self.tcp_server_sockets_port0(host); end
  private def self.unix_socket_abstract_name?(path); end
end

class IO
  include ::Enumerable
  include ::File::Constants
  def initialize(*_arg0); end
  def <<(_arg0); end
  def advise(*_arg0); end
  def autoclose=(_arg0); end
  def autoclose?; end
  def beep; end
  def binmode; end
  def binmode?; end
  def check_winsize_changed; end
  def clear_screen; end
  def close; end
  def close_on_exec=(_arg0); end
  def close_on_exec?; end
  def close_read; end
  def close_write; end
  def closed?; end
  def console_mode; end
  def console_mode=(_arg0); end
  def cooked; end
  def cooked!; end
  def cursor; end
  def cursor=(_arg0); end
  def cursor_down(_arg0); end
  def cursor_left(_arg0); end
  def cursor_right(_arg0); end
  def cursor_up(_arg0); end
  def each(*_arg0); end
  def each_byte; end
  def each_char; end
  def each_codepoint; end
  def each_line(*_arg0); end
  def echo=(_arg0); end
  def echo?; end
  def eof; end
  def eof?; end
  def erase_line(_arg0); end
  def erase_screen(_arg0); end
  def external_encoding; end
  def fcntl(*_arg0); end
  def fdatasync; end
  def fileno; end
  def flush; end
  def fsync; end
  def getbyte; end
  def getc; end
  def getch(*_arg0); end
  def getpass(*_arg0); end
  def gets(*_arg0); end
  def goto(_arg0, _arg1); end
  def goto_column(_arg0); end
  def iflush; end
  def inspect; end
  def internal_encoding; end
  def ioctl(*_arg0); end
  def ioflush; end
  def isatty; end
  def lineno; end
  def lineno=(_arg0); end
  def noecho; end
  def nonblock(*_arg0); end
  def nonblock=(_arg0); end
  def nonblock?; end
  def nread; end
  def oflush; end
  def pathconf(_arg0); end
  def pid; end
  def pos; end
  def pos=(_arg0); end
  def pread(*_arg0); end
  def pressed?; end
  def print(*_arg0); end
  def printf(*_arg0); end
  def putc(_arg0); end
  def puts(*_arg0); end
  def pwrite(_arg0, _arg1); end
  def raw(*_arg0); end
  def raw!(*_arg0); end
  def read(*_arg0); end
  def read_nonblock(len, buf = T.unsafe(nil), exception: T.unsafe(nil)); end
  def readbyte; end
  def readchar; end
  def readline(*_arg0); end
  def readlines(*_arg0); end
  def readpartial(*_arg0); end
  def ready?; end
  def reopen(*_arg0); end
  def rewind; end
  def scroll_backward(_arg0); end
  def scroll_forward(_arg0); end
  def seek(*_arg0); end
  def set_encoding(*_arg0); end
  def set_encoding_by_bom; end
  def stat; end
  def sync; end
  def sync=(_arg0); end
  def sysread(*_arg0); end
  def sysseek(*_arg0); end
  def syswrite(_arg0); end
  def tell; end
  def to_i; end
  def to_io; end
  def tty?; end
  def ungetbyte(_arg0); end
  def ungetc(_arg0); end
  def wait(*_arg0); end
  def wait_priority(*_arg0); end
  def wait_readable(*_arg0); end
  def wait_writable(*_arg0); end
  def winsize; end
  def winsize=(_arg0); end
  def write(*_arg0); end
  def write_nonblock(buf, exception: T.unsafe(nil)); end
  private def initialize_copy(_arg0); end
  def self.binread(*_arg0); end
  def self.binwrite(*_arg0); end
  def self.console(*_arg0); end
  def self.copy_stream(*_arg0); end
  def self.for_fd(*_arg0); end
  def self.foreach(*_arg0); end
  def self.new(*_arg0); end
  def self.open(*_arg0); end
  def self.pipe(*_arg0); end
  def self.popen(*_arg0); end
  def self.read(*_arg0); end
  def self.readlines(*_arg0); end
  def self.select(*_arg0); end
  def self.sysopen(*_arg0); end
  def self.try_convert(_arg0); end
  def self.write(*_arg0); end
end

Observable::VERSION = T.let(T.unsafe(nil), String)
class StandardError < ::Exception; end

module OpenSSL::ASN1
  private def BMPString(*_arg0); end
  private def BitString(*_arg0); end
  private def Boolean(*_arg0); end
  private def EndOfContent(*_arg0); end
  private def Enumerated(*_arg0); end
  private def GeneralString(*_arg0); end
  private def GeneralizedTime(*_arg0); end
  private def GraphicString(*_arg0); end
  private def IA5String(*_arg0); end
  private def ISO64String(*_arg0); end
  private def Integer(*_arg0); end
  private def Null(*_arg0); end
  private def NumericString(*_arg0); end
  private def ObjectId(*_arg0); end
  private def OctetString(*_arg0); end
  private def PrintableString(*_arg0); end
  private def Sequence(*_arg0); end
  private def Set(*_arg0); end
  private def T61String(*_arg0); end
  private def UTCTime(*_arg0); end
  private def UTF8String(*_arg0); end
  private def UniversalString(*_arg0); end
  private def VideotexString(*_arg0); end
  private def decode(_arg0); end
  private def decode_all(_arg0); end
  private def traverse(_arg0); end
  def self.BMPString(*_arg0); end
  def self.BitString(*_arg0); end
  def self.Boolean(*_arg0); end
  def self.EndOfContent(*_arg0); end
  def self.Enumerated(*_arg0); end
  def self.GeneralString(*_arg0); end
  def self.GeneralizedTime(*_arg0); end
  def self.GraphicString(*_arg0); end
  def self.IA5String(*_arg0); end
  def self.ISO64String(*_arg0); end
  def self.Integer(*_arg0); end
  def self.Null(*_arg0); end
  def self.NumericString(*_arg0); end
  def self.ObjectId(*_arg0); end
  def self.OctetString(*_arg0); end
  def self.PrintableString(*_arg0); end
  def self.Sequence(*_arg0); end
  def self.Set(*_arg0); end
  def self.T61String(*_arg0); end
  def self.UTCTime(*_arg0); end
  def self.UTF8String(*_arg0); end
  def self.UniversalString(*_arg0); end
  def self.VideotexString(*_arg0); end
  def self.decode(_arg0); end
  def self.decode_all(_arg0); end
  def self.traverse(_arg0); end
end

class OpenSSL::BN
  include ::Comparable
  def initialize(*_arg0); end
  def %(_arg0); end
  def *(_arg0); end
  def **(_arg0); end
  def +(_arg0); end
  def +@; end
  def -(_arg0); end
  def -@; end
  def /(_arg0); end
  def <<(_arg0); end
  def <=>(_arg0); end
  def ==(_arg0); end
  def ===(_arg0); end
  def >>(_arg0); end
  def bit_set?(_arg0); end
  def clear_bit!(_arg0); end
  def cmp(_arg0); end
  def coerce(_arg0); end
  def copy(_arg0); end
  def eql?(_arg0); end
  def gcd(_arg0); end
  def hash; end
  def lshift!(_arg0); end
  def mask_bits!(_arg0); end
  def mod_add(_arg0, _arg1); end
  def mod_exp(_arg0, _arg1); end
  def mod_inverse(_arg0); end
  def mod_mul(_arg0, _arg1); end
  def mod_sqr(_arg0); end
  def mod_sub(_arg0, _arg1); end
  def negative?; end
  def num_bits; end
  def num_bytes; end
  def odd?; end
  def one?; end
  def pretty_print(q); end
  def prime?(*_arg0); end
  def prime_fasttest?(*_arg0); end
  def rshift!(_arg0); end
  def set_bit!(_arg0); end
  def sqr; end
  def to_bn; end
  def to_i; end
  def to_int; end
  def to_s(*_arg0); end
  def ucmp(_arg0); end
  def zero?; end
  private def initialize_copy(_arg0); end
  def self.generate_prime(*_arg0); end
  def self.pseudo_rand(*_arg0); end
  def self.pseudo_rand_range(_arg0); end
  def self.rand(*_arg0); end
  def self.rand_range(_arg0); end
end

class OpenSSL::BNError < ::OpenSSL::OpenSSLError; end

module OpenSSL::Buffering
  include ::Enumerable
  def initialize(*_arg0); end
  def <<(s); end
  def close; end
  def each(eol = T.unsafe(nil)); end
  def each_byte; end
  def each_line(eol = T.unsafe(nil)); end
  def eof; end
  def eof?; end
  def flush; end
  def getc; end
  def gets(eol = T.unsafe(nil), limit = T.unsafe(nil)); end
  def print(*args); end
  def printf(s, *args); end
  def puts(*args); end
  def read(size = T.unsafe(nil), buf = T.unsafe(nil)); end
  def read_nonblock(maxlen, buf = T.unsafe(nil), exception: T.unsafe(nil)); end
  def readchar; end
  def readline(eol = T.unsafe(nil)); end
  def readlines(eol = T.unsafe(nil)); end
  def readpartial(maxlen, buf = T.unsafe(nil)); end
  def sync; end
  def sync=(_arg0); end
  def ungetc(c); end
  def write(*s); end
  def write_nonblock(s, exception: T.unsafe(nil)); end
  private def consume_rbuff(size = T.unsafe(nil)); end
  private def do_write(s); end
  private def fill_rbuff; end
end

class OpenSSL::Cipher
  def initialize(_arg0); end
  def auth_data=(_arg0); end
  def auth_tag(*_arg0); end
  def auth_tag=(_arg0); end
  def auth_tag_len=(_arg0); end
  def authenticated?; end
  def block_size; end
  def decrypt(*_arg0); end
  def encrypt(*_arg0); end
  def final; end
  def iv=(_arg0); end
  def iv_len; end
  def iv_len=(_arg0); end
  def key=(_arg0); end
  def key_len; end
  def key_len=(_arg0); end
  def name; end
  def padding=(_arg0); end
  def pkcs5_keyivgen(*_arg0); end
  def random_iv; end
  def random_key; end
  def reset; end
  def update(*_arg0); end
  private def ciphers; end
  private def initialize_copy(_arg0); end
  def self.ciphers; end
end

class OpenSSL::Config
  include ::Enumerable
  def initialize(filename = T.unsafe(nil)); end
  def [](section); end
  def []=(section, pairs); end
  def add_value(section, key, value); end
  def each; end
  def get_value(section, key); end
  def inspect; end
  def section(name); end
  def sections; end
  def set_section(section, pairs); end
  def to_s; end
  def value(arg1, arg2 = T.unsafe(nil)); end
  protected def data; end
  private def check_modify; end
  private def get_key_string(section, key); end
  private def initialize_copy(other); end
  def self.get_key_string(data, section, key); end
  def self.load(*_arg0); end
  def self.parse(string); end
  def self.parse_config(io); end
  private def self.clear_comments(line); end
  private def self.extract_reference(value); end
  private def self.get_definition(io_stack); end
  private def self.get_line(io_stack); end
  private def self.parse_config_lines(io); end
  private def self.unescape_value(data, section, value); end
end

class OpenSSL::ConfigError < ::OpenSSL::OpenSSLError; end

class OpenSSL::Digest < ::Digest::Class
  def initialize(*_arg0); end
  def <<(_arg0); end
  def block_length; end
  def digest_length; end
  def name; end
  def reset; end
  def update(_arg0); end
  private def finish(*_arg0); end
  private def initialize_copy(_arg0); end
  def self.digest(name, data); end
end

class OpenSSL::Engine
  def cipher(_arg0); end
  def cmds; end
  def ctrl_cmd(*_arg0); end
  def digest(_arg0); end
  def finish; end
  def id; end
  def inspect; end
  def load_private_key(*_arg0); end
  def load_public_key(*_arg0); end
  def name; end
  def set_default(_arg0); end
  def self.by_id(_arg0); end
  def self.cleanup; end
  def self.engines; end
  def self.load(*_arg0); end
end

module OpenSSL::ExtConfig; end

class OpenSSL::HMAC
  def initialize(_arg0, _arg1); end
  def <<(_arg0); end
  def ==(other); end
  def digest; end
  def hexdigest; end
  def inspect; end
  def reset; end
  def to_s; end
  def update(_arg0); end
  private def initialize_copy(_arg0); end
  def self.digest(_arg0, _arg1, _arg2); end
  def self.hexdigest(_arg0, _arg1, _arg2); end
end

class OpenSSL::HMACError < ::OpenSSL::OpenSSLError; end

module OpenSSL::KDF
  private def hkdf(*_arg0); end
  private def pbkdf2_hmac(*_arg0); end
  private def scrypt(*_arg0); end
  def self.hkdf(*_arg0); end
  def self.pbkdf2_hmac(*_arg0); end
  def self.scrypt(*_arg0); end
end

module OpenSSL::Marshal
  mixes_in_class_methods ::OpenSSL::Marshal::ClassMethods
  def _dump(_level); end
  def self.included(base); end
end

module OpenSSL::Netscape; end
module OpenSSL::OCSP; end
OpenSSL::OPENSSL_LIBRARY_VERSION = T.let(T.unsafe(nil), String)
OpenSSL::OPENSSL_VERSION = T.let(T.unsafe(nil), String)
OpenSSL::OPENSSL_VERSION_NUMBER = T.let(T.unsafe(nil), Integer)
class OpenSSL::OpenSSLError < ::StandardError; end

class OpenSSL::PKCS12
  def initialize(*_arg0); end
  def ca_certs; end
  def certificate; end
  def key; end
  def to_der; end
  private def initialize_copy(_arg0); end
  def self.create(*_arg0); end
end

module OpenSSL::PKCS5
  private def pbkdf2_hmac(pass, salt, iter, keylen, digest); end
  private def pbkdf2_hmac_sha1(pass, salt, iter, keylen); end
  def self.pbkdf2_hmac(pass, salt, iter, keylen, digest); end
  def self.pbkdf2_hmac_sha1(pass, salt, iter, keylen); end
end

class OpenSSL::PKCS7
  def initialize(*_arg0); end
  def add_certificate(_arg0); end
  def add_crl(_arg0); end
  def add_data(_arg0); end
  def add_recipient(_arg0); end
  def add_signer(_arg0); end
  def certificates; end
  def certificates=(_arg0); end
  def cipher=(_arg0); end
  def crls; end
  def crls=(_arg0); end
  def data; end
  def data=(_arg0); end
  def decrypt(*_arg0); end
  def detached; end
  def detached=(_arg0); end
  def detached?; end
  def error_string; end
  def error_string=(_arg0); end
  def recipients; end
  def signers; end
  def to_der; end
  def to_pem; end
  def to_s; end
  def type; end
  def type=(_arg0); end
  def verify(*_arg0); end
  private def initialize_copy(_arg0); end
  def self.encrypt(*_arg0); end
  def self.read_smime(_arg0); end
  def self.sign(*_arg0); end
  def self.write_smime(*_arg0); end
end

module OpenSSL::PKey
  private def read(*_arg0); end
  def self.read(*_arg0); end
end

module OpenSSL::Random
  private def load_random_file(_arg0); end
  private def random_add(_arg0, _arg1); end
  private def random_bytes(_arg0); end
  private def seed(_arg0); end
  private def status?; end
  private def write_random_file(_arg0); end
  def self.load_random_file(_arg0); end
  def self.random_add(_arg0, _arg1); end
  def self.random_bytes(_arg0); end
  def self.seed(_arg0); end
  def self.status?; end
  def self.write_random_file(_arg0); end
end

module OpenSSL::SSL
  private def verify_certificate_identity(cert, hostname); end
  private def verify_hostname(hostname, san); end
  private def verify_wildcard(domain_component, san_component); end
  def self.verify_certificate_identity(cert, hostname); end
  def self.verify_hostname(hostname, san); end
  def self.verify_wildcard(domain_component, san_component); end
end

module OpenSSL::Timestamp; end
OpenSSL::VERSION = T.let(T.unsafe(nil), String)
module OpenSSL::X509; end

module Singleton::SingletonClassMethods
  def _load(str); end
  def clone; end
  def instance; end
  private def inherited(sub_klass); end
end

Singleton::VERSION = T.let(T.unsafe(nil), String)
Etc::CS_PATH = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_ILP32_OFF32_CFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_ILP32_OFF32_LDFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_ILP32_OFF32_LIBS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_ILP32_OFFBIG_LIBS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_LP64_OFF64_CFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_LP64_OFF64_LDFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_LP64_OFF64_LIBS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_LPBIG_OFFBIG_LIBS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_WIDTH_RESTRICTED_ENVS = T.let(T.unsafe(nil), Integer)

class Etc::Group < ::Struct
  extend ::Enumerable
  def gid; end
  def gid=(_); end
  def mem; end
  def mem=(_); end
  def name; end
  def name=(_); end
  def passwd; end
  def passwd=(_); end
  def self.[](*_arg0); end
  def self.each; end
  def self.inspect; end
  def self.members; end
  def self.new(*_arg0); end
end

Etc::PC_2_SYMLINKS = T.let(T.unsafe(nil), Integer)
Etc::PC_ALLOC_SIZE_MIN = T.let(T.unsafe(nil), Integer)
Etc::PC_ASYNC_IO = T.let(T.unsafe(nil), Integer)
Etc::PC_CHOWN_RESTRICTED = T.let(T.unsafe(nil), Integer)
Etc::PC_FILESIZEBITS = T.let(T.unsafe(nil), Integer)
Etc::PC_LINK_MAX = T.let(T.unsafe(nil), Integer)
Etc::PC_MAX_CANON = T.let(T.unsafe(nil), Integer)
Etc::PC_MAX_INPUT = T.let(T.unsafe(nil), Integer)
Etc::PC_NAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::PC_NO_TRUNC = T.let(T.unsafe(nil), Integer)
Etc::PC_PATH_MAX = T.let(T.unsafe(nil), Integer)
Etc::PC_PIPE_BUF = T.let(T.unsafe(nil), Integer)
Etc::PC_PRIO_IO = T.let(T.unsafe(nil), Integer)
Etc::PC_REC_INCR_XFER_SIZE = T.let(T.unsafe(nil), Integer)
Etc::PC_REC_MAX_XFER_SIZE = T.let(T.unsafe(nil), Integer)
Etc::PC_REC_MIN_XFER_SIZE = T.let(T.unsafe(nil), Integer)
Etc::PC_REC_XFER_ALIGN = T.let(T.unsafe(nil), Integer)
Etc::PC_SYMLINK_MAX = T.let(T.unsafe(nil), Integer)
Etc::PC_SYNC_IO = T.let(T.unsafe(nil), Integer)
Etc::PC_VDISABLE = T.let(T.unsafe(nil), Integer)

class Etc::Passwd < ::Struct
  extend ::Enumerable
  def change; end
  def change=(_); end
  def dir; end
  def dir=(_); end
  def expire; end
  def expire=(_); end
  def gecos; end
  def gecos=(_); end
  def gid; end
  def gid=(_); end
  def name; end
  def name=(_); end
  def passwd; end
  def passwd=(_); end
  def shell; end
  def shell=(_); end
  def uclass; end
  def uclass=(_); end
  def uid; end
  def uid=(_); end
  def self.[](*_arg0); end
  def self.each; end
  def self.inspect; end
  def self.members; end
  def self.new(*_arg0); end
end

Etc::SC_2_CHAR_TERM = T.let(T.unsafe(nil), Integer)
Etc::SC_2_C_BIND = T.let(T.unsafe(nil), Integer)
Etc::SC_2_C_DEV = T.let(T.unsafe(nil), Integer)
Etc::SC_2_FORT_DEV = T.let(T.unsafe(nil), Integer)
Etc::SC_2_FORT_RUN = T.let(T.unsafe(nil), Integer)
Etc::SC_2_LOCALEDEF = T.let(T.unsafe(nil), Integer)
Etc::SC_2_PBS = T.let(T.unsafe(nil), Integer)
Etc::SC_2_PBS_ACCOUNTING = T.let(T.unsafe(nil), Integer)
Etc::SC_2_PBS_CHECKPOINT = T.let(T.unsafe(nil), Integer)
Etc::SC_2_PBS_LOCATE = T.let(T.unsafe(nil), Integer)
Etc::SC_2_PBS_MESSAGE = T.let(T.unsafe(nil), Integer)
Etc::SC_2_PBS_TRACK = T.let(T.unsafe(nil), Integer)
Etc::SC_2_SW_DEV = T.let(T.unsafe(nil), Integer)
Etc::SC_2_UPE = T.let(T.unsafe(nil), Integer)
Etc::SC_2_VERSION = T.let(T.unsafe(nil), Integer)
Etc::SC_ADVISORY_INFO = T.let(T.unsafe(nil), Integer)
Etc::SC_AIO_LISTIO_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_AIO_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_AIO_PRIO_DELTA_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_ARG_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_ASYNCHRONOUS_IO = T.let(T.unsafe(nil), Integer)
Etc::SC_ATEXIT_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_BARRIERS = T.let(T.unsafe(nil), Integer)
Etc::SC_BC_BASE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_BC_DIM_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_BC_SCALE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_BC_STRING_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_CHILD_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_CLK_TCK = T.let(T.unsafe(nil), Integer)
Etc::SC_CLOCK_SELECTION = T.let(T.unsafe(nil), Integer)
Etc::SC_COLL_WEIGHTS_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_CPUTIME = T.let(T.unsafe(nil), Integer)
Etc::SC_DELAYTIMER_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_EXPR_NEST_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_FSYNC = T.let(T.unsafe(nil), Integer)
Etc::SC_GETGR_R_SIZE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_GETPW_R_SIZE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_HOST_NAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_IOV_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_IPV6 = T.let(T.unsafe(nil), Integer)
Etc::SC_JOB_CONTROL = T.let(T.unsafe(nil), Integer)
Etc::SC_LINE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_LOGIN_NAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_MAPPED_FILES = T.let(T.unsafe(nil), Integer)
Etc::SC_MEMLOCK = T.let(T.unsafe(nil), Integer)
Etc::SC_MEMLOCK_RANGE = T.let(T.unsafe(nil), Integer)
Etc::SC_MEMORY_PROTECTION = T.let(T.unsafe(nil), Integer)
Etc::SC_MESSAGE_PASSING = T.let(T.unsafe(nil), Integer)
Etc::SC_MONOTONIC_CLOCK = T.let(T.unsafe(nil), Integer)
Etc::SC_MQ_OPEN_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_MQ_PRIO_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_NGROUPS_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_NPROCESSORS_CONF = T.let(T.unsafe(nil), Integer)
Etc::SC_NPROCESSORS_ONLN = T.let(T.unsafe(nil), Integer)
Etc::SC_OPEN_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_PAGESIZE = T.let(T.unsafe(nil), Integer)
Etc::SC_PAGE_SIZE = T.let(T.unsafe(nil), Integer)
Etc::SC_PHYS_PAGES = T.let(T.unsafe(nil), Integer)
Etc::SC_PRIORITIZED_IO = T.let(T.unsafe(nil), Integer)
Etc::SC_PRIORITY_SCHEDULING = T.let(T.unsafe(nil), Integer)
Etc::SC_RAW_SOCKETS = T.let(T.unsafe(nil), Integer)
Etc::SC_READER_WRITER_LOCKS = T.let(T.unsafe(nil), Integer)
Etc::SC_REALTIME_SIGNALS = T.let(T.unsafe(nil), Integer)
Etc::SC_REGEXP = T.let(T.unsafe(nil), Integer)
Etc::SC_RE_DUP_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_RTSIG_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_SAVED_IDS = T.let(T.unsafe(nil), Integer)
Etc::SC_SEMAPHORES = T.let(T.unsafe(nil), Integer)
Etc::SC_SEM_NSEMS_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_SEM_VALUE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_SHARED_MEMORY_OBJECTS = T.let(T.unsafe(nil), Integer)
Etc::SC_SHELL = T.let(T.unsafe(nil), Integer)
Etc::SC_SIGQUEUE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_SPAWN = T.let(T.unsafe(nil), Integer)
Etc::SC_SPIN_LOCKS = T.let(T.unsafe(nil), Integer)
Etc::SC_SPORADIC_SERVER = T.let(T.unsafe(nil), Integer)
Etc::SC_SS_REPL_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_STREAM_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_SYMLOOP_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_SYNCHRONIZED_IO = T.let(T.unsafe(nil), Integer)
Etc::SC_THREADS = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_ATTR_STACKADDR = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_ATTR_STACKSIZE = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_CPUTIME = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_DESTRUCTOR_ITERATIONS = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_KEYS_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_PRIORITY_SCHEDULING = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_PRIO_INHERIT = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_PRIO_PROTECT = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_PROCESS_SHARED = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_SAFE_FUNCTIONS = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_SPORADIC_SERVER = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_STACK_MIN = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_THREADS_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TIMEOUTS = T.let(T.unsafe(nil), Integer)
Etc::SC_TIMERS = T.let(T.unsafe(nil), Integer)
Etc::SC_TIMER_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_EVENT_FILTER = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_EVENT_NAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_INHERIT = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_LOG = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_NAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_SYS_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_USER_EVENT_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TTY_NAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TYPED_MEMORY_OBJECTS = T.let(T.unsafe(nil), Integer)
Etc::SC_TZNAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_V6_ILP32_OFF32 = T.let(T.unsafe(nil), Integer)
Etc::SC_V6_ILP32_OFFBIG = T.let(T.unsafe(nil), Integer)
Etc::SC_V6_LP64_OFF64 = T.let(T.unsafe(nil), Integer)
Etc::SC_V6_LPBIG_OFFBIG = T.let(T.unsafe(nil), Integer)
Etc::SC_VERSION = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_CRYPT = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_ENH_I18N = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_REALTIME = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_REALTIME_THREADS = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_SHM = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_STREAMS = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_UNIX = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_VERSION = T.let(T.unsafe(nil), Integer)
Etc::VERSION = T.let(T.unsafe(nil), String)

module FileUtils::DryRun
  include ::FileUtils::StreamUtils_
  include ::FileUtils
  include ::FileUtils::LowMethods
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils
  extend ::FileUtils::LowMethods
  extend ::FileUtils::DryRun
  private def chmod(*args, **options); end
  private def chmod_R(*args, **options); end
  private def chown(*args, **options); end
  private def chown_R(*args, **options); end
  private def copy(*args, **options); end
  private def cp(*args, **options); end
  private def cp_lr(*args, **options); end
  private def cp_r(*args, **options); end
  private def install(*args, **options); end
  private def link(*args, **options); end
  private def ln(*args, **options); end
  private def ln_s(*args, **options); end
  private def ln_sf(*args, **options); end
  private def makedirs(*args, **options); end
  private def mkdir(*args, **options); end
  private def mkdir_p(*args, **options); end
  private def mkpath(*args, **options); end
  private def move(*args, **options); end
  private def mv(*args, **options); end
  private def remove(*args, **options); end
  private def rm(*args, **options); end
  private def rm_f(*args, **options); end
  private def rm_r(*args, **options); end
  private def rm_rf(*args, **options); end
  private def rmdir(*args, **options); end
  private def rmtree(*args, **options); end
  private def safe_unlink(*args, **options); end
  private def symlink(*args, **options); end
  private def touch(*args, **options); end
end

class FileUtils::Entry_
  include ::FileUtils::StreamUtils_
  def initialize(a, b = T.unsafe(nil), deref = T.unsafe(nil)); end
  def blockdev?; end
  def chardev?; end
  def chmod(mode); end
  def chown(uid, gid); end
  def copy(dest); end
  def copy_file(dest); end
  def copy_metadata(path); end
  def dereference?; end
  def directory?; end
  def door?; end
  def entries; end
  def exist?; end
  def file?; end
  def inspect; end
  def link(dest); end
  def lstat; end
  def lstat!; end
  def path; end
  def pipe?; end
  def platform_support; end
  def postorder_traverse; end
  def prefix; end
  def preorder_traverse; end
  def rel; end
  def remove; end
  def remove_dir1; end
  def remove_file; end
  def socket?; end
  def stat; end
  def stat!; end
  def symlink?; end
  def traverse; end
  def wrap_traverse(pre, post); end
  private def check_have_lchmod?; end
  private def check_have_lchown?; end
  private def descendant_directory?(descendant, ascendant); end
  private def have_lchmod?; end
  private def have_lchown?; end
  private def join(dir, base); end
end

FileUtils::LOW_METHODS = T.let(T.unsafe(nil), Array)

module FileUtils::LowMethods
  private def _do_nothing(*_arg0); end
  private def cd(*_arg0); end
  private def chdir(*_arg0); end
  private def cmp(*_arg0); end
  private def collect_method(*_arg0); end
  private def commands(*_arg0); end
  private def compare_file(*_arg0); end
  private def compare_stream(*_arg0); end
  private def copy_entry(*_arg0); end
  private def copy_file(*_arg0); end
  private def copy_stream(*_arg0); end
  private def getwd(*_arg0); end
  private def have_option?(*_arg0); end
  private def identical?(*_arg0); end
  private def link_entry(*_arg0); end
  private def options(*_arg0); end
  private def options_of(*_arg0); end
  private def private_module_function(*_arg0); end
  private def pwd(*_arg0); end
  private def remove_dir(*_arg0); end
  private def remove_entry(*_arg0); end
  private def remove_entry_secure(*_arg0); end
  private def remove_file(*_arg0); end
  private def uptodate?(*_arg0); end
end

FileUtils::METHODS = T.let(T.unsafe(nil), Array)

module FileUtils::NoWrite
  include ::FileUtils::StreamUtils_
  include ::FileUtils
  include ::FileUtils::LowMethods
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils
  extend ::FileUtils::LowMethods
  extend ::FileUtils::NoWrite
  private def chmod(*args, **options); end
  private def chmod_R(*args, **options); end
  private def chown(*args, **options); end
  private def chown_R(*args, **options); end
  private def copy(*args, **options); end
  private def cp(*args, **options); end
  private def cp_lr(*args, **options); end
  private def cp_r(*args, **options); end
  private def install(*args, **options); end
  private def link(*args, **options); end
  private def ln(*args, **options); end
  private def ln_s(*args, **options); end
  private def ln_sf(*args, **options); end
  private def makedirs(*args, **options); end
  private def mkdir(*args, **options); end
  private def mkdir_p(*args, **options); end
  private def mkpath(*args, **options); end
  private def move(*args, **options); end
  private def mv(*args, **options); end
  private def remove(*args, **options); end
  private def rm(*args, **options); end
  private def rm_f(*args, **options); end
  private def rm_r(*args, **options); end
  private def rm_rf(*args, **options); end
  private def rmdir(*args, **options); end
  private def rmtree(*args, **options); end
  private def safe_unlink(*args, **options); end
  private def symlink(*args, **options); end
  private def touch(*args, **options); end
end

FileUtils::OPT_TABLE = T.let(T.unsafe(nil), Hash)

module FileUtils::StreamUtils_
  private def fu_blksize(st); end
  private def fu_copy_stream0(src, dest, blksize = T.unsafe(nil)); end
  private def fu_default_blksize; end
  private def fu_stream_blksize(*streams); end
  private def fu_windows?; end
end

FileUtils::VERSION = T.let(T.unsafe(nil), String)

module FileUtils::Verbose
  include ::FileUtils::StreamUtils_
  include ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils
  extend ::FileUtils::Verbose
  private def cd(*args, **options); end
  private def chdir(*args, **options); end
  private def chmod(*args, **options); end
  private def chmod_R(*args, **options); end
  private def chown(*args, **options); end
  private def chown_R(*args, **options); end
  private def copy(*args, **options); end
  private def cp(*args, **options); end
  private def cp_lr(*args, **options); end
  private def cp_r(*args, **options); end
  private def install(*args, **options); end
  private def link(*args, **options); end
  private def ln(*args, **options); end
  private def ln_s(*args, **options); end
  private def ln_sf(*args, **options); end
  private def makedirs(*args, **options); end
  private def mkdir(*args, **options); end
  private def mkdir_p(*args, **options); end
  private def mkpath(*args, **options); end
  private def move(*args, **options); end
  private def mv(*args, **options); end
  private def remove(*args, **options); end
  private def rm(*args, **options); end
  private def rm_f(*args, **options); end
  private def rm_r(*args, **options); end
  private def rm_rf(*args, **options); end
  private def rmdir(*args, **options); end
  private def rmtree(*args, **options); end
  private def safe_unlink(*args, **options); end
  private def symlink(*args, **options); end
  private def touch(*args, **options); end
end

class DRb::DRbArray
  def initialize(ary); end
  def _dump(lv); end
  def self._load(s); end
end

class DRb::DRbBadScheme < ::DRb::DRbError; end
class DRb::DRbBadURI < ::DRb::DRbError; end

class DRb::DRbConn
  def initialize(remote_uri); end
  def alive?; end
  def close; end
  def send_message(ref, msg_id, arg, block); end
  def uri; end
  def self.make_pool; end
  def self.open(remote_uri); end
  def self.stop_pool; end
end

class DRb::DRbConnError < ::DRb::DRbError; end
class DRb::DRbError < ::RuntimeError; end

class DRb::DRbIdConv
  def to_id(obj); end
  def to_obj(ref); end
end

class DRb::DRbMessage
  def initialize(config); end
  def dump(obj, error = T.unsafe(nil)); end
  def load(soc); end
  def recv_reply(stream); end
  def recv_request(stream); end
  def send_reply(stream, succ, result); end
  def send_request(stream, ref, msg_id, arg, b); end
  private def make_proxy(obj, error = T.unsafe(nil)); end
end

class DRb::DRbObject
  def initialize(obj, uri = T.unsafe(nil)); end
  def ==(other); end
  def __drbref; end
  def __drburi; end
  def _dump(lv); end
  def eql?(other); end
  def hash; end
  def method_missing(msg_id, *a, &b); end
  def pretty_print(q); end
  def pretty_print_cycle(q); end
  def respond_to?(msg_id, priv = T.unsafe(nil)); end
  def self._load(s); end
  def self.new_with(uri, ref); end
  def self.new_with_uri(uri); end
  def self.prepare_backtrace(uri, result); end
  def self.with_friend(uri); end
end

module DRb::DRbObservable
  include ::Observable
  def notify_observers(*arg); end
end

module DRb::DRbProtocol
  private def add_protocol(prot); end
  private def auto_load(uri); end
  private def open(uri, config, first = T.unsafe(nil)); end
  private def open_server(uri, config, first = T.unsafe(nil)); end
  private def uri_option(uri, config, first = T.unsafe(nil)); end
  def self.add_protocol(prot); end
  def self.auto_load(uri); end
  def self.open(uri, config, first = T.unsafe(nil)); end
  def self.open_server(uri, config, first = T.unsafe(nil)); end
  def self.uri_option(uri, config, first = T.unsafe(nil)); end
end

class DRb::DRbRemoteError < ::DRb::DRbError
  def initialize(error); end
  def reason; end
end

class DRb::DRbSSLSocket < ::DRb::DRbTCPSocket
  def initialize(uri, soc, config, is_established); end
  def accept; end
  def close; end
  def stream; end
  def self.open(uri, config); end
  def self.open_server(uri, config); end
  def self.parse_uri(uri); end
  def self.uri_option(uri, config); end
end

class DRb::DRbServer
  def initialize(uri = T.unsafe(nil), front = T.unsafe(nil), config_or_acl = T.unsafe(nil)); end
  def alive?; end
  def check_insecure_method(obj, msg_id); end
  def config; end
  def front; end
  def here?(uri); end
  def stop_service; end
  def thread; end
  def to_id(obj); end
  def to_obj(ref); end
  def uri; end
  def verbose; end
  def verbose=(v); end
  private def any_to_s(obj); end
  private def error_print(exception); end
  private def insecure_method?(msg_id); end
  private def main_loop; end
  private def run; end
  private def shutdown; end
  def self.default_acl(acl); end
  def self.default_argc_limit(argc); end
  def self.default_id_conv(idconv); end
  def self.default_load_limit(sz); end
  def self.make_config(hash = T.unsafe(nil)); end
  def self.verbose; end
  def self.verbose=(on); end
end

class DRb::DRbServerNotFound < ::DRb::DRbError; end

class DRb::DRbTCPSocket
  def initialize(uri, soc, config = T.unsafe(nil)); end
  def accept; end
  def alive?; end
  def close; end
  def peeraddr; end
  def recv_reply; end
  def recv_request; end
  def send_reply(succ, result); end
  def send_request(ref, msg_id, arg, b); end
  def set_sockopt(soc); end
  def shutdown; end
  def stream; end
  def uri; end
  private def accept_or_shutdown; end
  private def close_shutdown_pipe; end
  def self.getservername; end
  def self.open(uri, config); end
  def self.open_server(uri, config); end
  def self.open_server_inaddr_any(host, port); end
  def self.parse_uri(uri); end
  def self.uri_option(uri, config); end
end

class DRb::DRbUNIXSocket < ::DRb::DRbTCPSocket
  def initialize(uri, soc, config = T.unsafe(nil), server_mode = T.unsafe(nil)); end
  def accept; end
  def close; end
  def set_sockopt(soc); end
  def self.open(uri, config); end
  def self.open_server(uri, config); end
  def self.parse_uri(uri); end
  def self.temp_server; end
  def self.uri_option(uri, config); end
end

class DRb::DRbURIOption
  def initialize(option); end
  def ==(other); end
  def eql?(other); end
  def hash; end
  def option; end
  def to_s; end
end

module DRb::DRbUndumped
  def _dump(dummy); end
end

class DRb::DRbUnknown
  def initialize(err, buf); end
  def _dump(lv); end
  def buf; end
  def exception; end
  def name; end
  def reload; end
  def self._load(s); end
end

class DRb::DRbUnknownError < ::DRb::DRbError
  def initialize(unknown); end
  def _dump(lv); end
  def unknown; end
  def self._load(s); end
end

class DRb::ExtServ
  include ::MonitorMixin
  include ::DRb::DRbUndumped
  def initialize(there, name, server = T.unsafe(nil)); end
  def alive?; end
  def front; end
  def server; end
  def stop_service; end
end

class DRb::ExtServManager
  include ::DRb::DRbUndumped
  include ::MonitorMixin
  def initialize; end
  def regist(name, ro); end
  def service(name); end
  def unregist(name); end
  def uri; end
  def uri=(_arg0); end
  private def invoke_service(name); end
  private def invoke_service_command(name, command); end
  private def invoke_thread; end
  def self.command; end
  def self.command=(cmd); end
end

class DRb::GW
  include ::MonitorMixin
  def initialize; end
  def [](key); end
  def []=(key, v); end
end

class DRb::GWIdConv < ::DRb::DRbIdConv
  def to_obj(ref); end
end

class DRb::ThreadObject
  include ::MonitorMixin
  def initialize(&blk); end
  def _execute; end
  def alive?; end
  def kill; end
  def method_missing(msg, *arg, &blk); end
end

class DRb::TimerIdConv < ::DRb::DRbIdConv
  def initialize(keeping = T.unsafe(nil)); end
  def to_id(obj); end
  def to_obj(ref); end
end

DRb::VERSION = T.let(T.unsafe(nil), String)

class DRb::WeakIdConv < ::DRb::DRbIdConv
  def initialize; end
  def to_id(obj); end
  def to_obj(ref); end
end

class Digest::Base < ::Digest::Class
  def <<(_arg0); end
  def block_length; end
  def digest_length; end
  def reset; end
  def update(_arg0); end
  private def finish; end
  private def initialize_copy(_arg0); end
end

class Digest::Class
  include ::Digest::Instance
  def initialize; end
  def self.base64digest(str, *args); end
  def self.digest(*_arg0); end
  def self.file(name, *args); end
  def self.hexdigest(*_arg0); end
end

module Digest::Instance
  def <<(_arg0); end
  def ==(_arg0); end
  def base64digest(str = T.unsafe(nil)); end
  def base64digest!; end
  def block_length; end
  def digest(*_arg0); end
  def digest!; end
  def digest_length; end
  def file(name); end
  def hexdigest(*_arg0); end
  def hexdigest!; end
  def inspect; end
  def length; end
  def new; end
  def reset; end
  def size; end
  def to_s; end
  def update(_arg0); end
  private def finish; end
end

Digest::REQUIRE_MUTEX = T.let(T.unsafe(nil), Thread::Mutex)
class Digest::SHA1 < ::Digest::Base; end

class Digest::SHA2 < ::Digest::Class
  def initialize(bitlen = T.unsafe(nil)); end
  def <<(str); end
  def block_length; end
  def digest_length; end
  def inspect; end
  def reset; end
  def update(str); end
  private def finish; end
  private def initialize_copy(other); end
end

class Digest::SHA256 < ::Digest::Base; end
class Digest::SHA384 < ::Digest::Base; end
class Digest::SHA512 < ::Digest::Base; end
Digest::VERSION = T.let(T.unsafe(nil), String)

class ACL::ACLEntry
  def initialize(str); end
  def match(addr); end
  private def dot_pat(str); end
  private def dot_pat_str(str); end
end

class ACL::ACLList
  def initialize; end
  def add(str); end
  def match(addr); end
end

ACL::ALLOW_DENY = T.let(T.unsafe(nil), Integer)
ACL::DENY_ALLOW = T.let(T.unsafe(nil), Integer)
ACL::VERSION = T.let(T.unsafe(nil), Array)
class IPAddr::AddressFamilyError < ::IPAddr::Error; end
class IPAddr::Error < ::ArgumentError; end
IPAddr::IN4MASK = T.let(T.unsafe(nil), Integer)
IPAddr::IN6FORMAT = T.let(T.unsafe(nil), String)
IPAddr::IN6MASK = T.let(T.unsafe(nil), Integer)
class IPAddr::InvalidAddressError < ::IPAddr::Error; end
class IPAddr::InvalidPrefixError < ::IPAddr::InvalidAddressError; end
IPAddr::RE_IPV4ADDRLIKE = T.let(T.unsafe(nil), Regexp)
IPAddr::RE_IPV6ADDRLIKE_COMPRESSED = T.let(T.unsafe(nil), Regexp)
IPAddr::RE_IPV6ADDRLIKE_FULL = T.let(T.unsafe(nil), Regexp)
StringIO::VERSION = T.let(T.unsafe(nil), String)
Socket::AF_APPLETALK = T.let(T.unsafe(nil), Integer)
Socket::AF_CCITT = T.let(T.unsafe(nil), Integer)
Socket::AF_CHAOS = T.let(T.unsafe(nil), Integer)
Socket::AF_CNT = T.let(T.unsafe(nil), Integer)
Socket::AF_COIP = T.let(T.unsafe(nil), Integer)
Socket::AF_DATAKIT = T.let(T.unsafe(nil), Integer)
Socket::AF_DLI = T.let(T.unsafe(nil), Integer)
Socket::AF_E164 = T.let(T.unsafe(nil), Integer)
Socket::AF_ECMA = T.let(T.unsafe(nil), Integer)
Socket::AF_HYLINK = T.let(T.unsafe(nil), Integer)
Socket::AF_IMPLINK = T.let(T.unsafe(nil), Integer)
Socket::AF_INET = T.let(T.unsafe(nil), Integer)
Socket::AF_INET6 = T.let(T.unsafe(nil), Integer)
Socket::AF_IPX = T.let(T.unsafe(nil), Integer)
Socket::AF_ISDN = T.let(T.unsafe(nil), Integer)
Socket::AF_ISO = T.let(T.unsafe(nil), Integer)
Socket::AF_LAT = T.let(T.unsafe(nil), Integer)
Socket::AF_LINK = T.let(T.unsafe(nil), Integer)
Socket::AF_LOCAL = T.let(T.unsafe(nil), Integer)
Socket::AF_MAX = T.let(T.unsafe(nil), Integer)
Socket::AF_NATM = T.let(T.unsafe(nil), Integer)
Socket::AF_NDRV = T.let(T.unsafe(nil), Integer)
Socket::AF_NETBIOS = T.let(T.unsafe(nil), Integer)
Socket::AF_NS = T.let(T.unsafe(nil), Integer)
Socket::AF_OSI = T.let(T.unsafe(nil), Integer)
Socket::AF_PPP = T.let(T.unsafe(nil), Integer)
Socket::AF_PUP = T.let(T.unsafe(nil), Integer)
Socket::AF_ROUTE = T.let(T.unsafe(nil), Integer)
Socket::AF_SIP = T.let(T.unsafe(nil), Integer)
Socket::AF_SNA = T.let(T.unsafe(nil), Integer)
Socket::AF_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::AF_UNIX = T.let(T.unsafe(nil), Integer)
Socket::AF_UNSPEC = T.let(T.unsafe(nil), Integer)
Socket::AI_ADDRCONFIG = T.let(T.unsafe(nil), Integer)
Socket::AI_ALL = T.let(T.unsafe(nil), Integer)
Socket::AI_CANONNAME = T.let(T.unsafe(nil), Integer)
Socket::AI_DEFAULT = T.let(T.unsafe(nil), Integer)
Socket::AI_MASK = T.let(T.unsafe(nil), Integer)
Socket::AI_NUMERICHOST = T.let(T.unsafe(nil), Integer)
Socket::AI_NUMERICSERV = T.let(T.unsafe(nil), Integer)
Socket::AI_PASSIVE = T.let(T.unsafe(nil), Integer)
Socket::AI_V4MAPPED = T.let(T.unsafe(nil), Integer)
Socket::AI_V4MAPPED_CFG = T.let(T.unsafe(nil), Integer)

class Socket::AncillaryData
  def initialize(_arg0, _arg1, _arg2, _arg3); end
  def cmsg_is?(_arg0, _arg1); end
  def data; end
  def family; end
  def inspect; end
  def int; end
  def ip_pktinfo; end
  def ipv6_pktinfo; end
  def ipv6_pktinfo_addr; end
  def ipv6_pktinfo_ifindex; end
  def level; end
  def timestamp; end
  def type; end
  def unix_rights; end
  def self.int(_arg0, _arg1, _arg2, _arg3); end
  def self.ip_pktinfo(*_arg0); end
  def self.ipv6_pktinfo(_arg0, _arg1); end
  def self.unix_rights(*_arg0); end
end

module Socket::Constants; end
Socket::EAI_ADDRFAMILY = T.let(T.unsafe(nil), Integer)
Socket::EAI_AGAIN = T.let(T.unsafe(nil), Integer)
Socket::EAI_BADFLAGS = T.let(T.unsafe(nil), Integer)
Socket::EAI_BADHINTS = T.let(T.unsafe(nil), Integer)
Socket::EAI_FAIL = T.let(T.unsafe(nil), Integer)
Socket::EAI_FAMILY = T.let(T.unsafe(nil), Integer)
Socket::EAI_MAX = T.let(T.unsafe(nil), Integer)
Socket::EAI_MEMORY = T.let(T.unsafe(nil), Integer)
Socket::EAI_NODATA = T.let(T.unsafe(nil), Integer)
Socket::EAI_NONAME = T.let(T.unsafe(nil), Integer)
Socket::EAI_OVERFLOW = T.let(T.unsafe(nil), Integer)
Socket::EAI_PROTOCOL = T.let(T.unsafe(nil), Integer)
Socket::EAI_SERVICE = T.let(T.unsafe(nil), Integer)
Socket::EAI_SOCKTYPE = T.let(T.unsafe(nil), Integer)
Socket::EAI_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::IFF_ALLMULTI = T.let(T.unsafe(nil), Integer)
Socket::IFF_ALTPHYS = T.let(T.unsafe(nil), Integer)
Socket::IFF_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::IFF_DEBUG = T.let(T.unsafe(nil), Integer)
Socket::IFF_LINK0 = T.let(T.unsafe(nil), Integer)
Socket::IFF_LINK1 = T.let(T.unsafe(nil), Integer)
Socket::IFF_LINK2 = T.let(T.unsafe(nil), Integer)
Socket::IFF_LOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::IFF_MULTICAST = T.let(T.unsafe(nil), Integer)
Socket::IFF_NOARP = T.let(T.unsafe(nil), Integer)
Socket::IFF_NOTRAILERS = T.let(T.unsafe(nil), Integer)
Socket::IFF_OACTIVE = T.let(T.unsafe(nil), Integer)
Socket::IFF_POINTOPOINT = T.let(T.unsafe(nil), Integer)
Socket::IFF_PROMISC = T.let(T.unsafe(nil), Integer)
Socket::IFF_RUNNING = T.let(T.unsafe(nil), Integer)
Socket::IFF_SIMPLEX = T.let(T.unsafe(nil), Integer)
Socket::IFF_UP = T.let(T.unsafe(nil), Integer)
Socket::IFNAMSIZ = T.let(T.unsafe(nil), Integer)
Socket::IF_NAMESIZE = T.let(T.unsafe(nil), Integer)
Socket::INADDR_ALLHOSTS_GROUP = T.let(T.unsafe(nil), Integer)
Socket::INADDR_ANY = T.let(T.unsafe(nil), Integer)
Socket::INADDR_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::INADDR_LOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::INADDR_MAX_LOCAL_GROUP = T.let(T.unsafe(nil), Integer)
Socket::INADDR_NONE = T.let(T.unsafe(nil), Integer)
Socket::INADDR_UNSPEC_GROUP = T.let(T.unsafe(nil), Integer)
Socket::INET6_ADDRSTRLEN = T.let(T.unsafe(nil), Integer)
Socket::INET_ADDRSTRLEN = T.let(T.unsafe(nil), Integer)
Socket::IPPORT_RESERVED = T.let(T.unsafe(nil), Integer)
Socket::IPPORT_USERRESERVED = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_AH = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_DSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_EGP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_EON = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ESP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_FRAGMENT = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_GGP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_HELLO = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_HOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ICMP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ICMPV6 = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_IDP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_IGMP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_IP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_IPV6 = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_MAX = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ND = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_NONE = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_PUP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_RAW = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ROUTING = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_TCP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_TP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_UDP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_XTP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_CHECKSUM = T.let(T.unsafe(nil), Integer)
Socket::IPV6_DONTFRAG = T.let(T.unsafe(nil), Integer)
Socket::IPV6_DSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_HOPLIMIT = T.let(T.unsafe(nil), Integer)
Socket::IPV6_HOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_JOIN_GROUP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_LEAVE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_MULTICAST_HOPS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_MULTICAST_IF = T.let(T.unsafe(nil), Integer)
Socket::IPV6_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_NEXTHOP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_PATHMTU = T.let(T.unsafe(nil), Integer)
Socket::IPV6_PKTINFO = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVDSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVHOPLIMIT = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVHOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVPATHMTU = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVPKTINFO = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVRTHDR = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVTCLASS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RTHDR = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RTHDRDSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RTHDR_TYPE_0 = T.let(T.unsafe(nil), Integer)
Socket::IPV6_TCLASS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_UNICAST_HOPS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_USE_MIN_MTU = T.let(T.unsafe(nil), Integer)
Socket::IPV6_V6ONLY = T.let(T.unsafe(nil), Integer)
Socket::IP_ADD_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::IP_ADD_SOURCE_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::IP_BLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::IP_DEFAULT_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::IP_DEFAULT_MULTICAST_TTL = T.let(T.unsafe(nil), Integer)
Socket::IP_DONTFRAG = T.let(T.unsafe(nil), Integer)
Socket::IP_DROP_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::IP_DROP_SOURCE_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::IP_HDRINCL = T.let(T.unsafe(nil), Integer)
Socket::IP_IPSEC_POLICY = T.let(T.unsafe(nil), Integer)
Socket::IP_MAX_MEMBERSHIPS = T.let(T.unsafe(nil), Integer)
Socket::IP_MSFILTER = T.let(T.unsafe(nil), Integer)
Socket::IP_MULTICAST_IF = T.let(T.unsafe(nil), Integer)
Socket::IP_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::IP_MULTICAST_TTL = T.let(T.unsafe(nil), Integer)
Socket::IP_OPTIONS = T.let(T.unsafe(nil), Integer)
Socket::IP_PKTINFO = T.let(T.unsafe(nil), Integer)
Socket::IP_PORTRANGE = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVDSTADDR = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVIF = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVOPTS = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVRETOPTS = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVTOS = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVTTL = T.let(T.unsafe(nil), Integer)
Socket::IP_RETOPTS = T.let(T.unsafe(nil), Integer)
Socket::IP_TOS = T.let(T.unsafe(nil), Integer)
Socket::IP_TTL = T.let(T.unsafe(nil), Integer)
Socket::IP_UNBLOCK_SOURCE = T.let(T.unsafe(nil), Integer)

class Socket::Ifaddr
  def addr; end
  def broadaddr; end
  def dstaddr; end
  def flags; end
  def ifindex; end
  def inspect; end
  def name; end
  def netmask; end
end

Socket::LOCAL_PEERCRED = T.let(T.unsafe(nil), Integer)
Socket::MCAST_BLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::MCAST_EXCLUDE = T.let(T.unsafe(nil), Integer)
Socket::MCAST_INCLUDE = T.let(T.unsafe(nil), Integer)
Socket::MCAST_JOIN_GROUP = T.let(T.unsafe(nil), Integer)
Socket::MCAST_JOIN_SOURCE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::MCAST_LEAVE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::MCAST_LEAVE_SOURCE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::MCAST_UNBLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::MSG_CTRUNC = T.let(T.unsafe(nil), Integer)
Socket::MSG_DONTROUTE = T.let(T.unsafe(nil), Integer)
Socket::MSG_DONTWAIT = T.let(T.unsafe(nil), Integer)
Socket::MSG_EOF = T.let(T.unsafe(nil), Integer)
Socket::MSG_EOR = T.let(T.unsafe(nil), Integer)
Socket::MSG_FLUSH = T.let(T.unsafe(nil), Integer)
Socket::MSG_HAVEMORE = T.let(T.unsafe(nil), Integer)
Socket::MSG_HOLD = T.let(T.unsafe(nil), Integer)
Socket::MSG_NOSIGNAL = T.let(T.unsafe(nil), Integer)
Socket::MSG_OOB = T.let(T.unsafe(nil), Integer)
Socket::MSG_PEEK = T.let(T.unsafe(nil), Integer)
Socket::MSG_RCVMORE = T.let(T.unsafe(nil), Integer)
Socket::MSG_SEND = T.let(T.unsafe(nil), Integer)
Socket::MSG_TRUNC = T.let(T.unsafe(nil), Integer)
Socket::MSG_WAITALL = T.let(T.unsafe(nil), Integer)
Socket::NI_DGRAM = T.let(T.unsafe(nil), Integer)
Socket::NI_MAXHOST = T.let(T.unsafe(nil), Integer)
Socket::NI_MAXSERV = T.let(T.unsafe(nil), Integer)
Socket::NI_NAMEREQD = T.let(T.unsafe(nil), Integer)
Socket::NI_NOFQDN = T.let(T.unsafe(nil), Integer)
Socket::NI_NUMERICHOST = T.let(T.unsafe(nil), Integer)
Socket::NI_NUMERICSERV = T.let(T.unsafe(nil), Integer)

class Socket::Option
  def initialize(_arg0, _arg1, _arg2, _arg3); end
  def bool; end
  def byte; end
  def data; end
  def family; end
  def inspect; end
  def int; end
  def ipv4_multicast_loop; end
  def ipv4_multicast_ttl; end
  def level; end
  def linger; end
  def optname; end
  def to_s; end
  def unpack(_arg0); end
  def self.bool(_arg0, _arg1, _arg2, _arg3); end
  def self.byte(_arg0, _arg1, _arg2, _arg3); end
  def self.int(_arg0, _arg1, _arg2, _arg3); end
  def self.ipv4_multicast_loop(_arg0); end
  def self.ipv4_multicast_ttl(_arg0); end
  def self.linger(_arg0, _arg1); end
end

Socket::PF_APPLETALK = T.let(T.unsafe(nil), Integer)
Socket::PF_CCITT = T.let(T.unsafe(nil), Integer)
Socket::PF_CHAOS = T.let(T.unsafe(nil), Integer)
Socket::PF_CNT = T.let(T.unsafe(nil), Integer)
Socket::PF_COIP = T.let(T.unsafe(nil), Integer)
Socket::PF_DATAKIT = T.let(T.unsafe(nil), Integer)
Socket::PF_DLI = T.let(T.unsafe(nil), Integer)
Socket::PF_ECMA = T.let(T.unsafe(nil), Integer)
Socket::PF_HYLINK = T.let(T.unsafe(nil), Integer)
Socket::PF_IMPLINK = T.let(T.unsafe(nil), Integer)
Socket::PF_INET = T.let(T.unsafe(nil), Integer)
Socket::PF_INET6 = T.let(T.unsafe(nil), Integer)
Socket::PF_IPX = T.let(T.unsafe(nil), Integer)
Socket::PF_ISDN = T.let(T.unsafe(nil), Integer)
Socket::PF_ISO = T.let(T.unsafe(nil), Integer)
Socket::PF_KEY = T.let(T.unsafe(nil), Integer)
Socket::PF_LAT = T.let(T.unsafe(nil), Integer)
Socket::PF_LINK = T.let(T.unsafe(nil), Integer)
Socket::PF_LOCAL = T.let(T.unsafe(nil), Integer)
Socket::PF_MAX = T.let(T.unsafe(nil), Integer)
Socket::PF_NATM = T.let(T.unsafe(nil), Integer)
Socket::PF_NDRV = T.let(T.unsafe(nil), Integer)
Socket::PF_NETBIOS = T.let(T.unsafe(nil), Integer)
Socket::PF_NS = T.let(T.unsafe(nil), Integer)
Socket::PF_OSI = T.let(T.unsafe(nil), Integer)
Socket::PF_PIP = T.let(T.unsafe(nil), Integer)
Socket::PF_PPP = T.let(T.unsafe(nil), Integer)
Socket::PF_PUP = T.let(T.unsafe(nil), Integer)
Socket::PF_ROUTE = T.let(T.unsafe(nil), Integer)
Socket::PF_RTIP = T.let(T.unsafe(nil), Integer)
Socket::PF_SIP = T.let(T.unsafe(nil), Integer)
Socket::PF_SNA = T.let(T.unsafe(nil), Integer)
Socket::PF_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::PF_UNIX = T.let(T.unsafe(nil), Integer)
Socket::PF_UNSPEC = T.let(T.unsafe(nil), Integer)
Socket::PF_XTP = T.let(T.unsafe(nil), Integer)
Socket::SCM_CREDS = T.let(T.unsafe(nil), Integer)
Socket::SCM_RIGHTS = T.let(T.unsafe(nil), Integer)
Socket::SCM_TIMESTAMP = T.let(T.unsafe(nil), Integer)
Socket::SHUT_RD = T.let(T.unsafe(nil), Integer)
Socket::SHUT_RDWR = T.let(T.unsafe(nil), Integer)
Socket::SHUT_WR = T.let(T.unsafe(nil), Integer)
Socket::SOCK_DGRAM = T.let(T.unsafe(nil), Integer)
Socket::SOCK_RAW = T.let(T.unsafe(nil), Integer)
Socket::SOCK_RDM = T.let(T.unsafe(nil), Integer)
Socket::SOCK_SEQPACKET = T.let(T.unsafe(nil), Integer)
Socket::SOCK_STREAM = T.let(T.unsafe(nil), Integer)
Socket::SOL_SOCKET = T.let(T.unsafe(nil), Integer)
Socket::SOMAXCONN = T.let(T.unsafe(nil), Integer)
Socket::SO_ACCEPTCONN = T.let(T.unsafe(nil), Integer)
Socket::SO_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::SO_DEBUG = T.let(T.unsafe(nil), Integer)
Socket::SO_DONTROUTE = T.let(T.unsafe(nil), Integer)
Socket::SO_DONTTRUNC = T.let(T.unsafe(nil), Integer)
Socket::SO_ERROR = T.let(T.unsafe(nil), Integer)
Socket::SO_KEEPALIVE = T.let(T.unsafe(nil), Integer)
Socket::SO_LINGER = T.let(T.unsafe(nil), Integer)
Socket::SO_NKE = T.let(T.unsafe(nil), Integer)
Socket::SO_NOSIGPIPE = T.let(T.unsafe(nil), Integer)
Socket::SO_NREAD = T.let(T.unsafe(nil), Integer)
Socket::SO_OOBINLINE = T.let(T.unsafe(nil), Integer)
Socket::SO_RCVBUF = T.let(T.unsafe(nil), Integer)
Socket::SO_RCVLOWAT = T.let(T.unsafe(nil), Integer)
Socket::SO_RCVTIMEO = T.let(T.unsafe(nil), Integer)
Socket::SO_REUSEADDR = T.let(T.unsafe(nil), Integer)
Socket::SO_REUSEPORT = T.let(T.unsafe(nil), Integer)
Socket::SO_SNDBUF = T.let(T.unsafe(nil), Integer)
Socket::SO_SNDLOWAT = T.let(T.unsafe(nil), Integer)
Socket::SO_SNDTIMEO = T.let(T.unsafe(nil), Integer)
Socket::SO_TIMESTAMP = T.let(T.unsafe(nil), Integer)
Socket::SO_TYPE = T.let(T.unsafe(nil), Integer)
Socket::SO_USELOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::SO_WANTMORE = T.let(T.unsafe(nil), Integer)
Socket::SO_WANTOOBFLAG = T.let(T.unsafe(nil), Integer)
Socket::TCP_FASTOPEN = T.let(T.unsafe(nil), Integer)
Socket::TCP_KEEPCNT = T.let(T.unsafe(nil), Integer)
Socket::TCP_KEEPINTVL = T.let(T.unsafe(nil), Integer)
Socket::TCP_MAXSEG = T.let(T.unsafe(nil), Integer)
Socket::TCP_NODELAY = T.let(T.unsafe(nil), Integer)
Socket::TCP_NOOPT = T.let(T.unsafe(nil), Integer)
Socket::TCP_NOPUSH = T.let(T.unsafe(nil), Integer)

class Socket::UDPSource
  def initialize(remote_address, local_address, &reply_proc); end
  def inspect; end
  def local_address; end
  def remote_address; end
  def reply(msg); end
end

module Comparable
  def <(_arg0); end
  def <=(_arg0); end
  def ==(_arg0); end
  def >(_arg0); end
  def >=(_arg0); end
  def between?(_arg0, _arg1); end
  def clamp(*_arg0); end
end

module Enumerable
  def all?(*_arg0); end
  def any?(*_arg0); end
  def chain(*_arg0); end
  def chunk; end
  def chunk_while; end
  def collect; end
  def collect_concat; end
  def count(*_arg0); end
  def cycle(*_arg0); end
  def detect(*_arg0); end
  def drop(_arg0); end
  def drop_while; end
  def each_cons(_arg0); end
  def each_entry(*_arg0); end
  def each_slice(_arg0); end
  def each_with_index(*_arg0); end
  def each_with_object(_arg0); end
  def entries(*_arg0); end
  def filter; end
  def filter_map; end
  def find(*_arg0); end
  def find_all; end
  def find_index(*_arg0); end
  def first(*_arg0); end
  def flat_map; end
  def grep(_arg0); end
  def grep_v(_arg0); end
  def group_by; end
  def include?(_arg0); end
  def inject(*_arg0); end
  def lazy; end
  def map; end
  def max(*_arg0); end
  def max_by(*_arg0); end
  def member?(_arg0); end
  def min(*_arg0); end
  def min_by(*_arg0); end
  def minmax; end
  def minmax_by; end
  def none?(*_arg0); end
  def one?(*_arg0); end
  def partition; end
  def reduce(*_arg0); end
  def reject; end
  def reverse_each(*_arg0); end
  def select; end
  def slice_after(*_arg0); end
  def slice_before(*_arg0); end
  def slice_when; end
  def sort; end
  def sort_by; end
  def sum(*_arg0); end
  def take(_arg0); end
  def take_while; end
  def tally; end
  def to_a(*_arg0); end
  def to_h(*_arg0); end
  def to_set(klass = T.unsafe(nil), *args, &block); end
  def uniq; end
  def zip(*_arg0); end
end

class IO::ConsoleMode
  def echo=(_arg0); end
  def raw(*_arg0); end
  def raw!(*_arg0); end
  private def initialize_copy(_arg0); end
end

class IO::EAGAINWaitReadable < ::Errno::EAGAIN
  include ::IO::WaitReadable
end

class IO::EAGAINWaitWritable < ::Errno::EAGAIN
  include ::IO::WaitWritable
end

class IO::EINPROGRESSWaitReadable < ::Errno::EINPROGRESS
  include ::IO::WaitReadable
end

class IO::EINPROGRESSWaitWritable < ::Errno::EINPROGRESS
  include ::IO::WaitWritable
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable
IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable
IO::PRIORITY = T.let(T.unsafe(nil), Integer)
IO::READABLE = T.let(T.unsafe(nil), Integer)
IO::SEEK_CUR = T.let(T.unsafe(nil), Integer)
IO::SEEK_DATA = T.let(T.unsafe(nil), Integer)
IO::SEEK_END = T.let(T.unsafe(nil), Integer)
IO::SEEK_HOLE = T.let(T.unsafe(nil), Integer)
IO::SEEK_SET = T.let(T.unsafe(nil), Integer)
IO::WRITABLE = T.let(T.unsafe(nil), Integer)
module IO::WaitReadable; end
module IO::WaitWritable; end

class Exception
  def initialize(*_arg0); end
  def ==(_arg0); end
  def backtrace; end
  def backtrace_locations; end
  def cause; end
  def exception(*_arg0); end
  def full_message(*_arg0); end
  def inspect; end
  def message; end
  def respond_to?(*_arg0); end
  def set_backtrace(_arg0); end
  def to_s; end
  private def method_missing(*_arg0); end
  private def respond_to_missing?(_arg0, _arg1); end
  def self.exception(*_arg0); end
  def self.to_tty?; end
end

class OpenSSL::ASN1::ASN1Data
  def initialize(_arg0, _arg1, _arg2); end
  def indefinite_length; end
  def indefinite_length=(_arg0); end
  def infinite_length; end
  def infinite_length=(_arg0); end
  def tag; end
  def tag=(_arg0); end
  def tag_class; end
  def tag_class=(_arg0); end
  def to_der; end
  def value; end
  def value=(_arg0); end
end

class OpenSSL::ASN1::ASN1Error < ::OpenSSL::OpenSSLError; end
OpenSSL::ASN1::BIT_STRING = T.let(T.unsafe(nil), Integer)
OpenSSL::ASN1::BMPSTRING = T.let(T.unsafe(nil), Integer)
class OpenSSL::ASN1::BMPString < ::OpenSSL::ASN1::Primitive; end
OpenSSL::ASN1::BOOLEAN = T.let(T.unsafe(nil), Integer)

class OpenSSL::ASN1::BitString < ::OpenSSL::ASN1::Primitive
  def unused_bits; end
  def unused_bits=(_arg0); end
end

class OpenSSL::ASN1::Boolean < ::OpenSSL::ASN1::Primitive; end
OpenSSL::ASN1::CHARACTER_STRING = T.let(T.unsafe(nil), Integer)

class OpenSSL::ASN1::Constructive < ::OpenSSL::ASN1::ASN1Data
  include ::Enumerable
  def initialize(*_arg0); end
  def each; end
  def tagging; end
  def tagging=(_arg0); end
  def to_der; end
end

OpenSSL::ASN1::EMBEDDED_PDV = T.let(T.unsafe(nil), Integer)
OpenSSL::ASN1::ENUMERATED = T.let(T.unsafe(nil), Integer)
OpenSSL::ASN1::EOC = T.let(T.unsafe(nil), Integer)
OpenSSL::ASN1::EXTERNAL = T.let(T.unsafe(nil), Integer)

class OpenSSL::ASN1::EndOfContent < ::OpenSSL::ASN1::ASN1Data
  def initialize; end
  def to_der; end
end

class OpenSSL::ASN1::Enumerated < ::OpenSSL::ASN1::Primitive; end
OpenSSL::ASN1::GENERALIZEDTIME = T.let(T.unsafe(nil), Integer)
OpenSSL::ASN1::GENERALSTRING = T.let(T.unsafe(nil), Integer)
OpenSSL::ASN1::GRAPHICSTRING = T.let(T.unsafe(nil), Integer)
class OpenSSL::ASN1::GeneralString < ::OpenSSL::ASN1::Primitive; end
class OpenSSL::ASN1::GeneralizedTime < ::OpenSSL::ASN1::Primitive; end
class OpenSSL::ASN1::GraphicString < ::OpenSSL::ASN1::Primitive; end
OpenSSL::ASN1::IA5STRING = T.let(T.unsafe(nil), Integer)
class OpenSSL::ASN1::IA5String < ::OpenSSL::ASN1::Primitive; end
OpenSSL::ASN1::INTEGER = T.let(T.unsafe(nil), Integer)
OpenSSL::ASN1::ISO64STRING = T.let(T.unsafe(nil), Integer)
class OpenSSL::ASN1::ISO64String < ::OpenSSL::ASN1::Primitive; end
class OpenSSL::ASN1::Integer < ::OpenSSL::ASN1::Primitive; end
OpenSSL::ASN1::NULL = T.let(T.unsafe(nil), Integer)
OpenSSL::ASN1::NUMERICSTRING = T.let(T.unsafe(nil), Integer)
class OpenSSL::ASN1::Null < ::OpenSSL::ASN1::Primitive; end
class OpenSSL::ASN1::NumericString < ::OpenSSL::ASN1::Primitive; end
OpenSSL::ASN1::OBJECT = T.let(T.unsafe(nil), Integer)
OpenSSL::ASN1::OBJECT_DESCRIPTOR = T.let(T.unsafe(nil), Integer)
OpenSSL::ASN1::OCTET_STRING = T.let(T.unsafe(nil), Integer)

class OpenSSL::ASN1::ObjectId < ::OpenSSL::ASN1::Primitive
  def ==(_arg0); end
  def ln; end
  def long_name; end
  def oid; end
  def short_name; end
  def sn; end
  def self.register(_arg0, _arg1, _arg2); end
end

class OpenSSL::ASN1::OctetString < ::OpenSSL::ASN1::Primitive; end
OpenSSL::ASN1::PRINTABLESTRING = T.let(T.unsafe(nil), Integer)

class OpenSSL::ASN1::Primitive < ::OpenSSL::ASN1::ASN1Data
  def initialize(*_arg0); end
  def tagging; end
  def tagging=(_arg0); end
  def to_der; end
end

class OpenSSL::ASN1::PrintableString < ::OpenSSL::ASN1::Primitive; end
OpenSSL::ASN1::REAL = T.let(T.unsafe(nil), Integer)
OpenSSL::ASN1::RELATIVE_OID = T.let(T.unsafe(nil), Integer)
OpenSSL::ASN1::SEQUENCE = T.let(T.unsafe(nil), Integer)
OpenSSL::ASN1::SET = T.let(T.unsafe(nil), Integer)
class OpenSSL::ASN1::Sequence < ::OpenSSL::ASN1::Constructive; end
class OpenSSL::ASN1::Set < ::OpenSSL::ASN1::Constructive; end
OpenSSL::ASN1::T61STRING = T.let(T.unsafe(nil), Integer)
class OpenSSL::ASN1::T61String < ::OpenSSL::ASN1::Primitive; end
OpenSSL::ASN1::UNIVERSALSTRING = T.let(T.unsafe(nil), Integer)
OpenSSL::ASN1::UNIVERSAL_TAG_NAME = T.let(T.unsafe(nil), Array)
OpenSSL::ASN1::UTCTIME = T.let(T.unsafe(nil), Integer)
class OpenSSL::ASN1::UTCTime < ::OpenSSL::ASN1::Primitive; end
OpenSSL::ASN1::UTF8STRING = T.let(T.unsafe(nil), Integer)
class OpenSSL::ASN1::UTF8String < ::OpenSSL::ASN1::Primitive; end
class OpenSSL::ASN1::UniversalString < ::OpenSSL::ASN1::Primitive; end
OpenSSL::ASN1::VIDEOTEXSTRING = T.let(T.unsafe(nil), Integer)
class OpenSSL::ASN1::VideotexString < ::OpenSSL::ASN1::Primitive; end
OpenSSL::Buffering::BLOCK_SIZE = T.let(T.unsafe(nil), Integer)

class OpenSSL::Buffering::Buffer < ::String
  def initialize; end
  def <<(string); end
  def concat(string); end
end

class OpenSSL::Cipher::AES < ::OpenSSL::Cipher
  def initialize(*args); end
end

class OpenSSL::Cipher::AES128 < ::OpenSSL::Cipher
  def initialize(mode = T.unsafe(nil)); end
end

class OpenSSL::Cipher::AES192 < ::OpenSSL::Cipher
  def initialize(mode = T.unsafe(nil)); end
end

class OpenSSL::Cipher::AES256 < ::OpenSSL::Cipher
  def initialize(mode = T.unsafe(nil)); end
end

class OpenSSL::Cipher::BF < ::OpenSSL::Cipher
  def initialize(*args); end
end

class OpenSSL::Cipher::CAST5 < ::OpenSSL::Cipher
  def initialize(*args); end
end

class OpenSSL::Cipher::Cipher < ::OpenSSL::Cipher; end
class OpenSSL::Cipher::CipherError < ::OpenSSL::OpenSSLError; end

class OpenSSL::Cipher::DES < ::OpenSSL::Cipher
  def initialize(*args); end
end

class OpenSSL::Cipher::IDEA < ::OpenSSL::Cipher
  def initialize(*args); end
end

class OpenSSL::Cipher::RC2 < ::OpenSSL::Cipher
  def initialize(*args); end
end

class OpenSSL::Cipher::RC4 < ::OpenSSL::Cipher
  def initialize(*args); end
end

class OpenSSL::Cipher::RC5 < ::OpenSSL::Cipher
  def initialize(*args); end
end

OpenSSL::Config::DEFAULT_CONFIG_FILE = T.let(T.unsafe(nil), String)
class OpenSSL::Digest::Digest < ::OpenSSL::Digest; end
class OpenSSL::Digest::DigestError < ::OpenSSL::OpenSSLError; end

class OpenSSL::Digest::MD4 < ::OpenSSL::Digest
  def initialize(data = T.unsafe(nil)); end
  def self.digest(data); end
  def self.hexdigest(data); end
end

class OpenSSL::Digest::MD5 < ::OpenSSL::Digest
  def initialize(data = T.unsafe(nil)); end
  def self.digest(data); end
  def self.hexdigest(data); end
end

class OpenSSL::Digest::RIPEMD160 < ::OpenSSL::Digest
  def initialize(data = T.unsafe(nil)); end
  def self.digest(data); end
  def self.hexdigest(data); end
end

class OpenSSL::Digest::SHA1 < ::OpenSSL::Digest
  def initialize(data = T.unsafe(nil)); end
  def self.digest(data); end
  def self.hexdigest(data); end
end

class OpenSSL::Digest::SHA224 < ::OpenSSL::Digest
  def initialize(data = T.unsafe(nil)); end
  def self.digest(data); end
  def self.hexdigest(data); end
end

class OpenSSL::Digest::SHA256 < ::OpenSSL::Digest
  def initialize(data = T.unsafe(nil)); end
  def self.digest(data); end
  def self.hexdigest(data); end
end

class OpenSSL::Digest::SHA384 < ::OpenSSL::Digest
  def initialize(data = T.unsafe(nil)); end
  def self.digest(data); end
  def self.hexdigest(data); end
end

class OpenSSL::Digest::SHA512 < ::OpenSSL::Digest
  def initialize(data = T.unsafe(nil)); end
  def self.digest(data); end
  def self.hexdigest(data); end
end

class OpenSSL::Engine::EngineError < ::OpenSSL::OpenSSLError; end
OpenSSL::Engine::METHOD_ALL = T.let(T.unsafe(nil), Integer)
OpenSSL::Engine::METHOD_CIPHERS = T.let(T.unsafe(nil), Integer)
OpenSSL::Engine::METHOD_DH = T.let(T.unsafe(nil), Integer)
OpenSSL::Engine::METHOD_DIGESTS = T.let(T.unsafe(nil), Integer)
OpenSSL::Engine::METHOD_DSA = T.let(T.unsafe(nil), Integer)
OpenSSL::Engine::METHOD_NONE = T.let(T.unsafe(nil), Integer)
OpenSSL::Engine::METHOD_RAND = T.let(T.unsafe(nil), Integer)
OpenSSL::Engine::METHOD_RSA = T.let(T.unsafe(nil), Integer)
OpenSSL::ExtConfig::HAVE_TLSEXT_HOST_NAME = T.let(T.unsafe(nil), TrueClass)
class OpenSSL::KDF::KDFError < ::OpenSSL::OpenSSLError; end

module OpenSSL::Marshal::ClassMethods
  def _load(string); end
end

class OpenSSL::Netscape::SPKI
  def initialize(*_arg0); end
  def challenge; end
  def challenge=(_arg0); end
  def public_key; end
  def public_key=(_arg0); end
  def sign(_arg0, _arg1); end
  def to_der; end
  def to_pem; end
  def to_s; end
  def to_text; end
  def verify(_arg0); end
end

class OpenSSL::Netscape::SPKIError < ::OpenSSL::OpenSSLError; end

class OpenSSL::OCSP::BasicResponse
  def initialize(*_arg0); end
  def add_nonce(*_arg0); end
  def add_status(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6); end
  def copy_nonce(_arg0); end
  def find_response(_arg0); end
  def responses; end
  def sign(*_arg0); end
  def status; end
  def to_der; end
  def verify(*_arg0); end
  private def initialize_copy(_arg0); end
end

class OpenSSL::OCSP::CertificateId
  def initialize(*_arg0); end
  def cmp(_arg0); end
  def cmp_issuer(_arg0); end
  def hash_algorithm; end
  def issuer_key_hash; end
  def issuer_name_hash; end
  def serial; end
  def to_der; end
  private def initialize_copy(_arg0); end
end

OpenSSL::OCSP::NOCASIGN = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::NOCERTS = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::NOCHAIN = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::NOCHECKS = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::NODELEGATED = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::NOEXPLICIT = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::NOINTERN = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::NOSIGS = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::NOTIME = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::NOVERIFY = T.let(T.unsafe(nil), Integer)
class OpenSSL::OCSP::OCSPError < ::OpenSSL::OpenSSLError; end
OpenSSL::OCSP::RESPID_KEY = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::RESPONSE_STATUS_INTERNALERROR = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::RESPONSE_STATUS_MALFORMEDREQUEST = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::RESPONSE_STATUS_SIGREQUIRED = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::RESPONSE_STATUS_SUCCESSFUL = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::RESPONSE_STATUS_TRYLATER = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::RESPONSE_STATUS_UNAUTHORIZED = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::REVOKED_STATUS_AFFILIATIONCHANGED = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::REVOKED_STATUS_CACOMPROMISE = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::REVOKED_STATUS_CERTIFICATEHOLD = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::REVOKED_STATUS_CESSATIONOFOPERATION = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::REVOKED_STATUS_KEYCOMPROMISE = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::REVOKED_STATUS_NOSTATUS = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::REVOKED_STATUS_REMOVEFROMCRL = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::REVOKED_STATUS_SUPERSEDED = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::REVOKED_STATUS_UNSPECIFIED = T.let(T.unsafe(nil), Integer)

class OpenSSL::OCSP::Request
  def initialize(*_arg0); end
  def add_certid(_arg0); end
  def add_nonce(*_arg0); end
  def certid; end
  def check_nonce(_arg0); end
  def sign(*_arg0); end
  def signed?; end
  def to_der; end
  def verify(*_arg0); end
  private def initialize_copy(_arg0); end
end

class OpenSSL::OCSP::Response
  def initialize(*_arg0); end
  def basic; end
  def status; end
  def status_string; end
  def to_der; end
  private def initialize_copy(_arg0); end
  def self.create(_arg0, _arg1); end
end

class OpenSSL::OCSP::SingleResponse
  def initialize(_arg0); end
  def cert_status; end
  def certid; end
  def check_validity(*_arg0); end
  def extensions; end
  def next_update; end
  def revocation_reason; end
  def revocation_time; end
  def this_update; end
  def to_der; end
  private def initialize_copy(_arg0); end
end

OpenSSL::OCSP::TRUSTOTHER = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::V_CERTSTATUS_GOOD = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::V_CERTSTATUS_REVOKED = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::V_CERTSTATUS_UNKNOWN = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::V_RESPID_KEY = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::V_RESPID_NAME = T.let(T.unsafe(nil), Integer)
class OpenSSL::PKCS12::PKCS12Error < ::OpenSSL::OpenSSLError; end
OpenSSL::PKCS7::BINARY = T.let(T.unsafe(nil), Integer)
OpenSSL::PKCS7::DETACHED = T.let(T.unsafe(nil), Integer)
OpenSSL::PKCS7::NOATTR = T.let(T.unsafe(nil), Integer)
OpenSSL::PKCS7::NOCERTS = T.let(T.unsafe(nil), Integer)
OpenSSL::PKCS7::NOCHAIN = T.let(T.unsafe(nil), Integer)
OpenSSL::PKCS7::NOINTERN = T.let(T.unsafe(nil), Integer)
OpenSSL::PKCS7::NOSIGS = T.let(T.unsafe(nil), Integer)
OpenSSL::PKCS7::NOSMIMECAP = T.let(T.unsafe(nil), Integer)
OpenSSL::PKCS7::NOVERIFY = T.let(T.unsafe(nil), Integer)
class OpenSSL::PKCS7::PKCS7Error < ::OpenSSL::OpenSSLError; end

class OpenSSL::PKCS7::RecipientInfo
  def initialize(_arg0); end
  def enc_key; end
  def issuer; end
  def serial; end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKCS7::SignerInfo
  def initialize(_arg0, _arg1, _arg2); end
  def issuer; end
  def serial; end
  def signed_time; end
end

OpenSSL::PKCS7::TEXT = T.let(T.unsafe(nil), Integer)

class OpenSSL::PKey::DH < ::OpenSSL::PKey::PKey
  include ::OpenSSL::Marshal
  extend ::OpenSSL::Marshal::ClassMethods
  def initialize(*_arg0); end
  def compute_key(_arg0); end
  def export; end
  def g; end
  def generate_key!; end
  def p; end
  def params; end
  def params_ok?; end
  def priv_key; end
  def private?; end
  def pub_key; end
  def public?; end
  def public_key; end
  def q; end
  def set_key(_arg0, _arg1); end
  def set_pqg(_arg0, _arg1, _arg2); end
  def to_der; end
  def to_pem; end
  def to_s; end
  def to_text; end
  private def initialize_copy(_arg0); end
  def self.generate(*_arg0); end
end

class OpenSSL::PKey::DHError < ::OpenSSL::PKey::PKeyError; end

class OpenSSL::PKey::DSA < ::OpenSSL::PKey::PKey
  include ::OpenSSL::Marshal
  extend ::OpenSSL::Marshal::ClassMethods
  def initialize(*_arg0); end
  def export(*_arg0); end
  def g; end
  def p; end
  def params; end
  def priv_key; end
  def private?; end
  def pub_key; end
  def public?; end
  def public_key; end
  def q; end
  def set_key(_arg0, _arg1); end
  def set_pqg(_arg0, _arg1, _arg2); end
  def syssign(_arg0); end
  def sysverify(_arg0, _arg1); end
  def to_der; end
  def to_pem(*_arg0); end
  def to_s(*_arg0); end
  def to_text; end
  private def initialize_copy(_arg0); end
  def self.generate(_arg0); end
end

class OpenSSL::PKey::DSAError < ::OpenSSL::PKey::PKeyError; end

class OpenSSL::PKey::EC < ::OpenSSL::PKey::PKey
  include ::OpenSSL::Marshal
  extend ::OpenSSL::Marshal::ClassMethods
  def initialize(*_arg0); end
  def check_key; end
  def dh_compute_key(_arg0); end
  def dsa_sign_asn1(_arg0); end
  def dsa_verify_asn1(_arg0, _arg1); end
  def export(*_arg0); end
  def generate_key; end
  def generate_key!; end
  def group; end
  def group=(_arg0); end
  def private?; end
  def private_key; end
  def private_key=(_arg0); end
  def private_key?; end
  def public?; end
  def public_key; end
  def public_key=(_arg0); end
  def public_key?; end
  def to_der; end
  def to_pem(*_arg0); end
  def to_text; end
  private def initialize_copy(_arg0); end
  def self.builtin_curves; end
  def self.generate(_arg0); end
end

class OpenSSL::PKey::ECError < ::OpenSSL::PKey::PKeyError; end

class OpenSSL::PKey::PKey
  def initialize; end
  def inspect; end
  def oid; end
  def private_to_der(*_arg0); end
  def private_to_pem(*_arg0); end
  def public_to_der; end
  def public_to_pem; end
  def sign(_arg0, _arg1); end
  def verify(_arg0, _arg1, _arg2); end
end

class OpenSSL::PKey::PKeyError < ::OpenSSL::OpenSSLError; end

class OpenSSL::PKey::RSA < ::OpenSSL::PKey::PKey
  include ::OpenSSL::Marshal
  extend ::OpenSSL::Marshal::ClassMethods
  def initialize(*_arg0); end
  def d; end
  def dmp1; end
  def dmq1; end
  def e; end
  def export(*_arg0); end
  def iqmp; end
  def n; end
  def p; end
  def params; end
  def private?; end
  def private_decrypt(*_arg0); end
  def private_encrypt(*_arg0); end
  def public?; end
  def public_decrypt(*_arg0); end
  def public_encrypt(*_arg0); end
  def public_key; end
  def q; end
  def set_crt_params(_arg0, _arg1, _arg2); end
  def set_factors(_arg0, _arg1); end
  def set_key(_arg0, _arg1, _arg2); end
  def sign_pss(*_arg0); end
  def to_der; end
  def to_pem(*_arg0); end
  def to_s(*_arg0); end
  def to_text; end
  def verify_pss(*_arg0); end
  private def initialize_copy(_arg0); end
  def self.generate(*_arg0); end
end

class OpenSSL::PKey::RSAError < ::OpenSSL::PKey::PKeyError; end
class OpenSSL::Random::RandomError < ::OpenSSL::OpenSSLError; end
OpenSSL::SSL::OP_ALL = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_ALLOW_NO_DHE_KEX = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_CIPHER_SERVER_PREFERENCE = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_CRYPTOPRO_TLSEXT_BUG = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_DONT_INSERT_EMPTY_FRAGMENTS = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_EPHEMERAL_RSA = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_LEGACY_SERVER_CONNECT = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_MICROSOFT_BIG_SSLV3_BUFFER = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_MICROSOFT_SESS_ID_BUG = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_MSIE_SSLV2_RSA_PADDING = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_NETSCAPE_CA_DN_BUG = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_NETSCAPE_CHALLENGE_BUG = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_NO_COMPRESSION = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_NO_ENCRYPT_THEN_MAC = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_NO_RENEGOTIATION = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_NO_SSLv2 = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_NO_SSLv3 = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_NO_TICKET = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_NO_TLSv1 = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_NO_TLSv1_1 = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_NO_TLSv1_2 = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_NO_TLSv1_3 = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_PKCS1_CHECK_1 = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_PKCS1_CHECK_2 = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_SAFARI_ECDHE_ECDSA_BUG = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_SINGLE_DH_USE = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_SINGLE_ECDH_USE = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_SSLEAY_080_CLIENT_DH_BUG = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_SSLREF2_REUSE_CERT_TYPE_BUG = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_TLSEXT_PADDING = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_TLS_BLOCK_PADDING_BUG = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_TLS_D5_BUG = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_TLS_ROLLBACK_BUG = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::SSL2_VERSION = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::SSL3_VERSION = T.let(T.unsafe(nil), Integer)

class OpenSSL::SSL::SSLContext
  def initialize(version = T.unsafe(nil)); end
  def add_certificate(*_arg0); end
  def alpn_protocols; end
  def alpn_protocols=(_arg0); end
  def alpn_select_cb; end
  def alpn_select_cb=(_arg0); end
  def ca_file; end
  def ca_file=(_arg0); end
  def ca_path; end
  def ca_path=(_arg0); end
  def cert; end
  def cert=(_arg0); end
  def cert_store; end
  def cert_store=(_arg0); end
  def ciphers; end
  def ciphers=(_arg0); end
  def client_ca; end
  def client_ca=(_arg0); end
  def client_cert_cb; end
  def client_cert_cb=(_arg0); end
  def ecdh_curves=(_arg0); end
  def enable_fallback_scsv; end
  def extra_chain_cert; end
  def extra_chain_cert=(_arg0); end
  def flush_sessions(*_arg0); end
  def freeze; end
  def key; end
  def key=(_arg0); end
  def max_version=(version); end
  def min_version=(version); end
  def npn_protocols; end
  def npn_protocols=(_arg0); end
  def npn_select_cb; end
  def npn_select_cb=(_arg0); end
  def options; end
  def options=(_arg0); end
  def renegotiation_cb; end
  def renegotiation_cb=(_arg0); end
  def security_level; end
  def security_level=(_arg0); end
  def servername_cb; end
  def servername_cb=(_arg0); end
  def session_add(_arg0); end
  def session_cache_mode; end
  def session_cache_mode=(_arg0); end
  def session_cache_size; end
  def session_cache_size=(_arg0); end
  def session_cache_stats; end
  def session_get_cb; end
  def session_get_cb=(_arg0); end
  def session_id_context; end
  def session_id_context=(_arg0); end
  def session_new_cb; end
  def session_new_cb=(_arg0); end
  def session_remove(_arg0); end
  def session_remove_cb; end
  def session_remove_cb=(_arg0); end
  def set_params(params = T.unsafe(nil)); end
  def setup; end
  def ssl_timeout; end
  def ssl_timeout=(_arg0); end
  def ssl_version=(meth); end
  def timeout; end
  def timeout=(_arg0); end
  def tmp_dh_callback; end
  def tmp_dh_callback=(_arg0); end
  def verify_callback; end
  def verify_callback=(_arg0); end
  def verify_depth; end
  def verify_depth=(_arg0); end
  def verify_hostname; end
  def verify_hostname=(_arg0); end
  def verify_mode; end
  def verify_mode=(_arg0); end
  private def set_minmax_proto_version(_arg0, _arg1); end
end

class OpenSSL::SSL::SSLError < ::OpenSSL::OpenSSLError; end

class OpenSSL::SSL::SSLErrorWaitReadable < ::OpenSSL::SSL::SSLError
  include ::IO::WaitReadable
end

class OpenSSL::SSL::SSLErrorWaitWritable < ::OpenSSL::SSL::SSLError
  include ::IO::WaitWritable
end

class OpenSSL::SSL::SSLServer
  include ::OpenSSL::SSL::SocketForwarder
  def initialize(svr, ctx); end
  def accept; end
  def close; end
  def listen(backlog = T.unsafe(nil)); end
  def shutdown(how = T.unsafe(nil)); end
  def start_immediately; end
  def start_immediately=(_arg0); end
  def to_io; end
end

class OpenSSL::SSL::SSLSocket
  include ::Enumerable
  include ::OpenSSL::Buffering
  include ::OpenSSL::SSL::SocketForwarder
  def initialize(*_arg0); end
  def accept; end
  def accept_nonblock(*_arg0); end
  def alpn_protocol; end
  def cert; end
  def cipher; end
  def client_ca; end
  def connect; end
  def connect_nonblock(*_arg0); end
  def context; end
  def finished_message; end
  def hostname; end
  def hostname=(_arg0); end
  def io; end
  def npn_protocol; end
  def peer_cert; end
  def peer_cert_chain; end
  def peer_finished_message; end
  def pending; end
  def post_connection_check(hostname); end
  def session; end
  def session=(_arg0); end
  def session_reused?; end
  def ssl_version; end
  def state; end
  def sync_close; end
  def sync_close=(_arg0); end
  def sysclose; end
  def sysread(*_arg0); end
  def syswrite(_arg0); end
  def tmp_key; end
  def to_io; end
  def verify_result; end
  private def client_cert_cb; end
  private def session_get_cb; end
  private def session_new_cb; end
  private def stop; end
  private def sysread_nonblock(*_arg0); end
  private def syswrite_nonblock(*_arg0); end
  private def tmp_dh_callback; end
  private def tmp_ecdh_callback; end
  private def using_anon_cipher?; end
  def self.open(remote_host, remote_port, local_host = T.unsafe(nil), local_port = T.unsafe(nil), context: T.unsafe(nil)); end
end

class OpenSSL::SSL::Session
  def initialize(_arg0); end
  def ==(_arg0); end
  def id; end
  def time; end
  def time=(_arg0); end
  def timeout; end
  def timeout=(_arg0); end
  def to_der; end
  def to_pem; end
  def to_text; end
  private def initialize_copy(_arg0); end
end

module OpenSSL::SSL::SocketForwarder
  def addr; end
  def closed?; end
  def do_not_reverse_lookup=(flag); end
  def fcntl(*args); end
  def fileno; end
  def getsockopt(level, optname); end
  def peeraddr; end
  def setsockopt(level, optname, optval); end
end

OpenSSL::SSL::TLS1_1_VERSION = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::TLS1_2_VERSION = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::TLS1_3_VERSION = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::TLS1_VERSION = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::VERIFY_CLIENT_ONCE = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::VERIFY_FAIL_IF_NO_PEER_CERT = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::VERIFY_NONE = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::VERIFY_PEER = T.let(T.unsafe(nil), Integer)

class OpenSSL::Timestamp::Factory
  def additional_certs; end
  def additional_certs=(_arg0); end
  def allowed_digests; end
  def allowed_digests=(_arg0); end
  def create_timestamp(_arg0, _arg1, _arg2); end
  def default_policy_id; end
  def default_policy_id=(_arg0); end
  def gen_time; end
  def gen_time=(_arg0); end
  def serial_number; end
  def serial_number=(_arg0); end
end

class OpenSSL::Timestamp::Request
  def initialize(*_arg0); end
  def algorithm; end
  def algorithm=(_arg0); end
  def cert_requested=(_arg0); end
  def cert_requested?; end
  def message_imprint; end
  def message_imprint=(_arg0); end
  def nonce; end
  def nonce=(_arg0); end
  def policy_id; end
  def policy_id=(_arg0); end
  def to_der; end
  def version; end
  def version=(_arg0); end
end

class OpenSSL::Timestamp::Response
  def initialize(_arg0); end
  def failure_info; end
  def status; end
  def status_text; end
  def to_der; end
  def token; end
  def token_info; end
  def tsa_certificate; end
  def verify(*_arg0); end
end

class OpenSSL::Timestamp::TimestampError < ::OpenSSL::OpenSSLError; end

class OpenSSL::Timestamp::TokenInfo
  def initialize(_arg0); end
  def algorithm; end
  def gen_time; end
  def message_imprint; end
  def nonce; end
  def ordering; end
  def policy_id; end
  def serial_number; end
  def to_der; end
  def version; end
end

class OpenSSL::X509::Attribute
  include ::OpenSSL::Marshal
  extend ::OpenSSL::Marshal::ClassMethods
  def initialize(*_arg0); end
  def ==(other); end
  def oid; end
  def oid=(_arg0); end
  def to_der; end
  def value; end
  def value=(_arg0); end
  private def initialize_copy(_arg0); end
end

class OpenSSL::X509::AttributeError < ::OpenSSL::OpenSSLError; end

class OpenSSL::X509::CRL
  include ::OpenSSL::Marshal
  include ::OpenSSL::X509::Extension::Helpers
  include ::OpenSSL::X509::Extension::AuthorityKeyIdentifier
  extend ::OpenSSL::Marshal::ClassMethods
  def initialize(*_arg0); end
  def ==(other); end
  def add_extension(_arg0); end
  def add_revoked(_arg0); end
  def extensions; end
  def extensions=(_arg0); end
  def issuer; end
  def issuer=(_arg0); end
  def last_update; end
  def last_update=(_arg0); end
  def next_update; end
  def next_update=(_arg0); end
  def revoked; end
  def revoked=(_arg0); end
  def sign(_arg0, _arg1); end
  def signature_algorithm; end
  def to_der; end
  def to_pem; end
  def to_s; end
  def to_text; end
  def verify(_arg0); end
  def version; end
  def version=(_arg0); end
  private def initialize_copy(_arg0); end
end

class OpenSSL::X509::CRLError < ::OpenSSL::OpenSSLError; end

class OpenSSL::X509::Certificate
  include ::OpenSSL::Marshal
  include ::OpenSSL::X509::Extension::Helpers
  include ::OpenSSL::X509::Extension::SubjectKeyIdentifier
  include ::OpenSSL::X509::Extension::AuthorityKeyIdentifier
  include ::OpenSSL::X509::Extension::CRLDistributionPoints
  include ::OpenSSL::X509::Extension::AuthorityInfoAccess
  extend ::OpenSSL::Marshal::ClassMethods
  def initialize(*_arg0); end
  def ==(_arg0); end
  def add_extension(_arg0); end
  def check_private_key(_arg0); end
  def extensions; end
  def extensions=(_arg0); end
  def inspect; end
  def issuer; end
  def issuer=(_arg0); end
  def not_after; end
  def not_after=(_arg0); end
  def not_before; end
  def not_before=(_arg0); end
  def pretty_print(q); end
  def public_key; end
  def public_key=(_arg0); end
  def serial; end
  def serial=(_arg0); end
  def sign(_arg0, _arg1); end
  def signature_algorithm; end
  def subject; end
  def subject=(_arg0); end
  def to_der; end
  def to_pem; end
  def to_s; end
  def to_text; end
  def verify(_arg0); end
  def version; end
  def version=(_arg0); end
  private def initialize_copy(_arg0); end
end

class OpenSSL::X509::CertificateError < ::OpenSSL::OpenSSLError; end
OpenSSL::X509::DEFAULT_CERT_AREA = T.let(T.unsafe(nil), String)
OpenSSL::X509::DEFAULT_CERT_DIR = T.let(T.unsafe(nil), String)
OpenSSL::X509::DEFAULT_CERT_DIR_ENV = T.let(T.unsafe(nil), String)
OpenSSL::X509::DEFAULT_CERT_FILE = T.let(T.unsafe(nil), String)
OpenSSL::X509::DEFAULT_CERT_FILE_ENV = T.let(T.unsafe(nil), String)
OpenSSL::X509::DEFAULT_PRIVATE_DIR = T.let(T.unsafe(nil), String)

class OpenSSL::X509::Extension
  include ::OpenSSL::Marshal
  extend ::OpenSSL::Marshal::ClassMethods
  def initialize(*_arg0); end
  def ==(other); end
  def critical=(_arg0); end
  def critical?; end
  def oid; end
  def oid=(_arg0); end
  def to_a; end
  def to_der; end
  def to_h; end
  def to_s; end
  def value; end
  def value=(_arg0); end
  def value_der; end
  private def initialize_copy(_arg0); end
end

class OpenSSL::X509::ExtensionError < ::OpenSSL::OpenSSLError; end

class OpenSSL::X509::ExtensionFactory
  def initialize(*_arg0); end
  def config; end
  def config=(_arg0); end
  def create_ext(*_arg0); end
  def create_ext_from_array(ary); end
  def create_ext_from_hash(hash); end
  def create_ext_from_string(str); end
  def create_extension(*arg); end
  def crl; end
  def crl=(_arg0); end
  def issuer_certificate; end
  def issuer_certificate=(_arg0); end
  def subject_certificate; end
  def subject_certificate=(_arg0); end
  def subject_request; end
  def subject_request=(_arg0); end
end

class OpenSSL::X509::Name
  include ::Comparable
  include ::OpenSSL::Marshal
  extend ::OpenSSL::Marshal::ClassMethods
  def initialize(*_arg0); end
  def <=>(_arg0); end
  def add_entry(*_arg0); end
  def cmp(_arg0); end
  def eql?(_arg0); end
  def hash; end
  def hash_old; end
  def inspect; end
  def pretty_print(q); end
  def to_a; end
  def to_der; end
  def to_s(*_arg0); end
  def to_utf8; end
  private def initialize_copy(_arg0); end
  def self.parse(str, template = T.unsafe(nil)); end
  def self.parse_openssl(str, template = T.unsafe(nil)); end
  def self.parse_rfc2253(str, template = T.unsafe(nil)); end
end

class OpenSSL::X509::NameError < ::OpenSSL::OpenSSLError; end
OpenSSL::X509::PURPOSE_ANY = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::PURPOSE_CRL_SIGN = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::PURPOSE_NS_SSL_SERVER = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::PURPOSE_OCSP_HELPER = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::PURPOSE_SMIME_ENCRYPT = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::PURPOSE_SMIME_SIGN = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::PURPOSE_SSL_CLIENT = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::PURPOSE_SSL_SERVER = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::PURPOSE_TIMESTAMP_SIGN = T.let(T.unsafe(nil), Integer)

class OpenSSL::X509::Request
  include ::OpenSSL::Marshal
  extend ::OpenSSL::Marshal::ClassMethods
  def initialize(*_arg0); end
  def ==(other); end
  def add_attribute(_arg0); end
  def attributes; end
  def attributes=(_arg0); end
  def public_key; end
  def public_key=(_arg0); end
  def sign(_arg0, _arg1); end
  def signature_algorithm; end
  def subject; end
  def subject=(_arg0); end
  def to_der; end
  def to_pem; end
  def to_s; end
  def to_text; end
  def verify(_arg0); end
  def version; end
  def version=(_arg0); end
  private def initialize_copy(_arg0); end
end

class OpenSSL::X509::RequestError < ::OpenSSL::OpenSSLError; end

class OpenSSL::X509::Revoked
  def initialize(*_arg0); end
  def ==(other); end
  def add_extension(_arg0); end
  def extensions; end
  def extensions=(_arg0); end
  def serial; end
  def serial=(_arg0); end
  def time; end
  def time=(_arg0); end
  def to_der; end
  private def initialize_copy(_arg0); end
end

class OpenSSL::X509::RevokedError < ::OpenSSL::OpenSSLError; end

class OpenSSL::X509::Store
  def initialize(*_arg0); end
  def add_cert(_arg0); end
  def add_crl(_arg0); end
  def add_file(_arg0); end
  def add_path(_arg0); end
  def chain; end
  def error; end
  def error_string; end
  def flags=(_arg0); end
  def purpose=(_arg0); end
  def set_default_paths; end
  def time=(_arg0); end
  def trust=(_arg0); end
  def verify(*_arg0); end
  def verify_callback; end
  def verify_callback=(_arg0); end
end

class OpenSSL::X509::StoreContext
  def initialize(*_arg0); end
  def chain; end
  def cleanup; end
  def current_cert; end
  def current_crl; end
  def error; end
  def error=(_arg0); end
  def error_depth; end
  def error_string; end
  def flags=(_arg0); end
  def purpose=(_arg0); end
  def time=(_arg0); end
  def trust=(_arg0); end
  def verify; end
end

class OpenSSL::X509::StoreError < ::OpenSSL::OpenSSLError; end
OpenSSL::X509::TRUST_COMPAT = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::TRUST_EMAIL = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::TRUST_OBJECT_SIGN = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::TRUST_OCSP_REQUEST = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::TRUST_OCSP_SIGN = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::TRUST_SSL_CLIENT = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::TRUST_SSL_SERVER = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::TRUST_TSA = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_AKID_ISSUER_SERIAL_MISMATCH = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_AKID_SKID_MISMATCH = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_APPLICATION_VERIFICATION = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_CA_KEY_TOO_SMALL = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_CA_MD_TOO_WEAK = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_CERT_CHAIN_TOO_LONG = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_CERT_HAS_EXPIRED = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_CERT_NOT_YET_VALID = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_CERT_REJECTED = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_CERT_REVOKED = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_CERT_SIGNATURE_FAILURE = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_CERT_UNTRUSTED = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_CRL_HAS_EXPIRED = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_CRL_NOT_YET_VALID = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_CRL_PATH_VALIDATION_ERROR = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_CRL_SIGNATURE_FAILURE = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_DANE_NO_MATCH = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_DIFFERENT_CRL_SCOPE = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_EE_KEY_TOO_SMALL = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_EMAIL_MISMATCH = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_EXCLUDED_VIOLATION = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_HOSTNAME_MISMATCH = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_INVALID_CA = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_INVALID_CALL = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_INVALID_EXTENSION = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_INVALID_NON_CA = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_INVALID_POLICY_EXTENSION = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_INVALID_PURPOSE = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_IP_ADDRESS_MISMATCH = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_KEYUSAGE_NO_CERTSIGN = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_KEYUSAGE_NO_CRL_SIGN = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_NO_EXPLICIT_POLICY = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_NO_VALID_SCTS = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_OCSP_CERT_UNKNOWN = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_OCSP_VERIFY_FAILED = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_OCSP_VERIFY_NEEDED = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_OUT_OF_MEM = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_PATH_LENGTH_EXCEEDED = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_PATH_LOOP = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_PERMITTED_VIOLATION = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_PROXY_PATH_LENGTH_EXCEEDED = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_PROXY_SUBJECT_NAME_VIOLATION = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_SELF_SIGNED_CERT_IN_CHAIN = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_STORE_LOOKUP = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_SUBJECT_ISSUER_MISMATCH = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_SUBTREE_MINMAX = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256 = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_SUITE_B_INVALID_ALGORITHM = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_SUITE_B_INVALID_CURVE = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_SUITE_B_INVALID_VERSION = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_SUITE_B_LOS_NOT_ALLOWED = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_UNABLE_TO_GET_CRL = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_UNABLE_TO_GET_CRL_ISSUER = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_UNABLE_TO_GET_ISSUER_CERT = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_UNHANDLED_CRITICAL_EXTENSION = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_UNNESTED_RESOURCE = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_UNSPECIFIED = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_UNSUPPORTED_CONSTRAINT_TYPE = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_UNSUPPORTED_EXTENSION_FEATURE = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_UNSUPPORTED_NAME_SYNTAX = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_ALLOW_PROXY_CERTS = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_CHECK_SS_SIGNATURE = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_CRL_CHECK = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_CRL_CHECK_ALL = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_EXPLICIT_POLICY = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_EXTENDED_CRL_SUPPORT = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_IGNORE_CRITICAL = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_INHIBIT_ANY = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_INHIBIT_MAP = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_NOTIFY_POLICY = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_NO_ALT_CHAINS = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_NO_CHECK_TIME = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_PARTIAL_CHAIN = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_POLICY_CHECK = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_SUITEB_128_LOS = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_SUITEB_128_LOS_ONLY = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_SUITEB_192_LOS = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_TRUSTED_FIRST = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_USE_CHECK_TIME = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_USE_DELTAS = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_X509_STRICT = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_OK = T.let(T.unsafe(nil), Integer)

class Struct
  include ::Enumerable
  def initialize(*_arg0); end
  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def deconstruct; end
  def deconstruct_keys(_arg0); end
  def dig(*_arg0); end
  def each; end
  def each_pair; end
  def eql?(_arg0); end
  def filter(*_arg0); end
  def hash; end
  def inspect; end
  def length; end
  def members; end
  def select(*_arg0); end
  def size; end
  def to_a; end
  def to_h; end
  def to_s; end
  def values; end
  def values_at(*_arg0); end
  private def initialize_copy(_arg0); end
  def self.new(*_arg0); end
end

FileUtils::Entry_::DIRECTORY_TERM = T.let(T.unsafe(nil), String)
FileUtils::Entry_::S_IF_DOOR = T.let(T.unsafe(nil), Integer)
DRb::DRbConn::POOL_SIZE = T.let(T.unsafe(nil), Integer)
class RuntimeError < ::StandardError; end

class DRb::DRbSSLSocket::SSLConfig
  def initialize(config); end
  def [](key); end
  def accept(tcp); end
  def connect(tcp); end
  def setup_certificate; end
  def setup_ssl_context; end
end

DRb::DRbServer::INSECURE_METHOD = T.let(T.unsafe(nil), Array)

class DRb::DRbServer::InvokeMethod
  include ::DRb::DRbServer::InvokeMethod18Mixin
  def initialize(drb_server, client); end
  def perform; end
  private def check_insecure_method; end
  private def init_with_client; end
  private def perform_without_block; end
  private def setup_message; end
end

module DRb::DRbServer::InvokeMethod18Mixin
  def block_yield(x); end
  def perform_with_block; end
end

DRb::DRbUNIXSocket::Max_try = T.let(T.unsafe(nil), Integer)

class DRb::TimerIdConv::TimerHolder2
  include ::MonitorMixin
  def initialize(keeping = T.unsafe(nil)); end
  def add(obj); end
  def fetch(key); end
  private def invoke_keeper; end
  private def on_gc; end
  private def peek(key); end
  private def rotate; end
end

class DRb::WeakIdConv::WeakSet
  include ::MonitorMixin
  def initialize; end
  def add(obj); end
  def fetch(ref); end
end

class ArgumentError < ::StandardError; end
Socket::Constants::AF_APPLETALK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_CCITT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_CHAOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_CNT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_COIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_DATAKIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_DLI = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_E164 = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_ECMA = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_HYLINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_IMPLINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_INET = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_INET6 = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_IPX = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_ISDN = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_ISO = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_LAT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_LINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_LOCAL = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_MAX = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_NATM = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_NDRV = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_NETBIOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_NS = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_OSI = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_PPP = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_PUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_ROUTE = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_SIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_SNA = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_UNIX = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_UNSPEC = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_ADDRCONFIG = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_ALL = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_CANONNAME = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_DEFAULT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_MASK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_NUMERICHOST = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_NUMERICSERV = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_PASSIVE = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_V4MAPPED = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_V4MAPPED_CFG = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_ADDRFAMILY = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_AGAIN = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_BADFLAGS = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_BADHINTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_FAIL = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_FAMILY = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_MAX = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_MEMORY = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_NODATA = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_NONAME = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_OVERFLOW = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_PROTOCOL = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_SERVICE = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_SOCKTYPE = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_ALLMULTI = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_ALTPHYS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_DEBUG = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_LINK0 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_LINK1 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_LINK2 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_LOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_MULTICAST = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_NOARP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_NOTRAILERS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_OACTIVE = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_POINTOPOINT = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_PROMISC = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_RUNNING = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_SIMPLEX = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_UP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFNAMSIZ = T.let(T.unsafe(nil), Integer)
Socket::Constants::IF_NAMESIZE = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_ALLHOSTS_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_ANY = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_LOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_MAX_LOCAL_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_NONE = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_UNSPEC_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::INET6_ADDRSTRLEN = T.let(T.unsafe(nil), Integer)
Socket::Constants::INET_ADDRSTRLEN = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPORT_RESERVED = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPORT_USERRESERVED = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_AH = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_DSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_EGP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_EON = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ESP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_FRAGMENT = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_GGP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_HELLO = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_HOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ICMP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ICMPV6 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_IDP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_IGMP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_IP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_IPV6 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_MAX = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ND = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_NONE = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_PUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_RAW = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ROUTING = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_TCP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_TP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_UDP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_XTP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_CHECKSUM = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_DONTFRAG = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_DSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_HOPLIMIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_HOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_JOIN_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_LEAVE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_MULTICAST_HOPS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_MULTICAST_IF = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_NEXTHOP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_PATHMTU = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_PKTINFO = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVDSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVHOPLIMIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVHOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVPATHMTU = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVPKTINFO = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVRTHDR = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVTCLASS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RTHDR = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RTHDRDSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RTHDR_TYPE_0 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_TCLASS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_UNICAST_HOPS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_USE_MIN_MTU = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_V6ONLY = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_ADD_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_ADD_SOURCE_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_BLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DEFAULT_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DEFAULT_MULTICAST_TTL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DONTFRAG = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DROP_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DROP_SOURCE_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_HDRINCL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_IPSEC_POLICY = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MAX_MEMBERSHIPS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MSFILTER = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MULTICAST_IF = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MULTICAST_TTL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_OPTIONS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_PKTINFO = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_PORTRANGE = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVDSTADDR = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVIF = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVRETOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVTOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVTTL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RETOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_TOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_TTL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_UNBLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::Constants::LOCAL_PEERCRED = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_BLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_EXCLUDE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_INCLUDE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_JOIN_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_JOIN_SOURCE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_LEAVE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_LEAVE_SOURCE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_UNBLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_CTRUNC = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_DONTROUTE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_DONTWAIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_EOF = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_EOR = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_FLUSH = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_HAVEMORE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_HOLD = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_NOSIGNAL = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_OOB = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_PEEK = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_RCVMORE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_SEND = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_TRUNC = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_WAITALL = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_DGRAM = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_MAXHOST = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_MAXSERV = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_NAMEREQD = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_NOFQDN = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_NUMERICHOST = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_NUMERICSERV = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_APPLETALK = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_CCITT = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_CHAOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_CNT = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_COIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_DATAKIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_DLI = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_ECMA = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_HYLINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_IMPLINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_INET = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_INET6 = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_IPX = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_ISDN = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_ISO = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_KEY = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_LAT = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_LINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_LOCAL = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_MAX = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_NATM = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_NDRV = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_NETBIOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_NS = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_OSI = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_PIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_PPP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_PUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_ROUTE = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_RTIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_SIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_SNA = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_UNIX = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_UNSPEC = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_XTP = T.let(T.unsafe(nil), Integer)
Socket::Constants::SCM_CREDS = T.let(T.unsafe(nil), Integer)
Socket::Constants::SCM_RIGHTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::SCM_TIMESTAMP = T.let(T.unsafe(nil), Integer)
Socket::Constants::SHUT_RD = T.let(T.unsafe(nil), Integer)
Socket::Constants::SHUT_RDWR = T.let(T.unsafe(nil), Integer)
Socket::Constants::SHUT_WR = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_DGRAM = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_RAW = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_RDM = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_SEQPACKET = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_STREAM = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOL_SOCKET = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOMAXCONN = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_ACCEPTCONN = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_DEBUG = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_DONTROUTE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_DONTTRUNC = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_ERROR = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_KEEPALIVE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_LINGER = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_NKE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_NOSIGPIPE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_NREAD = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_OOBINLINE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_RCVBUF = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_RCVLOWAT = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_RCVTIMEO = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_REUSEADDR = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_REUSEPORT = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_SNDBUF = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_SNDLOWAT = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_SNDTIMEO = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_TIMESTAMP = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_TYPE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_USELOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_WANTMORE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_WANTOOBFLAG = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_FASTOPEN = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_KEEPCNT = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_KEEPINTVL = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_MAXSEG = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_NODELAY = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_NOOPT = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_NOPUSH = T.let(T.unsafe(nil), Integer)
module File::Constants; end

module MonitorMixin
  def initialize(*_arg0, &_arg1); end
  def mon_enter; end
  def mon_exit; end
  def mon_locked?; end
  def mon_owned?; end
  def mon_synchronize(&b); end
  def mon_try_enter; end
  def new_cond; end
  def synchronize(&b); end
  def try_mon_enter; end
  private def mon_check_owner; end
  private def mon_initialize; end
  def self.extend_object(obj); end
end

class Errno::EAGAIN < ::SystemCallError; end
class Errno::EINPROGRESS < ::SystemCallError; end

class String
  include ::Comparable
  include ::JSON::Ext::Generator::GeneratorMethods::String
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend
  def initialize(*_arg0); end
  def %(_arg0); end
  def *(_arg0); end
  def +(_arg0); end
  def +@; end
  def -@; end
  def <<(_arg0); end
  def <=>(_arg0); end
  def ==(_arg0); end
  def ===(_arg0); end
  def =~(_arg0); end
  def [](*_arg0); end
  def []=(*_arg0); end
  def ascii_only?; end
  def b; end
  def bytes; end
  def bytesize; end
  def byteslice(*_arg0); end
  def capitalize(*_arg0); end
  def capitalize!(*_arg0); end
  def casecmp(_arg0); end
  def casecmp?(_arg0); end
  def center(*_arg0); end
  def chars; end
  def chomp(*_arg0); end
  def chomp!(*_arg0); end
  def chop; end
  def chop!; end
  def chr; end
  def clear; end
  def codepoints; end
  def concat(*_arg0); end
  def count(*_arg0); end
  def crypt(_arg0); end
  def delete(*_arg0); end
  def delete!(*_arg0); end
  def delete_prefix(_arg0); end
  def delete_prefix!(_arg0); end
  def delete_suffix(_arg0); end
  def delete_suffix!(_arg0); end
  def downcase(*_arg0); end
  def downcase!(*_arg0); end
  def dump; end
  def each_byte; end
  def each_char; end
  def each_codepoint; end
  def each_grapheme_cluster; end
  def each_line(*_arg0); end
  def empty?; end
  def encode(*_arg0); end
  def encode!(*_arg0); end
  def encoding; end
  def end_with?(*_arg0); end
  def eql?(_arg0); end
  def force_encoding(_arg0); end
  def freeze; end
  def getbyte(_arg0); end
  def grapheme_clusters; end
  def gsub(*_arg0); end
  def gsub!(*_arg0); end
  def hash; end
  def hex; end
  def include?(_arg0); end
  def index(*_arg0); end
  def insert(_arg0, _arg1); end
  def inspect; end
  def intern; end
  def length; end
  def lines(*_arg0); end
  def ljust(*_arg0); end
  def lstrip; end
  def lstrip!; end
  def match(*_arg0); end
  def match?(*_arg0); end
  def next; end
  def next!; end
  def oct; end
  def ord; end
  def partition(_arg0); end
  def prepend(*_arg0); end
  def replace(_arg0); end
  def reverse; end
  def reverse!; end
  def rindex(*_arg0); end
  def rjust(*_arg0); end
  def rpartition(_arg0); end
  def rstrip; end
  def rstrip!; end
  def scan(_arg0); end
  def scrub(*_arg0); end
  def scrub!(*_arg0); end
  def setbyte(_arg0, _arg1); end
  def shell_split; end
  def shellescape; end
  def shellsplit; end
  def size; end
  def slice(*_arg0); end
  def slice!(*_arg0); end
  def split(*_arg0); end
  def squeeze(*_arg0); end
  def squeeze!(*_arg0); end
  def start_with?(*_arg0); end
  def strip; end
  def strip!; end
  def sub(*_arg0); end
  def sub!(*_arg0); end
  def succ; end
  def succ!; end
  def sum(*_arg0); end
  def swapcase(*_arg0); end
  def swapcase!(*_arg0); end
  def to_c; end
  def to_d; end
  def to_f; end
  def to_i(*_arg0); end
  def to_r; end
  def to_s; end
  def to_str; end
  def to_sym; end
  def tr(_arg0, _arg1); end
  def tr!(_arg0, _arg1); end
  def tr_s(_arg0, _arg1); end
  def tr_s!(_arg0, _arg1); end
  def undump; end
  def unicode_normalize(*_arg0); end
  def unicode_normalize!(*_arg0); end
  def unicode_normalized?(*_arg0); end
  def unpack(fmt); end
  def unpack1(fmt); end
  def upcase(*_arg0); end
  def upcase!(*_arg0); end
  def upto(*_arg0); end
  def valid_encoding?; end
  private def initialize_copy(_arg0); end
  def self.try_convert(_arg0); end
end

OpenSSL::Buffering::Buffer::BINARY = T.let(T.unsafe(nil), Encoding)
OpenSSL::PKey::EC::EXPLICIT_CURVE = T.let(T.unsafe(nil), Integer)

class OpenSSL::PKey::EC::Group
  def initialize(*_arg0); end
  def ==(_arg0); end
  def asn1_flag; end
  def asn1_flag=(_arg0); end
  def cofactor; end
  def curve_name; end
  def degree; end
  def eql?(_arg0); end
  def generator; end
  def order; end
  def point_conversion_form; end
  def point_conversion_form=(_arg0); end
  def seed; end
  def seed=(_arg0); end
  def set_generator(_arg0, _arg1, _arg2); end
  def to_der; end
  def to_pem; end
  def to_text; end
  private def initialize_copy(_arg0); end
end

OpenSSL::PKey::EC::NAMED_CURVE = T.let(T.unsafe(nil), Integer)

class OpenSSL::PKey::EC::Point
  def initialize(*_arg0); end
  def ==(_arg0); end
  def add(_arg0); end
  def eql?(_arg0); end
  def group; end
  def infinity?; end
  def invert!; end
  def make_affine!; end
  def mul(*_arg0); end
  def on_curve?; end
  def set_to_infinity!; end
  def to_bn(conversion_form = T.unsafe(nil)); end
  def to_octet_string(_arg0); end
  private def initialize_copy(_arg0); end
end

OpenSSL::PKey::RSA::NO_PADDING = T.let(T.unsafe(nil), Integer)
OpenSSL::PKey::RSA::PKCS1_OAEP_PADDING = T.let(T.unsafe(nil), Integer)
OpenSSL::PKey::RSA::PKCS1_PADDING = T.let(T.unsafe(nil), Integer)
OpenSSL::PKey::RSA::SSLV23_PADDING = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::SSLContext::DEFAULT_CERT_STORE = T.let(T.unsafe(nil), OpenSSL::X509::Store)
OpenSSL::SSL::SSLContext::DEFAULT_PARAMS = T.let(T.unsafe(nil), Hash)
OpenSSL::SSL::SSLContext::DEFAULT_TMP_DH_CALLBACK = T.let(T.unsafe(nil), Proc)
OpenSSL::SSL::SSLContext::METHODS = T.let(T.unsafe(nil), Array)
OpenSSL::SSL::SSLContext::SESSION_CACHE_BOTH = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::SSLContext::SESSION_CACHE_CLIENT = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::SSLContext::SESSION_CACHE_NO_AUTO_CLEAR = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::SSLContext::SESSION_CACHE_NO_INTERNAL = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::SSLContext::SESSION_CACHE_NO_INTERNAL_LOOKUP = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::SSLContext::SESSION_CACHE_NO_INTERNAL_STORE = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::SSLContext::SESSION_CACHE_OFF = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::SSLContext::SESSION_CACHE_SERVER = T.let(T.unsafe(nil), Integer)
class OpenSSL::SSL::Session::SessionError < ::OpenSSL::OpenSSLError; end
OpenSSL::Timestamp::Response::GRANTED = T.let(T.unsafe(nil), Integer)
OpenSSL::Timestamp::Response::GRANTED_WITH_MODS = T.let(T.unsafe(nil), Integer)
OpenSSL::Timestamp::Response::REJECTION = T.let(T.unsafe(nil), Integer)
OpenSSL::Timestamp::Response::REVOCATION_NOTIFICATION = T.let(T.unsafe(nil), Integer)
OpenSSL::Timestamp::Response::REVOCATION_WARNING = T.let(T.unsafe(nil), Integer)
OpenSSL::Timestamp::Response::WAITING = T.let(T.unsafe(nil), Integer)

module OpenSSL::X509::Extension::AuthorityInfoAccess
  include ::OpenSSL::X509::Extension::Helpers
  def ca_issuer_uris; end
  def ocsp_uris; end
  private def parse_aia_asn1; end
end

module OpenSSL::X509::Extension::AuthorityKeyIdentifier
  include ::OpenSSL::X509::Extension::Helpers
  def authority_key_identifier; end
end

module OpenSSL::X509::Extension::CRLDistributionPoints
  include ::OpenSSL::X509::Extension::Helpers
  def crl_uris; end
end

module OpenSSL::X509::Extension::Helpers
  def find_extension(oid); end
end

module OpenSSL::X509::Extension::SubjectKeyIdentifier
  include ::OpenSSL::X509::Extension::Helpers
  def subject_key_identifier; end
end

OpenSSL::X509::Name::COMPAT = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::Name::DEFAULT_OBJECT_TYPE = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::Name::MULTILINE = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::Name::OBJECT_TYPE_TEMPLATE = T.let(T.unsafe(nil), Hash)
OpenSSL::X509::Name::ONELINE = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::Name::RFC2253 = T.let(T.unsafe(nil), Integer)

module OpenSSL::X509::Name::RFC2253DN
  private def expand_hexstring(str); end
  private def expand_pair(str); end
  private def expand_value(str1, str2, str3); end
  private def scan(dn); end
  def self.expand_hexstring(str); end
  def self.expand_pair(str); end
  def self.expand_value(str1, str2, str3); end
  def self.scan(dn); end
end

Struct::Group = Etc::Group
Struct::Passwd = Etc::Passwd
DRb::DRbSSLSocket::SSLConfig::DEFAULT = T.let(T.unsafe(nil), Hash)
class DRb::TimerIdConv::TimerHolder2::InvalidIndexError < ::RuntimeError; end
File::Constants::APPEND = T.let(T.unsafe(nil), Integer)
File::Constants::BINARY = T.let(T.unsafe(nil), Integer)
File::Constants::CREAT = T.let(T.unsafe(nil), Integer)
File::Constants::DSYNC = T.let(T.unsafe(nil), Integer)
File::Constants::EXCL = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_CASEFOLD = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_DOTMATCH = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_EXTGLOB = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_NOESCAPE = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_PATHNAME = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_SHORTNAME = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_SYSCASE = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_EX = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_NB = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_SH = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_UN = T.let(T.unsafe(nil), Integer)
File::Constants::NOCTTY = T.let(T.unsafe(nil), Integer)
File::Constants::NOFOLLOW = T.let(T.unsafe(nil), Integer)
File::Constants::NONBLOCK = T.let(T.unsafe(nil), Integer)
File::Constants::NULL = T.let(T.unsafe(nil), String)
File::Constants::RDONLY = T.let(T.unsafe(nil), Integer)
File::Constants::RDWR = T.let(T.unsafe(nil), Integer)
File::Constants::SHARE_DELETE = T.let(T.unsafe(nil), Integer)
File::Constants::SYNC = T.let(T.unsafe(nil), Integer)
File::Constants::TRUNC = T.let(T.unsafe(nil), Integer)
File::Constants::WRONLY = T.let(T.unsafe(nil), Integer)

class MonitorMixin::ConditionVariable
  def initialize(monitor); end
  def broadcast; end
  def signal; end
  def wait(timeout = T.unsafe(nil)); end
  def wait_until; end
  def wait_while; end
end

class SystemCallError < ::StandardError
  def initialize(*_arg0); end
  def errno; end
  def self.===(_arg0); end
end

Errno::EAGAIN::Errno = T.let(T.unsafe(nil), Integer)
Errno::EINPROGRESS::Errno = T.let(T.unsafe(nil), Integer)
class OpenSSL::PKey::EC::Group::Error < ::OpenSSL::OpenSSLError; end
class OpenSSL::PKey::EC::Point::Error < ::OpenSSL::OpenSSLError; end
OpenSSL::X509::Name::RFC2253DN::AttributeType = T.let(T.unsafe(nil), Regexp)
OpenSSL::X509::Name::RFC2253DN::AttributeValue = T.let(T.unsafe(nil), Regexp)
OpenSSL::X509::Name::RFC2253DN::HexChar = T.let(T.unsafe(nil), Regexp)
OpenSSL::X509::Name::RFC2253DN::HexPair = T.let(T.unsafe(nil), Regexp)
OpenSSL::X509::Name::RFC2253DN::HexString = T.let(T.unsafe(nil), Regexp)
OpenSSL::X509::Name::RFC2253DN::Pair = T.let(T.unsafe(nil), Regexp)
OpenSSL::X509::Name::RFC2253DN::QuoteChar = T.let(T.unsafe(nil), Regexp)
OpenSSL::X509::Name::RFC2253DN::Special = T.let(T.unsafe(nil), String)
OpenSSL::X509::Name::RFC2253DN::StringChar = T.let(T.unsafe(nil), Regexp)
OpenSSL::X509::Name::RFC2253DN::TypeAndValue = T.let(T.unsafe(nil), Regexp)

module JSON::Ext::Generator::GeneratorMethods::String
  mixes_in_class_methods ::JSON::Ext::Generator::GeneratorMethods::String::Extend
  def to_json(*_arg0); end
  def to_json_raw(*_arg0); end
  def to_json_raw_object; end
  def self.included(_arg0); end
end

module JSON::Ext::Generator::GeneratorMethods::String::Extend
  def json_create(_arg0); end
end
class CGI
  include ::CGI::Util
  include ::CGI::Escape
  extend ::CGI::Util
  extend ::CGI::Escape
  def initialize(options = T.unsafe(nil), &block); end
  def accept_charset; end
  def header(options = T.unsafe(nil)); end
  def http_header(options = T.unsafe(nil)); end
  def nph?; end
  def out(options = T.unsafe(nil)); end
  def print(*options); end
  private def _header_for_hash(options); end
  private def _header_for_modruby(buf); end
  private def _header_for_string(content_type); end
  private def env_table; end
  private def stdinput; end
  private def stdoutput; end
  def self.accept_charset; end
  def self.accept_charset=(accept_charset); end
  def self.parse(query); end
end

ScanError = StringScanner::Error

class ERB
  def initialize(str, safe_level = T.unsafe(nil), legacy_trim_mode = T.unsafe(nil), legacy_eoutvar = T.unsafe(nil), trim_mode: T.unsafe(nil), eoutvar: T.unsafe(nil)); end
  def def_class(superklass = T.unsafe(nil), methodname = T.unsafe(nil)); end
  def def_method(mod, methodname, fname = T.unsafe(nil)); end
  def def_module(methodname = T.unsafe(nil)); end
  def encoding; end
  def filename; end
  def filename=(_arg0); end
  def lineno; end
  def lineno=(_arg0); end
  def location=(_arg0); end
  def make_compiler(trim_mode); end
  def result(b = T.unsafe(nil)); end
  def result_with_hash(hash); end
  def run(b = T.unsafe(nil)); end
  def set_eoutvar(compiler, eoutvar = T.unsafe(nil)); end
  def src; end
  private def new_toplevel(vars = T.unsafe(nil)); end
  def self.version; end
end

class StringScanner
  def initialize(*_arg0); end
  def <<(_arg0); end
  def [](_arg0); end
  def beginning_of_line?; end
  def bol?; end
  def captures; end
  def charpos; end
  def check(_arg0); end
  def check_until(_arg0); end
  def clear; end
  def concat(_arg0); end
  def empty?; end
  def eos?; end
  def exist?(_arg0); end
  def fixed_anchor?; end
  def get_byte; end
  def getbyte; end
  def getch; end
  def inspect; end
  def match?(_arg0); end
  def matched; end
  def matched?; end
  def matched_size; end
  def peek(_arg0); end
  def peep(_arg0); end
  def pointer; end
  def pointer=(_arg0); end
  def pos; end
  def pos=(_arg0); end
  def post_match; end
  def pre_match; end
  def reset; end
  def rest; end
  def rest?; end
  def rest_size; end
  def restsize; end
  def scan(_arg0); end
  def scan_full(_arg0, _arg1, _arg2); end
  def scan_until(_arg0); end
  def search_full(_arg0, _arg1, _arg2); end
  def size; end
  def skip(_arg0); end
  def skip_until(_arg0); end
  def string; end
  def string=(_arg0); end
  def terminate; end
  def unscan; end
  def values_at(*_arg0); end
  private def initialize_copy(_arg0); end
  def self.must_C_version; end
end

CGI::CR = T.let(T.unsafe(nil), String)

class CGI::Cookie < ::Array
  def initialize(name = T.unsafe(nil), *value); end
  def domain; end
  def domain=(_arg0); end
  def expires; end
  def expires=(_arg0); end
  def httponly; end
  def httponly=(val); end
  def inspect; end
  def name; end
  def name=(_arg0); end
  def path; end
  def path=(_arg0); end
  def secure; end
  def secure=(val); end
  def to_s; end
  def value; end
  def value=(val); end
  def self.parse(raw_cookie); end
end

CGI::EOL = T.let(T.unsafe(nil), String)

module CGI::Escape
  def escape(_arg0); end
  def escapeHTML(_arg0); end
  def unescape(*_arg0); end
  def unescapeHTML(_arg0); end
end

class CGI::HTML3
  include ::CGI::TagMaker
  include ::CGI::Html3
  include ::CGI::HtmlExtension
end

class CGI::HTML4
  include ::CGI::TagMaker
  include ::CGI::Html4
  include ::CGI::HtmlExtension
end

class CGI::HTML4Fr
  include ::CGI::TagMaker
  include ::CGI::Html4Tr
  include ::CGI::Html4Fr
  include ::CGI::HtmlExtension
end

class CGI::HTML4Tr
  include ::CGI::TagMaker
  include ::CGI::Html4Tr
  include ::CGI::HtmlExtension
end

class CGI::HTML5
  include ::CGI::TagMaker
  include ::CGI::Html5
  include ::CGI::HtmlExtension
end

CGI::HTTP_STATUS = T.let(T.unsafe(nil), Hash)

module CGI::Html3
  include ::CGI::TagMaker
  def a(attributes = T.unsafe(nil), &block); end
  def address(attributes = T.unsafe(nil), &block); end
  def applet(attributes = T.unsafe(nil), &block); end
  def area(attributes = T.unsafe(nil), &block); end
  def b(attributes = T.unsafe(nil), &block); end
  def base(attributes = T.unsafe(nil), &block); end
  def basefont(attributes = T.unsafe(nil), &block); end
  def big(attributes = T.unsafe(nil), &block); end
  def blockquote(attributes = T.unsafe(nil), &block); end
  def body(attributes = T.unsafe(nil), &block); end
  def br(attributes = T.unsafe(nil), &block); end
  def caption(attributes = T.unsafe(nil), &block); end
  def center(attributes = T.unsafe(nil), &block); end
  def cite(attributes = T.unsafe(nil), &block); end
  def code(attributes = T.unsafe(nil), &block); end
  def dd(attributes = T.unsafe(nil), &block); end
  def dfn(attributes = T.unsafe(nil), &block); end
  def dir(attributes = T.unsafe(nil), &block); end
  def div(attributes = T.unsafe(nil), &block); end
  def dl(attributes = T.unsafe(nil), &block); end
  def doctype; end
  def dt(attributes = T.unsafe(nil), &block); end
  def em(attributes = T.unsafe(nil), &block); end
  def font(attributes = T.unsafe(nil), &block); end
  def form(attributes = T.unsafe(nil), &block); end
  def h1(attributes = T.unsafe(nil), &block); end
  def h2(attributes = T.unsafe(nil), &block); end
  def h3(attributes = T.unsafe(nil), &block); end
  def h4(attributes = T.unsafe(nil), &block); end
  def h5(attributes = T.unsafe(nil), &block); end
  def h6(attributes = T.unsafe(nil), &block); end
  def head(attributes = T.unsafe(nil), &block); end
  def hr(attributes = T.unsafe(nil), &block); end
  def html(attributes = T.unsafe(nil), &block); end
  def i(attributes = T.unsafe(nil), &block); end
  def img(attributes = T.unsafe(nil), &block); end
  def input(attributes = T.unsafe(nil), &block); end
  def isindex(attributes = T.unsafe(nil), &block); end
  def kbd(attributes = T.unsafe(nil), &block); end
  def li(attributes = T.unsafe(nil), &block); end
  def link(attributes = T.unsafe(nil), &block); end
  def listing(attributes = T.unsafe(nil), &block); end
  def map(attributes = T.unsafe(nil), &block); end
  def menu(attributes = T.unsafe(nil), &block); end
  def meta(attributes = T.unsafe(nil), &block); end
  def ol(attributes = T.unsafe(nil), &block); end
  def option(attributes = T.unsafe(nil), &block); end
  def p(attributes = T.unsafe(nil), &block); end
  def param(attributes = T.unsafe(nil), &block); end
  def plaintext(attributes = T.unsafe(nil), &block); end
  def pre(attributes = T.unsafe(nil), &block); end
  def samp(attributes = T.unsafe(nil), &block); end
  def script(attributes = T.unsafe(nil), &block); end
  def select(attributes = T.unsafe(nil), &block); end
  def small(attributes = T.unsafe(nil), &block); end
  def strike(attributes = T.unsafe(nil), &block); end
  def strong(attributes = T.unsafe(nil), &block); end
  def style(attributes = T.unsafe(nil), &block); end
  def sub(attributes = T.unsafe(nil), &block); end
  def sup(attributes = T.unsafe(nil), &block); end
  def table(attributes = T.unsafe(nil), &block); end
  def td(attributes = T.unsafe(nil), &block); end
  def textarea(attributes = T.unsafe(nil), &block); end
  def th(attributes = T.unsafe(nil), &block); end
  def title(attributes = T.unsafe(nil), &block); end
  def tr(attributes = T.unsafe(nil), &block); end
  def tt(attributes = T.unsafe(nil), &block); end
  def u(attributes = T.unsafe(nil), &block); end
  def ul(attributes = T.unsafe(nil), &block); end
  def var(attributes = T.unsafe(nil), &block); end
  def xmp(attributes = T.unsafe(nil), &block); end
end

module CGI::Html4
  include ::CGI::TagMaker
  def a(attributes = T.unsafe(nil), &block); end
  def abbr(attributes = T.unsafe(nil), &block); end
  def acronym(attributes = T.unsafe(nil), &block); end
  def address(attributes = T.unsafe(nil), &block); end
  def area(attributes = T.unsafe(nil), &block); end
  def b(attributes = T.unsafe(nil), &block); end
  def base(attributes = T.unsafe(nil), &block); end
  def bdo(attributes = T.unsafe(nil), &block); end
  def big(attributes = T.unsafe(nil), &block); end
  def blockquote(attributes = T.unsafe(nil), &block); end
  def body(attributes = T.unsafe(nil), &block); end
  def br(attributes = T.unsafe(nil), &block); end
  def button(attributes = T.unsafe(nil), &block); end
  def caption(attributes = T.unsafe(nil), &block); end
  def cite(attributes = T.unsafe(nil), &block); end
  def code(attributes = T.unsafe(nil), &block); end
  def col(attributes = T.unsafe(nil), &block); end
  def colgroup(attributes = T.unsafe(nil), &block); end
  def dd(attributes = T.unsafe(nil), &block); end
  def del(attributes = T.unsafe(nil), &block); end
  def dfn(attributes = T.unsafe(nil), &block); end
  def div(attributes = T.unsafe(nil), &block); end
  def dl(attributes = T.unsafe(nil), &block); end
  def doctype; end
  def dt(attributes = T.unsafe(nil), &block); end
  def em(attributes = T.unsafe(nil), &block); end
  def fieldset(attributes = T.unsafe(nil), &block); end
  def form(attributes = T.unsafe(nil), &block); end
  def h1(attributes = T.unsafe(nil), &block); end
  def h2(attributes = T.unsafe(nil), &block); end
  def h3(attributes = T.unsafe(nil), &block); end
  def h4(attributes = T.unsafe(nil), &block); end
  def h5(attributes = T.unsafe(nil), &block); end
  def h6(attributes = T.unsafe(nil), &block); end
  def head(attributes = T.unsafe(nil), &block); end
  def hr(attributes = T.unsafe(nil), &block); end
  def html(attributes = T.unsafe(nil), &block); end
  def i(attributes = T.unsafe(nil), &block); end
  def img(attributes = T.unsafe(nil), &block); end
  def input(attributes = T.unsafe(nil), &block); end
  def ins(attributes = T.unsafe(nil), &block); end
  def kbd(attributes = T.unsafe(nil), &block); end
  def label(attributes = T.unsafe(nil), &block); end
  def legend(attributes = T.unsafe(nil), &block); end
  def li(attributes = T.unsafe(nil), &block); end
  def link(attributes = T.unsafe(nil), &block); end
  def map(attributes = T.unsafe(nil), &block); end
  def meta(attributes = T.unsafe(nil), &block); end
  def noscript(attributes = T.unsafe(nil), &block); end
  def object(attributes = T.unsafe(nil), &block); end
  def ol(attributes = T.unsafe(nil), &block); end
  def optgroup(attributes = T.unsafe(nil), &block); end
  def option(attributes = T.unsafe(nil), &block); end
  def p(attributes = T.unsafe(nil), &block); end
  def param(attributes = T.unsafe(nil), &block); end
  def pre(attributes = T.unsafe(nil), &block); end
  def q(attributes = T.unsafe(nil), &block); end
  def samp(attributes = T.unsafe(nil), &block); end
  def script(attributes = T.unsafe(nil), &block); end
  def select(attributes = T.unsafe(nil), &block); end
  def small(attributes = T.unsafe(nil), &block); end
  def span(attributes = T.unsafe(nil), &block); end
  def strong(attributes = T.unsafe(nil), &block); end
  def style(attributes = T.unsafe(nil), &block); end
  def sub(attributes = T.unsafe(nil), &block); end
  def sup(attributes = T.unsafe(nil), &block); end
  def table(attributes = T.unsafe(nil), &block); end
  def tbody(attributes = T.unsafe(nil), &block); end
  def td(attributes = T.unsafe(nil), &block); end
  def textarea(attributes = T.unsafe(nil), &block); end
  def tfoot(attributes = T.unsafe(nil), &block); end
  def th(attributes = T.unsafe(nil), &block); end
  def thead(attributes = T.unsafe(nil), &block); end
  def title(attributes = T.unsafe(nil), &block); end
  def tr(attributes = T.unsafe(nil), &block); end
  def tt(attributes = T.unsafe(nil), &block); end
  def ul(attributes = T.unsafe(nil), &block); end
  def var(attributes = T.unsafe(nil), &block); end
end

module CGI::Html4Fr
  include ::CGI::TagMaker
  def doctype; end
  def frame(attributes = T.unsafe(nil), &block); end
  def frameset(attributes = T.unsafe(nil), &block); end
end

module CGI::Html4Tr
  include ::CGI::TagMaker
  def a(attributes = T.unsafe(nil), &block); end
  def abbr(attributes = T.unsafe(nil), &block); end
  def acronym(attributes = T.unsafe(nil), &block); end
  def address(attributes = T.unsafe(nil), &block); end
  def applet(attributes = T.unsafe(nil), &block); end
  def area(attributes = T.unsafe(nil), &block); end
  def b(attributes = T.unsafe(nil), &block); end
  def base(attributes = T.unsafe(nil), &block); end
  def basefont(attributes = T.unsafe(nil), &block); end
  def bdo(attributes = T.unsafe(nil), &block); end
  def big(attributes = T.unsafe(nil), &block); end
  def blockquote(attributes = T.unsafe(nil), &block); end
  def body(attributes = T.unsafe(nil), &block); end
  def br(attributes = T.unsafe(nil), &block); end
  def button(attributes = T.unsafe(nil), &block); end
  def caption(attributes = T.unsafe(nil), &block); end
  def center(attributes = T.unsafe(nil), &block); end
  def cite(attributes = T.unsafe(nil), &block); end
  def code(attributes = T.unsafe(nil), &block); end
  def col(attributes = T.unsafe(nil), &block); end
  def colgroup(attributes = T.unsafe(nil), &block); end
  def dd(attributes = T.unsafe(nil), &block); end
  def del(attributes = T.unsafe(nil), &block); end
  def dfn(attributes = T.unsafe(nil), &block); end
  def dir(attributes = T.unsafe(nil), &block); end
  def div(attributes = T.unsafe(nil), &block); end
  def dl(attributes = T.unsafe(nil), &block); end
  def doctype; end
  def dt(attributes = T.unsafe(nil), &block); end
  def em(attributes = T.unsafe(nil), &block); end
  def fieldset(attributes = T.unsafe(nil), &block); end
  def font(attributes = T.unsafe(nil), &block); end
  def form(attributes = T.unsafe(nil), &block); end
  def h1(attributes = T.unsafe(nil), &block); end
  def h2(attributes = T.unsafe(nil), &block); end
  def h3(attributes = T.unsafe(nil), &block); end
  def h4(attributes = T.unsafe(nil), &block); end
  def h5(attributes = T.unsafe(nil), &block); end
  def h6(attributes = T.unsafe(nil), &block); end
  def head(attributes = T.unsafe(nil), &block); end
  def hr(attributes = T.unsafe(nil), &block); end
  def html(attributes = T.unsafe(nil), &block); end
  def i(attributes = T.unsafe(nil), &block); end
  def iframe(attributes = T.unsafe(nil), &block); end
  def img(attributes = T.unsafe(nil), &block); end
  def input(attributes = T.unsafe(nil), &block); end
  def ins(attributes = T.unsafe(nil), &block); end
  def isindex(attributes = T.unsafe(nil), &block); end
  def kbd(attributes = T.unsafe(nil), &block); end
  def label(attributes = T.unsafe(nil), &block); end
  def legend(attributes = T.unsafe(nil), &block); end
  def li(attributes = T.unsafe(nil), &block); end
  def link(attributes = T.unsafe(nil), &block); end
  def map(attributes = T.unsafe(nil), &block); end
  def menu(attributes = T.unsafe(nil), &block); end
  def meta(attributes = T.unsafe(nil), &block); end
  def noframes(attributes = T.unsafe(nil), &block); end
  def noscript(attributes = T.unsafe(nil), &block); end
  def object(attributes = T.unsafe(nil), &block); end
  def ol(attributes = T.unsafe(nil), &block); end
  def optgroup(attributes = T.unsafe(nil), &block); end
  def option(attributes = T.unsafe(nil), &block); end
  def p(attributes = T.unsafe(nil), &block); end
  def param(attributes = T.unsafe(nil), &block); end
  def pre(attributes = T.unsafe(nil), &block); end
  def q(attributes = T.unsafe(nil), &block); end
  def s(attributes = T.unsafe(nil), &block); end
  def samp(attributes = T.unsafe(nil), &block); end
  def script(attributes = T.unsafe(nil), &block); end
  def select(attributes = T.unsafe(nil), &block); end
  def small(attributes = T.unsafe(nil), &block); end
  def span(attributes = T.unsafe(nil), &block); end
  def strike(attributes = T.unsafe(nil), &block); end
  def strong(attributes = T.unsafe(nil), &block); end
  def style(attributes = T.unsafe(nil), &block); end
  def sub(attributes = T.unsafe(nil), &block); end
  def sup(attributes = T.unsafe(nil), &block); end
  def table(attributes = T.unsafe(nil), &block); end
  def tbody(attributes = T.unsafe(nil), &block); end
  def td(attributes = T.unsafe(nil), &block); end
  def textarea(attributes = T.unsafe(nil), &block); end
  def tfoot(attributes = T.unsafe(nil), &block); end
  def th(attributes = T.unsafe(nil), &block); end
  def thead(attributes = T.unsafe(nil), &block); end
  def title(attributes = T.unsafe(nil), &block); end
  def tr(attributes = T.unsafe(nil), &block); end
  def tt(attributes = T.unsafe(nil), &block); end
  def u(attributes = T.unsafe(nil), &block); end
  def ul(attributes = T.unsafe(nil), &block); end
  def var(attributes = T.unsafe(nil), &block); end
end

module CGI::Html5
  include ::CGI::TagMaker
  def a(attributes = T.unsafe(nil), &block); end
  def abbr(attributes = T.unsafe(nil), &block); end
  def address(attributes = T.unsafe(nil), &block); end
  def area(attributes = T.unsafe(nil), &block); end
  def article(attributes = T.unsafe(nil), &block); end
  def aside(attributes = T.unsafe(nil), &block); end
  def audio(attributes = T.unsafe(nil), &block); end
  def b(attributes = T.unsafe(nil), &block); end
  def base(attributes = T.unsafe(nil), &block); end
  def bdi(attributes = T.unsafe(nil), &block); end
  def bdo(attributes = T.unsafe(nil), &block); end
  def blockquote(attributes = T.unsafe(nil), &block); end
  def body(attributes = T.unsafe(nil), &block); end
  def br(attributes = T.unsafe(nil), &block); end
  def button(attributes = T.unsafe(nil), &block); end
  def canvas(attributes = T.unsafe(nil), &block); end
  def caption(attributes = T.unsafe(nil), &block); end
  def cite(attributes = T.unsafe(nil), &block); end
  def code(attributes = T.unsafe(nil), &block); end
  def col(attributes = T.unsafe(nil), &block); end
  def colgroup(attributes = T.unsafe(nil), &block); end
  def command(attributes = T.unsafe(nil), &block); end
  def datalist(attributes = T.unsafe(nil), &block); end
  def dd(attributes = T.unsafe(nil), &block); end
  def del(attributes = T.unsafe(nil), &block); end
  def details(attributes = T.unsafe(nil), &block); end
  def dfn(attributes = T.unsafe(nil), &block); end
  def dialog(attributes = T.unsafe(nil), &block); end
  def div(attributes = T.unsafe(nil), &block); end
  def dl(attributes = T.unsafe(nil), &block); end
  def doctype; end
  def dt(attributes = T.unsafe(nil), &block); end
  def em(attributes = T.unsafe(nil), &block); end
  def embed(attributes = T.unsafe(nil), &block); end
  def fieldset(attributes = T.unsafe(nil), &block); end
  def figcaption(attributes = T.unsafe(nil), &block); end
  def figure(attributes = T.unsafe(nil), &block); end
  def footer(attributes = T.unsafe(nil), &block); end
  def form(attributes = T.unsafe(nil), &block); end
  def h1(attributes = T.unsafe(nil), &block); end
  def h2(attributes = T.unsafe(nil), &block); end
  def h3(attributes = T.unsafe(nil), &block); end
  def h4(attributes = T.unsafe(nil), &block); end
  def h5(attributes = T.unsafe(nil), &block); end
  def h6(attributes = T.unsafe(nil), &block); end
  def head(attributes = T.unsafe(nil), &block); end
  def header(attributes = T.unsafe(nil), &block); end
  def hgroup(attributes = T.unsafe(nil), &block); end
  def hr(attributes = T.unsafe(nil), &block); end
  def html(attributes = T.unsafe(nil), &block); end
  def i(attributes = T.unsafe(nil), &block); end
  def iframe(attributes = T.unsafe(nil), &block); end
  def img(attributes = T.unsafe(nil), &block); end
  def input(attributes = T.unsafe(nil), &block); end
  def ins(attributes = T.unsafe(nil), &block); end
  def kbd(attributes = T.unsafe(nil), &block); end
  def keygen(attributes = T.unsafe(nil), &block); end
  def label(attributes = T.unsafe(nil), &block); end
  def legend(attributes = T.unsafe(nil), &block); end
  def li(attributes = T.unsafe(nil), &block); end
  def link(attributes = T.unsafe(nil), &block); end
  def map(attributes = T.unsafe(nil), &block); end
  def mark(attributes = T.unsafe(nil), &block); end
  def menu(attributes = T.unsafe(nil), &block); end
  def meta(attributes = T.unsafe(nil), &block); end
  def meter(attributes = T.unsafe(nil), &block); end
  def nav(attributes = T.unsafe(nil), &block); end
  def noscript(attributes = T.unsafe(nil), &block); end
  def object(attributes = T.unsafe(nil), &block); end
  def ol(attributes = T.unsafe(nil), &block); end
  def optgroup(attributes = T.unsafe(nil), &block); end
  def option(attributes = T.unsafe(nil), &block); end
  def output(attributes = T.unsafe(nil), &block); end
  def p(attributes = T.unsafe(nil), &block); end
  def param(attributes = T.unsafe(nil), &block); end
  def pre(attributes = T.unsafe(nil), &block); end
  def progress(attributes = T.unsafe(nil), &block); end
  def q(attributes = T.unsafe(nil), &block); end
  def rp(attributes = T.unsafe(nil), &block); end
  def rt(attributes = T.unsafe(nil), &block); end
  def ruby(attributes = T.unsafe(nil), &block); end
  def s(attributes = T.unsafe(nil), &block); end
  def samp(attributes = T.unsafe(nil), &block); end
  def script(attributes = T.unsafe(nil), &block); end
  def section(attributes = T.unsafe(nil), &block); end
  def select(attributes = T.unsafe(nil), &block); end
  def small(attributes = T.unsafe(nil), &block); end
  def source(attributes = T.unsafe(nil), &block); end
  def span(attributes = T.unsafe(nil), &block); end
  def strong(attributes = T.unsafe(nil), &block); end
  def style(attributes = T.unsafe(nil), &block); end
  def sub(attributes = T.unsafe(nil), &block); end
  def summary(attributes = T.unsafe(nil), &block); end
  def sup(attributes = T.unsafe(nil), &block); end
  def table(attributes = T.unsafe(nil), &block); end
  def tbody(attributes = T.unsafe(nil), &block); end
  def td(attributes = T.unsafe(nil), &block); end
  def textarea(attributes = T.unsafe(nil), &block); end
  def tfoot(attributes = T.unsafe(nil), &block); end
  def th(attributes = T.unsafe(nil), &block); end
  def thead(attributes = T.unsafe(nil), &block); end
  def time(attributes = T.unsafe(nil), &block); end
  def title(attributes = T.unsafe(nil), &block); end
  def tr(attributes = T.unsafe(nil), &block); end
  def track(attributes = T.unsafe(nil), &block); end
  def u(attributes = T.unsafe(nil), &block); end
  def ul(attributes = T.unsafe(nil), &block); end
  def var(attributes = T.unsafe(nil), &block); end
  def video(attributes = T.unsafe(nil), &block); end
  def wbr(attributes = T.unsafe(nil), &block); end
end

module CGI::HtmlExtension
  def a(href = T.unsafe(nil)); end
  def base(href = T.unsafe(nil)); end
  def blockquote(cite = T.unsafe(nil)); end
  def caption(align = T.unsafe(nil)); end
  def checkbox(name = T.unsafe(nil), value = T.unsafe(nil), checked = T.unsafe(nil)); end
  def checkbox_group(name = T.unsafe(nil), *values); end
  def file_field(name = T.unsafe(nil), size = T.unsafe(nil), maxlength = T.unsafe(nil)); end
  def form(method = T.unsafe(nil), action = T.unsafe(nil), enctype = T.unsafe(nil)); end
  def hidden(name = T.unsafe(nil), value = T.unsafe(nil)); end
  def html(attributes = T.unsafe(nil)); end
  def image_button(src = T.unsafe(nil), name = T.unsafe(nil), alt = T.unsafe(nil)); end
  def img(src = T.unsafe(nil), alt = T.unsafe(nil), width = T.unsafe(nil), height = T.unsafe(nil)); end
  def multipart_form(action = T.unsafe(nil), enctype = T.unsafe(nil)); end
  def password_field(name = T.unsafe(nil), value = T.unsafe(nil), size = T.unsafe(nil), maxlength = T.unsafe(nil)); end
  def popup_menu(name = T.unsafe(nil), *values); end
  def radio_button(name = T.unsafe(nil), value = T.unsafe(nil), checked = T.unsafe(nil)); end
  def radio_group(name = T.unsafe(nil), *values); end
  def reset(value = T.unsafe(nil), name = T.unsafe(nil)); end
  def scrolling_list(name = T.unsafe(nil), *values); end
  def submit(value = T.unsafe(nil), name = T.unsafe(nil)); end
  def text_field(name = T.unsafe(nil), value = T.unsafe(nil), size = T.unsafe(nil), maxlength = T.unsafe(nil)); end
  def textarea(name = T.unsafe(nil), cols = T.unsafe(nil), rows = T.unsafe(nil)); end
end

class CGI::InvalidEncoding < ::Exception; end
CGI::LF = T.let(T.unsafe(nil), String)
CGI::MAX_MULTIPART_COUNT = T.let(T.unsafe(nil), Integer)
CGI::PATH_SEPARATOR = T.let(T.unsafe(nil), Hash)

module CGI::QueryExtension
  def [](key); end
  def accept; end
  def accept_charset; end
  def accept_encoding; end
  def accept_language; end
  def auth_type; end
  def cache_control; end
  def content_length; end
  def content_type; end
  def cookies; end
  def cookies=(_arg0); end
  def create_body(is_large); end
  def files; end
  def from; end
  def gateway_interface; end
  def has_key?(*args); end
  def host; end
  def include?(*args); end
  def key?(*args); end
  def keys(*args); end
  def multipart?; end
  def negotiate; end
  def params; end
  def params=(hash); end
  def path_info; end
  def path_translated; end
  def pragma; end
  def query_string; end
  def raw_cookie; end
  def raw_cookie2; end
  def referer; end
  def remote_addr; end
  def remote_host; end
  def remote_ident; end
  def remote_user; end
  def request_method; end
  def script_name; end
  def server_name; end
  def server_port; end
  def server_protocol; end
  def server_software; end
  def unescape_filename?; end
  def user_agent; end
  private def initialize_query; end
  private def read_from_cmdline; end
  private def read_multipart(boundary, content_length); end
end

CGI::REVISION = T.let(T.unsafe(nil), String)

class CGI::Session
  def initialize(request, option = T.unsafe(nil)); end
  def [](key); end
  def []=(key, val); end
  def close; end
  def delete; end
  def new_session; end
  def session_id; end
  def update; end
  private def create_new_id; end
  def self.callback(dbman); end
end

module CGI::TagMaker
  def nOE_element(element, attributes = T.unsafe(nil)); end
  def nOE_element_def(attributes = T.unsafe(nil), &block); end
  def nO_element(element, attributes = T.unsafe(nil)); end
  def nO_element_def(attributes = T.unsafe(nil), &block); end
  def nn_element(element, attributes = T.unsafe(nil)); end
  def nn_element_def(attributes = T.unsafe(nil), &block); end
end

module CGI::Util
  include ::CGI::Escape
  def escape(_arg0); end
  def escapeElement(string, *elements); end
  def escapeHTML(_arg0); end
  def escape_element(string, *elements); end
  def escape_html(_arg0); end
  def h(_arg0); end
  def pretty(string, shift = T.unsafe(nil)); end
  def rfc1123_date(time); end
  def unescape(*_arg0); end
  def unescapeElement(string, *elements); end
  def unescapeHTML(_arg0); end
  def unescape_element(string, *elements); end
  def unescape_html(_arg0); end
end

CGI::VERSION = T.let(T.unsafe(nil), String)

class ERB::Compiler
  def initialize(trim_mode); end
  def add_insert_cmd(out, content); end
  def add_put_cmd(out, content); end
  def compile(s); end
  def compile_content(stag, out); end
  def compile_etag(etag, out, scanner); end
  def compile_stag(stag, out, scanner); end
  def insert_cmd; end
  def insert_cmd=(_arg0); end
  def make_scanner(src); end
  def percent; end
  def post_cmd; end
  def post_cmd=(_arg0); end
  def pre_cmd; end
  def pre_cmd=(_arg0); end
  def prepare_trim_mode(mode); end
  def put_cmd; end
  def put_cmd=(_arg0); end
  def trim_mode; end
  private def content; end
  private def content=(_arg0); end
  private def detect_magic_comment(s, enc = T.unsafe(nil)); end
  private def warn_invalid_trim_mode(mode, uplevel:); end
end

module ERB::DefMethod
  private def def_erb_method(methodname, erb_or_fname); end
  def self.def_erb_method(methodname, erb_or_fname); end
end

ERB::Revision = T.let(T.unsafe(nil), String)

module ERB::Util
  private def h(s); end
  private def html_escape(s); end
  private def u(s); end
  private def url_encode(s); end
  def self.h(s); end
  def self.html_escape(s); end
  def self.u(s); end
  def self.url_encode(s); end
end

class StringScanner::Error < ::StandardError; end
StringScanner::Id = T.let(T.unsafe(nil), String)
StringScanner::Version = T.let(T.unsafe(nil), String)

class Array
  include ::Enumerable
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def initialize(*_arg0); end
  def &(_arg0); end
  def *(_arg0); end
  def +(_arg0); end
  def -(_arg0); end
  def <<(_arg0); end
  def <=>(_arg0); end
  def ==(_arg0); end
  def [](*_arg0); end
  def []=(*_arg0); end
  def abbrev(pattern = T.unsafe(nil)); end
  def all?(*_arg0); end
  def any?(*_arg0); end
  def append(*_arg0); end
  def assoc(_arg0); end
  def at(_arg0); end
  def bsearch; end
  def bsearch_index; end
  def clear; end
  def collect; end
  def collect!; end
  def combination(_arg0); end
  def compact; end
  def compact!; end
  def concat(*_arg0); end
  def count(*_arg0); end
  def cycle(*_arg0); end
  def deconstruct; end
  def delete(_arg0); end
  def delete_at(_arg0); end
  def delete_if; end
  def difference(*_arg0); end
  def dig(*_arg0); end
  def drop(_arg0); end
  def drop_while; end
  def each; end
  def each_index; end
  def empty?; end
  def eql?(_arg0); end
  def fetch(*_arg0); end
  def fill(*_arg0); end
  def filter; end
  def filter!; end
  def find_index(*_arg0); end
  def first(*_arg0); end
  def flatten(*_arg0); end
  def flatten!(*_arg0); end
  def hash; end
  def include?(_arg0); end
  def index(*_arg0); end
  def insert(*_arg0); end
  def inspect; end
  def intersection(*_arg0); end
  def join(*_arg0); end
  def keep_if; end
  def last(*_arg0); end
  def length; end
  def map; end
  def map!; end
  def max(*_arg0); end
  def min(*_arg0); end
  def minmax; end
  def none?(*_arg0); end
  def one?(*_arg0); end
  def pack(fmt, buffer: T.unsafe(nil)); end
  def permutation(*_arg0); end
  def place(*values); end
  def pop(*_arg0); end
  def prepend(*_arg0); end
  def product(*_arg0); end
  def push(*_arg0); end
  def rassoc(_arg0); end
  def reject; end
  def reject!; end
  def repeated_combination(_arg0); end
  def repeated_permutation(_arg0); end
  def replace(_arg0); end
  def reverse; end
  def reverse!; end
  def reverse_each; end
  def rindex(*_arg0); end
  def rotate(*_arg0); end
  def rotate!(*_arg0); end
  def sample(n = T.unsafe(nil), random: T.unsafe(nil)); end
  def select; end
  def select!; end
  def shelljoin; end
  def shift(*_arg0); end
  def shuffle(random: T.unsafe(nil)); end
  def shuffle!(random: T.unsafe(nil)); end
  def size; end
  def slice(*_arg0); end
  def slice!(*_arg0); end
  def sort; end
  def sort!; end
  def sort_by!; end
  def sum(*_arg0); end
  def take(_arg0); end
  def take_while; end
  def to_a; end
  def to_ary; end
  def to_h; end
  def to_s; end
  def transpose; end
  def union(*_arg0); end
  def uniq; end
  def uniq!; end
  def unshift(*_arg0); end
  def values_at(*_arg0); end
  def zip(*_arg0); end
  def |(_arg0); end
  private def initialize_copy(_arg0); end
  def self.[](*_arg0); end
  def self.try_convert(_arg0); end
end

class Exception
  def initialize(*_arg0); end
  def ==(_arg0); end
  def backtrace; end
  def backtrace_locations; end
  def cause; end
  def exception(*_arg0); end
  def full_message(*_arg0); end
  def inspect; end
  def message; end
  def respond_to?(*_arg0); end
  def set_backtrace(_arg0); end
  def to_s; end
  private def method_missing(*_arg0); end
  private def respond_to_missing?(_arg0, _arg1); end
  def self.exception(*_arg0); end
  def self.to_tty?; end
end

class CGI::Session::FileStore
  def initialize(session, option = T.unsafe(nil)); end
  def close; end
  def delete; end
  def restore; end
  def update; end
end

class CGI::Session::MemoryStore
  def initialize(session, option = T.unsafe(nil)); end
  def close; end
  def delete; end
  def restore; end
  def update; end
end

class CGI::Session::NoSession < ::RuntimeError; end

class CGI::Session::NullStore
  def initialize(session, option = T.unsafe(nil)); end
  def close; end
  def delete; end
  def restore; end
  def update; end
end

CGI::Util::RFC822_DAYS = T.let(T.unsafe(nil), Array)
CGI::Util::RFC822_MONTHS = T.let(T.unsafe(nil), Array)
CGI::Util::TABLE_FOR_ESCAPE_HTML__ = T.let(T.unsafe(nil), Hash)

class ERB::Compiler::Buffer
  def initialize(compiler, enc = T.unsafe(nil), frozen = T.unsafe(nil)); end
  def close; end
  def cr; end
  def push(cmd); end
  def script; end
end

class ERB::Compiler::ExplicitScanner < ::ERB::Compiler::Scanner
  def scan; end
end

class ERB::Compiler::PercentLine
  def initialize(str); end
  def to_s; end
  def value; end
end

class ERB::Compiler::Scanner
  def initialize(src, trim_mode, percent); end
  def etags; end
  def scan; end
  def stag; end
  def stag=(_arg0); end
  def stags; end
  def self.default_scanner=(klass); end
  def self.make_scanner(src, trim_mode, percent); end
  def self.regist_scanner(klass, trim_mode, percent); end
  def self.register_scanner(klass, trim_mode, percent); end
end

class ERB::Compiler::SimpleScanner < ::ERB::Compiler::Scanner
  def scan; end
end

class ERB::Compiler::TrimScanner < ::ERB::Compiler::Scanner
  def initialize(src, trim_mode, percent); end
  def explicit_trim_line(line); end
  def is_erb_stag?(s); end
  def percent_line(line, &block); end
  def scan(&block); end
  def scan_line(line); end
  def trim_line1(line); end
  def trim_line2(line); end
end

class StandardError < ::Exception; end
CGI::Session::MemoryStore::GLOBAL_HASH_TABLE = T.let(T.unsafe(nil), Hash)
class RuntimeError < ::StandardError; end
ERB::Compiler::Scanner::DEFAULT_ETAGS = T.let(T.unsafe(nil), Array)
ERB::Compiler::Scanner::DEFAULT_STAGS = T.let(T.unsafe(nil), Array)
ERB::Compiler::TrimScanner::ERB_STAG = T.let(T.unsafe(nil), Array)

module Enumerable
  def all?(*_arg0); end
  def any?(*_arg0); end
  def chain(*_arg0); end
  def chunk; end
  def chunk_while; end
  def collect; end
  def collect_concat; end
  def count(*_arg0); end
  def cycle(*_arg0); end
  def detect(*_arg0); end
  def drop(_arg0); end
  def drop_while; end
  def each_cons(_arg0); end
  def each_entry(*_arg0); end
  def each_slice(_arg0); end
  def each_with_index(*_arg0); end
  def each_with_object(_arg0); end
  def entries(*_arg0); end
  def filter; end
  def filter_map; end
  def find(*_arg0); end
  def find_all; end
  def find_index(*_arg0); end
  def first(*_arg0); end
  def flat_map; end
  def grep(_arg0); end
  def grep_v(_arg0); end
  def group_by; end
  def include?(_arg0); end
  def inject(*_arg0); end
  def lazy; end
  def map; end
  def max(*_arg0); end
  def max_by(*_arg0); end
  def member?(_arg0); end
  def min(*_arg0); end
  def min_by(*_arg0); end
  def minmax; end
  def minmax_by; end
  def none?(*_arg0); end
  def one?(*_arg0); end
  def partition; end
  def reduce(*_arg0); end
  def reject; end
  def reverse_each(*_arg0); end
  def select; end
  def slice_after(*_arg0); end
  def slice_before(*_arg0); end
  def slice_when; end
  def sort; end
  def sort_by; end
  def sum(*_arg0); end
  def take(_arg0); end
  def take_while; end
  def tally; end
  def to_a(*_arg0); end
  def to_h(*_arg0); end
  def to_set(klass = T.unsafe(nil), *args, &block); end
  def uniq; end
  def zip(*_arg0); end
end

module JSON::Ext::Generator::GeneratorMethods::Array
  def to_json(*_arg0); end
end

module FileUtils
  include ::FileUtils::StreamUtils_
  extend ::FileUtils::StreamUtils_
  private def apply_mask(mode, user_mask, op, mode_mask); end
  private def cd(dir, verbose: T.unsafe(nil), &block); end
  private def chdir(dir, verbose: T.unsafe(nil), &block); end
  private def chmod(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def chmod_R(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end
  private def chown(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def chown_R(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end
  private def cmp(a, b); end
  private def compare_file(a, b); end
  private def compare_stream(a, b); end
  private def copy(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def copy_entry(src, dest, preserve = T.unsafe(nil), dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end
  private def copy_file(src, dest, preserve = T.unsafe(nil), dereference = T.unsafe(nil)); end
  private def copy_stream(src, dest); end
  private def cp(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end
  private def cp_r(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end
  private def fu_each_src_dest(src, dest); end
  private def fu_each_src_dest0(src, dest); end
  private def fu_get_gid(group); end
  private def fu_get_uid(user); end
  private def fu_have_symlink?; end
  private def fu_list(arg); end
  private def fu_mkdir(path, mode); end
  private def fu_mode(mode, path); end
  private def fu_output_message(msg); end
  private def fu_same?(a, b); end
  private def fu_stat_identical_entry?(a, b); end
  private def getwd; end
  private def identical?(a, b); end
  private def install(src, dest, mode: T.unsafe(nil), owner: T.unsafe(nil), group: T.unsafe(nil), preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def link(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def link_entry(src, dest, dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end
  private def ln(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def ln_s(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def ln_sf(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def makedirs(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def mkdir(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def mkdir_p(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def mkpath(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def mode_to_s(mode); end
  private def move(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def mv(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def pwd; end
  private def remove(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def remove_dir(path, force = T.unsafe(nil)); end
  private def remove_entry(path, force = T.unsafe(nil)); end
  private def remove_entry_secure(path, force = T.unsafe(nil)); end
  private def remove_file(path, force = T.unsafe(nil)); end
  private def remove_trailing_slash(dir); end
  private def rm(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def rm_f(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def rm_r(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def rm_rf(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def rmdir(list, parents: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def rmtree(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def safe_unlink(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def symbolic_modes_to_i(mode_sym, path); end
  private def symlink(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def touch(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), mtime: T.unsafe(nil), nocreate: T.unsafe(nil)); end
  private def uptodate?(new, old_list); end
  private def user_mask(target); end
  def self.cd(dir, verbose: T.unsafe(nil), &block); end
  def self.chdir(dir, verbose: T.unsafe(nil), &block); end
  def self.chmod(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.chmod_R(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end
  def self.chown(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.chown_R(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end
  def self.cmp(a, b); end
  def self.collect_method(opt); end
  def self.commands; end
  def self.compare_file(a, b); end
  def self.compare_stream(a, b); end
  def self.copy(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.copy_entry(src, dest, preserve = T.unsafe(nil), dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end
  def self.copy_file(src, dest, preserve = T.unsafe(nil), dereference = T.unsafe(nil)); end
  def self.copy_stream(src, dest); end
  def self.cp(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end
  def self.cp_r(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end
  def self.getwd; end
  def self.have_option?(mid, opt); end
  def self.identical?(a, b); end
  def self.install(src, dest, mode: T.unsafe(nil), owner: T.unsafe(nil), group: T.unsafe(nil), preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.link(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.link_entry(src, dest, dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end
  def self.ln(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.ln_s(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.ln_sf(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.makedirs(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.mkdir(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.mkdir_p(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.mkpath(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.move(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.mv(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.options; end
  def self.options_of(mid); end
  def self.private_module_function(name); end
  def self.pwd; end
  def self.remove(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.remove_dir(path, force = T.unsafe(nil)); end
  def self.remove_entry(path, force = T.unsafe(nil)); end
  def self.remove_entry_secure(path, force = T.unsafe(nil)); end
  def self.remove_file(path, force = T.unsafe(nil)); end
  def self.rm(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.rm_f(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.rm_r(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.rm_rf(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.rmdir(list, parents: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.rmtree(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.safe_unlink(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.symlink(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.touch(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), mtime: T.unsafe(nil), nocreate: T.unsafe(nil)); end
  def self.uptodate?(new, old_list); end
  private def self.apply_mask(mode, user_mask, op, mode_mask); end
  private def self.fu_each_src_dest(src, dest); end
  private def self.fu_each_src_dest0(src, dest); end
  private def self.fu_get_gid(group); end
  private def self.fu_get_uid(user); end
  private def self.fu_have_symlink?; end
  private def self.fu_list(arg); end
  private def self.fu_mkdir(path, mode); end
  private def self.fu_mode(mode, path); end
  private def self.fu_output_message(msg); end
  private def self.fu_same?(a, b); end
  private def self.fu_stat_identical_entry?(a, b); end
  private def self.mode_to_s(mode); end
  private def self.remove_trailing_slash(dir); end
  private def self.symbolic_modes_to_i(mode_sym, path); end
  private def self.user_mask(target); end
end

module FileUtils::DryRun
  include ::FileUtils::StreamUtils_
  include ::FileUtils
  include ::FileUtils::LowMethods
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils
  extend ::FileUtils::LowMethods
  extend ::FileUtils::DryRun
  private def chmod(*args, **options); end
  private def chmod_R(*args, **options); end
  private def chown(*args, **options); end
  private def chown_R(*args, **options); end
  private def copy(*args, **options); end
  private def cp(*args, **options); end
  private def cp_lr(*args, **options); end
  private def cp_r(*args, **options); end
  private def install(*args, **options); end
  private def link(*args, **options); end
  private def ln(*args, **options); end
  private def ln_s(*args, **options); end
  private def ln_sf(*args, **options); end
  private def makedirs(*args, **options); end
  private def mkdir(*args, **options); end
  private def mkdir_p(*args, **options); end
  private def mkpath(*args, **options); end
  private def move(*args, **options); end
  private def mv(*args, **options); end
  private def remove(*args, **options); end
  private def rm(*args, **options); end
  private def rm_f(*args, **options); end
  private def rm_r(*args, **options); end
  private def rm_rf(*args, **options); end
  private def rmdir(*args, **options); end
  private def rmtree(*args, **options); end
  private def safe_unlink(*args, **options); end
  private def symlink(*args, **options); end
  private def touch(*args, **options); end
end

class FileUtils::Entry_
  include ::FileUtils::StreamUtils_
  def initialize(a, b = T.unsafe(nil), deref = T.unsafe(nil)); end
  def blockdev?; end
  def chardev?; end
  def chmod(mode); end
  def chown(uid, gid); end
  def copy(dest); end
  def copy_file(dest); end
  def copy_metadata(path); end
  def dereference?; end
  def directory?; end
  def door?; end
  def entries; end
  def exist?; end
  def file?; end
  def inspect; end
  def link(dest); end
  def lstat; end
  def lstat!; end
  def path; end
  def pipe?; end
  def platform_support; end
  def postorder_traverse; end
  def prefix; end
  def preorder_traverse; end
  def rel; end
  def remove; end
  def remove_dir1; end
  def remove_file; end
  def socket?; end
  def stat; end
  def stat!; end
  def symlink?; end
  def traverse; end
  def wrap_traverse(pre, post); end
  private def check_have_lchmod?; end
  private def check_have_lchown?; end
  private def descendant_directory?(descendant, ascendant); end
  private def have_lchmod?; end
  private def have_lchown?; end
  private def join(dir, base); end
end

FileUtils::LOW_METHODS = T.let(T.unsafe(nil), Array)

module FileUtils::LowMethods
  private def _do_nothing(*_arg0); end
  private def cd(*_arg0); end
  private def chdir(*_arg0); end
  private def cmp(*_arg0); end
  private def collect_method(*_arg0); end
  private def commands(*_arg0); end
  private def compare_file(*_arg0); end
  private def compare_stream(*_arg0); end
  private def copy_entry(*_arg0); end
  private def copy_file(*_arg0); end
  private def copy_stream(*_arg0); end
  private def getwd(*_arg0); end
  private def have_option?(*_arg0); end
  private def identical?(*_arg0); end
  private def link_entry(*_arg0); end
  private def options(*_arg0); end
  private def options_of(*_arg0); end
  private def private_module_function(*_arg0); end
  private def pwd(*_arg0); end
  private def remove_dir(*_arg0); end
  private def remove_entry(*_arg0); end
  private def remove_entry_secure(*_arg0); end
  private def remove_file(*_arg0); end
  private def uptodate?(*_arg0); end
end

FileUtils::METHODS = T.let(T.unsafe(nil), Array)

module FileUtils::NoWrite
  include ::FileUtils::StreamUtils_
  include ::FileUtils
  include ::FileUtils::LowMethods
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils
  extend ::FileUtils::LowMethods
  extend ::FileUtils::NoWrite
  private def chmod(*args, **options); end
  private def chmod_R(*args, **options); end
  private def chown(*args, **options); end
  private def chown_R(*args, **options); end
  private def copy(*args, **options); end
  private def cp(*args, **options); end
  private def cp_lr(*args, **options); end
  private def cp_r(*args, **options); end
  private def install(*args, **options); end
  private def link(*args, **options); end
  private def ln(*args, **options); end
  private def ln_s(*args, **options); end
  private def ln_sf(*args, **options); end
  private def makedirs(*args, **options); end
  private def mkdir(*args, **options); end
  private def mkdir_p(*args, **options); end
  private def mkpath(*args, **options); end
  private def move(*args, **options); end
  private def mv(*args, **options); end
  private def remove(*args, **options); end
  private def rm(*args, **options); end
  private def rm_f(*args, **options); end
  private def rm_r(*args, **options); end
  private def rm_rf(*args, **options); end
  private def rmdir(*args, **options); end
  private def rmtree(*args, **options); end
  private def safe_unlink(*args, **options); end
  private def symlink(*args, **options); end
  private def touch(*args, **options); end
end

FileUtils::OPT_TABLE = T.let(T.unsafe(nil), Hash)

module FileUtils::StreamUtils_
  private def fu_blksize(st); end
  private def fu_copy_stream0(src, dest, blksize = T.unsafe(nil)); end
  private def fu_default_blksize; end
  private def fu_stream_blksize(*streams); end
  private def fu_windows?; end
end

FileUtils::VERSION = T.let(T.unsafe(nil), String)

module FileUtils::Verbose
  include ::FileUtils::StreamUtils_
  include ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils
  extend ::FileUtils::Verbose
  private def cd(*args, **options); end
  private def chdir(*args, **options); end
  private def chmod(*args, **options); end
  private def chmod_R(*args, **options); end
  private def chown(*args, **options); end
  private def chown_R(*args, **options); end
  private def copy(*args, **options); end
  private def cp(*args, **options); end
  private def cp_lr(*args, **options); end
  private def cp_r(*args, **options); end
  private def install(*args, **options); end
  private def link(*args, **options); end
  private def ln(*args, **options); end
  private def ln_s(*args, **options); end
  private def ln_sf(*args, **options); end
  private def makedirs(*args, **options); end
  private def mkdir(*args, **options); end
  private def mkdir_p(*args, **options); end
  private def mkpath(*args, **options); end
  private def move(*args, **options); end
  private def mv(*args, **options); end
  private def remove(*args, **options); end
  private def rm(*args, **options); end
  private def rm_f(*args, **options); end
  private def rm_r(*args, **options); end
  private def rm_rf(*args, **options); end
  private def rmdir(*args, **options); end
  private def rmtree(*args, **options); end
  private def safe_unlink(*args, **options); end
  private def symlink(*args, **options); end
  private def touch(*args, **options); end
end

FileUtils::Entry_::DIRECTORY_TERM = T.let(T.unsafe(nil), String)
FileUtils::Entry_::S_IF_DOOR = T.let(T.unsafe(nil), Integer)
module Find
  private def find(*paths, ignore_error: T.unsafe(nil)); end
  private def prune; end
  def self.find(*paths, ignore_error: T.unsafe(nil)); end
  def self.prune; end
end
module Forwardable
  def def_delegator(accessor, method, ali = T.unsafe(nil)); end
  def def_delegators(accessor, *methods); end
  def def_instance_delegator(accessor, method, ali = T.unsafe(nil)); end
  def def_instance_delegators(accessor, *methods); end
  def delegate(hash); end
  def instance_delegate(hash); end
  def self._compile_method(src, file, line); end
  def self._delegator_method(obj, accessor, method, ali); end
  def self._valid_method?(method); end
  def self.debug; end
  def self.debug=(_arg0); end
end

module SingleForwardable
  def def_delegator(accessor, method, ali = T.unsafe(nil)); end
  def def_delegators(accessor, *methods); end
  def def_single_delegator(accessor, method, ali = T.unsafe(nil)); end
  def def_single_delegators(accessor, *methods); end
  def delegate(hash); end
  def single_delegate(hash); end
end

Forwardable::FORWARDABLE_VERSION = T.let(T.unsafe(nil), String)
Forwardable::VERSION = T.let(T.unsafe(nil), String)
class GetoptLong
  def initialize(*arguments); end
  def each; end
  def each_option; end
  def error; end
  def error?; end
  def error_message; end
  def get; end
  def get_option; end
  def ordering; end
  def ordering=(ordering); end
  def quiet; end
  def quiet=(_arg0); end
  def quiet?; end
  def set_options(*arguments); end
  def terminate; end
  def terminated?; end
  protected def set_error(type, message); end
end

GetoptLong::ARGUMENT_FLAGS = T.let(T.unsafe(nil), Array)
class GetoptLong::AmbiguousOption < ::GetoptLong::Error; end
class GetoptLong::Error < ::StandardError; end
class GetoptLong::InvalidOption < ::GetoptLong::Error; end
class GetoptLong::MissingArgument < ::GetoptLong::Error; end
GetoptLong::NO_ARGUMENT = T.let(T.unsafe(nil), Integer)
class GetoptLong::NeedlessArgument < ::GetoptLong::Error; end
GetoptLong::OPTIONAL_ARGUMENT = T.let(T.unsafe(nil), Integer)
GetoptLong::ORDERINGS = T.let(T.unsafe(nil), Array)
GetoptLong::PERMUTE = T.let(T.unsafe(nil), Integer)
GetoptLong::REQUIRED_ARGUMENT = T.let(T.unsafe(nil), Integer)
GetoptLong::REQUIRE_ORDER = T.let(T.unsafe(nil), Integer)
GetoptLong::RETURN_IN_ORDER = T.let(T.unsafe(nil), Integer)
GetoptLong::STATUS_STARTED = T.let(T.unsafe(nil), Integer)
GetoptLong::STATUS_TERMINATED = T.let(T.unsafe(nil), Integer)
GetoptLong::STATUS_YET = T.let(T.unsafe(nil), Integer)
GetoptLong::VERSION = T.let(T.unsafe(nil), String)
class StandardError < ::Exception; end

class Exception
  def initialize(*_arg0); end
  def ==(_arg0); end
  def backtrace; end
  def backtrace_locations; end
  def cause; end
  def exception(*_arg0); end
  def full_message(*_arg0); end
  def inspect; end
  def message; end
  def respond_to?(*_arg0); end
  def set_backtrace(_arg0); end
  def to_s; end
  private def method_missing(*_arg0); end
  private def respond_to_missing?(_arg0, _arg1); end
  def self.exception(*_arg0); end
  def self.to_tty?; end
end
class BasicSocket < ::IO
  def close_read; end
  def close_write; end
  def connect_address; end
  def do_not_reverse_lookup; end
  def do_not_reverse_lookup=(_arg0); end
  def getpeereid; end
  def getpeername; end
  def getsockname; end
  def getsockopt(_arg0, _arg1); end
  def local_address; end
  def recv(*_arg0); end
  def recv_nonblock(len, flag = T.unsafe(nil), str = T.unsafe(nil), exception: T.unsafe(nil)); end
  def recvmsg(dlen = T.unsafe(nil), flags = T.unsafe(nil), clen = T.unsafe(nil), scm_rights: T.unsafe(nil)); end
  def recvmsg_nonblock(dlen = T.unsafe(nil), flags = T.unsafe(nil), clen = T.unsafe(nil), scm_rights: T.unsafe(nil), exception: T.unsafe(nil)); end
  def remote_address; end
  def send(*_arg0); end
  def sendmsg(mesg, flags = T.unsafe(nil), dest_sockaddr = T.unsafe(nil), *controls); end
  def sendmsg_nonblock(mesg, flags = T.unsafe(nil), dest_sockaddr = T.unsafe(nil), *controls, exception: T.unsafe(nil)); end
  def setsockopt(*_arg0); end
  def shutdown(*_arg0); end
  private def __recv_nonblock(_arg0, _arg1, _arg2, _arg3); end
  private def __recvmsg(_arg0, _arg1, _arg2, _arg3); end
  private def __recvmsg_nonblock(_arg0, _arg1, _arg2, _arg3, _arg4); end
  private def __sendmsg(_arg0, _arg1, _arg2, _arg3); end
  private def __sendmsg_nonblock(_arg0, _arg1, _arg2, _arg3, _arg4); end
  def self.do_not_reverse_lookup; end
  def self.do_not_reverse_lookup=(_arg0); end
  def self.for_fd(_arg0); end
end

class Addrinfo
  def initialize(*_arg0); end
  def afamily; end
  def bind; end
  def canonname; end
  def connect(timeout: T.unsafe(nil), &block); end
  def connect_from(*args, timeout: T.unsafe(nil), &block); end
  def connect_to(*args, timeout: T.unsafe(nil), &block); end
  def family_addrinfo(*args); end
  def getnameinfo(*_arg0); end
  def inspect; end
  def inspect_sockaddr; end
  def ip?; end
  def ip_address; end
  def ip_port; end
  def ip_unpack; end
  def ipv4?; end
  def ipv4_loopback?; end
  def ipv4_multicast?; end
  def ipv4_private?; end
  def ipv6?; end
  def ipv6_linklocal?; end
  def ipv6_loopback?; end
  def ipv6_mc_global?; end
  def ipv6_mc_linklocal?; end
  def ipv6_mc_nodelocal?; end
  def ipv6_mc_orglocal?; end
  def ipv6_mc_sitelocal?; end
  def ipv6_multicast?; end
  def ipv6_sitelocal?; end
  def ipv6_to_ipv4; end
  def ipv6_unique_local?; end
  def ipv6_unspecified?; end
  def ipv6_v4compat?; end
  def ipv6_v4mapped?; end
  def listen(backlog = T.unsafe(nil)); end
  def marshal_dump; end
  def marshal_load(_arg0); end
  def pfamily; end
  def protocol; end
  def socktype; end
  def to_s; end
  def to_sockaddr; end
  def unix?; end
  def unix_path; end
  protected def connect_internal(local_addrinfo, timeout = T.unsafe(nil)); end
  def self.foreach(nodename, service, family = T.unsafe(nil), socktype = T.unsafe(nil), protocol = T.unsafe(nil), flags = T.unsafe(nil), timeout: T.unsafe(nil), &block); end
  def self.getaddrinfo(*_arg0); end
  def self.ip(_arg0); end
  def self.tcp(_arg0, _arg1); end
  def self.udp(_arg0, _arg1); end
  def self.unix(*_arg0); end
end

class SocketError < ::StandardError; end

class IPSocket < ::BasicSocket
  def addr(*_arg0); end
  def inspect; end
  def peeraddr(*_arg0); end
  def recvfrom(*_arg0); end
  def self.getaddress(_arg0); end
end

class UDPSocket < ::IPSocket
  def initialize(*_arg0); end
  def bind(_arg0, _arg1); end
  def connect(_arg0, _arg1); end
  def recvfrom_nonblock(len, flag = T.unsafe(nil), outbuf = T.unsafe(nil), exception: T.unsafe(nil)); end
  def send(*_arg0); end
  private def __recvfrom_nonblock(_arg0, _arg1, _arg2, _arg3); end
end

class TCPSocket < ::IPSocket
  def initialize(*_arg0); end
  def self.gethostbyname(_arg0); end
end

class TCPServer < ::TCPSocket
  def initialize(*_arg0); end
  def accept; end
  def accept_nonblock(exception: T.unsafe(nil)); end
  def listen(_arg0); end
  def sysaccept; end
  private def __accept_nonblock(_arg0); end
end

class UNIXSocket < ::BasicSocket
  def initialize(_arg0); end
  def addr; end
  def path; end
  def peeraddr; end
  def recv_io(*_arg0); end
  def recvfrom(*_arg0); end
  def send_io(_arg0); end
  def self.pair(*_arg0); end
  def self.socketpair(*_arg0); end
end

class UNIXServer < ::UNIXSocket
  def initialize(_arg0); end
  def accept; end
  def accept_nonblock(exception: T.unsafe(nil)); end
  def listen(_arg0); end
  def sysaccept; end
  private def __accept_nonblock(_arg0); end
end

class IPAddr
  include ::Comparable
  def initialize(addr = T.unsafe(nil), family = T.unsafe(nil)); end
  def &(other); end
  def <<(num); end
  def <=>(other); end
  def ==(other); end
  def ===(other); end
  def >>(num); end
  def eql?(other); end
  def family; end
  def hash; end
  def hton; end
  def include?(other); end
  def inspect; end
  def ip6_arpa; end
  def ip6_int; end
  def ipv4?; end
  def ipv4_compat; end
  def ipv4_compat?; end
  def ipv4_mapped; end
  def ipv4_mapped?; end
  def ipv6?; end
  def link_local?; end
  def loopback?; end
  def mask(prefixlen); end
  def native; end
  def prefix; end
  def prefix=(prefix); end
  def private?; end
  def reverse; end
  def succ; end
  def to_i; end
  def to_range; end
  def to_s; end
  def to_string; end
  def |(other); end
  def ~; end
  protected def mask!(mask); end
  protected def set(addr, *family); end
  private def _ipv4_compat?; end
  private def _reverse; end
  private def _to_string(addr); end
  private def addr_mask(addr); end
  private def coerce_other(other); end
  private def in6_addr(left); end
  private def in_addr(addr); end
  def self.new_ntoh(addr); end
  def self.ntop(addr); end
end

class Socket < ::BasicSocket
  def initialize(*_arg0); end
  def accept; end
  def accept_nonblock(exception: T.unsafe(nil)); end
  def bind(_arg0); end
  def connect(_arg0); end
  def connect_nonblock(addr, exception: T.unsafe(nil)); end
  def ipv6only!; end
  def listen(_arg0); end
  def recvfrom(*_arg0); end
  def recvfrom_nonblock(len, flag = T.unsafe(nil), str = T.unsafe(nil), exception: T.unsafe(nil)); end
  def sysaccept; end
  private def __accept_nonblock(_arg0); end
  private def __connect_nonblock(_arg0, _arg1); end
  private def __recvfrom_nonblock(_arg0, _arg1, _arg2, _arg3); end
  def self.accept_loop(*sockets); end
  def self.getaddrinfo(*_arg0); end
  def self.gethostbyaddr(*_arg0); end
  def self.gethostbyname(_arg0); end
  def self.gethostname; end
  def self.getifaddrs; end
  def self.getnameinfo(*_arg0); end
  def self.getservbyname(*_arg0); end
  def self.getservbyport(*_arg0); end
  def self.ip_address_list; end
  def self.pack_sockaddr_in(_arg0, _arg1); end
  def self.pack_sockaddr_un(_arg0); end
  def self.pair(*_arg0); end
  def self.sockaddr_in(_arg0, _arg1); end
  def self.sockaddr_un(_arg0); end
  def self.socketpair(*_arg0); end
  def self.tcp(host, port, local_host = T.unsafe(nil), local_port = T.unsafe(nil), connect_timeout: T.unsafe(nil), resolv_timeout: T.unsafe(nil)); end
  def self.tcp_server_loop(host = T.unsafe(nil), port, &b); end
  def self.tcp_server_sockets(host = T.unsafe(nil), port); end
  def self.udp_server_loop(host = T.unsafe(nil), port, &b); end
  def self.udp_server_loop_on(sockets, &b); end
  def self.udp_server_recv(sockets); end
  def self.udp_server_sockets(host = T.unsafe(nil), port); end
  def self.unix(path); end
  def self.unix_server_loop(path, &b); end
  def self.unix_server_socket(path); end
  def self.unpack_sockaddr_in(_arg0); end
  def self.unpack_sockaddr_un(_arg0); end
  private def self.ip_sockets_port0(ai_list, reuseaddr); end
  private def self.tcp_server_sockets_port0(host); end
  private def self.unix_socket_abstract_name?(path); end
end

class IO
  include ::Enumerable
  include ::File::Constants
  def initialize(*_arg0); end
  def <<(_arg0); end
  def advise(*_arg0); end
  def autoclose=(_arg0); end
  def autoclose?; end
  def beep; end
  def binmode; end
  def binmode?; end
  def check_winsize_changed; end
  def clear_screen; end
  def close; end
  def close_on_exec=(_arg0); end
  def close_on_exec?; end
  def close_read; end
  def close_write; end
  def closed?; end
  def console_mode; end
  def console_mode=(_arg0); end
  def cooked; end
  def cooked!; end
  def cursor; end
  def cursor=(_arg0); end
  def cursor_down(_arg0); end
  def cursor_left(_arg0); end
  def cursor_right(_arg0); end
  def cursor_up(_arg0); end
  def each(*_arg0); end
  def each_byte; end
  def each_char; end
  def each_codepoint; end
  def each_line(*_arg0); end
  def echo=(_arg0); end
  def echo?; end
  def eof; end
  def eof?; end
  def erase_line(_arg0); end
  def erase_screen(_arg0); end
  def expect(pat, timeout = T.unsafe(nil)); end
  def external_encoding; end
  def fcntl(*_arg0); end
  def fdatasync; end
  def fileno; end
  def flush; end
  def fsync; end
  def getbyte; end
  def getc; end
  def getch(*_arg0); end
  def getpass(*_arg0); end
  def gets(*_arg0); end
  def goto(_arg0, _arg1); end
  def goto_column(_arg0); end
  def iflush; end
  def inspect; end
  def internal_encoding; end
  def ioctl(*_arg0); end
  def ioflush; end
  def isatty; end
  def lineno; end
  def lineno=(_arg0); end
  def noecho; end
  def nonblock(*_arg0); end
  def nonblock=(_arg0); end
  def nonblock?; end
  def nread; end
  def oflush; end
  def pathconf(_arg0); end
  def pid; end
  def pos; end
  def pos=(_arg0); end
  def pread(*_arg0); end
  def pressed?; end
  def print(*_arg0); end
  def printf(*_arg0); end
  def putc(_arg0); end
  def puts(*_arg0); end
  def pwrite(_arg0, _arg1); end
  def raw(*_arg0); end
  def raw!(*_arg0); end
  def read(*_arg0); end
  def read_nonblock(len, buf = T.unsafe(nil), exception: T.unsafe(nil)); end
  def readbyte; end
  def readchar; end
  def readline(*_arg0); end
  def readlines(*_arg0); end
  def readpartial(*_arg0); end
  def ready?; end
  def reopen(*_arg0); end
  def rewind; end
  def scroll_backward(_arg0); end
  def scroll_forward(_arg0); end
  def seek(*_arg0); end
  def set_encoding(*_arg0); end
  def set_encoding_by_bom; end
  def stat; end
  def sync; end
  def sync=(_arg0); end
  def sysread(*_arg0); end
  def sysseek(*_arg0); end
  def syswrite(_arg0); end
  def tell; end
  def to_i; end
  def to_io; end
  def tty?; end
  def ungetbyte(_arg0); end
  def ungetc(_arg0); end
  def wait(*_arg0); end
  def wait_priority(*_arg0); end
  def wait_readable(*_arg0); end
  def wait_writable(*_arg0); end
  def winsize; end
  def winsize=(_arg0); end
  def write(*_arg0); end
  def write_nonblock(buf, exception: T.unsafe(nil)); end
  private def initialize_copy(_arg0); end
  def self.binread(*_arg0); end
  def self.binwrite(*_arg0); end
  def self.console(*_arg0); end
  def self.copy_stream(*_arg0); end
  def self.for_fd(*_arg0); end
  def self.foreach(*_arg0); end
  def self.new(*_arg0); end
  def self.open(*_arg0); end
  def self.pipe(*_arg0); end
  def self.popen(*_arg0); end
  def self.read(*_arg0); end
  def self.readlines(*_arg0); end
  def self.select(*_arg0); end
  def self.sysopen(*_arg0); end
  def self.try_convert(_arg0); end
  def self.write(*_arg0); end
end

class StandardError < ::Exception; end
class IPAddr::AddressFamilyError < ::IPAddr::Error; end
class IPAddr::Error < ::ArgumentError; end
IPAddr::IN4MASK = T.let(T.unsafe(nil), Integer)
IPAddr::IN6FORMAT = T.let(T.unsafe(nil), String)
IPAddr::IN6MASK = T.let(T.unsafe(nil), Integer)
class IPAddr::InvalidAddressError < ::IPAddr::Error; end
class IPAddr::InvalidPrefixError < ::IPAddr::InvalidAddressError; end
IPAddr::RE_IPV4ADDRLIKE = T.let(T.unsafe(nil), Regexp)
IPAddr::RE_IPV6ADDRLIKE_COMPRESSED = T.let(T.unsafe(nil), Regexp)
IPAddr::RE_IPV6ADDRLIKE_FULL = T.let(T.unsafe(nil), Regexp)
Socket::AF_APPLETALK = T.let(T.unsafe(nil), Integer)
Socket::AF_CCITT = T.let(T.unsafe(nil), Integer)
Socket::AF_CHAOS = T.let(T.unsafe(nil), Integer)
Socket::AF_CNT = T.let(T.unsafe(nil), Integer)
Socket::AF_COIP = T.let(T.unsafe(nil), Integer)
Socket::AF_DATAKIT = T.let(T.unsafe(nil), Integer)
Socket::AF_DLI = T.let(T.unsafe(nil), Integer)
Socket::AF_E164 = T.let(T.unsafe(nil), Integer)
Socket::AF_ECMA = T.let(T.unsafe(nil), Integer)
Socket::AF_HYLINK = T.let(T.unsafe(nil), Integer)
Socket::AF_IMPLINK = T.let(T.unsafe(nil), Integer)
Socket::AF_INET = T.let(T.unsafe(nil), Integer)
Socket::AF_INET6 = T.let(T.unsafe(nil), Integer)
Socket::AF_IPX = T.let(T.unsafe(nil), Integer)
Socket::AF_ISDN = T.let(T.unsafe(nil), Integer)
Socket::AF_ISO = T.let(T.unsafe(nil), Integer)
Socket::AF_LAT = T.let(T.unsafe(nil), Integer)
Socket::AF_LINK = T.let(T.unsafe(nil), Integer)
Socket::AF_LOCAL = T.let(T.unsafe(nil), Integer)
Socket::AF_MAX = T.let(T.unsafe(nil), Integer)
Socket::AF_NATM = T.let(T.unsafe(nil), Integer)
Socket::AF_NDRV = T.let(T.unsafe(nil), Integer)
Socket::AF_NETBIOS = T.let(T.unsafe(nil), Integer)
Socket::AF_NS = T.let(T.unsafe(nil), Integer)
Socket::AF_OSI = T.let(T.unsafe(nil), Integer)
Socket::AF_PPP = T.let(T.unsafe(nil), Integer)
Socket::AF_PUP = T.let(T.unsafe(nil), Integer)
Socket::AF_ROUTE = T.let(T.unsafe(nil), Integer)
Socket::AF_SIP = T.let(T.unsafe(nil), Integer)
Socket::AF_SNA = T.let(T.unsafe(nil), Integer)
Socket::AF_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::AF_UNIX = T.let(T.unsafe(nil), Integer)
Socket::AF_UNSPEC = T.let(T.unsafe(nil), Integer)
Socket::AI_ADDRCONFIG = T.let(T.unsafe(nil), Integer)
Socket::AI_ALL = T.let(T.unsafe(nil), Integer)
Socket::AI_CANONNAME = T.let(T.unsafe(nil), Integer)
Socket::AI_DEFAULT = T.let(T.unsafe(nil), Integer)
Socket::AI_MASK = T.let(T.unsafe(nil), Integer)
Socket::AI_NUMERICHOST = T.let(T.unsafe(nil), Integer)
Socket::AI_NUMERICSERV = T.let(T.unsafe(nil), Integer)
Socket::AI_PASSIVE = T.let(T.unsafe(nil), Integer)
Socket::AI_V4MAPPED = T.let(T.unsafe(nil), Integer)
Socket::AI_V4MAPPED_CFG = T.let(T.unsafe(nil), Integer)

class Socket::AncillaryData
  def initialize(_arg0, _arg1, _arg2, _arg3); end
  def cmsg_is?(_arg0, _arg1); end
  def data; end
  def family; end
  def inspect; end
  def int; end
  def ip_pktinfo; end
  def ipv6_pktinfo; end
  def ipv6_pktinfo_addr; end
  def ipv6_pktinfo_ifindex; end
  def level; end
  def timestamp; end
  def type; end
  def unix_rights; end
  def self.int(_arg0, _arg1, _arg2, _arg3); end
  def self.ip_pktinfo(*_arg0); end
  def self.ipv6_pktinfo(_arg0, _arg1); end
  def self.unix_rights(*_arg0); end
end

module Socket::Constants; end
Socket::EAI_ADDRFAMILY = T.let(T.unsafe(nil), Integer)
Socket::EAI_AGAIN = T.let(T.unsafe(nil), Integer)
Socket::EAI_BADFLAGS = T.let(T.unsafe(nil), Integer)
Socket::EAI_BADHINTS = T.let(T.unsafe(nil), Integer)
Socket::EAI_FAIL = T.let(T.unsafe(nil), Integer)
Socket::EAI_FAMILY = T.let(T.unsafe(nil), Integer)
Socket::EAI_MAX = T.let(T.unsafe(nil), Integer)
Socket::EAI_MEMORY = T.let(T.unsafe(nil), Integer)
Socket::EAI_NODATA = T.let(T.unsafe(nil), Integer)
Socket::EAI_NONAME = T.let(T.unsafe(nil), Integer)
Socket::EAI_OVERFLOW = T.let(T.unsafe(nil), Integer)
Socket::EAI_PROTOCOL = T.let(T.unsafe(nil), Integer)
Socket::EAI_SERVICE = T.let(T.unsafe(nil), Integer)
Socket::EAI_SOCKTYPE = T.let(T.unsafe(nil), Integer)
Socket::EAI_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::IFF_ALLMULTI = T.let(T.unsafe(nil), Integer)
Socket::IFF_ALTPHYS = T.let(T.unsafe(nil), Integer)
Socket::IFF_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::IFF_DEBUG = T.let(T.unsafe(nil), Integer)
Socket::IFF_LINK0 = T.let(T.unsafe(nil), Integer)
Socket::IFF_LINK1 = T.let(T.unsafe(nil), Integer)
Socket::IFF_LINK2 = T.let(T.unsafe(nil), Integer)
Socket::IFF_LOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::IFF_MULTICAST = T.let(T.unsafe(nil), Integer)
Socket::IFF_NOARP = T.let(T.unsafe(nil), Integer)
Socket::IFF_NOTRAILERS = T.let(T.unsafe(nil), Integer)
Socket::IFF_OACTIVE = T.let(T.unsafe(nil), Integer)
Socket::IFF_POINTOPOINT = T.let(T.unsafe(nil), Integer)
Socket::IFF_PROMISC = T.let(T.unsafe(nil), Integer)
Socket::IFF_RUNNING = T.let(T.unsafe(nil), Integer)
Socket::IFF_SIMPLEX = T.let(T.unsafe(nil), Integer)
Socket::IFF_UP = T.let(T.unsafe(nil), Integer)
Socket::IFNAMSIZ = T.let(T.unsafe(nil), Integer)
Socket::IF_NAMESIZE = T.let(T.unsafe(nil), Integer)
Socket::INADDR_ALLHOSTS_GROUP = T.let(T.unsafe(nil), Integer)
Socket::INADDR_ANY = T.let(T.unsafe(nil), Integer)
Socket::INADDR_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::INADDR_LOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::INADDR_MAX_LOCAL_GROUP = T.let(T.unsafe(nil), Integer)
Socket::INADDR_NONE = T.let(T.unsafe(nil), Integer)
Socket::INADDR_UNSPEC_GROUP = T.let(T.unsafe(nil), Integer)
Socket::INET6_ADDRSTRLEN = T.let(T.unsafe(nil), Integer)
Socket::INET_ADDRSTRLEN = T.let(T.unsafe(nil), Integer)
Socket::IPPORT_RESERVED = T.let(T.unsafe(nil), Integer)
Socket::IPPORT_USERRESERVED = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_AH = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_DSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_EGP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_EON = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ESP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_FRAGMENT = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_GGP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_HELLO = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_HOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ICMP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ICMPV6 = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_IDP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_IGMP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_IP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_IPV6 = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_MAX = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ND = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_NONE = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_PUP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_RAW = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ROUTING = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_TCP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_TP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_UDP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_XTP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_CHECKSUM = T.let(T.unsafe(nil), Integer)
Socket::IPV6_DONTFRAG = T.let(T.unsafe(nil), Integer)
Socket::IPV6_DSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_HOPLIMIT = T.let(T.unsafe(nil), Integer)
Socket::IPV6_HOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_JOIN_GROUP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_LEAVE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_MULTICAST_HOPS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_MULTICAST_IF = T.let(T.unsafe(nil), Integer)
Socket::IPV6_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_NEXTHOP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_PATHMTU = T.let(T.unsafe(nil), Integer)
Socket::IPV6_PKTINFO = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVDSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVHOPLIMIT = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVHOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVPATHMTU = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVPKTINFO = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVRTHDR = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVTCLASS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RTHDR = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RTHDRDSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RTHDR_TYPE_0 = T.let(T.unsafe(nil), Integer)
Socket::IPV6_TCLASS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_UNICAST_HOPS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_USE_MIN_MTU = T.let(T.unsafe(nil), Integer)
Socket::IPV6_V6ONLY = T.let(T.unsafe(nil), Integer)
Socket::IP_ADD_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::IP_ADD_SOURCE_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::IP_BLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::IP_DEFAULT_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::IP_DEFAULT_MULTICAST_TTL = T.let(T.unsafe(nil), Integer)
Socket::IP_DONTFRAG = T.let(T.unsafe(nil), Integer)
Socket::IP_DROP_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::IP_DROP_SOURCE_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::IP_HDRINCL = T.let(T.unsafe(nil), Integer)
Socket::IP_IPSEC_POLICY = T.let(T.unsafe(nil), Integer)
Socket::IP_MAX_MEMBERSHIPS = T.let(T.unsafe(nil), Integer)
Socket::IP_MSFILTER = T.let(T.unsafe(nil), Integer)
Socket::IP_MULTICAST_IF = T.let(T.unsafe(nil), Integer)
Socket::IP_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::IP_MULTICAST_TTL = T.let(T.unsafe(nil), Integer)
Socket::IP_OPTIONS = T.let(T.unsafe(nil), Integer)
Socket::IP_PKTINFO = T.let(T.unsafe(nil), Integer)
Socket::IP_PORTRANGE = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVDSTADDR = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVIF = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVOPTS = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVRETOPTS = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVTOS = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVTTL = T.let(T.unsafe(nil), Integer)
Socket::IP_RETOPTS = T.let(T.unsafe(nil), Integer)
Socket::IP_TOS = T.let(T.unsafe(nil), Integer)
Socket::IP_TTL = T.let(T.unsafe(nil), Integer)
Socket::IP_UNBLOCK_SOURCE = T.let(T.unsafe(nil), Integer)

class Socket::Ifaddr
  def addr; end
  def broadaddr; end
  def dstaddr; end
  def flags; end
  def ifindex; end
  def inspect; end
  def name; end
  def netmask; end
end

Socket::LOCAL_PEERCRED = T.let(T.unsafe(nil), Integer)
Socket::MCAST_BLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::MCAST_EXCLUDE = T.let(T.unsafe(nil), Integer)
Socket::MCAST_INCLUDE = T.let(T.unsafe(nil), Integer)
Socket::MCAST_JOIN_GROUP = T.let(T.unsafe(nil), Integer)
Socket::MCAST_JOIN_SOURCE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::MCAST_LEAVE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::MCAST_LEAVE_SOURCE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::MCAST_UNBLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::MSG_CTRUNC = T.let(T.unsafe(nil), Integer)
Socket::MSG_DONTROUTE = T.let(T.unsafe(nil), Integer)
Socket::MSG_DONTWAIT = T.let(T.unsafe(nil), Integer)
Socket::MSG_EOF = T.let(T.unsafe(nil), Integer)
Socket::MSG_EOR = T.let(T.unsafe(nil), Integer)
Socket::MSG_FLUSH = T.let(T.unsafe(nil), Integer)
Socket::MSG_HAVEMORE = T.let(T.unsafe(nil), Integer)
Socket::MSG_HOLD = T.let(T.unsafe(nil), Integer)
Socket::MSG_NOSIGNAL = T.let(T.unsafe(nil), Integer)
Socket::MSG_OOB = T.let(T.unsafe(nil), Integer)
Socket::MSG_PEEK = T.let(T.unsafe(nil), Integer)
Socket::MSG_RCVMORE = T.let(T.unsafe(nil), Integer)
Socket::MSG_SEND = T.let(T.unsafe(nil), Integer)
Socket::MSG_TRUNC = T.let(T.unsafe(nil), Integer)
Socket::MSG_WAITALL = T.let(T.unsafe(nil), Integer)
Socket::NI_DGRAM = T.let(T.unsafe(nil), Integer)
Socket::NI_MAXHOST = T.let(T.unsafe(nil), Integer)
Socket::NI_MAXSERV = T.let(T.unsafe(nil), Integer)
Socket::NI_NAMEREQD = T.let(T.unsafe(nil), Integer)
Socket::NI_NOFQDN = T.let(T.unsafe(nil), Integer)
Socket::NI_NUMERICHOST = T.let(T.unsafe(nil), Integer)
Socket::NI_NUMERICSERV = T.let(T.unsafe(nil), Integer)

class Socket::Option
  def initialize(_arg0, _arg1, _arg2, _arg3); end
  def bool; end
  def byte; end
  def data; end
  def family; end
  def inspect; end
  def int; end
  def ipv4_multicast_loop; end
  def ipv4_multicast_ttl; end
  def level; end
  def linger; end
  def optname; end
  def to_s; end
  def unpack(_arg0); end
  def self.bool(_arg0, _arg1, _arg2, _arg3); end
  def self.byte(_arg0, _arg1, _arg2, _arg3); end
  def self.int(_arg0, _arg1, _arg2, _arg3); end
  def self.ipv4_multicast_loop(_arg0); end
  def self.ipv4_multicast_ttl(_arg0); end
  def self.linger(_arg0, _arg1); end
end

Socket::PF_APPLETALK = T.let(T.unsafe(nil), Integer)
Socket::PF_CCITT = T.let(T.unsafe(nil), Integer)
Socket::PF_CHAOS = T.let(T.unsafe(nil), Integer)
Socket::PF_CNT = T.let(T.unsafe(nil), Integer)
Socket::PF_COIP = T.let(T.unsafe(nil), Integer)
Socket::PF_DATAKIT = T.let(T.unsafe(nil), Integer)
Socket::PF_DLI = T.let(T.unsafe(nil), Integer)
Socket::PF_ECMA = T.let(T.unsafe(nil), Integer)
Socket::PF_HYLINK = T.let(T.unsafe(nil), Integer)
Socket::PF_IMPLINK = T.let(T.unsafe(nil), Integer)
Socket::PF_INET = T.let(T.unsafe(nil), Integer)
Socket::PF_INET6 = T.let(T.unsafe(nil), Integer)
Socket::PF_IPX = T.let(T.unsafe(nil), Integer)
Socket::PF_ISDN = T.let(T.unsafe(nil), Integer)
Socket::PF_ISO = T.let(T.unsafe(nil), Integer)
Socket::PF_KEY = T.let(T.unsafe(nil), Integer)
Socket::PF_LAT = T.let(T.unsafe(nil), Integer)
Socket::PF_LINK = T.let(T.unsafe(nil), Integer)
Socket::PF_LOCAL = T.let(T.unsafe(nil), Integer)
Socket::PF_MAX = T.let(T.unsafe(nil), Integer)
Socket::PF_NATM = T.let(T.unsafe(nil), Integer)
Socket::PF_NDRV = T.let(T.unsafe(nil), Integer)
Socket::PF_NETBIOS = T.let(T.unsafe(nil), Integer)
Socket::PF_NS = T.let(T.unsafe(nil), Integer)
Socket::PF_OSI = T.let(T.unsafe(nil), Integer)
Socket::PF_PIP = T.let(T.unsafe(nil), Integer)
Socket::PF_PPP = T.let(T.unsafe(nil), Integer)
Socket::PF_PUP = T.let(T.unsafe(nil), Integer)
Socket::PF_ROUTE = T.let(T.unsafe(nil), Integer)
Socket::PF_RTIP = T.let(T.unsafe(nil), Integer)
Socket::PF_SIP = T.let(T.unsafe(nil), Integer)
Socket::PF_SNA = T.let(T.unsafe(nil), Integer)
Socket::PF_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::PF_UNIX = T.let(T.unsafe(nil), Integer)
Socket::PF_UNSPEC = T.let(T.unsafe(nil), Integer)
Socket::PF_XTP = T.let(T.unsafe(nil), Integer)
Socket::SCM_CREDS = T.let(T.unsafe(nil), Integer)
Socket::SCM_RIGHTS = T.let(T.unsafe(nil), Integer)
Socket::SCM_TIMESTAMP = T.let(T.unsafe(nil), Integer)
Socket::SHUT_RD = T.let(T.unsafe(nil), Integer)
Socket::SHUT_RDWR = T.let(T.unsafe(nil), Integer)
Socket::SHUT_WR = T.let(T.unsafe(nil), Integer)
Socket::SOCK_DGRAM = T.let(T.unsafe(nil), Integer)
Socket::SOCK_RAW = T.let(T.unsafe(nil), Integer)
Socket::SOCK_RDM = T.let(T.unsafe(nil), Integer)
Socket::SOCK_SEQPACKET = T.let(T.unsafe(nil), Integer)
Socket::SOCK_STREAM = T.let(T.unsafe(nil), Integer)
Socket::SOL_SOCKET = T.let(T.unsafe(nil), Integer)
Socket::SOMAXCONN = T.let(T.unsafe(nil), Integer)
Socket::SO_ACCEPTCONN = T.let(T.unsafe(nil), Integer)
Socket::SO_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::SO_DEBUG = T.let(T.unsafe(nil), Integer)
Socket::SO_DONTROUTE = T.let(T.unsafe(nil), Integer)
Socket::SO_DONTTRUNC = T.let(T.unsafe(nil), Integer)
Socket::SO_ERROR = T.let(T.unsafe(nil), Integer)
Socket::SO_KEEPALIVE = T.let(T.unsafe(nil), Integer)
Socket::SO_LINGER = T.let(T.unsafe(nil), Integer)
Socket::SO_NKE = T.let(T.unsafe(nil), Integer)
Socket::SO_NOSIGPIPE = T.let(T.unsafe(nil), Integer)
Socket::SO_NREAD = T.let(T.unsafe(nil), Integer)
Socket::SO_OOBINLINE = T.let(T.unsafe(nil), Integer)
Socket::SO_RCVBUF = T.let(T.unsafe(nil), Integer)
Socket::SO_RCVLOWAT = T.let(T.unsafe(nil), Integer)
Socket::SO_RCVTIMEO = T.let(T.unsafe(nil), Integer)
Socket::SO_REUSEADDR = T.let(T.unsafe(nil), Integer)
Socket::SO_REUSEPORT = T.let(T.unsafe(nil), Integer)
Socket::SO_SNDBUF = T.let(T.unsafe(nil), Integer)
Socket::SO_SNDLOWAT = T.let(T.unsafe(nil), Integer)
Socket::SO_SNDTIMEO = T.let(T.unsafe(nil), Integer)
Socket::SO_TIMESTAMP = T.let(T.unsafe(nil), Integer)
Socket::SO_TYPE = T.let(T.unsafe(nil), Integer)
Socket::SO_USELOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::SO_WANTMORE = T.let(T.unsafe(nil), Integer)
Socket::SO_WANTOOBFLAG = T.let(T.unsafe(nil), Integer)
Socket::TCP_FASTOPEN = T.let(T.unsafe(nil), Integer)
Socket::TCP_KEEPCNT = T.let(T.unsafe(nil), Integer)
Socket::TCP_KEEPINTVL = T.let(T.unsafe(nil), Integer)
Socket::TCP_MAXSEG = T.let(T.unsafe(nil), Integer)
Socket::TCP_NODELAY = T.let(T.unsafe(nil), Integer)
Socket::TCP_NOOPT = T.let(T.unsafe(nil), Integer)
Socket::TCP_NOPUSH = T.let(T.unsafe(nil), Integer)

class Socket::UDPSource
  def initialize(remote_address, local_address, &reply_proc); end
  def inspect; end
  def local_address; end
  def remote_address; end
  def reply(msg); end
end

module Comparable
  def <(_arg0); end
  def <=(_arg0); end
  def ==(_arg0); end
  def >(_arg0); end
  def >=(_arg0); end
  def between?(_arg0, _arg1); end
  def clamp(*_arg0); end
end

class IO::ConsoleMode
  def echo=(_arg0); end
  def raw(*_arg0); end
  def raw!(*_arg0); end
  private def initialize_copy(_arg0); end
end

class IO::EAGAINWaitReadable < ::Errno::EAGAIN
  include ::IO::WaitReadable
end

class IO::EAGAINWaitWritable < ::Errno::EAGAIN
  include ::IO::WaitWritable
end

class IO::EINPROGRESSWaitReadable < ::Errno::EINPROGRESS
  include ::IO::WaitReadable
end

class IO::EINPROGRESSWaitWritable < ::Errno::EINPROGRESS
  include ::IO::WaitWritable
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable
IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable
IO::PRIORITY = T.let(T.unsafe(nil), Integer)
IO::READABLE = T.let(T.unsafe(nil), Integer)
IO::SEEK_CUR = T.let(T.unsafe(nil), Integer)
IO::SEEK_DATA = T.let(T.unsafe(nil), Integer)
IO::SEEK_END = T.let(T.unsafe(nil), Integer)
IO::SEEK_HOLE = T.let(T.unsafe(nil), Integer)
IO::SEEK_SET = T.let(T.unsafe(nil), Integer)
IO::WRITABLE = T.let(T.unsafe(nil), Integer)
module IO::WaitReadable; end
module IO::WaitWritable; end

class Exception
  def initialize(*_arg0); end
  def ==(_arg0); end
  def backtrace; end
  def backtrace_locations; end
  def cause; end
  def exception(*_arg0); end
  def full_message(*_arg0); end
  def inspect; end
  def message; end
  def respond_to?(*_arg0); end
  def set_backtrace(_arg0); end
  def to_s; end
  private def method_missing(*_arg0); end
  private def respond_to_missing?(_arg0, _arg1); end
  def self.exception(*_arg0); end
  def self.to_tty?; end
end

class ArgumentError < ::StandardError; end
Socket::Constants::AF_APPLETALK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_CCITT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_CHAOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_CNT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_COIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_DATAKIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_DLI = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_E164 = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_ECMA = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_HYLINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_IMPLINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_INET = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_INET6 = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_IPX = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_ISDN = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_ISO = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_LAT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_LINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_LOCAL = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_MAX = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_NATM = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_NDRV = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_NETBIOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_NS = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_OSI = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_PPP = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_PUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_ROUTE = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_SIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_SNA = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_UNIX = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_UNSPEC = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_ADDRCONFIG = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_ALL = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_CANONNAME = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_DEFAULT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_MASK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_NUMERICHOST = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_NUMERICSERV = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_PASSIVE = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_V4MAPPED = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_V4MAPPED_CFG = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_ADDRFAMILY = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_AGAIN = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_BADFLAGS = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_BADHINTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_FAIL = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_FAMILY = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_MAX = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_MEMORY = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_NODATA = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_NONAME = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_OVERFLOW = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_PROTOCOL = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_SERVICE = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_SOCKTYPE = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_ALLMULTI = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_ALTPHYS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_DEBUG = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_LINK0 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_LINK1 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_LINK2 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_LOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_MULTICAST = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_NOARP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_NOTRAILERS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_OACTIVE = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_POINTOPOINT = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_PROMISC = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_RUNNING = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_SIMPLEX = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_UP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFNAMSIZ = T.let(T.unsafe(nil), Integer)
Socket::Constants::IF_NAMESIZE = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_ALLHOSTS_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_ANY = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_LOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_MAX_LOCAL_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_NONE = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_UNSPEC_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::INET6_ADDRSTRLEN = T.let(T.unsafe(nil), Integer)
Socket::Constants::INET_ADDRSTRLEN = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPORT_RESERVED = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPORT_USERRESERVED = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_AH = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_DSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_EGP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_EON = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ESP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_FRAGMENT = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_GGP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_HELLO = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_HOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ICMP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ICMPV6 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_IDP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_IGMP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_IP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_IPV6 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_MAX = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ND = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_NONE = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_PUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_RAW = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ROUTING = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_TCP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_TP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_UDP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_XTP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_CHECKSUM = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_DONTFRAG = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_DSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_HOPLIMIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_HOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_JOIN_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_LEAVE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_MULTICAST_HOPS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_MULTICAST_IF = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_NEXTHOP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_PATHMTU = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_PKTINFO = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVDSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVHOPLIMIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVHOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVPATHMTU = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVPKTINFO = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVRTHDR = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVTCLASS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RTHDR = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RTHDRDSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RTHDR_TYPE_0 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_TCLASS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_UNICAST_HOPS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_USE_MIN_MTU = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_V6ONLY = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_ADD_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_ADD_SOURCE_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_BLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DEFAULT_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DEFAULT_MULTICAST_TTL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DONTFRAG = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DROP_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DROP_SOURCE_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_HDRINCL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_IPSEC_POLICY = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MAX_MEMBERSHIPS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MSFILTER = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MULTICAST_IF = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MULTICAST_TTL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_OPTIONS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_PKTINFO = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_PORTRANGE = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVDSTADDR = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVIF = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVRETOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVTOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVTTL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RETOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_TOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_TTL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_UNBLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::Constants::LOCAL_PEERCRED = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_BLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_EXCLUDE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_INCLUDE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_JOIN_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_JOIN_SOURCE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_LEAVE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_LEAVE_SOURCE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_UNBLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_CTRUNC = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_DONTROUTE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_DONTWAIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_EOF = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_EOR = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_FLUSH = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_HAVEMORE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_HOLD = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_NOSIGNAL = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_OOB = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_PEEK = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_RCVMORE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_SEND = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_TRUNC = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_WAITALL = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_DGRAM = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_MAXHOST = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_MAXSERV = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_NAMEREQD = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_NOFQDN = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_NUMERICHOST = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_NUMERICSERV = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_APPLETALK = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_CCITT = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_CHAOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_CNT = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_COIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_DATAKIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_DLI = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_ECMA = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_HYLINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_IMPLINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_INET = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_INET6 = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_IPX = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_ISDN = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_ISO = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_KEY = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_LAT = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_LINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_LOCAL = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_MAX = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_NATM = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_NDRV = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_NETBIOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_NS = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_OSI = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_PIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_PPP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_PUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_ROUTE = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_RTIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_SIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_SNA = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_UNIX = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_UNSPEC = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_XTP = T.let(T.unsafe(nil), Integer)
Socket::Constants::SCM_CREDS = T.let(T.unsafe(nil), Integer)
Socket::Constants::SCM_RIGHTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::SCM_TIMESTAMP = T.let(T.unsafe(nil), Integer)
Socket::Constants::SHUT_RD = T.let(T.unsafe(nil), Integer)
Socket::Constants::SHUT_RDWR = T.let(T.unsafe(nil), Integer)
Socket::Constants::SHUT_WR = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_DGRAM = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_RAW = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_RDM = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_SEQPACKET = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_STREAM = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOL_SOCKET = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOMAXCONN = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_ACCEPTCONN = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_DEBUG = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_DONTROUTE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_DONTTRUNC = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_ERROR = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_KEEPALIVE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_LINGER = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_NKE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_NOSIGPIPE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_NREAD = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_OOBINLINE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_RCVBUF = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_RCVLOWAT = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_RCVTIMEO = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_REUSEADDR = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_REUSEPORT = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_SNDBUF = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_SNDLOWAT = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_SNDTIMEO = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_TIMESTAMP = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_TYPE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_USELOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_WANTMORE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_WANTOOBFLAG = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_FASTOPEN = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_KEEPCNT = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_KEEPINTVL = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_MAXSEG = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_NODELAY = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_NOOPT = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_NOPUSH = T.let(T.unsafe(nil), Integer)

module Enumerable
  def all?(*_arg0); end
  def any?(*_arg0); end
  def chain(*_arg0); end
  def chunk; end
  def chunk_while; end
  def collect; end
  def collect_concat; end
  def count(*_arg0); end
  def cycle(*_arg0); end
  def detect(*_arg0); end
  def drop(_arg0); end
  def drop_while; end
  def each_cons(_arg0); end
  def each_entry(*_arg0); end
  def each_slice(_arg0); end
  def each_with_index(*_arg0); end
  def each_with_object(_arg0); end
  def entries(*_arg0); end
  def filter; end
  def filter_map; end
  def find(*_arg0); end
  def find_all; end
  def find_index(*_arg0); end
  def first(*_arg0); end
  def flat_map; end
  def grep(_arg0); end
  def grep_v(_arg0); end
  def group_by; end
  def include?(_arg0); end
  def inject(*_arg0); end
  def lazy; end
  def map; end
  def max(*_arg0); end
  def max_by(*_arg0); end
  def member?(_arg0); end
  def min(*_arg0); end
  def min_by(*_arg0); end
  def minmax; end
  def minmax_by; end
  def none?(*_arg0); end
  def one?(*_arg0); end
  def partition; end
  def reduce(*_arg0); end
  def reject; end
  def reverse_each(*_arg0); end
  def select; end
  def slice_after(*_arg0); end
  def slice_before(*_arg0); end
  def slice_when; end
  def sort; end
  def sort_by; end
  def sum(*_arg0); end
  def take(_arg0); end
  def take_while; end
  def tally; end
  def to_a(*_arg0); end
  def to_h(*_arg0); end
  def to_set(klass = T.unsafe(nil), *args, &block); end
  def uniq; end
  def zip(*_arg0); end
end

module File::Constants; end
class Errno::EAGAIN < ::SystemCallError; end
class Errno::EINPROGRESS < ::SystemCallError; end
File::Constants::APPEND = T.let(T.unsafe(nil), Integer)
File::Constants::BINARY = T.let(T.unsafe(nil), Integer)
File::Constants::CREAT = T.let(T.unsafe(nil), Integer)
File::Constants::DSYNC = T.let(T.unsafe(nil), Integer)
File::Constants::EXCL = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_CASEFOLD = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_DOTMATCH = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_EXTGLOB = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_NOESCAPE = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_PATHNAME = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_SHORTNAME = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_SYSCASE = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_EX = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_NB = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_SH = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_UN = T.let(T.unsafe(nil), Integer)
File::Constants::NOCTTY = T.let(T.unsafe(nil), Integer)
File::Constants::NOFOLLOW = T.let(T.unsafe(nil), Integer)
File::Constants::NONBLOCK = T.let(T.unsafe(nil), Integer)
File::Constants::NULL = T.let(T.unsafe(nil), String)
File::Constants::RDONLY = T.let(T.unsafe(nil), Integer)
File::Constants::RDWR = T.let(T.unsafe(nil), Integer)
File::Constants::SHARE_DELETE = T.let(T.unsafe(nil), Integer)
File::Constants::SYNC = T.let(T.unsafe(nil), Integer)
File::Constants::TRUNC = T.let(T.unsafe(nil), Integer)
File::Constants::WRONLY = T.let(T.unsafe(nil), Integer)

class SystemCallError < ::StandardError
  def initialize(*_arg0); end
  def errno; end
  def self.===(_arg0); end
end

Errno::EAGAIN::Errno = T.let(T.unsafe(nil), Integer)
Errno::EINPROGRESS::Errno = T.let(T.unsafe(nil), Integer)

module Kconv
  private def guess(str); end
  private def iseuc(str); end
  private def isjis(str); end
  private def issjis(str); end
  private def isutf8(str); end
  private def kconv(str, to_enc, from_enc = T.unsafe(nil)); end
  private def toeuc(str); end
  private def tojis(str); end
  private def tolocale(str); end
  private def tosjis(str); end
  private def toutf16(str); end
  private def toutf32(str); end
  private def toutf8(str); end
  def self.guess(str); end
  def self.iseuc(str); end
  def self.isjis(str); end
  def self.issjis(str); end
  def self.isutf8(str); end
  def self.kconv(str, to_enc, from_enc = T.unsafe(nil)); end
  def self.toeuc(str); end
  def self.tojis(str); end
  def self.tolocale(str); end
  def self.tosjis(str); end
  def self.toutf16(str); end
  def self.toutf32(str); end
  def self.toutf8(str); end
end

module NKF
  private def guess(_arg0); end
  private def nkf(_arg0, _arg1); end
  def self.guess(_arg0); end
  def self.nkf(_arg0, _arg1); end
end

Kconv::ASCII = T.let(T.unsafe(nil), Encoding)
Kconv::BINARY = T.let(T.unsafe(nil), Encoding)
Kconv::EUC = T.let(T.unsafe(nil), Encoding)
Kconv::JIS = T.let(T.unsafe(nil), Encoding)
Kconv::SJIS = T.let(T.unsafe(nil), Encoding)
Kconv::UTF16 = T.let(T.unsafe(nil), Encoding)
Kconv::UTF32 = T.let(T.unsafe(nil), Encoding)
Kconv::UTF8 = T.let(T.unsafe(nil), Encoding)
NKF::ASCII = T.let(T.unsafe(nil), Encoding)
NKF::BINARY = T.let(T.unsafe(nil), Encoding)
NKF::EUC = T.let(T.unsafe(nil), Encoding)
NKF::JIS = T.let(T.unsafe(nil), Encoding)
NKF::NKF_RELEASE_DATE = T.let(T.unsafe(nil), String)
NKF::NKF_VERSION = T.let(T.unsafe(nil), String)
NKF::SJIS = T.let(T.unsafe(nil), Encoding)
NKF::UTF16 = T.let(T.unsafe(nil), Encoding)
NKF::UTF32 = T.let(T.unsafe(nil), Encoding)
NKF::UTF8 = T.let(T.unsafe(nil), Encoding)
NKF::VERSION = T.let(T.unsafe(nil), String)
class Logger
  include ::Logger::Severity
  def initialize(logdev, shift_age = T.unsafe(nil), shift_size = T.unsafe(nil), level: T.unsafe(nil), progname: T.unsafe(nil), formatter: T.unsafe(nil), datetime_format: T.unsafe(nil), binmode: T.unsafe(nil), shift_period_suffix: T.unsafe(nil)); end
  def <<(msg); end
  def add(severity, message = T.unsafe(nil), progname = T.unsafe(nil)); end
  def close; end
  def datetime_format; end
  def datetime_format=(datetime_format); end
  def debug(progname = T.unsafe(nil), &block); end
  def debug!; end
  def debug?; end
  def error(progname = T.unsafe(nil), &block); end
  def error!; end
  def error?; end
  def fatal(progname = T.unsafe(nil), &block); end
  def fatal!; end
  def fatal?; end
  def formatter; end
  def formatter=(_arg0); end
  def info(progname = T.unsafe(nil), &block); end
  def info!; end
  def info?; end
  def level; end
  def level=(severity); end
  def log(severity, message = T.unsafe(nil), progname = T.unsafe(nil)); end
  def progname; end
  def progname=(_arg0); end
  def reopen(logdev = T.unsafe(nil)); end
  def sev_threshold; end
  def sev_threshold=(severity); end
  def unknown(progname = T.unsafe(nil), &block); end
  def warn(progname = T.unsafe(nil), &block); end
  def warn!; end
  def warn?; end
  private def format_message(severity, datetime, progname, msg); end
  private def format_severity(severity); end
end

class Logger::Error < ::RuntimeError; end

class Logger::Formatter
  def initialize; end
  def call(severity, time, progname, msg); end
  def datetime_format; end
  def datetime_format=(_arg0); end
  private def format_datetime(time); end
  private def msg2str(msg); end
end

class Logger::LogDevice
  include ::Logger::Period
  include ::MonitorMixin
  def initialize(log = T.unsafe(nil), shift_age: T.unsafe(nil), shift_size: T.unsafe(nil), shift_period_suffix: T.unsafe(nil), binmode: T.unsafe(nil)); end
  def close; end
  def dev; end
  def filename; end
  def reopen(log = T.unsafe(nil)); end
  def write(message); end
  private def add_log_header(file); end
  private def check_shift_log; end
  private def create_logfile(filename); end
  private def lock_shift_log; end
  private def open_logfile(filename); end
  private def set_dev(log); end
  private def shift_log_age; end
  private def shift_log_period(period_end); end
end

module Logger::Period
  private def next_rotate_time(now, shift_age); end
  private def previous_period_end(now, shift_age); end
  def self.next_rotate_time(now, shift_age); end
  def self.previous_period_end(now, shift_age); end
end

Logger::ProgName = T.let(T.unsafe(nil), String)
Logger::SEV_LABEL = T.let(T.unsafe(nil), Array)
module Logger::Severity; end
class Logger::ShiftingError < ::Logger::Error; end
Logger::VERSION = T.let(T.unsafe(nil), String)
class RuntimeError < ::StandardError; end
Logger::Formatter::Format = T.let(T.unsafe(nil), String)
Logger::Period::SiD = T.let(T.unsafe(nil), Integer)
Logger::Severity::DEBUG = T.let(T.unsafe(nil), Integer)
Logger::Severity::ERROR = T.let(T.unsafe(nil), Integer)
Logger::Severity::FATAL = T.let(T.unsafe(nil), Integer)
Logger::Severity::INFO = T.let(T.unsafe(nil), Integer)
Logger::Severity::UNKNOWN = T.let(T.unsafe(nil), Integer)
Logger::Severity::WARN = T.let(T.unsafe(nil), Integer)

module MonitorMixin
  def initialize(*_arg0, &_arg1); end
  def mon_enter; end
  def mon_exit; end
  def mon_locked?; end
  def mon_owned?; end
  def mon_synchronize(&b); end
  def mon_try_enter; end
  def new_cond; end
  def synchronize(&b); end
  def try_mon_enter; end
  private def mon_check_owner; end
  private def mon_initialize; end
  def self.extend_object(obj); end
end

class StandardError < ::Exception; end

class MonitorMixin::ConditionVariable
  def initialize(monitor); end
  def broadcast; end
  def signal; end
  def wait(timeout = T.unsafe(nil)); end
  def wait_until; end
  def wait_while; end
end

class Exception
  def initialize(*_arg0); end
  def ==(_arg0); end
  def backtrace; end
  def backtrace_locations; end
  def cause; end
  def exception(*_arg0); end
  def full_message(*_arg0); end
  def inspect; end
  def message; end
  def respond_to?(*_arg0); end
  def set_backtrace(_arg0); end
  def to_s; end
  private def method_missing(*_arg0); end
  private def respond_to_missing?(_arg0, _arg1); end
  def self.exception(*_arg0); end
  def self.to_tty?; end
end

module FileUtils
  include ::FileUtils::StreamUtils_
  extend ::FileUtils::StreamUtils_
  private def apply_mask(mode, user_mask, op, mode_mask); end
  private def cd(dir, verbose: T.unsafe(nil), &block); end
  private def chdir(dir, verbose: T.unsafe(nil), &block); end
  private def chmod(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def chmod_R(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end
  private def chown(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def chown_R(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end
  private def cmp(a, b); end
  private def compare_file(a, b); end
  private def compare_stream(a, b); end
  private def copy(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def copy_entry(src, dest, preserve = T.unsafe(nil), dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end
  private def copy_file(src, dest, preserve = T.unsafe(nil), dereference = T.unsafe(nil)); end
  private def copy_stream(src, dest); end
  private def cp(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end
  private def cp_r(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end
  private def fu_each_src_dest(src, dest); end
  private def fu_each_src_dest0(src, dest); end
  private def fu_get_gid(group); end
  private def fu_get_uid(user); end
  private def fu_have_symlink?; end
  private def fu_list(arg); end
  private def fu_mkdir(path, mode); end
  private def fu_mode(mode, path); end
  private def fu_output_message(msg); end
  private def fu_same?(a, b); end
  private def fu_stat_identical_entry?(a, b); end
  private def getwd; end
  private def identical?(a, b); end
  private def install(src, dest, mode: T.unsafe(nil), owner: T.unsafe(nil), group: T.unsafe(nil), preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def link(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def link_entry(src, dest, dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end
  private def ln(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def ln_s(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def ln_sf(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def makedirs(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def mkdir(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def mkdir_p(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def mkpath(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def mode_to_s(mode); end
  private def move(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def mv(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def pwd; end
  private def remove(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def remove_dir(path, force = T.unsafe(nil)); end
  private def remove_entry(path, force = T.unsafe(nil)); end
  private def remove_entry_secure(path, force = T.unsafe(nil)); end
  private def remove_file(path, force = T.unsafe(nil)); end
  private def remove_trailing_slash(dir); end
  private def rm(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def rm_f(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def rm_r(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def rm_rf(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def rmdir(list, parents: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def rmtree(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def safe_unlink(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def symbolic_modes_to_i(mode_sym, path); end
  private def symlink(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def touch(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), mtime: T.unsafe(nil), nocreate: T.unsafe(nil)); end
  private def uptodate?(new, old_list); end
  private def user_mask(target); end
  def self.cd(dir, verbose: T.unsafe(nil), &block); end
  def self.chdir(dir, verbose: T.unsafe(nil), &block); end
  def self.chmod(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.chmod_R(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end
  def self.chown(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.chown_R(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end
  def self.cmp(a, b); end
  def self.collect_method(opt); end
  def self.commands; end
  def self.compare_file(a, b); end
  def self.compare_stream(a, b); end
  def self.copy(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.copy_entry(src, dest, preserve = T.unsafe(nil), dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end
  def self.copy_file(src, dest, preserve = T.unsafe(nil), dereference = T.unsafe(nil)); end
  def self.copy_stream(src, dest); end
  def self.cp(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end
  def self.cp_r(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end
  def self.getwd; end
  def self.have_option?(mid, opt); end
  def self.identical?(a, b); end
  def self.install(src, dest, mode: T.unsafe(nil), owner: T.unsafe(nil), group: T.unsafe(nil), preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.link(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.link_entry(src, dest, dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end
  def self.ln(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.ln_s(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.ln_sf(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.makedirs(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.mkdir(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.mkdir_p(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.mkpath(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.move(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.mv(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.options; end
  def self.options_of(mid); end
  def self.private_module_function(name); end
  def self.pwd; end
  def self.remove(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.remove_dir(path, force = T.unsafe(nil)); end
  def self.remove_entry(path, force = T.unsafe(nil)); end
  def self.remove_entry_secure(path, force = T.unsafe(nil)); end
  def self.remove_file(path, force = T.unsafe(nil)); end
  def self.rm(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.rm_f(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.rm_r(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.rm_rf(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.rmdir(list, parents: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.rmtree(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.safe_unlink(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.symlink(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.touch(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), mtime: T.unsafe(nil), nocreate: T.unsafe(nil)); end
  def self.uptodate?(new, old_list); end
  private def self.apply_mask(mode, user_mask, op, mode_mask); end
  private def self.fu_each_src_dest(src, dest); end
  private def self.fu_each_src_dest0(src, dest); end
  private def self.fu_get_gid(group); end
  private def self.fu_get_uid(user); end
  private def self.fu_have_symlink?; end
  private def self.fu_list(arg); end
  private def self.fu_mkdir(path, mode); end
  private def self.fu_mode(mode, path); end
  private def self.fu_output_message(msg); end
  private def self.fu_same?(a, b); end
  private def self.fu_stat_identical_entry?(a, b); end
  private def self.mode_to_s(mode); end
  private def self.remove_trailing_slash(dir); end
  private def self.symbolic_modes_to_i(mode_sym, path); end
  private def self.user_mask(target); end
end

module MakeMakefile
  def append_cflags(flags, *opts); end
  def append_cppflags(flags, *opts); end
  def append_ldflags(flags, *opts); end
  def append_library(libs, lib); end
  def arg_config(config, default = T.unsafe(nil), &block); end
  def cc_command(opt = T.unsafe(nil)); end
  def cc_config(opt = T.unsafe(nil)); end
  def check_signedness(type, headers = T.unsafe(nil), opts = T.unsafe(nil), &b); end
  def check_sizeof(type, headers = T.unsafe(nil), opts = T.unsafe(nil), &b); end
  def checking_for(m, fmt = T.unsafe(nil)); end
  def checking_message(target, place = T.unsafe(nil), opt = T.unsafe(nil)); end
  def configuration(srcdir); end
  def conftest_source; end
  def convertible_int(type, headers = T.unsafe(nil), opts = T.unsafe(nil), &b); end
  def cpp_command(outfile, opt = T.unsafe(nil)); end
  def cpp_include(header); end
  def create_header(header = T.unsafe(nil)); end
  def create_makefile(target, srcprefix = T.unsafe(nil)); end
  def create_tmpsrc(src); end
  def depend_rules(depend); end
  def dir_config(target, idefault = T.unsafe(nil), ldefault = T.unsafe(nil)); end
  def dummy_makefile(srcdir); end
  def each_compile_rules; end
  def egrep_cpp(pat, src, opt = T.unsafe(nil), &b); end
  def enable_config(config, default = T.unsafe(nil)); end
  def find_executable(bin, path = T.unsafe(nil)); end
  def find_executable0(bin, path = T.unsafe(nil)); end
  def find_header(header, *paths); end
  def find_library(lib, func, *paths, &b); end
  def find_type(type, opt, *headers, &b); end
  def have_const(const, headers = T.unsafe(nil), opt = T.unsafe(nil), &b); end
  def have_devel?; end
  def have_framework(fw, &b); end
  def have_func(func, headers = T.unsafe(nil), opt = T.unsafe(nil), &b); end
  def have_header(header, preheaders = T.unsafe(nil), opt = T.unsafe(nil), &b); end
  def have_library(lib, func = T.unsafe(nil), headers = T.unsafe(nil), opt = T.unsafe(nil), &b); end
  def have_macro(macro, headers = T.unsafe(nil), opt = T.unsafe(nil), &b); end
  def have_struct_member(type, member, headers = T.unsafe(nil), opt = T.unsafe(nil), &b); end
  def have_type(type, headers = T.unsafe(nil), opt = T.unsafe(nil), &b); end
  def have_typeof?; end
  def have_var(var, headers = T.unsafe(nil), opt = T.unsafe(nil), &b); end
  def init_mkmf(config = T.unsafe(nil), rbconfig = T.unsafe(nil)); end
  def install_dirs(target_prefix = T.unsafe(nil)); end
  def install_files(mfile, ifiles, map = T.unsafe(nil), srcprefix = T.unsafe(nil)); end
  def install_rb(mfile, dest, srcdir = T.unsafe(nil)); end
  def libpath_env; end
  def libpathflag(libpath = T.unsafe(nil)); end
  def link_command(ldflags, *opts); end
  def link_config(ldflags, opt = T.unsafe(nil), libpath = T.unsafe(nil)); end
  def log_src(src, heading = T.unsafe(nil)); end
  def macro_defined?(macro, src, opt = T.unsafe(nil), &b); end
  def map_dir(dir, map = T.unsafe(nil)); end
  def merge_libs(*libs); end
  def message(*s); end
  def mkintpath(path); end
  def mkmf_failed(path); end
  def modified?(target, times); end
  def pkg_config(pkg, option = T.unsafe(nil)); end
  def relative_from(path, base); end
  def scalar_ptr_type?(type, member = T.unsafe(nil), headers = T.unsafe(nil), &b); end
  def scalar_type?(type, member = T.unsafe(nil), headers = T.unsafe(nil), &b); end
  def split_libs(*strs); end
  def timestamp_file(name, target_prefix = T.unsafe(nil)); end
  def try_cflags(flags, opts = T.unsafe(nil)); end
  def try_compile(src, opt = T.unsafe(nil), *opts, &b); end
  def try_const(const, headers = T.unsafe(nil), opt = T.unsafe(nil), &b); end
  def try_constant(const, headers = T.unsafe(nil), opt = T.unsafe(nil), &b); end
  def try_cpp(src, opt = T.unsafe(nil), *opts, &b); end
  def try_cppflags(flags, opts = T.unsafe(nil)); end
  def try_do(src, command, *opts, &b); end
  def try_func(func, libs, headers = T.unsafe(nil), opt = T.unsafe(nil), &b); end
  def try_header(src, opt = T.unsafe(nil), *opts, &b); end
  def try_ldflags(flags, opts = T.unsafe(nil)); end
  def try_link(src, opt = T.unsafe(nil), *opts, &b); end
  def try_link0(src, opt = T.unsafe(nil), *opts, &b); end
  def try_run(src, opt = T.unsafe(nil), &b); end
  def try_signedness(type, member, headers = T.unsafe(nil), opts = T.unsafe(nil)); end
  def try_static_assert(expr, headers = T.unsafe(nil), opt = T.unsafe(nil), &b); end
  def try_type(type, headers = T.unsafe(nil), opt = T.unsafe(nil), &b); end
  def try_var(var, headers = T.unsafe(nil), opt = T.unsafe(nil), &b); end
  def typedef_expr(type, headers); end
  def what_type?(type, member = T.unsafe(nil), headers = T.unsafe(nil), &b); end
  def winsep(s); end
  def with_cflags(flags); end
  def with_config(config, default = T.unsafe(nil)); end
  def with_cppflags(flags); end
  def with_destdir(dir); end
  def with_ldflags(flags); end
  def with_werror(opt, opts = T.unsafe(nil)); end
  def xpopen(command, *mode, &block); end
  def xsystem(command, opts = T.unsafe(nil)); end
  private def MAIN_DOES_NOTHING(*refs); end
  private def _libdir_basename; end
  private def config_string(key, config = T.unsafe(nil)); end
  private def dir_re(dir); end
  private def rm_f(*files); end
  private def rm_rf(*files); end
  def self.[](name); end
  def self.[]=(name, mod); end
  def self.config_string(key, config = T.unsafe(nil)); end
  def self.dir_re(dir); end
  def self.rm_f(*files); end
  def self.rm_rf(*files); end
end

module Shellwords
  private def shellescape(str); end
  private def shelljoin(array); end
  private def shellsplit(line); end
  private def shellwords(line); end
  def self.escape(str); end
  def self.join(array); end
  def self.shellescape(str); end
  def self.shelljoin(array); end
  def self.shellsplit(line); end
  def self.shellwords(line); end
  def self.split(line); end
end

module FileUtils::DryRun
  include ::FileUtils::StreamUtils_
  include ::FileUtils
  include ::FileUtils::LowMethods
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils
  extend ::FileUtils::LowMethods
  extend ::FileUtils::DryRun
  private def chmod(*args, **options); end
  private def chmod_R(*args, **options); end
  private def chown(*args, **options); end
  private def chown_R(*args, **options); end
  private def copy(*args, **options); end
  private def cp(*args, **options); end
  private def cp_lr(*args, **options); end
  private def cp_r(*args, **options); end
  private def install(*args, **options); end
  private def link(*args, **options); end
  private def ln(*args, **options); end
  private def ln_s(*args, **options); end
  private def ln_sf(*args, **options); end
  private def makedirs(*args, **options); end
  private def mkdir(*args, **options); end
  private def mkdir_p(*args, **options); end
  private def mkpath(*args, **options); end
  private def move(*args, **options); end
  private def mv(*args, **options); end
  private def remove(*args, **options); end
  private def rm(*args, **options); end
  private def rm_f(*args, **options); end
  private def rm_r(*args, **options); end
  private def rm_rf(*args, **options); end
  private def rmdir(*args, **options); end
  private def rmtree(*args, **options); end
  private def safe_unlink(*args, **options); end
  private def symlink(*args, **options); end
  private def touch(*args, **options); end
end

class FileUtils::Entry_
  include ::FileUtils::StreamUtils_
  def initialize(a, b = T.unsafe(nil), deref = T.unsafe(nil)); end
  def blockdev?; end
  def chardev?; end
  def chmod(mode); end
  def chown(uid, gid); end
  def copy(dest); end
  def copy_file(dest); end
  def copy_metadata(path); end
  def dereference?; end
  def directory?; end
  def door?; end
  def entries; end
  def exist?; end
  def file?; end
  def inspect; end
  def link(dest); end
  def lstat; end
  def lstat!; end
  def path; end
  def pipe?; end
  def platform_support; end
  def postorder_traverse; end
  def prefix; end
  def preorder_traverse; end
  def rel; end
  def remove; end
  def remove_dir1; end
  def remove_file; end
  def socket?; end
  def stat; end
  def stat!; end
  def symlink?; end
  def traverse; end
  def wrap_traverse(pre, post); end
  private def check_have_lchmod?; end
  private def check_have_lchown?; end
  private def descendant_directory?(descendant, ascendant); end
  private def have_lchmod?; end
  private def have_lchown?; end
  private def join(dir, base); end
end

FileUtils::LOW_METHODS = T.let(T.unsafe(nil), Array)

module FileUtils::LowMethods
  private def _do_nothing(*_arg0); end
  private def cd(*_arg0); end
  private def chdir(*_arg0); end
  private def cmp(*_arg0); end
  private def collect_method(*_arg0); end
  private def commands(*_arg0); end
  private def compare_file(*_arg0); end
  private def compare_stream(*_arg0); end
  private def copy_entry(*_arg0); end
  private def copy_file(*_arg0); end
  private def copy_stream(*_arg0); end
  private def getwd(*_arg0); end
  private def have_option?(*_arg0); end
  private def identical?(*_arg0); end
  private def link_entry(*_arg0); end
  private def options(*_arg0); end
  private def options_of(*_arg0); end
  private def private_module_function(*_arg0); end
  private def pwd(*_arg0); end
  private def remove_dir(*_arg0); end
  private def remove_entry(*_arg0); end
  private def remove_entry_secure(*_arg0); end
  private def remove_file(*_arg0); end
  private def uptodate?(*_arg0); end
end

FileUtils::METHODS = T.let(T.unsafe(nil), Array)

module FileUtils::NoWrite
  include ::FileUtils::StreamUtils_
  include ::FileUtils
  include ::FileUtils::LowMethods
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils
  extend ::FileUtils::LowMethods
  extend ::FileUtils::NoWrite
  private def chmod(*args, **options); end
  private def chmod_R(*args, **options); end
  private def chown(*args, **options); end
  private def chown_R(*args, **options); end
  private def copy(*args, **options); end
  private def cp(*args, **options); end
  private def cp_lr(*args, **options); end
  private def cp_r(*args, **options); end
  private def install(*args, **options); end
  private def link(*args, **options); end
  private def ln(*args, **options); end
  private def ln_s(*args, **options); end
  private def ln_sf(*args, **options); end
  private def makedirs(*args, **options); end
  private def mkdir(*args, **options); end
  private def mkdir_p(*args, **options); end
  private def mkpath(*args, **options); end
  private def move(*args, **options); end
  private def mv(*args, **options); end
  private def remove(*args, **options); end
  private def rm(*args, **options); end
  private def rm_f(*args, **options); end
  private def rm_r(*args, **options); end
  private def rm_rf(*args, **options); end
  private def rmdir(*args, **options); end
  private def rmtree(*args, **options); end
  private def safe_unlink(*args, **options); end
  private def symlink(*args, **options); end
  private def touch(*args, **options); end
end

FileUtils::OPT_TABLE = T.let(T.unsafe(nil), Hash)

module FileUtils::StreamUtils_
  private def fu_blksize(st); end
  private def fu_copy_stream0(src, dest, blksize = T.unsafe(nil)); end
  private def fu_default_blksize; end
  private def fu_stream_blksize(*streams); end
  private def fu_windows?; end
end

FileUtils::VERSION = T.let(T.unsafe(nil), String)

module FileUtils::Verbose
  include ::FileUtils::StreamUtils_
  include ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils
  extend ::FileUtils::Verbose
  private def cd(*args, **options); end
  private def chdir(*args, **options); end
  private def chmod(*args, **options); end
  private def chmod_R(*args, **options); end
  private def chown(*args, **options); end
  private def chown_R(*args, **options); end
  private def copy(*args, **options); end
  private def cp(*args, **options); end
  private def cp_lr(*args, **options); end
  private def cp_r(*args, **options); end
  private def install(*args, **options); end
  private def link(*args, **options); end
  private def ln(*args, **options); end
  private def ln_s(*args, **options); end
  private def ln_sf(*args, **options); end
  private def makedirs(*args, **options); end
  private def mkdir(*args, **options); end
  private def mkdir_p(*args, **options); end
  private def mkpath(*args, **options); end
  private def move(*args, **options); end
  private def mv(*args, **options); end
  private def remove(*args, **options); end
  private def rm(*args, **options); end
  private def rm_f(*args, **options); end
  private def rm_r(*args, **options); end
  private def rm_rf(*args, **options); end
  private def rmdir(*args, **options); end
  private def rmtree(*args, **options); end
  private def safe_unlink(*args, **options); end
  private def symlink(*args, **options); end
  private def touch(*args, **options); end
end

MakeMakefile::ASSEMBLE_C = T.let(T.unsafe(nil), String)
MakeMakefile::ASSEMBLE_CXX = T.let(T.unsafe(nil), String)
MakeMakefile::CLEANINGS = T.let(T.unsafe(nil), String)
MakeMakefile::COMMON_HEADERS = T.let(T.unsafe(nil), String)
MakeMakefile::COMMON_LIBS = T.let(T.unsafe(nil), Array)
MakeMakefile::COMPILE_C = T.let(T.unsafe(nil), String)
MakeMakefile::COMPILE_CXX = T.let(T.unsafe(nil), String)
MakeMakefile::COMPILE_RULES = T.let(T.unsafe(nil), Array)
MakeMakefile::CONFIG = T.let(T.unsafe(nil), Hash)
MakeMakefile::CONFTEST = T.let(T.unsafe(nil), String)
MakeMakefile::CONFTEST_C = T.let(T.unsafe(nil), String)
MakeMakefile::CONFTEST_CXX = T.let(T.unsafe(nil), String)
MakeMakefile::COUTFLAG = T.let(T.unsafe(nil), String)
MakeMakefile::CPPOUTFILE = T.let(T.unsafe(nil), String)
MakeMakefile::CSRCFLAG = T.let(T.unsafe(nil), String)
MakeMakefile::CXX_EXT = T.let(T.unsafe(nil), Array)
MakeMakefile::C_EXT = T.let(T.unsafe(nil), Array)
MakeMakefile::FailedMessage = T.let(T.unsafe(nil), String)
MakeMakefile::HDR_EXT = T.let(T.unsafe(nil), Array)
MakeMakefile::INSTALL_DIRS = T.let(T.unsafe(nil), Array)
MakeMakefile::LIBARG = T.let(T.unsafe(nil), String)
MakeMakefile::LIBPATHFLAG = T.let(T.unsafe(nil), String)
MakeMakefile::LINK_SO = T.let(T.unsafe(nil), String)

module MakeMakefile::Logging
  def self.log_close; end
  def self.log_open; end
  def self.log_opened?; end
  def self.logfile(file); end
  def self.message(*s); end
  def self.open; end
  def self.postpone; end
  def self.quiet; end
  def self.quiet=(_arg0); end
end

MakeMakefile::MAIN_DOES_NOTHING = T.let(T.unsafe(nil), String)
MakeMakefile::OUTFLAG = T.let(T.unsafe(nil), String)
MakeMakefile::RPATHFLAG = T.let(T.unsafe(nil), String)
MakeMakefile::SRC_EXT = T.let(T.unsafe(nil), Array)
MakeMakefile::STRING_OR_FAILED_FORMAT = T.let(T.unsafe(nil), String)
MakeMakefile::TRY_LINK = T.let(T.unsafe(nil), String)
MakeMakefile::TRY_LINK_CXX = T.let(T.unsafe(nil), String)
MakeMakefile::UNIVERSAL_INTS = T.let(T.unsafe(nil), Array)
FileUtils::Entry_::DIRECTORY_TERM = T.let(T.unsafe(nil), String)
FileUtils::Entry_::S_IF_DOOR = T.let(T.unsafe(nil), Integer)
module Mutex_m
  def initialize(*args); end
  def mu_extended; end
  def mu_lock; end
  def mu_locked?; end
  def mu_synchronize(&block); end
  def mu_try_lock; end
  def mu_unlock; end
  def sleep(timeout = T.unsafe(nil)); end
  private def mu_initialize; end
  def self.append_features(cl); end
  def self.define_aliases(cl); end
  def self.extend_object(obj); end
end

Mutex_m::VERSION = T.let(T.unsafe(nil), String)
class TCPSocket < ::IPSocket
  def initialize(*_arg0); end
  def self.gethostbyname(_arg0); end
end

class UNIXServer < ::UNIXSocket
  def initialize(_arg0); end
  def accept; end
  def accept_nonblock(exception: T.unsafe(nil)); end
  def listen(_arg0); end
  def sysaccept; end
  private def __accept_nonblock(_arg0); end
end

module Timeout
  private def timeout(sec, klass = T.unsafe(nil), message = T.unsafe(nil), &block); end
  def self.timeout(sec, klass = T.unsafe(nil), message = T.unsafe(nil), &block); end
end

class Socket < ::BasicSocket
  def initialize(*_arg0); end
  def accept; end
  def accept_nonblock(exception: T.unsafe(nil)); end
  def bind(_arg0); end
  def connect(_arg0); end
  def connect_nonblock(addr, exception: T.unsafe(nil)); end
  def ipv6only!; end
  def listen(_arg0); end
  def recvfrom(*_arg0); end
  def recvfrom_nonblock(len, flag = T.unsafe(nil), str = T.unsafe(nil), exception: T.unsafe(nil)); end
  def sysaccept; end
  private def __accept_nonblock(_arg0); end
  private def __connect_nonblock(_arg0, _arg1); end
  private def __recvfrom_nonblock(_arg0, _arg1, _arg2, _arg3); end
  def self.accept_loop(*sockets); end
  def self.getaddrinfo(*_arg0); end
  def self.gethostbyaddr(*_arg0); end
  def self.gethostbyname(_arg0); end
  def self.gethostname; end
  def self.getifaddrs; end
  def self.getnameinfo(*_arg0); end
  def self.getservbyname(*_arg0); end
  def self.getservbyport(*_arg0); end
  def self.ip_address_list; end
  def self.pack_sockaddr_in(_arg0, _arg1); end
  def self.pack_sockaddr_un(_arg0); end
  def self.pair(*_arg0); end
  def self.sockaddr_in(_arg0, _arg1); end
  def self.sockaddr_un(_arg0); end
  def self.socketpair(*_arg0); end
  def self.tcp(host, port, local_host = T.unsafe(nil), local_port = T.unsafe(nil), connect_timeout: T.unsafe(nil), resolv_timeout: T.unsafe(nil)); end
  def self.tcp_server_loop(host = T.unsafe(nil), port, &b); end
  def self.tcp_server_sockets(host = T.unsafe(nil), port); end
  def self.udp_server_loop(host = T.unsafe(nil), port, &b); end
  def self.udp_server_loop_on(sockets, &b); end
  def self.udp_server_recv(sockets); end
  def self.udp_server_sockets(host = T.unsafe(nil), port); end
  def self.unix(path); end
  def self.unix_server_loop(path, &b); end
  def self.unix_server_socket(path); end
  def self.unpack_sockaddr_in(_arg0); end
  def self.unpack_sockaddr_un(_arg0); end
  private def self.ip_sockets_port0(ai_list, reuseaddr); end
  private def self.tcp_server_sockets_port0(host); end
  private def self.unix_socket_abstract_name?(path); end
end

class UDPSocket < ::IPSocket
  def initialize(*_arg0); end
  def bind(_arg0, _arg1); end
  def connect(_arg0, _arg1); end
  def recvfrom_nonblock(len, flag = T.unsafe(nil), outbuf = T.unsafe(nil), exception: T.unsafe(nil)); end
  def send(*_arg0); end
  private def __recvfrom_nonblock(_arg0, _arg1, _arg2, _arg3); end
end

class TCPServer < ::TCPSocket
  def initialize(*_arg0); end
  def accept; end
  def accept_nonblock(exception: T.unsafe(nil)); end
  def listen(_arg0); end
  def sysaccept; end
  private def __accept_nonblock(_arg0); end
end

class IPAddr
  include ::Comparable
  def initialize(addr = T.unsafe(nil), family = T.unsafe(nil)); end
  def &(other); end
  def <<(num); end
  def <=>(other); end
  def ==(other); end
  def ===(other); end
  def >>(num); end
  def eql?(other); end
  def family; end
  def hash; end
  def hton; end
  def include?(other); end
  def inspect; end
  def ip6_arpa; end
  def ip6_int; end
  def ipv4?; end
  def ipv4_compat; end
  def ipv4_compat?; end
  def ipv4_mapped; end
  def ipv4_mapped?; end
  def ipv6?; end
  def link_local?; end
  def loopback?; end
  def mask(prefixlen); end
  def native; end
  def prefix; end
  def prefix=(prefix); end
  def private?; end
  def reverse; end
  def succ; end
  def to_i; end
  def to_range; end
  def to_s; end
  def to_string; end
  def |(other); end
  def ~; end
  protected def mask!(mask); end
  protected def set(addr, *family); end
  private def _ipv4_compat?; end
  private def _reverse; end
  private def _to_string(addr); end
  private def addr_mask(addr); end
  private def coerce_other(other); end
  private def in6_addr(left); end
  private def in_addr(addr); end
  def self.new_ntoh(addr); end
  def self.ntop(addr); end
end

class IPSocket < ::BasicSocket
  def addr(*_arg0); end
  def inspect; end
  def peeraddr(*_arg0); end
  def recvfrom(*_arg0); end
  def self.getaddress(_arg0); end
end

class Addrinfo
  def initialize(*_arg0); end
  def afamily; end
  def bind; end
  def canonname; end
  def connect(timeout: T.unsafe(nil), &block); end
  def connect_from(*args, timeout: T.unsafe(nil), &block); end
  def connect_to(*args, timeout: T.unsafe(nil), &block); end
  def family_addrinfo(*args); end
  def getnameinfo(*_arg0); end
  def inspect; end
  def inspect_sockaddr; end
  def ip?; end
  def ip_address; end
  def ip_port; end
  def ip_unpack; end
  def ipv4?; end
  def ipv4_loopback?; end
  def ipv4_multicast?; end
  def ipv4_private?; end
  def ipv6?; end
  def ipv6_linklocal?; end
  def ipv6_loopback?; end
  def ipv6_mc_global?; end
  def ipv6_mc_linklocal?; end
  def ipv6_mc_nodelocal?; end
  def ipv6_mc_orglocal?; end
  def ipv6_mc_sitelocal?; end
  def ipv6_multicast?; end
  def ipv6_sitelocal?; end
  def ipv6_to_ipv4; end
  def ipv6_unique_local?; end
  def ipv6_unspecified?; end
  def ipv6_v4compat?; end
  def ipv6_v4mapped?; end
  def listen(backlog = T.unsafe(nil)); end
  def marshal_dump; end
  def marshal_load(_arg0); end
  def pfamily; end
  def protocol; end
  def socktype; end
  def to_s; end
  def to_sockaddr; end
  def unix?; end
  def unix_path; end
  protected def connect_internal(local_addrinfo, timeout = T.unsafe(nil)); end
  def self.foreach(nodename, service, family = T.unsafe(nil), socktype = T.unsafe(nil), protocol = T.unsafe(nil), flags = T.unsafe(nil), timeout: T.unsafe(nil), &block); end
  def self.getaddrinfo(*_arg0); end
  def self.ip(_arg0); end
  def self.tcp(_arg0, _arg1); end
  def self.udp(_arg0, _arg1); end
  def self.unix(*_arg0); end
end

class UNIXSocket < ::BasicSocket
  def initialize(_arg0); end
  def addr; end
  def path; end
  def peeraddr; end
  def recv_io(*_arg0); end
  def recvfrom(*_arg0); end
  def send_io(_arg0); end
  def self.pair(*_arg0); end
  def self.socketpair(*_arg0); end
end

module URI
  include ::URI::RFC2396_REGEXP
  def self.decode_www_form(str, enc = T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end
  def self.decode_www_form_component(str, enc = T.unsafe(nil)); end
  def self.encode_www_form(enum, enc = T.unsafe(nil)); end
  def self.encode_www_form_component(str, enc = T.unsafe(nil)); end
  def self.extract(str, schemes = T.unsafe(nil), &block); end
  def self.for(scheme, *arguments, default: T.unsafe(nil)); end
  def self.get_encoding(label); end
  def self.join(*str); end
  def self.parse(uri); end
  def self.regexp(schemes = T.unsafe(nil)); end
  def self.scheme_list; end
  def self.split(uri); end
end

module Zlib
  private def adler32(*_arg0); end
  private def adler32_combine(_arg0, _arg1, _arg2); end
  private def crc32(*_arg0); end
  private def crc32_combine(_arg0, _arg1, _arg2); end
  private def crc_table; end
  private def zlib_version; end
  def self.adler32(*_arg0); end
  def self.adler32_combine(_arg0, _arg1, _arg2); end
  def self.crc32(*_arg0); end
  def self.crc32_combine(_arg0, _arg1, _arg2); end
  def self.crc_table; end
  def self.deflate(*_arg0); end
  def self.gunzip(_arg0); end
  def self.gzip(*_arg0); end
  def self.inflate(_arg0); end
  def self.zlib_version; end
end

class DateTime < ::Date
  def hour; end
  def iso8601(*_arg0); end
  def jisx0301(*_arg0); end
  def min; end
  def minute; end
  def new_offset(*_arg0); end
  def offset; end
  def rfc3339(*_arg0); end
  def sec; end
  def sec_fraction; end
  def second; end
  def second_fraction; end
  def strftime(*_arg0); end
  def to_date; end
  def to_datetime; end
  def to_s; end
  def to_time; end
  def xmlschema(*_arg0); end
  def zone; end
  def self._strptime(*_arg0); end
  def self.civil(*_arg0); end
  def self.commercial(*_arg0); end
  def self.httpdate(*_arg0); end
  def self.iso8601(*_arg0); end
  def self.jd(*_arg0); end
  def self.jisx0301(*_arg0); end
  def self.new(*_arg0); end
  def self.now(*_arg0); end
  def self.ordinal(*_arg0); end
  def self.parse(*_arg0); end
  def self.rfc2822(*_arg0); end
  def self.rfc3339(*_arg0); end
  def self.rfc822(*_arg0); end
  def self.strptime(*_arg0); end
  def self.xmlschema(*_arg0); end
end

module Digest
  private def hexencode(_arg0); end
  def self.const_missing(name); end
  def self.hexencode(_arg0); end
end

class StringScanner
  def initialize(*_arg0); end
  def <<(_arg0); end
  def [](_arg0); end
  def beginning_of_line?; end
  def bol?; end
  def captures; end
  def charpos; end
  def check(_arg0); end
  def check_until(_arg0); end
  def clear; end
  def concat(_arg0); end
  def empty?; end
  def eos?; end
  def exist?(_arg0); end
  def fixed_anchor?; end
  def get_byte; end
  def getbyte; end
  def getch; end
  def inspect; end
  def match?(_arg0); end
  def matched; end
  def matched?; end
  def matched_size; end
  def peek(_arg0); end
  def peep(_arg0); end
  def pointer; end
  def pointer=(_arg0); end
  def pos; end
  def pos=(_arg0); end
  def post_match; end
  def pre_match; end
  def reset; end
  def rest; end
  def rest?; end
  def rest_size; end
  def restsize; end
  def scan(_arg0); end
  def scan_full(_arg0, _arg1, _arg2); end
  def scan_until(_arg0); end
  def search_full(_arg0, _arg1, _arg2); end
  def size; end
  def skip(_arg0); end
  def skip_until(_arg0); end
  def string; end
  def string=(_arg0); end
  def terminate; end
  def unscan; end
  def values_at(*_arg0); end
  private def initialize_copy(_arg0); end
  def self.must_C_version; end
end

class Date
  include ::Comparable
  def initialize(*_arg0); end
  def +(_arg0); end
  def -(_arg0); end
  def <<(_arg0); end
  def <=>(_arg0); end
  def ===(_arg0); end
  def >>(_arg0); end
  def ajd; end
  def amjd; end
  def asctime; end
  def ctime; end
  def cwday; end
  def cweek; end
  def cwyear; end
  def day; end
  def day_fraction; end
  def downto(_arg0); end
  def england; end
  def eql?(_arg0); end
  def friday?; end
  def gregorian; end
  def gregorian?; end
  def hash; end
  def httpdate; end
  def infinite?; end
  def inspect; end
  def iso8601; end
  def italy; end
  def jd; end
  def jisx0301; end
  def julian; end
  def julian?; end
  def ld; end
  def leap?; end
  def marshal_dump; end
  def marshal_load(_arg0); end
  def mday; end
  def mjd; end
  def mon; end
  def monday?; end
  def month; end
  def new_start(*_arg0); end
  def next; end
  def next_day(*_arg0); end
  def next_month(*_arg0); end
  def next_year(*_arg0); end
  def prev_day(*_arg0); end
  def prev_month(*_arg0); end
  def prev_year(*_arg0); end
  def rfc2822; end
  def rfc3339; end
  def rfc822; end
  def saturday?; end
  def start; end
  def step(*_arg0); end
  def strftime(*_arg0); end
  def succ; end
  def sunday?; end
  def thursday?; end
  def to_date; end
  def to_datetime; end
  def to_s; end
  def to_time; end
  def tuesday?; end
  def upto(_arg0); end
  def wday; end
  def wednesday?; end
  def xmlschema; end
  def yday; end
  def year; end
  private def hour; end
  private def initialize_copy(_arg0); end
  private def min; end
  private def minute; end
  private def sec; end
  private def second; end
  def self._httpdate(_arg0); end
  def self._iso8601(_arg0); end
  def self._jisx0301(_arg0); end
  def self._load(_arg0); end
  def self._parse(*_arg0); end
  def self._rfc2822(_arg0); end
  def self._rfc3339(_arg0); end
  def self._rfc822(_arg0); end
  def self._strptime(*_arg0); end
  def self._xmlschema(_arg0); end
  def self.civil(*_arg0); end
  def self.commercial(*_arg0); end
  def self.gregorian_leap?(_arg0); end
  def self.httpdate(*_arg0); end
  def self.iso8601(*_arg0); end
  def self.jd(*_arg0); end
  def self.jisx0301(*_arg0); end
  def self.julian_leap?(_arg0); end
  def self.leap?(_arg0); end
  def self.ordinal(*_arg0); end
  def self.parse(*_arg0); end
  def self.rfc2822(*_arg0); end
  def self.rfc3339(*_arg0); end
  def self.rfc822(*_arg0); end
  def self.strptime(*_arg0); end
  def self.today(*_arg0); end
  def self.valid_civil?(*_arg0); end
  def self.valid_commercial?(*_arg0); end
  def self.valid_date?(*_arg0); end
  def self.valid_jd?(*_arg0); end
  def self.valid_ordinal?(*_arg0); end
  def self.xmlschema(*_arg0); end
end

ScanError = StringScanner::Error

class BasicSocket < ::IO
  def close_read; end
  def close_write; end
  def connect_address; end
  def do_not_reverse_lookup; end
  def do_not_reverse_lookup=(_arg0); end
  def getpeereid; end
  def getpeername; end
  def getsockname; end
  def getsockopt(_arg0, _arg1); end
  def local_address; end
  def recv(*_arg0); end
  def recv_nonblock(len, flag = T.unsafe(nil), str = T.unsafe(nil), exception: T.unsafe(nil)); end
  def recvmsg(dlen = T.unsafe(nil), flags = T.unsafe(nil), clen = T.unsafe(nil), scm_rights: T.unsafe(nil)); end
  def recvmsg_nonblock(dlen = T.unsafe(nil), flags = T.unsafe(nil), clen = T.unsafe(nil), scm_rights: T.unsafe(nil), exception: T.unsafe(nil)); end
  def remote_address; end
  def send(*_arg0); end
  def sendmsg(mesg, flags = T.unsafe(nil), dest_sockaddr = T.unsafe(nil), *controls); end
  def sendmsg_nonblock(mesg, flags = T.unsafe(nil), dest_sockaddr = T.unsafe(nil), *controls, exception: T.unsafe(nil)); end
  def setsockopt(*_arg0); end
  def shutdown(*_arg0); end
  private def __recv_nonblock(_arg0, _arg1, _arg2, _arg3); end
  private def __recvmsg(_arg0, _arg1, _arg2, _arg3); end
  private def __recvmsg_nonblock(_arg0, _arg1, _arg2, _arg3, _arg4); end
  private def __sendmsg(_arg0, _arg1, _arg2, _arg3); end
  private def __sendmsg_nonblock(_arg0, _arg1, _arg2, _arg3, _arg4); end
  def self.do_not_reverse_lookup; end
  def self.do_not_reverse_lookup=(_arg0); end
  def self.for_fd(_arg0); end
end

class SocketError < ::StandardError; end
module Net; end

module OpenSSL
  private def Digest(name); end
  private def debug; end
  private def debug=(_arg0); end
  private def errors; end
  private def fips_mode; end
  private def fips_mode=(_arg0); end
  def self.Digest(name); end
  def self.debug; end
  def self.debug=(_arg0); end
  def self.errors; end
  def self.fips_mode; end
  def self.fips_mode=(_arg0); end
  def self.fixed_length_secure_compare(_arg0, _arg1); end
  def self.secure_compare(a, b); end
end

class StringIO
  include ::Enumerable
  def initialize(*_arg0); end
  def binmode; end
  def close; end
  def close_read; end
  def close_write; end
  def closed?; end
  def closed_read?; end
  def closed_write?; end
  def each(*_arg0); end
  def each_byte; end
  def each_char; end
  def each_codepoint; end
  def each_line(*_arg0); end
  def eof; end
  def eof?; end
  def external_encoding; end
  def fcntl(*_arg0); end
  def fileno; end
  def flush; end
  def fsync; end
  def getbyte; end
  def getc; end
  def gets(*_arg0); end
  def internal_encoding; end
  def isatty; end
  def length; end
  def lineno; end
  def lineno=(_arg0); end
  def pid; end
  def pos; end
  def pos=(_arg0); end
  def putc(_arg0); end
  def read(*_arg0); end
  def readlines(*_arg0); end
  def reopen(*_arg0); end
  def rewind; end
  def seek(*_arg0); end
  def set_encoding(*_arg0); end
  def set_encoding_by_bom; end
  def size; end
  def string; end
  def string=(_arg0); end
  def sync; end
  def sync=(_arg0); end
  def tell; end
  def truncate(_arg0); end
  def tty?; end
  def ungetbyte(_arg0); end
  def ungetc(_arg0); end
  def write(*_arg0); end
  private def initialize_copy(_arg0); end
  def self.new(*_arg0); end
  def self.open(*_arg0); end
end

class Timeout::Error < ::RuntimeError
  def exception(*_arg0); end
  def thread; end
  def self.catch(*args); end
end

Timeout::VERSION = T.let(T.unsafe(nil), String)
Socket::AF_APPLETALK = T.let(T.unsafe(nil), Integer)
Socket::AF_CCITT = T.let(T.unsafe(nil), Integer)
Socket::AF_CHAOS = T.let(T.unsafe(nil), Integer)
Socket::AF_CNT = T.let(T.unsafe(nil), Integer)
Socket::AF_COIP = T.let(T.unsafe(nil), Integer)
Socket::AF_DATAKIT = T.let(T.unsafe(nil), Integer)
Socket::AF_DLI = T.let(T.unsafe(nil), Integer)
Socket::AF_E164 = T.let(T.unsafe(nil), Integer)
Socket::AF_ECMA = T.let(T.unsafe(nil), Integer)
Socket::AF_HYLINK = T.let(T.unsafe(nil), Integer)
Socket::AF_IMPLINK = T.let(T.unsafe(nil), Integer)
Socket::AF_INET = T.let(T.unsafe(nil), Integer)
Socket::AF_INET6 = T.let(T.unsafe(nil), Integer)
Socket::AF_IPX = T.let(T.unsafe(nil), Integer)
Socket::AF_ISDN = T.let(T.unsafe(nil), Integer)
Socket::AF_ISO = T.let(T.unsafe(nil), Integer)
Socket::AF_LAT = T.let(T.unsafe(nil), Integer)
Socket::AF_LINK = T.let(T.unsafe(nil), Integer)
Socket::AF_LOCAL = T.let(T.unsafe(nil), Integer)
Socket::AF_MAX = T.let(T.unsafe(nil), Integer)
Socket::AF_NATM = T.let(T.unsafe(nil), Integer)
Socket::AF_NDRV = T.let(T.unsafe(nil), Integer)
Socket::AF_NETBIOS = T.let(T.unsafe(nil), Integer)
Socket::AF_NS = T.let(T.unsafe(nil), Integer)
Socket::AF_OSI = T.let(T.unsafe(nil), Integer)
Socket::AF_PPP = T.let(T.unsafe(nil), Integer)
Socket::AF_PUP = T.let(T.unsafe(nil), Integer)
Socket::AF_ROUTE = T.let(T.unsafe(nil), Integer)
Socket::AF_SIP = T.let(T.unsafe(nil), Integer)
Socket::AF_SNA = T.let(T.unsafe(nil), Integer)
Socket::AF_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::AF_UNIX = T.let(T.unsafe(nil), Integer)
Socket::AF_UNSPEC = T.let(T.unsafe(nil), Integer)
Socket::AI_ADDRCONFIG = T.let(T.unsafe(nil), Integer)
Socket::AI_ALL = T.let(T.unsafe(nil), Integer)
Socket::AI_CANONNAME = T.let(T.unsafe(nil), Integer)
Socket::AI_DEFAULT = T.let(T.unsafe(nil), Integer)
Socket::AI_MASK = T.let(T.unsafe(nil), Integer)
Socket::AI_NUMERICHOST = T.let(T.unsafe(nil), Integer)
Socket::AI_NUMERICSERV = T.let(T.unsafe(nil), Integer)
Socket::AI_PASSIVE = T.let(T.unsafe(nil), Integer)
Socket::AI_V4MAPPED = T.let(T.unsafe(nil), Integer)
Socket::AI_V4MAPPED_CFG = T.let(T.unsafe(nil), Integer)

class Socket::AncillaryData
  def initialize(_arg0, _arg1, _arg2, _arg3); end
  def cmsg_is?(_arg0, _arg1); end
  def data; end
  def family; end
  def inspect; end
  def int; end
  def ip_pktinfo; end
  def ipv6_pktinfo; end
  def ipv6_pktinfo_addr; end
  def ipv6_pktinfo_ifindex; end
  def level; end
  def timestamp; end
  def type; end
  def unix_rights; end
  def self.int(_arg0, _arg1, _arg2, _arg3); end
  def self.ip_pktinfo(*_arg0); end
  def self.ipv6_pktinfo(_arg0, _arg1); end
  def self.unix_rights(*_arg0); end
end

module Socket::Constants; end
Socket::EAI_ADDRFAMILY = T.let(T.unsafe(nil), Integer)
Socket::EAI_AGAIN = T.let(T.unsafe(nil), Integer)
Socket::EAI_BADFLAGS = T.let(T.unsafe(nil), Integer)
Socket::EAI_BADHINTS = T.let(T.unsafe(nil), Integer)
Socket::EAI_FAIL = T.let(T.unsafe(nil), Integer)
Socket::EAI_FAMILY = T.let(T.unsafe(nil), Integer)
Socket::EAI_MAX = T.let(T.unsafe(nil), Integer)
Socket::EAI_MEMORY = T.let(T.unsafe(nil), Integer)
Socket::EAI_NODATA = T.let(T.unsafe(nil), Integer)
Socket::EAI_NONAME = T.let(T.unsafe(nil), Integer)
Socket::EAI_OVERFLOW = T.let(T.unsafe(nil), Integer)
Socket::EAI_PROTOCOL = T.let(T.unsafe(nil), Integer)
Socket::EAI_SERVICE = T.let(T.unsafe(nil), Integer)
Socket::EAI_SOCKTYPE = T.let(T.unsafe(nil), Integer)
Socket::EAI_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::IFF_ALLMULTI = T.let(T.unsafe(nil), Integer)
Socket::IFF_ALTPHYS = T.let(T.unsafe(nil), Integer)
Socket::IFF_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::IFF_DEBUG = T.let(T.unsafe(nil), Integer)
Socket::IFF_LINK0 = T.let(T.unsafe(nil), Integer)
Socket::IFF_LINK1 = T.let(T.unsafe(nil), Integer)
Socket::IFF_LINK2 = T.let(T.unsafe(nil), Integer)
Socket::IFF_LOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::IFF_MULTICAST = T.let(T.unsafe(nil), Integer)
Socket::IFF_NOARP = T.let(T.unsafe(nil), Integer)
Socket::IFF_NOTRAILERS = T.let(T.unsafe(nil), Integer)
Socket::IFF_OACTIVE = T.let(T.unsafe(nil), Integer)
Socket::IFF_POINTOPOINT = T.let(T.unsafe(nil), Integer)
Socket::IFF_PROMISC = T.let(T.unsafe(nil), Integer)
Socket::IFF_RUNNING = T.let(T.unsafe(nil), Integer)
Socket::IFF_SIMPLEX = T.let(T.unsafe(nil), Integer)
Socket::IFF_UP = T.let(T.unsafe(nil), Integer)
Socket::IFNAMSIZ = T.let(T.unsafe(nil), Integer)
Socket::IF_NAMESIZE = T.let(T.unsafe(nil), Integer)
Socket::INADDR_ALLHOSTS_GROUP = T.let(T.unsafe(nil), Integer)
Socket::INADDR_ANY = T.let(T.unsafe(nil), Integer)
Socket::INADDR_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::INADDR_LOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::INADDR_MAX_LOCAL_GROUP = T.let(T.unsafe(nil), Integer)
Socket::INADDR_NONE = T.let(T.unsafe(nil), Integer)
Socket::INADDR_UNSPEC_GROUP = T.let(T.unsafe(nil), Integer)
Socket::INET6_ADDRSTRLEN = T.let(T.unsafe(nil), Integer)
Socket::INET_ADDRSTRLEN = T.let(T.unsafe(nil), Integer)
Socket::IPPORT_RESERVED = T.let(T.unsafe(nil), Integer)
Socket::IPPORT_USERRESERVED = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_AH = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_DSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_EGP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_EON = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ESP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_FRAGMENT = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_GGP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_HELLO = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_HOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ICMP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ICMPV6 = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_IDP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_IGMP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_IP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_IPV6 = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_MAX = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ND = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_NONE = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_PUP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_RAW = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ROUTING = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_TCP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_TP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_UDP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_XTP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_CHECKSUM = T.let(T.unsafe(nil), Integer)
Socket::IPV6_DONTFRAG = T.let(T.unsafe(nil), Integer)
Socket::IPV6_DSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_HOPLIMIT = T.let(T.unsafe(nil), Integer)
Socket::IPV6_HOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_JOIN_GROUP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_LEAVE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_MULTICAST_HOPS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_MULTICAST_IF = T.let(T.unsafe(nil), Integer)
Socket::IPV6_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_NEXTHOP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_PATHMTU = T.let(T.unsafe(nil), Integer)
Socket::IPV6_PKTINFO = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVDSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVHOPLIMIT = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVHOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVPATHMTU = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVPKTINFO = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVRTHDR = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVTCLASS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RTHDR = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RTHDRDSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RTHDR_TYPE_0 = T.let(T.unsafe(nil), Integer)
Socket::IPV6_TCLASS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_UNICAST_HOPS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_USE_MIN_MTU = T.let(T.unsafe(nil), Integer)
Socket::IPV6_V6ONLY = T.let(T.unsafe(nil), Integer)
Socket::IP_ADD_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::IP_ADD_SOURCE_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::IP_BLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::IP_DEFAULT_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::IP_DEFAULT_MULTICAST_TTL = T.let(T.unsafe(nil), Integer)
Socket::IP_DONTFRAG = T.let(T.unsafe(nil), Integer)
Socket::IP_DROP_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::IP_DROP_SOURCE_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::IP_HDRINCL = T.let(T.unsafe(nil), Integer)
Socket::IP_IPSEC_POLICY = T.let(T.unsafe(nil), Integer)
Socket::IP_MAX_MEMBERSHIPS = T.let(T.unsafe(nil), Integer)
Socket::IP_MSFILTER = T.let(T.unsafe(nil), Integer)
Socket::IP_MULTICAST_IF = T.let(T.unsafe(nil), Integer)
Socket::IP_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::IP_MULTICAST_TTL = T.let(T.unsafe(nil), Integer)
Socket::IP_OPTIONS = T.let(T.unsafe(nil), Integer)
Socket::IP_PKTINFO = T.let(T.unsafe(nil), Integer)
Socket::IP_PORTRANGE = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVDSTADDR = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVIF = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVOPTS = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVRETOPTS = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVTOS = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVTTL = T.let(T.unsafe(nil), Integer)
Socket::IP_RETOPTS = T.let(T.unsafe(nil), Integer)
Socket::IP_TOS = T.let(T.unsafe(nil), Integer)
Socket::IP_TTL = T.let(T.unsafe(nil), Integer)
Socket::IP_UNBLOCK_SOURCE = T.let(T.unsafe(nil), Integer)

class Socket::Ifaddr
  def addr; end
  def broadaddr; end
  def dstaddr; end
  def flags; end
  def ifindex; end
  def inspect; end
  def name; end
  def netmask; end
end

Socket::LOCAL_PEERCRED = T.let(T.unsafe(nil), Integer)
Socket::MCAST_BLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::MCAST_EXCLUDE = T.let(T.unsafe(nil), Integer)
Socket::MCAST_INCLUDE = T.let(T.unsafe(nil), Integer)
Socket::MCAST_JOIN_GROUP = T.let(T.unsafe(nil), Integer)
Socket::MCAST_JOIN_SOURCE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::MCAST_LEAVE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::MCAST_LEAVE_SOURCE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::MCAST_UNBLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::MSG_CTRUNC = T.let(T.unsafe(nil), Integer)
Socket::MSG_DONTROUTE = T.let(T.unsafe(nil), Integer)
Socket::MSG_DONTWAIT = T.let(T.unsafe(nil), Integer)
Socket::MSG_EOF = T.let(T.unsafe(nil), Integer)
Socket::MSG_EOR = T.let(T.unsafe(nil), Integer)
Socket::MSG_FLUSH = T.let(T.unsafe(nil), Integer)
Socket::MSG_HAVEMORE = T.let(T.unsafe(nil), Integer)
Socket::MSG_HOLD = T.let(T.unsafe(nil), Integer)
Socket::MSG_NOSIGNAL = T.let(T.unsafe(nil), Integer)
Socket::MSG_OOB = T.let(T.unsafe(nil), Integer)
Socket::MSG_PEEK = T.let(T.unsafe(nil), Integer)
Socket::MSG_RCVMORE = T.let(T.unsafe(nil), Integer)
Socket::MSG_SEND = T.let(T.unsafe(nil), Integer)
Socket::MSG_TRUNC = T.let(T.unsafe(nil), Integer)
Socket::MSG_WAITALL = T.let(T.unsafe(nil), Integer)
Socket::NI_DGRAM = T.let(T.unsafe(nil), Integer)
Socket::NI_MAXHOST = T.let(T.unsafe(nil), Integer)
Socket::NI_MAXSERV = T.let(T.unsafe(nil), Integer)
Socket::NI_NAMEREQD = T.let(T.unsafe(nil), Integer)
Socket::NI_NOFQDN = T.let(T.unsafe(nil), Integer)
Socket::NI_NUMERICHOST = T.let(T.unsafe(nil), Integer)
Socket::NI_NUMERICSERV = T.let(T.unsafe(nil), Integer)

class Socket::Option
  def initialize(_arg0, _arg1, _arg2, _arg3); end
  def bool; end
  def byte; end
  def data; end
  def family; end
  def inspect; end
  def int; end
  def ipv4_multicast_loop; end
  def ipv4_multicast_ttl; end
  def level; end
  def linger; end
  def optname; end
  def to_s; end
  def unpack(_arg0); end
  def self.bool(_arg0, _arg1, _arg2, _arg3); end
  def self.byte(_arg0, _arg1, _arg2, _arg3); end
  def self.int(_arg0, _arg1, _arg2, _arg3); end
  def self.ipv4_multicast_loop(_arg0); end
  def self.ipv4_multicast_ttl(_arg0); end
  def self.linger(_arg0, _arg1); end
end

Socket::PF_APPLETALK = T.let(T.unsafe(nil), Integer)
Socket::PF_CCITT = T.let(T.unsafe(nil), Integer)
Socket::PF_CHAOS = T.let(T.unsafe(nil), Integer)
Socket::PF_CNT = T.let(T.unsafe(nil), Integer)
Socket::PF_COIP = T.let(T.unsafe(nil), Integer)
Socket::PF_DATAKIT = T.let(T.unsafe(nil), Integer)
Socket::PF_DLI = T.let(T.unsafe(nil), Integer)
Socket::PF_ECMA = T.let(T.unsafe(nil), Integer)
Socket::PF_HYLINK = T.let(T.unsafe(nil), Integer)
Socket::PF_IMPLINK = T.let(T.unsafe(nil), Integer)
Socket::PF_INET = T.let(T.unsafe(nil), Integer)
Socket::PF_INET6 = T.let(T.unsafe(nil), Integer)
Socket::PF_IPX = T.let(T.unsafe(nil), Integer)
Socket::PF_ISDN = T.let(T.unsafe(nil), Integer)
Socket::PF_ISO = T.let(T.unsafe(nil), Integer)
Socket::PF_KEY = T.let(T.unsafe(nil), Integer)
Socket::PF_LAT = T.let(T.unsafe(nil), Integer)
Socket::PF_LINK = T.let(T.unsafe(nil), Integer)
Socket::PF_LOCAL = T.let(T.unsafe(nil), Integer)
Socket::PF_MAX = T.let(T.unsafe(nil), Integer)
Socket::PF_NATM = T.let(T.unsafe(nil), Integer)
Socket::PF_NDRV = T.let(T.unsafe(nil), Integer)
Socket::PF_NETBIOS = T.let(T.unsafe(nil), Integer)
Socket::PF_NS = T.let(T.unsafe(nil), Integer)
Socket::PF_OSI = T.let(T.unsafe(nil), Integer)
Socket::PF_PIP = T.let(T.unsafe(nil), Integer)
Socket::PF_PPP = T.let(T.unsafe(nil), Integer)
Socket::PF_PUP = T.let(T.unsafe(nil), Integer)
Socket::PF_ROUTE = T.let(T.unsafe(nil), Integer)
Socket::PF_RTIP = T.let(T.unsafe(nil), Integer)
Socket::PF_SIP = T.let(T.unsafe(nil), Integer)
Socket::PF_SNA = T.let(T.unsafe(nil), Integer)
Socket::PF_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::PF_UNIX = T.let(T.unsafe(nil), Integer)
Socket::PF_UNSPEC = T.let(T.unsafe(nil), Integer)
Socket::PF_XTP = T.let(T.unsafe(nil), Integer)
Socket::SCM_CREDS = T.let(T.unsafe(nil), Integer)
Socket::SCM_RIGHTS = T.let(T.unsafe(nil), Integer)
Socket::SCM_TIMESTAMP = T.let(T.unsafe(nil), Integer)
Socket::SHUT_RD = T.let(T.unsafe(nil), Integer)
Socket::SHUT_RDWR = T.let(T.unsafe(nil), Integer)
Socket::SHUT_WR = T.let(T.unsafe(nil), Integer)
Socket::SOCK_DGRAM = T.let(T.unsafe(nil), Integer)
Socket::SOCK_RAW = T.let(T.unsafe(nil), Integer)
Socket::SOCK_RDM = T.let(T.unsafe(nil), Integer)
Socket::SOCK_SEQPACKET = T.let(T.unsafe(nil), Integer)
Socket::SOCK_STREAM = T.let(T.unsafe(nil), Integer)
Socket::SOL_SOCKET = T.let(T.unsafe(nil), Integer)
Socket::SOMAXCONN = T.let(T.unsafe(nil), Integer)
Socket::SO_ACCEPTCONN = T.let(T.unsafe(nil), Integer)
Socket::SO_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::SO_DEBUG = T.let(T.unsafe(nil), Integer)
Socket::SO_DONTROUTE = T.let(T.unsafe(nil), Integer)
Socket::SO_DONTTRUNC = T.let(T.unsafe(nil), Integer)
Socket::SO_ERROR = T.let(T.unsafe(nil), Integer)
Socket::SO_KEEPALIVE = T.let(T.unsafe(nil), Integer)
Socket::SO_LINGER = T.let(T.unsafe(nil), Integer)
Socket::SO_NKE = T.let(T.unsafe(nil), Integer)
Socket::SO_NOSIGPIPE = T.let(T.unsafe(nil), Integer)
Socket::SO_NREAD = T.let(T.unsafe(nil), Integer)
Socket::SO_OOBINLINE = T.let(T.unsafe(nil), Integer)
Socket::SO_RCVBUF = T.let(T.unsafe(nil), Integer)
Socket::SO_RCVLOWAT = T.let(T.unsafe(nil), Integer)
Socket::SO_RCVTIMEO = T.let(T.unsafe(nil), Integer)
Socket::SO_REUSEADDR = T.let(T.unsafe(nil), Integer)
Socket::SO_REUSEPORT = T.let(T.unsafe(nil), Integer)
Socket::SO_SNDBUF = T.let(T.unsafe(nil), Integer)
Socket::SO_SNDLOWAT = T.let(T.unsafe(nil), Integer)
Socket::SO_SNDTIMEO = T.let(T.unsafe(nil), Integer)
Socket::SO_TIMESTAMP = T.let(T.unsafe(nil), Integer)
Socket::SO_TYPE = T.let(T.unsafe(nil), Integer)
Socket::SO_USELOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::SO_WANTMORE = T.let(T.unsafe(nil), Integer)
Socket::SO_WANTOOBFLAG = T.let(T.unsafe(nil), Integer)
Socket::TCP_FASTOPEN = T.let(T.unsafe(nil), Integer)
Socket::TCP_KEEPCNT = T.let(T.unsafe(nil), Integer)
Socket::TCP_KEEPINTVL = T.let(T.unsafe(nil), Integer)
Socket::TCP_MAXSEG = T.let(T.unsafe(nil), Integer)
Socket::TCP_NODELAY = T.let(T.unsafe(nil), Integer)
Socket::TCP_NOOPT = T.let(T.unsafe(nil), Integer)
Socket::TCP_NOPUSH = T.let(T.unsafe(nil), Integer)

class Socket::UDPSource
  def initialize(remote_address, local_address, &reply_proc); end
  def inspect; end
  def local_address; end
  def remote_address; end
  def reply(msg); end
end

class IPAddr::AddressFamilyError < ::IPAddr::Error; end
class IPAddr::Error < ::ArgumentError; end
IPAddr::IN4MASK = T.let(T.unsafe(nil), Integer)
IPAddr::IN6FORMAT = T.let(T.unsafe(nil), String)
IPAddr::IN6MASK = T.let(T.unsafe(nil), Integer)
class IPAddr::InvalidAddressError < ::IPAddr::Error; end
class IPAddr::InvalidPrefixError < ::IPAddr::InvalidAddressError; end
IPAddr::RE_IPV4ADDRLIKE = T.let(T.unsafe(nil), Regexp)
IPAddr::RE_IPV6ADDRLIKE_COMPRESSED = T.let(T.unsafe(nil), Regexp)
IPAddr::RE_IPV6ADDRLIKE_FULL = T.let(T.unsafe(nil), Regexp)
URI::ABS_PATH = T.let(T.unsafe(nil), Regexp)
URI::ABS_URI = T.let(T.unsafe(nil), Regexp)
URI::ABS_URI_REF = T.let(T.unsafe(nil), Regexp)
class URI::BadURIError < ::URI::Error; end
URI::DEFAULT_PARSER = T.let(T.unsafe(nil), URI::RFC2396_Parser)
URI::ESCAPED = T.let(T.unsafe(nil), Regexp)
class URI::Error < ::StandardError; end
URI::FRAGMENT = T.let(T.unsafe(nil), Regexp)

class URI::FTP < ::URI::Generic
  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser = T.unsafe(nil), arg_check = T.unsafe(nil)); end
  def merge(oth); end
  def path; end
  def to_s; end
  def typecode; end
  def typecode=(typecode); end
  protected def set_path(v); end
  protected def set_typecode(v); end
  private def check_typecode(v); end
  def self.build(args); end
  def self.new2(user, password, host, port, path, typecode = T.unsafe(nil), arg_check = T.unsafe(nil)); end
end

class URI::File < ::URI::Generic
  def check_password(user); end
  def check_user(user); end
  def check_userinfo(user); end
  def set_host(v); end
  def set_password(v); end
  def set_port(v); end
  def set_user(v); end
  def set_userinfo(v); end
  def self.build(args); end
end

class URI::Generic
  include ::URI::RFC2396_REGEXP
  include ::URI
  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser = T.unsafe(nil), arg_check = T.unsafe(nil)); end
  def +(oth); end
  def -(oth); end
  def ==(oth); end
  def absolute; end
  def absolute?; end
  def coerce(oth); end
  def component; end
  def default_port; end
  def eql?(oth); end
  def find_proxy(env = T.unsafe(nil)); end
  def fragment; end
  def fragment=(v); end
  def hash; end
  def hierarchical?; end
  def host; end
  def host=(v); end
  def hostname; end
  def hostname=(v); end
  def inspect; end
  def merge(oth); end
  def merge!(oth); end
  def normalize; end
  def normalize!; end
  def opaque; end
  def opaque=(v); end
  def parser; end
  def password; end
  def password=(password); end
  def path; end
  def path=(v); end
  def port; end
  def port=(v); end
  def query; end
  def query=(v); end
  def registry; end
  def registry=(v); end
  def relative?; end
  def route_from(oth); end
  def route_to(oth); end
  def scheme; end
  def scheme=(v); end
  def select(*components); end
  def to_s; end
  def user; end
  def user=(user); end
  def userinfo; end
  def userinfo=(userinfo); end
  protected def component_ary; end
  protected def set_host(v); end
  protected def set_opaque(v); end
  protected def set_password(v); end
  protected def set_path(v); end
  protected def set_port(v); end
  protected def set_registry(v); end
  protected def set_scheme(v); end
  protected def set_user(v); end
  protected def set_userinfo(user, password = T.unsafe(nil)); end
  private def check_host(v); end
  private def check_opaque(v); end
  private def check_password(v, user = T.unsafe(nil)); end
  private def check_path(v); end
  private def check_port(v); end
  private def check_registry(v); end
  private def check_scheme(v); end
  private def check_user(v); end
  private def check_userinfo(user, password = T.unsafe(nil)); end
  private def escape_userpass(v); end
  private def merge_path(base, rel); end
  private def replace!(oth); end
  private def route_from0(oth); end
  private def route_from_path(src, dst); end
  private def split_path(path); end
  private def split_userinfo(ui); end
  def self.build(args); end
  def self.build2(args); end
  def self.component; end
  def self.default_port; end
  def self.use_proxy?(hostname, addr, port, no_proxy); end
  def self.use_registry; end
end

URI::HOST = T.let(T.unsafe(nil), Regexp)

class URI::HTTP < ::URI::Generic
  def request_uri; end
  def self.build(args); end
end

class URI::HTTPS < ::URI::HTTP; end
class URI::InvalidComponentError < ::URI::Error; end
class URI::InvalidURIError < ::URI::Error; end

class URI::LDAP < ::URI::Generic
  def initialize(*arg); end
  def attributes; end
  def attributes=(val); end
  def dn; end
  def dn=(val); end
  def extensions; end
  def extensions=(val); end
  def filter; end
  def filter=(val); end
  def hierarchical?; end
  def scope; end
  def scope=(val); end
  protected def set_attributes(val); end
  protected def set_dn(val); end
  protected def set_extensions(val); end
  protected def set_filter(val); end
  protected def set_scope(val); end
  private def build_path_query; end
  private def parse_dn; end
  private def parse_query; end
  def self.build(args); end
end

class URI::LDAPS < ::URI::LDAP; end

class URI::MailTo < ::URI::Generic
  def initialize(*arg); end
  def headers; end
  def headers=(v); end
  def to; end
  def to=(v); end
  def to_mailtext; end
  def to_rfc822text; end
  def to_s; end
  protected def set_headers(v); end
  protected def set_to(v); end
  private def check_headers(v); end
  private def check_to(v); end
  def self.build(args); end
end

URI::OPAQUE = T.let(T.unsafe(nil), Regexp)
URI::PORT = T.let(T.unsafe(nil), Regexp)
URI::Parser = URI::RFC2396_Parser
URI::QUERY = T.let(T.unsafe(nil), Regexp)
URI::REGEXP = URI::RFC2396_REGEXP
URI::REGISTRY = T.let(T.unsafe(nil), Regexp)
URI::REL_PATH = T.let(T.unsafe(nil), Regexp)
URI::REL_URI = T.let(T.unsafe(nil), Regexp)
URI::REL_URI_REF = T.let(T.unsafe(nil), Regexp)

class URI::RFC2396_Parser
  include ::URI::RFC2396_REGEXP
  def initialize(opts = T.unsafe(nil)); end
  def escape(str, unsafe = T.unsafe(nil)); end
  def extract(str, schemes = T.unsafe(nil)); end
  def inspect; end
  def join(*uris); end
  def make_regexp(schemes = T.unsafe(nil)); end
  def parse(uri); end
  def pattern; end
  def regexp; end
  def split(uri); end
  def unescape(str, escaped = T.unsafe(nil)); end
  private def convert_to_uri(uri); end
  private def initialize_pattern(opts = T.unsafe(nil)); end
  private def initialize_regexp(pattern); end
end

module URI::RFC2396_REGEXP; end
URI::RFC3986_PARSER = T.let(T.unsafe(nil), URI::RFC3986_Parser)

class URI::RFC3986_Parser
  def initialize; end
  def inspect; end
  def join(*uris); end
  def parse(uri); end
  def regexp; end
  def split(uri); end
  private def convert_to_uri(uri); end
  private def default_regexp; end
end

URI::SCHEME = T.let(T.unsafe(nil), Regexp)
URI::TBLDECWWWCOMP_ = T.let(T.unsafe(nil), Hash)
URI::TBLENCWWWCOMP_ = T.let(T.unsafe(nil), Hash)
URI::UNSAFE = T.let(T.unsafe(nil), Regexp)
URI::URI_REF = T.let(T.unsafe(nil), Regexp)
URI::USERINFO = T.let(T.unsafe(nil), Regexp)

module URI::Util
  private def make_components_hash(klass, array_hash); end
  def self.make_components_hash(klass, array_hash); end
end

URI::VERSION = T.let(T.unsafe(nil), String)
URI::VERSION_CODE = T.let(T.unsafe(nil), String)
URI::WEB_ENCODINGS_ = T.let(T.unsafe(nil), Hash)
Zlib::ASCII = T.let(T.unsafe(nil), Integer)
Zlib::BEST_COMPRESSION = T.let(T.unsafe(nil), Integer)
Zlib::BEST_SPEED = T.let(T.unsafe(nil), Integer)
Zlib::BINARY = T.let(T.unsafe(nil), Integer)
class Zlib::BufError < ::Zlib::Error; end
Zlib::DEFAULT_COMPRESSION = T.let(T.unsafe(nil), Integer)
Zlib::DEFAULT_STRATEGY = T.let(T.unsafe(nil), Integer)
Zlib::DEF_MEM_LEVEL = T.let(T.unsafe(nil), Integer)
class Zlib::DataError < ::Zlib::Error; end

class Zlib::Deflate < ::Zlib::ZStream
  def initialize(*_arg0); end
  def <<(_arg0); end
  def deflate(*_arg0); end
  def flush(*_arg0); end
  def params(_arg0, _arg1); end
  def set_dictionary(_arg0); end
  private def initialize_copy(_arg0); end
  def self.deflate(*_arg0); end
end

class Zlib::Error < ::StandardError; end
Zlib::FILTERED = T.let(T.unsafe(nil), Integer)
Zlib::FINISH = T.let(T.unsafe(nil), Integer)
Zlib::FIXED = T.let(T.unsafe(nil), Integer)
Zlib::FULL_FLUSH = T.let(T.unsafe(nil), Integer)

class Zlib::GzipFile
  def close; end
  def closed?; end
  def comment; end
  def crc; end
  def finish; end
  def level; end
  def mtime; end
  def orig_name; end
  def os_code; end
  def sync; end
  def sync=(_arg0); end
  def to_io; end
  def self.wrap(*_arg0); end
end

class Zlib::GzipReader < ::Zlib::GzipFile
  include ::Enumerable
  def initialize(*_arg0); end
  def each(*_arg0); end
  def each_byte; end
  def each_char; end
  def each_line(*_arg0); end
  def eof; end
  def eof?; end
  def external_encoding; end
  def getbyte; end
  def getc; end
  def gets(*_arg0); end
  def lineno; end
  def lineno=(_arg0); end
  def pos; end
  def read(*_arg0); end
  def readbyte; end
  def readchar; end
  def readline(*_arg0); end
  def readlines(*_arg0); end
  def readpartial(*_arg0); end
  def rewind; end
  def tell; end
  def ungetbyte(_arg0); end
  def ungetc(_arg0); end
  def unused; end
  def self.open(*_arg0); end
  def self.zcat(*_arg0); end
end

class Zlib::GzipWriter < ::Zlib::GzipFile
  def initialize(*_arg0); end
  def <<(_arg0); end
  def comment=(_arg0); end
  def flush(*_arg0); end
  def mtime=(_arg0); end
  def orig_name=(_arg0); end
  def pos; end
  def print(*_arg0); end
  def printf(*_arg0); end
  def putc(_arg0); end
  def puts(*_arg0); end
  def tell; end
  def write(*_arg0); end
  def self.open(*_arg0); end
end

Zlib::HUFFMAN_ONLY = T.let(T.unsafe(nil), Integer)

class Zlib::Inflate < ::Zlib::ZStream
  def initialize(*_arg0); end
  def <<(_arg0); end
  def add_dictionary(_arg0); end
  def inflate(*_arg0); end
  def set_dictionary(_arg0); end
  def sync(_arg0); end
  def sync_point?; end
  def self.inflate(_arg0); end
end

Zlib::MAX_MEM_LEVEL = T.let(T.unsafe(nil), Integer)
Zlib::MAX_WBITS = T.let(T.unsafe(nil), Integer)
class Zlib::MemError < ::Zlib::Error; end
Zlib::NO_COMPRESSION = T.let(T.unsafe(nil), Integer)
Zlib::NO_FLUSH = T.let(T.unsafe(nil), Integer)
class Zlib::NeedDict < ::Zlib::Error; end
Zlib::OS_AMIGA = T.let(T.unsafe(nil), Integer)
Zlib::OS_ATARI = T.let(T.unsafe(nil), Integer)
Zlib::OS_CODE = T.let(T.unsafe(nil), Integer)
Zlib::OS_CPM = T.let(T.unsafe(nil), Integer)
Zlib::OS_MACOS = T.let(T.unsafe(nil), Integer)
Zlib::OS_MSDOS = T.let(T.unsafe(nil), Integer)
Zlib::OS_OS2 = T.let(T.unsafe(nil), Integer)
Zlib::OS_QDOS = T.let(T.unsafe(nil), Integer)
Zlib::OS_RISCOS = T.let(T.unsafe(nil), Integer)
Zlib::OS_TOPS20 = T.let(T.unsafe(nil), Integer)
Zlib::OS_UNIX = T.let(T.unsafe(nil), Integer)
Zlib::OS_UNKNOWN = T.let(T.unsafe(nil), Integer)
Zlib::OS_VMCMS = T.let(T.unsafe(nil), Integer)
Zlib::OS_VMS = T.let(T.unsafe(nil), Integer)
Zlib::OS_WIN32 = T.let(T.unsafe(nil), Integer)
Zlib::OS_ZSYSTEM = T.let(T.unsafe(nil), Integer)
Zlib::RLE = T.let(T.unsafe(nil), Integer)
Zlib::SYNC_FLUSH = T.let(T.unsafe(nil), Integer)
class Zlib::StreamEnd < ::Zlib::Error; end
class Zlib::StreamError < ::Zlib::Error; end
Zlib::TEXT = T.let(T.unsafe(nil), Integer)
Zlib::UNKNOWN = T.let(T.unsafe(nil), Integer)
Zlib::VERSION = T.let(T.unsafe(nil), String)
class Zlib::VersionError < ::Zlib::Error; end
Zlib::ZLIB_VERSION = T.let(T.unsafe(nil), String)

class Zlib::ZStream
  def adler; end
  def avail_in; end
  def avail_out; end
  def avail_out=(_arg0); end
  def close; end
  def closed?; end
  def data_type; end
  def end; end
  def ended?; end
  def finish; end
  def finished?; end
  def flush_next_in; end
  def flush_next_out; end
  def reset; end
  def stream_end?; end
  def total_in; end
  def total_out; end
end

class Digest::Base < ::Digest::Class
  def <<(_arg0); end
  def block_length; end
  def digest_length; end
  def reset; end
  def update(_arg0); end
  private def finish; end
  private def initialize_copy(_arg0); end
end

class Digest::Class
  include ::Digest::Instance
  def initialize; end
  def self.base64digest(str, *args); end
  def self.digest(*_arg0); end
  def self.file(name, *args); end
  def self.hexdigest(*_arg0); end
end

module Digest::Instance
  def <<(_arg0); end
  def ==(_arg0); end
  def base64digest(str = T.unsafe(nil)); end
  def base64digest!; end
  def block_length; end
  def digest(*_arg0); end
  def digest!; end
  def digest_length; end
  def file(name); end
  def hexdigest(*_arg0); end
  def hexdigest!; end
  def inspect; end
  def length; end
  def new; end
  def reset; end
  def size; end
  def to_s; end
  def update(_arg0); end
  private def finish; end
end

class Digest::MD5 < ::Digest::Base; end
Digest::REQUIRE_MUTEX = T.let(T.unsafe(nil), Thread::Mutex)
class Digest::SHA1 < ::Digest::Base; end

class Digest::SHA2 < ::Digest::Class
  def initialize(bitlen = T.unsafe(nil)); end
  def <<(str); end
  def block_length; end
  def digest_length; end
  def inspect; end
  def reset; end
  def update(str); end
  private def finish; end
  private def initialize_copy(other); end
end

class Digest::SHA256 < ::Digest::Base; end
class Digest::SHA384 < ::Digest::Base; end
class Digest::SHA512 < ::Digest::Base; end
Digest::VERSION = T.let(T.unsafe(nil), String)
class StringScanner::Error < ::StandardError; end
StringScanner::Id = T.let(T.unsafe(nil), String)
StringScanner::Version = T.let(T.unsafe(nil), String)
Date::ABBR_DAYNAMES = T.let(T.unsafe(nil), Array)
Date::ABBR_MONTHNAMES = T.let(T.unsafe(nil), Array)
Date::DAYNAMES = T.let(T.unsafe(nil), Array)
Date::ENGLAND = T.let(T.unsafe(nil), Integer)
class Date::Error < ::ArgumentError; end
Date::GREGORIAN = T.let(T.unsafe(nil), Float)
Date::ITALY = T.let(T.unsafe(nil), Integer)

class Date::Infinity < ::Numeric
  def initialize(d = T.unsafe(nil)); end
  def +@; end
  def -@; end
  def <=>(other); end
  def abs; end
  def coerce(other); end
  def finite?; end
  def infinite?; end
  def nan?; end
  def to_f; end
  def zero?; end
  protected def d; end
end

Date::JULIAN = T.let(T.unsafe(nil), Float)
Date::MONTHNAMES = T.let(T.unsafe(nil), Array)

class IO
  include ::Enumerable
  include ::File::Constants
  def initialize(*_arg0); end
  def <<(_arg0); end
  def advise(*_arg0); end
  def autoclose=(_arg0); end
  def autoclose?; end
  def beep; end
  def binmode; end
  def binmode?; end
  def check_winsize_changed; end
  def clear_screen; end
  def close; end
  def close_on_exec=(_arg0); end
  def close_on_exec?; end
  def close_read; end
  def close_write; end
  def closed?; end
  def console_mode; end
  def console_mode=(_arg0); end
  def cooked; end
  def cooked!; end
  def cursor; end
  def cursor=(_arg0); end
  def cursor_down(_arg0); end
  def cursor_left(_arg0); end
  def cursor_right(_arg0); end
  def cursor_up(_arg0); end
  def each(*_arg0); end
  def each_byte; end
  def each_char; end
  def each_codepoint; end
  def each_line(*_arg0); end
  def echo=(_arg0); end
  def echo?; end
  def eof; end
  def eof?; end
  def erase_line(_arg0); end
  def erase_screen(_arg0); end
  def expect(pat, timeout = T.unsafe(nil)); end
  def external_encoding; end
  def fcntl(*_arg0); end
  def fdatasync; end
  def fileno; end
  def flush; end
  def fsync; end
  def getbyte; end
  def getc; end
  def getch(*_arg0); end
  def getpass(*_arg0); end
  def gets(*_arg0); end
  def goto(_arg0, _arg1); end
  def goto_column(_arg0); end
  def iflush; end
  def inspect; end
  def internal_encoding; end
  def ioctl(*_arg0); end
  def ioflush; end
  def isatty; end
  def lineno; end
  def lineno=(_arg0); end
  def noecho; end
  def nonblock(*_arg0); end
  def nonblock=(_arg0); end
  def nonblock?; end
  def nread; end
  def oflush; end
  def pathconf(_arg0); end
  def pid; end
  def pos; end
  def pos=(_arg0); end
  def pread(*_arg0); end
  def pressed?; end
  def print(*_arg0); end
  def printf(*_arg0); end
  def putc(_arg0); end
  def puts(*_arg0); end
  def pwrite(_arg0, _arg1); end
  def raw(*_arg0); end
  def raw!(*_arg0); end
  def read(*_arg0); end
  def read_nonblock(len, buf = T.unsafe(nil), exception: T.unsafe(nil)); end
  def readbyte; end
  def readchar; end
  def readline(*_arg0); end
  def readlines(*_arg0); end
  def readpartial(*_arg0); end
  def ready?; end
  def reopen(*_arg0); end
  def rewind; end
  def scroll_backward(_arg0); end
  def scroll_forward(_arg0); end
  def seek(*_arg0); end
  def set_encoding(*_arg0); end
  def set_encoding_by_bom; end
  def stat; end
  def sync; end
  def sync=(_arg0); end
  def sysread(*_arg0); end
  def sysseek(*_arg0); end
  def syswrite(_arg0); end
  def tell; end
  def to_i; end
  def to_io; end
  def tty?; end
  def ungetbyte(_arg0); end
  def ungetc(_arg0); end
  def wait(*_arg0); end
  def wait_priority(*_arg0); end
  def wait_readable(*_arg0); end
  def wait_writable(*_arg0); end
  def winsize; end
  def winsize=(_arg0); end
  def write(*_arg0); end
  def write_nonblock(buf, exception: T.unsafe(nil)); end
  private def initialize_copy(_arg0); end
  def self.binread(*_arg0); end
  def self.binwrite(*_arg0); end
  def self.console(*_arg0); end
  def self.copy_stream(*_arg0); end
  def self.for_fd(*_arg0); end
  def self.foreach(*_arg0); end
  def self.new(*_arg0); end
  def self.open(*_arg0); end
  def self.pipe(*_arg0); end
  def self.popen(*_arg0); end
  def self.read(*_arg0); end
  def self.readlines(*_arg0); end
  def self.select(*_arg0); end
  def self.sysopen(*_arg0); end
  def self.try_convert(_arg0); end
  def self.write(*_arg0); end
end

class StandardError < ::Exception; end

class Net::APOP < ::Net::POP3
  def apop?; end
end

Net::APOPSession = Net::APOP

class Net::BufferedIO
  def initialize(io, read_timeout: T.unsafe(nil), write_timeout: T.unsafe(nil), continue_timeout: T.unsafe(nil), debug_output: T.unsafe(nil)); end
  def <<(*strs); end
  def close; end
  def closed?; end
  def continue_timeout; end
  def continue_timeout=(_arg0); end
  def debug_output; end
  def debug_output=(_arg0); end
  def eof?; end
  def inspect; end
  def io; end
  def read(len, dest = T.unsafe(nil), ignore_eof = T.unsafe(nil)); end
  def read_all(dest = T.unsafe(nil)); end
  def read_timeout; end
  def read_timeout=(_arg0); end
  def readline; end
  def readuntil(terminator, ignore_eof = T.unsafe(nil)); end
  def write(*strs); end
  def write_timeout; end
  def write_timeout=(_arg0); end
  def writeline(str); end
  private def LOG(msg); end
  private def LOG_off; end
  private def LOG_on; end
  private def rbuf_consume(len); end
  private def rbuf_fill; end
  private def write0(*strs); end
  private def writing; end
end

class Net::FTP < ::Net::Protocol
  include ::MonitorMixin
  include ::OpenSSL
  include ::OpenSSL::SSL
  def initialize(host = T.unsafe(nil), user_or_options = T.unsafe(nil), passwd = T.unsafe(nil), acct = T.unsafe(nil)); end
  def abort; end
  def acct(account); end
  def binary; end
  def binary=(newmode); end
  def chdir(dirname); end
  def close; end
  def closed?; end
  def connect(host, port = T.unsafe(nil)); end
  def debug_mode; end
  def debug_mode=(_arg0); end
  def delete(filename); end
  def dir(*args, &block); end
  def features; end
  def get(remotefile, localfile = T.unsafe(nil), blocksize = T.unsafe(nil), &block); end
  def getbinaryfile(remotefile, localfile = T.unsafe(nil), blocksize = T.unsafe(nil), &block); end
  def getdir; end
  def gettextfile(remotefile, localfile = T.unsafe(nil), &block); end
  def help(arg = T.unsafe(nil)); end
  def last_response; end
  def last_response_code; end
  def lastresp; end
  def list(*args, &block); end
  def login(user = T.unsafe(nil), passwd = T.unsafe(nil), acct = T.unsafe(nil)); end
  def ls(*args, &block); end
  def mdtm(filename); end
  def mkdir(dirname); end
  def mlsd(pathname = T.unsafe(nil), &block); end
  def mlst(pathname = T.unsafe(nil)); end
  def mtime(filename, local = T.unsafe(nil)); end
  def nlst(dir = T.unsafe(nil)); end
  def noop; end
  def open_timeout; end
  def open_timeout=(_arg0); end
  def option(name, params = T.unsafe(nil)); end
  def passive; end
  def passive=(_arg0); end
  def put(localfile, remotefile = T.unsafe(nil), blocksize = T.unsafe(nil), &block); end
  def putbinaryfile(localfile, remotefile = T.unsafe(nil), blocksize = T.unsafe(nil), &block); end
  def puttextfile(localfile, remotefile = T.unsafe(nil), &block); end
  def pwd; end
  def quit; end
  def read_timeout; end
  def read_timeout=(sec); end
  def rename(fromname, toname); end
  def resume; end
  def resume=(_arg0); end
  def retrbinary(cmd, blocksize, rest_offset = T.unsafe(nil)); end
  def retrlines(cmd); end
  def return_code; end
  def return_code=(s); end
  def rmdir(dirname); end
  def sendcmd(cmd); end
  def set_socket(sock, get_greeting = T.unsafe(nil)); end
  def site(arg); end
  def size(filename); end
  def ssl_handshake_timeout; end
  def ssl_handshake_timeout=(_arg0); end
  def status(pathname = T.unsafe(nil)); end
  def storbinary(cmd, file, blocksize, rest_offset = T.unsafe(nil)); end
  def storlines(cmd, file); end
  def system; end
  def use_pasv_ip; end
  def use_pasv_ip=(_arg0); end
  def voidcmd(cmd); end
  def welcome; end
  private def get_body(resp); end
  private def getline; end
  private def getmultiline; end
  private def getresp; end
  private def makepasv; end
  private def makeport; end
  private def open_socket(host, port); end
  private def parse227(resp); end
  private def parse228(resp); end
  private def parse229(resp); end
  private def parse257(resp); end
  private def parse_mlsx_entry(entry); end
  private def parse_pasv_ipv4_host(s); end
  private def parse_pasv_ipv6_host(s); end
  private def parse_pasv_port(s); end
  private def putline(line); end
  private def sanitize(s); end
  private def send_type_command; end
  private def sendport(host, port); end
  private def start_tls_session(sock); end
  private def transfercmd(cmd, rest_offset = T.unsafe(nil)); end
  private def voidresp; end
  private def with_binary(newmode); end
  def self.default_passive; end
  def self.default_passive=(value); end
  def self.open(host, *args); end
end

class Net::FTPConnectionError < ::Net::FTPError; end
class Net::FTPError < ::StandardError; end
class Net::FTPPermError < ::Net::FTPError; end
class Net::FTPProtoError < ::Net::FTPError; end
class Net::FTPReplyError < ::Net::FTPError; end
class Net::FTPTempError < ::Net::FTPError; end

class Net::HTTP < ::Net::Protocol
  def initialize(address, port = T.unsafe(nil)); end
  def active?; end
  def address; end
  def ca_file; end
  def ca_file=(_arg0); end
  def ca_path; end
  def ca_path=(_arg0); end
  def cert; end
  def cert=(_arg0); end
  def cert_store; end
  def cert_store=(_arg0); end
  def ciphers; end
  def ciphers=(_arg0); end
  def close_on_empty_response; end
  def close_on_empty_response=(_arg0); end
  def continue_timeout; end
  def continue_timeout=(sec); end
  def copy(path, initheader = T.unsafe(nil)); end
  def delete(path, initheader = T.unsafe(nil)); end
  def extra_chain_cert; end
  def extra_chain_cert=(_arg0); end
  def finish; end
  def get(path, initheader = T.unsafe(nil), dest = T.unsafe(nil), &block); end
  def get2(path, initheader = T.unsafe(nil), &block); end
  def head(path, initheader = T.unsafe(nil)); end
  def head2(path, initheader = T.unsafe(nil), &block); end
  def inspect; end
  def ipaddr; end
  def ipaddr=(addr); end
  def keep_alive_timeout; end
  def keep_alive_timeout=(_arg0); end
  def key; end
  def key=(_arg0); end
  def local_host; end
  def local_host=(_arg0); end
  def local_port; end
  def local_port=(_arg0); end
  def lock(path, body, initheader = T.unsafe(nil)); end
  def max_retries; end
  def max_retries=(retries); end
  def max_version; end
  def max_version=(_arg0); end
  def min_version; end
  def min_version=(_arg0); end
  def mkcol(path, body = T.unsafe(nil), initheader = T.unsafe(nil)); end
  def move(path, initheader = T.unsafe(nil)); end
  def open_timeout; end
  def open_timeout=(_arg0); end
  def options(path, initheader = T.unsafe(nil)); end
  def patch(path, data, initheader = T.unsafe(nil), dest = T.unsafe(nil), &block); end
  def peer_cert; end
  def port; end
  def post(path, data, initheader = T.unsafe(nil), dest = T.unsafe(nil), &block); end
  def post2(path, data, initheader = T.unsafe(nil), &block); end
  def propfind(path, body = T.unsafe(nil), initheader = T.unsafe(nil)); end
  def proppatch(path, body, initheader = T.unsafe(nil)); end
  def proxy?; end
  def proxy_address; end
  def proxy_address=(_arg0); end
  def proxy_from_env=(_arg0); end
  def proxy_from_env?; end
  def proxy_pass; end
  def proxy_pass=(_arg0); end
  def proxy_port; end
  def proxy_port=(_arg0); end
  def proxy_uri; end
  def proxy_user; end
  def proxy_user=(_arg0); end
  def proxyaddr; end
  def proxyport; end
  def put(path, data, initheader = T.unsafe(nil)); end
  def put2(path, data, initheader = T.unsafe(nil), &block); end
  def read_timeout; end
  def read_timeout=(sec); end
  def request(req, body = T.unsafe(nil), &block); end
  def request_get(path, initheader = T.unsafe(nil), &block); end
  def request_head(path, initheader = T.unsafe(nil), &block); end
  def request_post(path, data, initheader = T.unsafe(nil), &block); end
  def request_put(path, data, initheader = T.unsafe(nil), &block); end
  def send_request(name, path, data = T.unsafe(nil), header = T.unsafe(nil)); end
  def set_debug_output(output); end
  def ssl_timeout; end
  def ssl_timeout=(_arg0); end
  def ssl_version; end
  def ssl_version=(_arg0); end
  def start; end
  def started?; end
  def trace(path, initheader = T.unsafe(nil)); end
  def unlock(path, body, initheader = T.unsafe(nil)); end
  def use_ssl=(flag); end
  def use_ssl?; end
  def verify_callback; end
  def verify_callback=(_arg0); end
  def verify_depth; end
  def verify_depth=(_arg0); end
  def verify_hostname; end
  def verify_hostname=(_arg0); end
  def verify_mode; end
  def verify_mode=(_arg0); end
  def write_timeout; end
  def write_timeout=(sec); end
  private def D(msg); end
  private def addr_port; end
  private def begin_transport(req); end
  private def conn_address; end
  private def conn_port; end
  private def connect; end
  private def do_finish; end
  private def do_start; end
  private def edit_path(path); end
  private def end_transport(req, res); end
  private def keep_alive?(req, res); end
  private def on_connect; end
  private def send_entity(path, data, initheader, dest, type, &block); end
  private def sspi_auth(req); end
  private def sspi_auth?(res); end
  private def transport_request(req); end
  def self.Proxy(p_addr = T.unsafe(nil), p_port = T.unsafe(nil), p_user = T.unsafe(nil), p_pass = T.unsafe(nil)); end
  def self.default_port; end
  def self.get(uri_or_host, path_or_headers = T.unsafe(nil), port = T.unsafe(nil)); end
  def self.get_print(uri_or_host, path_or_headers = T.unsafe(nil), port = T.unsafe(nil)); end
  def self.get_response(uri_or_host, path_or_headers = T.unsafe(nil), port = T.unsafe(nil), &block); end
  def self.http_default_port; end
  def self.https_default_port; end
  def self.is_version_1_1?; end
  def self.is_version_1_2?; end
  def self.new(address, port = T.unsafe(nil), p_addr = T.unsafe(nil), p_port = T.unsafe(nil), p_user = T.unsafe(nil), p_pass = T.unsafe(nil), p_no_proxy = T.unsafe(nil)); end
  def self.newobj(*_arg0); end
  def self.post(url, data, header = T.unsafe(nil)); end
  def self.post_form(url, params); end
  def self.proxy_address; end
  def self.proxy_class?; end
  def self.proxy_pass; end
  def self.proxy_port; end
  def self.proxy_user; end
  def self.socket_type; end
  def self.start(address, *arg, &block); end
  def self.version_1_1?; end
  def self.version_1_2; end
  def self.version_1_2?; end
end

class Net::HTTPAccepted < ::Net::HTTPSuccess; end
class Net::HTTPAlreadyReported < ::Net::HTTPSuccess; end
class Net::HTTPBadGateway < ::Net::HTTPServerError; end
class Net::HTTPBadRequest < ::Net::HTTPClientError; end
class Net::HTTPBadResponse < ::StandardError; end
class Net::HTTPClientError < ::Net::HTTPResponse; end
Net::HTTPClientErrorCode = Net::HTTPClientError
Net::HTTPClientException = Net::HTTPServerException
class Net::HTTPConflict < ::Net::HTTPClientError; end
class Net::HTTPContinue < ::Net::HTTPInformation; end
class Net::HTTPCreated < ::Net::HTTPSuccess; end
class Net::HTTPEarlyHints < ::Net::HTTPInformation; end

class Net::HTTPError < ::Net::ProtocolError
  include ::Net::HTTPExceptions
end

module Net::HTTPExceptions
  def initialize(msg, res); end
  def data; end
  def response; end
end

class Net::HTTPExpectationFailed < ::Net::HTTPClientError; end
class Net::HTTPFailedDependency < ::Net::HTTPClientError; end

class Net::HTTPFatalError < ::Net::ProtoFatalError
  include ::Net::HTTPExceptions
end

Net::HTTPFatalErrorCode = Net::HTTPClientError
class Net::HTTPForbidden < ::Net::HTTPClientError; end
class Net::HTTPFound < ::Net::HTTPRedirection; end
Net::HTTPGatewayTimeOut = Net::HTTPGatewayTimeout
class Net::HTTPGatewayTimeout < ::Net::HTTPServerError; end

class Net::HTTPGenericRequest
  include ::Net::HTTPHeader
  def initialize(m, reqbody, resbody, uri_or_path, initheader = T.unsafe(nil)); end
  def []=(key, val); end
  def body; end
  def body=(str); end
  def body_exist?; end
  def body_stream; end
  def body_stream=(input); end
  def decode_content; end
  def exec(sock, ver, path); end
  def inspect; end
  def method; end
  def path; end
  def request_body_permitted?; end
  def response_body_permitted?; end
  def set_body_internal(str); end
  def update_uri(addr, port, ssl); end
  def uri; end
  private def encode_multipart_form_data(out, params, opt); end
  private def flush_buffer(out, buf, chunked_p); end
  private def quote_string(str, charset); end
  private def send_request_with_body(sock, ver, path, body); end
  private def send_request_with_body_data(sock, ver, path, params); end
  private def send_request_with_body_stream(sock, ver, path, f); end
  private def supply_default_content_type; end
  private def wait_for_continue(sock, ver); end
  private def write_header(sock, ver, path); end
end

class Net::HTTPGone < ::Net::HTTPClientError; end

module Net::HTTPHeader
  def [](key); end
  def []=(key, val); end
  def add_field(key, val); end
  def basic_auth(account, password); end
  def canonical_each; end
  def chunked?; end
  def connection_close?; end
  def connection_keep_alive?; end
  def content_length; end
  def content_length=(len); end
  def content_range; end
  def content_type; end
  def content_type=(type, params = T.unsafe(nil)); end
  def delete(key); end
  def each; end
  def each_capitalized; end
  def each_capitalized_name; end
  def each_header; end
  def each_key(&block); end
  def each_name(&block); end
  def each_value; end
  def fetch(key, *args, &block); end
  def form_data=(params, sep = T.unsafe(nil)); end
  def get_fields(key); end
  def initialize_http_header(initheader); end
  def key?(key); end
  def length; end
  def main_type; end
  def proxy_basic_auth(account, password); end
  def range; end
  def range=(r, e = T.unsafe(nil)); end
  def range_length; end
  def set_content_type(type, params = T.unsafe(nil)); end
  def set_form(params, enctype = T.unsafe(nil), formopt = T.unsafe(nil)); end
  def set_form_data(params, sep = T.unsafe(nil)); end
  def set_range(r, e = T.unsafe(nil)); end
  def size; end
  def sub_type; end
  def to_hash; end
  def type_params; end
  private def append_field_value(ary, val); end
  private def basic_encode(account, password); end
  private def capitalize(name); end
  private def set_field(key, val); end
end

class Net::HTTPHeaderSyntaxError < ::StandardError; end
class Net::HTTPIMUsed < ::Net::HTTPSuccess; end
class Net::HTTPInformation < ::Net::HTTPResponse; end
Net::HTTPInformationCode = Net::HTTPInformation
class Net::HTTPInsufficientStorage < ::Net::HTTPServerError; end
class Net::HTTPInternalServerError < ::Net::HTTPServerError; end
class Net::HTTPLengthRequired < ::Net::HTTPClientError; end
class Net::HTTPLocked < ::Net::HTTPClientError; end
class Net::HTTPLoopDetected < ::Net::HTTPServerError; end
class Net::HTTPMethodNotAllowed < ::Net::HTTPClientError; end
class Net::HTTPMisdirectedRequest < ::Net::HTTPClientError; end
class Net::HTTPMovedPermanently < ::Net::HTTPRedirection; end
Net::HTTPMovedTemporarily = Net::HTTPFound
class Net::HTTPMultiStatus < ::Net::HTTPSuccess; end
Net::HTTPMultipleChoice = Net::HTTPMultipleChoices
class Net::HTTPMultipleChoices < ::Net::HTTPRedirection; end
class Net::HTTPNetworkAuthenticationRequired < ::Net::HTTPServerError; end
class Net::HTTPNoContent < ::Net::HTTPSuccess; end
class Net::HTTPNonAuthoritativeInformation < ::Net::HTTPSuccess; end
class Net::HTTPNotAcceptable < ::Net::HTTPClientError; end
class Net::HTTPNotExtended < ::Net::HTTPServerError; end
class Net::HTTPNotFound < ::Net::HTTPClientError; end
class Net::HTTPNotImplemented < ::Net::HTTPServerError; end
class Net::HTTPNotModified < ::Net::HTTPRedirection; end
class Net::HTTPOK < ::Net::HTTPSuccess; end
class Net::HTTPPartialContent < ::Net::HTTPSuccess; end
class Net::HTTPPayloadTooLarge < ::Net::HTTPClientError; end
class Net::HTTPPaymentRequired < ::Net::HTTPClientError; end
class Net::HTTPPermanentRedirect < ::Net::HTTPRedirection; end
class Net::HTTPPreconditionFailed < ::Net::HTTPClientError; end
class Net::HTTPPreconditionRequired < ::Net::HTTPClientError; end
class Net::HTTPProcessing < ::Net::HTTPInformation; end
class Net::HTTPProxyAuthenticationRequired < ::Net::HTTPClientError; end
class Net::HTTPRangeNotSatisfiable < ::Net::HTTPClientError; end
class Net::HTTPRedirection < ::Net::HTTPResponse; end
Net::HTTPRedirectionCode = Net::HTTPRedirection

class Net::HTTPRequest < ::Net::HTTPGenericRequest
  def initialize(path, initheader = T.unsafe(nil)); end
end

Net::HTTPRequestEntityTooLarge = Net::HTTPPayloadTooLarge
class Net::HTTPRequestHeaderFieldsTooLarge < ::Net::HTTPClientError; end
Net::HTTPRequestTimeOut = Net::HTTPRequestTimeout
class Net::HTTPRequestTimeout < ::Net::HTTPClientError; end
Net::HTTPRequestURITooLarge = Net::HTTPURITooLong
Net::HTTPRequestURITooLong = Net::HTTPURITooLong
Net::HTTPRequestedRangeNotSatisfiable = Net::HTTPRangeNotSatisfiable
class Net::HTTPResetContent < ::Net::HTTPSuccess; end
Net::HTTPResponceReceiver = Net::HTTPResponse

class Net::HTTPResponse
  include ::Net::HTTPHeader
  def initialize(httpv, code, msg); end
  def body; end
  def body=(value); end
  def code; end
  def code_type; end
  def decode_content; end
  def decode_content=(_arg0); end
  def entity; end
  def error!; end
  def error_type; end
  def header; end
  def http_version; end
  def inspect; end
  def message; end
  def msg; end
  def read_body(dest = T.unsafe(nil), &block); end
  def read_header; end
  def reading_body(sock, reqmethodallowbody); end
  def response; end
  def uri; end
  def uri=(uri); end
  def value; end
  private def inflater; end
  private def procdest(dest, block); end
  private def read_body_0(dest); end
  private def read_chunked(dest, chunk_data_io); end
  private def stream_check; end
  def self.body_permitted?; end
  def self.exception_type; end
  def self.read_new(sock); end
  private def self.each_response_header(sock); end
  private def self.read_status_line(sock); end
  private def self.response_class(code); end
end

Net::HTTPRetriableCode = Net::HTTPRedirection

class Net::HTTPRetriableError < ::Net::ProtoRetriableError
  include ::Net::HTTPExceptions
end

class Net::HTTPSeeOther < ::Net::HTTPRedirection; end
class Net::HTTPServerError < ::Net::HTTPResponse; end
Net::HTTPServerErrorCode = Net::HTTPServerError

class Net::HTTPServerException < ::Net::ProtoServerError
  include ::Net::HTTPExceptions
end

class Net::HTTPServiceUnavailable < ::Net::HTTPServerError; end
Net::HTTPSession = Net::HTTP
class Net::HTTPSuccess < ::Net::HTTPResponse; end
Net::HTTPSuccessCode = Net::HTTPSuccess
class Net::HTTPSwitchProtocol < ::Net::HTTPInformation; end
class Net::HTTPTemporaryRedirect < ::Net::HTTPRedirection; end
class Net::HTTPTooManyRequests < ::Net::HTTPClientError; end
class Net::HTTPURITooLong < ::Net::HTTPClientError; end
class Net::HTTPUnauthorized < ::Net::HTTPClientError; end
class Net::HTTPUnavailableForLegalReasons < ::Net::HTTPClientError; end
class Net::HTTPUnknownResponse < ::Net::HTTPResponse; end
class Net::HTTPUnprocessableEntity < ::Net::HTTPClientError; end
class Net::HTTPUnsupportedMediaType < ::Net::HTTPClientError; end
class Net::HTTPUpgradeRequired < ::Net::HTTPClientError; end
class Net::HTTPUseProxy < ::Net::HTTPRedirection; end
class Net::HTTPVariantAlsoNegotiates < ::Net::HTTPServerError; end
class Net::HTTPVersionNotSupported < ::Net::HTTPServerError; end

class Net::IMAP < ::Net::Protocol
  include ::MonitorMixin
  include ::OpenSSL
  include ::OpenSSL::SSL
  extend ::Net::IMAP::Authenticators
  def initialize(host, port_or_options = T.unsafe(nil), usessl = T.unsafe(nil), certs = T.unsafe(nil), verify = T.unsafe(nil)); end
  def add_response_handler(handler = T.unsafe(nil), &block); end
  def append(mailbox, message, flags = T.unsafe(nil), date_time = T.unsafe(nil)); end
  def authenticate(auth_type, *args); end
  def capability; end
  def check; end
  def client_thread; end
  def client_thread=(_arg0); end
  def close; end
  def copy(set, mailbox); end
  def create(mailbox); end
  def delete(mailbox); end
  def disconnect; end
  def disconnected?; end
  def examine(mailbox); end
  def expunge; end
  def fetch(set, attr, mod = T.unsafe(nil)); end
  def getacl(mailbox); end
  def getquota(mailbox); end
  def getquotaroot(mailbox); end
  def greeting; end
  def id(client_id = T.unsafe(nil)); end
  def idle(timeout = T.unsafe(nil), &response_handler); end
  def idle_done; end
  def idle_response_timeout; end
  def list(refname, mailbox); end
  def login(user, password); end
  def logout; end
  def lsub(refname, mailbox); end
  def move(set, mailbox); end
  def namespace; end
  def noop; end
  def open_timeout; end
  def remove_response_handler(handler); end
  def rename(mailbox, newname); end
  def response_handlers; end
  def responses; end
  def search(keys, charset = T.unsafe(nil)); end
  def select(mailbox); end
  def setacl(mailbox, user, rights); end
  def setquota(mailbox, quota); end
  def sort(sort_keys, search_keys, charset); end
  def starttls(options = T.unsafe(nil), verify = T.unsafe(nil)); end
  def status(mailbox, attr); end
  def store(set, attr, flags); end
  def subscribe(mailbox); end
  def thread(algorithm, search_keys, charset); end
  def uid_copy(set, mailbox); end
  def uid_fetch(set, attr, mod = T.unsafe(nil)); end
  def uid_move(set, mailbox); end
  def uid_search(keys, charset = T.unsafe(nil)); end
  def uid_sort(sort_keys, search_keys, charset); end
  def uid_store(set, attr, flags); end
  def uid_thread(algorithm, search_keys, charset); end
  def unsubscribe(mailbox); end
  def xlist(refname, mailbox); end
  private def copy_internal(cmd, set, mailbox); end
  private def create_ssl_params(certs = T.unsafe(nil), verify = T.unsafe(nil)); end
  private def fetch_internal(cmd, set, attr, mod = T.unsafe(nil)); end
  private def generate_tag; end
  private def get_response; end
  private def get_tagged_response(tag, cmd, timeout = T.unsafe(nil)); end
  private def normalize_searching_criteria(keys); end
  private def put_string(str); end
  private def receive_responses; end
  private def record_response(name, data); end
  private def search_internal(cmd, keys, charset); end
  private def send_command(cmd, *args, &block); end
  private def send_data(data, tag = T.unsafe(nil)); end
  private def send_list_data(list, tag = T.unsafe(nil)); end
  private def send_literal(str, tag = T.unsafe(nil)); end
  private def send_number_data(num); end
  private def send_quoted_string(str); end
  private def send_string_data(str, tag = T.unsafe(nil)); end
  private def send_symbol_data(symbol); end
  private def send_time_data(time); end
  private def sort_internal(cmd, sort_keys, search_keys, charset); end
  private def start_tls_session(params = T.unsafe(nil)); end
  private def store_internal(cmd, set, attr, flags); end
  private def tcp_socket(host, port); end
  private def thread_internal(cmd, algorithm, search_keys, charset); end
  private def validate_data(data); end
  def self.debug; end
  def self.debug=(val); end
  def self.decode_utf7(s); end
  def self.default_imap_port; end
  def self.default_imaps_port; end
  def self.default_port; end
  def self.default_ssl_port; end
  def self.default_tls_port; end
  def self.encode_utf7(s); end
  def self.format_date(time); end
  def self.format_datetime(time); end
end

class Net::InternetMessageIO < ::Net::BufferedIO
  def initialize(*_arg0, **_arg1); end
  def each_list_item; end
  def each_message_chunk; end
  def write_message(src); end
  def write_message_0(src); end
  def write_message_by_block(&block); end
  private def buffer_filling(buf, src); end
  private def dot_stuff(s); end
  private def each_crlf_line(src); end
  private def using_each_crlf_line; end
end

module Net::NetPrivate; end
class Net::OpenTimeout < ::Timeout::Error; end
Net::POP = Net::POP3

class Net::POP3 < ::Net::Protocol
  def initialize(addr, port = T.unsafe(nil), isapop = T.unsafe(nil)); end
  def active?; end
  def address; end
  def apop?; end
  def auth_only(account, password); end
  def delete_all; end
  def disable_ssl; end
  def each(&block); end
  def each_mail(&block); end
  def enable_ssl(verify_or_params = T.unsafe(nil), certs = T.unsafe(nil), port = T.unsafe(nil)); end
  def finish; end
  def inspect; end
  def logging(msg); end
  def mails; end
  def n_bytes; end
  def n_mails; end
  def open_timeout; end
  def open_timeout=(_arg0); end
  def port; end
  def read_timeout; end
  def read_timeout=(sec); end
  def reset; end
  def set_all_uids; end
  def set_debug_output(arg); end
  def start(account, password); end
  def started?; end
  def use_ssl?; end
  private def command; end
  private def do_finish; end
  private def do_start(account, password); end
  private def on_connect; end
  def self.APOP(isapop); end
  def self.auth_only(address, port = T.unsafe(nil), account = T.unsafe(nil), password = T.unsafe(nil), isapop = T.unsafe(nil)); end
  def self.certs; end
  def self.create_ssl_params(verify_or_params = T.unsafe(nil), certs = T.unsafe(nil)); end
  def self.default_pop3_port; end
  def self.default_pop3s_port; end
  def self.default_port; end
  def self.delete_all(address, port = T.unsafe(nil), account = T.unsafe(nil), password = T.unsafe(nil), isapop = T.unsafe(nil), &block); end
  def self.disable_ssl; end
  def self.enable_ssl(*args); end
  def self.foreach(address, port = T.unsafe(nil), account = T.unsafe(nil), password = T.unsafe(nil), isapop = T.unsafe(nil), &block); end
  def self.socket_type; end
  def self.ssl_params; end
  def self.start(address, port = T.unsafe(nil), account = T.unsafe(nil), password = T.unsafe(nil), isapop = T.unsafe(nil), &block); end
  def self.use_ssl?; end
  def self.verify; end
end

class Net::POP3Command
  def initialize(sock); end
  def apop(account, password); end
  def auth(account, password); end
  def dele(num); end
  def inspect; end
  def list; end
  def quit; end
  def retr(num, &block); end
  def rset; end
  def socket; end
  def stat; end
  def top(num, lines = T.unsafe(nil), &block); end
  def uidl(num = T.unsafe(nil)); end
  private def check_response(res); end
  private def check_response_auth(res); end
  private def critical; end
  private def get_response(fmt, *fargs); end
  private def getok(fmt, *fargs); end
  private def recv_response; end
end

Net::POP3Session = Net::POP3
class Net::POPAuthenticationError < ::Net::ProtoAuthError; end
class Net::POPBadResponse < ::Net::POPError; end
class Net::POPError < ::Net::ProtocolError; end

class Net::POPMail
  def initialize(num, len, pop, cmd); end
  def all(dest = T.unsafe(nil), &block); end
  def delete; end
  def delete!; end
  def deleted?; end
  def header(dest = T.unsafe(nil)); end
  def inspect; end
  def length; end
  def mail(dest = T.unsafe(nil), &block); end
  def number; end
  def pop(dest = T.unsafe(nil), &block); end
  def size; end
  def top(lines, dest = T.unsafe(nil)); end
  def uid=(uid); end
  def uidl; end
  def unique_id; end
end

Net::POPSession = Net::POP3
class Net::ProtoAuthError < ::Net::ProtocolError; end
class Net::ProtoCommandError < ::Net::ProtocolError; end
class Net::ProtoFatalError < ::Net::ProtocolError; end
class Net::ProtoRetriableError < ::Net::ProtocolError; end
class Net::ProtoServerError < ::Net::ProtocolError; end
class Net::ProtoSyntaxError < ::Net::ProtocolError; end
class Net::ProtoUnknownError < ::Net::ProtocolError; end
Net::ProtocRetryError = Net::ProtoRetriableError

class Net::Protocol
  private def ssl_socket_connect(s, timeout); end
  def self.protocol_param(name, val); end
end

class Net::ProtocolError < ::StandardError; end

class Net::ReadAdapter
  def initialize(block); end
  def <<(str); end
  def inspect; end
  private def call_block(str); end
end

class Net::ReadTimeout < ::Timeout::Error
  def initialize(io = T.unsafe(nil)); end
  def io; end
  def message; end
end

class Net::SMTP < ::Net::Protocol
  def initialize(address, port = T.unsafe(nil), tls: T.unsafe(nil), starttls: T.unsafe(nil), tls_verify: T.unsafe(nil), tls_hostname: T.unsafe(nil), ssl_context_params: T.unsafe(nil)); end
  def address; end
  def auth_cram_md5(user, secret); end
  def auth_login(user, secret); end
  def auth_plain(user, secret); end
  def authenticate(user, secret, authtype = T.unsafe(nil)); end
  def capabilities; end
  def capable?(key); end
  def capable_auth_types; end
  def capable_cram_md5_auth?; end
  def capable_login_auth?; end
  def capable_plain_auth?; end
  def capable_starttls?; end
  def data(msgstr = T.unsafe(nil), &block); end
  def debug_output=(arg); end
  def disable_ssl; end
  def disable_starttls; end
  def disable_tls; end
  def ehlo(domain); end
  def enable_ssl(context = T.unsafe(nil)); end
  def enable_starttls(context = T.unsafe(nil)); end
  def enable_starttls_auto(context = T.unsafe(nil)); end
  def enable_tls(context = T.unsafe(nil)); end
  def esmtp; end
  def esmtp=(_arg0); end
  def esmtp?; end
  def finish; end
  def helo(domain); end
  def inspect; end
  def mailfrom(from_addr); end
  def open_message_stream(from_addr, *to_addrs, &block); end
  def open_timeout; end
  def open_timeout=(_arg0); end
  def port; end
  def quit; end
  def rcptto(to_addr); end
  def rcptto_list(to_addrs); end
  def read_timeout; end
  def read_timeout=(sec); end
  def ready(from_addr, *to_addrs, &block); end
  def rset; end
  def send_mail(msgstr, from_addr, *to_addrs); end
  def send_message(msgstr, from_addr, *to_addrs); end
  def sendmail(msgstr, from_addr, *to_addrs); end
  def set_debug_output(arg); end
  def ssl?; end
  def ssl_context_params; end
  def ssl_context_params=(_arg0); end
  def start(*args, helo: T.unsafe(nil), user: T.unsafe(nil), secret: T.unsafe(nil), password: T.unsafe(nil), authtype: T.unsafe(nil)); end
  def started?; end
  def starttls; end
  def starttls?; end
  def starttls_always?; end
  def starttls_auto?; end
  def tls?; end
  def tls_hostname; end
  def tls_hostname=(_arg0); end
  def tls_verify; end
  def tls_verify=(_arg0); end
  private def auth_capable?(type); end
  private def auth_method(type); end
  private def base64_encode(str); end
  private def check_auth_args(user, secret, authtype = T.unsafe(nil)); end
  private def check_auth_continue(res); end
  private def check_auth_method(type); end
  private def check_auth_response(res); end
  private def check_continue(res); end
  private def check_response(res); end
  private def cram_md5_response(secret, challenge); end
  private def cram_secret(secret, mask); end
  private def critical; end
  private def do_finish; end
  private def do_helo(helo_domain); end
  private def do_start(helo_domain, user, secret, authtype); end
  private def get_response(reqline); end
  private def getok(reqline); end
  private def logging(msg); end
  private def new_internet_message_io(s); end
  private def recv_response; end
  private def ssl_socket(socket, context); end
  private def tcp_socket(address, port); end
  private def tlsconnect(s, context); end
  private def validate_line(line); end
  def self.default_port; end
  def self.default_ssl_context(ssl_context_params = T.unsafe(nil)); end
  def self.default_ssl_port; end
  def self.default_submission_port; end
  def self.default_tls_port; end
  def self.start(address, port = T.unsafe(nil), *args, helo: T.unsafe(nil), user: T.unsafe(nil), secret: T.unsafe(nil), password: T.unsafe(nil), authtype: T.unsafe(nil), tls: T.unsafe(nil), starttls: T.unsafe(nil), tls_verify: T.unsafe(nil), tls_hostname: T.unsafe(nil), ssl_context_params: T.unsafe(nil), &block); end
end

class Net::SMTPAuthenticationError < ::Net::ProtoAuthError
  include ::Net::SMTPError
end

module Net::SMTPError
  def initialize(response, message: T.unsafe(nil)); end
  def message; end
  def response; end
end

class Net::SMTPFatalError < ::Net::ProtoFatalError
  include ::Net::SMTPError
end

class Net::SMTPServerBusy < ::Net::ProtoServerError
  include ::Net::SMTPError
end

Net::SMTPSession = Net::SMTP

class Net::SMTPSyntaxError < ::Net::ProtoSyntaxError
  include ::Net::SMTPError
end

class Net::SMTPUnknownError < ::Net::ProtoUnknownError
  include ::Net::SMTPError
end

class Net::SMTPUnsupportedCommand < ::Net::ProtocolError
  include ::Net::SMTPError
end

class Net::WriteAdapter
  def initialize(writer); end
  def <<(str); end
  def inspect; end
  def print(str); end
  def printf(*args); end
  def puts(str = T.unsafe(nil)); end
  def write(str); end
end

class Net::WriteTimeout < ::Timeout::Error
  def initialize(io = T.unsafe(nil)); end
  def io; end
  def message; end
end

module OpenSSL::ASN1
  private def BMPString(*_arg0); end
  private def BitString(*_arg0); end
  private def Boolean(*_arg0); end
  private def EndOfContent(*_arg0); end
  private def Enumerated(*_arg0); end
  private def GeneralString(*_arg0); end
  private def GeneralizedTime(*_arg0); end
  private def GraphicString(*_arg0); end
  private def IA5String(*_arg0); end
  private def ISO64String(*_arg0); end
  private def Integer(*_arg0); end
  private def Null(*_arg0); end
  private def NumericString(*_arg0); end
  private def ObjectId(*_arg0); end
  private def OctetString(*_arg0); end
  private def PrintableString(*_arg0); end
  private def Sequence(*_arg0); end
  private def Set(*_arg0); end
  private def T61String(*_arg0); end
  private def UTCTime(*_arg0); end
  private def UTF8String(*_arg0); end
  private def UniversalString(*_arg0); end
  private def VideotexString(*_arg0); end
  private def decode(_arg0); end
  private def decode_all(_arg0); end
  private def traverse(_arg0); end
  def self.BMPString(*_arg0); end
  def self.BitString(*_arg0); end
  def self.Boolean(*_arg0); end
  def self.EndOfContent(*_arg0); end
  def self.Enumerated(*_arg0); end
  def self.GeneralString(*_arg0); end
  def self.GeneralizedTime(*_arg0); end
  def self.GraphicString(*_arg0); end
  def self.IA5String(*_arg0); end
  def self.ISO64String(*_arg0); end
  def self.Integer(*_arg0); end
  def self.Null(*_arg0); end
  def self.NumericString(*_arg0); end
  def self.ObjectId(*_arg0); end
  def self.OctetString(*_arg0); end
  def self.PrintableString(*_arg0); end
  def self.Sequence(*_arg0); end
  def self.Set(*_arg0); end
  def self.T61String(*_arg0); end
  def self.UTCTime(*_arg0); end
  def self.UTF8String(*_arg0); end
  def self.UniversalString(*_arg0); end
  def self.VideotexString(*_arg0); end
  def self.decode(_arg0); end
  def self.decode_all(_arg0); end
  def self.traverse(_arg0); end
end

class OpenSSL::BN
  include ::Comparable
  def initialize(*_arg0); end
  def %(_arg0); end
  def *(_arg0); end
  def **(_arg0); end
  def +(_arg0); end
  def +@; end
  def -(_arg0); end
  def -@; end
  def /(_arg0); end
  def <<(_arg0); end
  def <=>(_arg0); end
  def ==(_arg0); end
  def ===(_arg0); end
  def >>(_arg0); end
  def bit_set?(_arg0); end
  def clear_bit!(_arg0); end
  def cmp(_arg0); end
  def coerce(_arg0); end
  def copy(_arg0); end
  def eql?(_arg0); end
  def gcd(_arg0); end
  def hash; end
  def lshift!(_arg0); end
  def mask_bits!(_arg0); end
  def mod_add(_arg0, _arg1); end
  def mod_exp(_arg0, _arg1); end
  def mod_inverse(_arg0); end
  def mod_mul(_arg0, _arg1); end
  def mod_sqr(_arg0); end
  def mod_sub(_arg0, _arg1); end
  def negative?; end
  def num_bits; end
  def num_bytes; end
  def odd?; end
  def one?; end
  def pretty_print(q); end
  def prime?(*_arg0); end
  def prime_fasttest?(*_arg0); end
  def rshift!(_arg0); end
  def set_bit!(_arg0); end
  def sqr; end
  def to_bn; end
  def to_i; end
  def to_int; end
  def to_s(*_arg0); end
  def ucmp(_arg0); end
  def zero?; end
  private def initialize_copy(_arg0); end
  def self.generate_prime(*_arg0); end
  def self.pseudo_rand(*_arg0); end
  def self.pseudo_rand_range(_arg0); end
  def self.rand(*_arg0); end
  def self.rand_range(_arg0); end
end

class OpenSSL::BNError < ::OpenSSL::OpenSSLError; end

module OpenSSL::Buffering
  include ::Enumerable
  def initialize(*_arg0); end
  def <<(s); end
  def close; end
  def each(eol = T.unsafe(nil)); end
  def each_byte; end
  def each_line(eol = T.unsafe(nil)); end
  def eof; end
  def eof?; end
  def flush; end
  def getc; end
  def gets(eol = T.unsafe(nil), limit = T.unsafe(nil)); end
  def print(*args); end
  def printf(s, *args); end
  def puts(*args); end
  def read(size = T.unsafe(nil), buf = T.unsafe(nil)); end
  def read_nonblock(maxlen, buf = T.unsafe(nil), exception: T.unsafe(nil)); end
  def readchar; end
  def readline(eol = T.unsafe(nil)); end
  def readlines(eol = T.unsafe(nil)); end
  def readpartial(maxlen, buf = T.unsafe(nil)); end
  def sync; end
  def sync=(_arg0); end
  def ungetc(c); end
  def write(*s); end
  def write_nonblock(s, exception: T.unsafe(nil)); end
  private def consume_rbuff(size = T.unsafe(nil)); end
  private def do_write(s); end
  private def fill_rbuff; end
end

class OpenSSL::Cipher
  def initialize(_arg0); end
  def auth_data=(_arg0); end
  def auth_tag(*_arg0); end
  def auth_tag=(_arg0); end
  def auth_tag_len=(_arg0); end
  def authenticated?; end
  def block_size; end
  def decrypt(*_arg0); end
  def encrypt(*_arg0); end
  def final; end
  def iv=(_arg0); end
  def iv_len; end
  def iv_len=(_arg0); end
  def key=(_arg0); end
  def key_len; end
  def key_len=(_arg0); end
  def name; end
  def padding=(_arg0); end
  def pkcs5_keyivgen(*_arg0); end
  def random_iv; end
  def random_key; end
  def reset; end
  def update(*_arg0); end
  private def ciphers; end
  private def initialize_copy(_arg0); end
  def self.ciphers; end
end

class OpenSSL::Config
  include ::Enumerable
  def initialize(filename = T.unsafe(nil)); end
  def [](section); end
  def []=(section, pairs); end
  def add_value(section, key, value); end
  def each; end
  def get_value(section, key); end
  def inspect; end
  def section(name); end
  def sections; end
  def set_section(section, pairs); end
  def to_s; end
  def value(arg1, arg2 = T.unsafe(nil)); end
  protected def data; end
  private def check_modify; end
  private def get_key_string(section, key); end
  private def initialize_copy(other); end
  def self.get_key_string(data, section, key); end
  def self.load(*_arg0); end
  def self.parse(string); end
  def self.parse_config(io); end
  private def self.clear_comments(line); end
  private def self.extract_reference(value); end
  private def self.get_definition(io_stack); end
  private def self.get_line(io_stack); end
  private def self.parse_config_lines(io); end
  private def self.unescape_value(data, section, value); end
end

class OpenSSL::ConfigError < ::OpenSSL::OpenSSLError; end

class OpenSSL::Digest < ::Digest::Class
  def initialize(*_arg0); end
  def <<(_arg0); end
  def block_length; end
  def digest_length; end
  def name; end
  def reset; end
  def update(_arg0); end
  private def finish(*_arg0); end
  private def initialize_copy(_arg0); end
  def self.digest(name, data); end
end

class OpenSSL::Engine
  def cipher(_arg0); end
  def cmds; end
  def ctrl_cmd(*_arg0); end
  def digest(_arg0); end
  def finish; end
  def id; end
  def inspect; end
  def load_private_key(*_arg0); end
  def load_public_key(*_arg0); end
  def name; end
  def set_default(_arg0); end
  def self.by_id(_arg0); end
  def self.cleanup; end
  def self.engines; end
  def self.load(*_arg0); end
end

module OpenSSL::ExtConfig; end

class OpenSSL::HMAC
  def initialize(_arg0, _arg1); end
  def <<(_arg0); end
  def ==(other); end
  def digest; end
  def hexdigest; end
  def inspect; end
  def reset; end
  def to_s; end
  def update(_arg0); end
  private def initialize_copy(_arg0); end
  def self.digest(_arg0, _arg1, _arg2); end
  def self.hexdigest(_arg0, _arg1, _arg2); end
end

class OpenSSL::HMACError < ::OpenSSL::OpenSSLError; end

module OpenSSL::KDF
  private def hkdf(*_arg0); end
  private def pbkdf2_hmac(*_arg0); end
  private def scrypt(*_arg0); end
  def self.hkdf(*_arg0); end
  def self.pbkdf2_hmac(*_arg0); end
  def self.scrypt(*_arg0); end
end

module OpenSSL::Marshal
  mixes_in_class_methods ::OpenSSL::Marshal::ClassMethods
  def _dump(_level); end
  def self.included(base); end
end

module OpenSSL::Netscape; end
module OpenSSL::OCSP; end
OpenSSL::OPENSSL_LIBRARY_VERSION = T.let(T.unsafe(nil), String)
OpenSSL::OPENSSL_VERSION = T.let(T.unsafe(nil), String)
OpenSSL::OPENSSL_VERSION_NUMBER = T.let(T.unsafe(nil), Integer)
class OpenSSL::OpenSSLError < ::StandardError; end

class OpenSSL::PKCS12
  def initialize(*_arg0); end
  def ca_certs; end
  def certificate; end
  def key; end
  def to_der; end
  private def initialize_copy(_arg0); end
  def self.create(*_arg0); end
end

module OpenSSL::PKCS5
  private def pbkdf2_hmac(pass, salt, iter, keylen, digest); end
  private def pbkdf2_hmac_sha1(pass, salt, iter, keylen); end
  def self.pbkdf2_hmac(pass, salt, iter, keylen, digest); end
  def self.pbkdf2_hmac_sha1(pass, salt, iter, keylen); end
end

class OpenSSL::PKCS7
  def initialize(*_arg0); end
  def add_certificate(_arg0); end
  def add_crl(_arg0); end
  def add_data(_arg0); end
  def add_recipient(_arg0); end
  def add_signer(_arg0); end
  def certificates; end
  def certificates=(_arg0); end
  def cipher=(_arg0); end
  def crls; end
  def crls=(_arg0); end
  def data; end
  def data=(_arg0); end
  def decrypt(*_arg0); end
  def detached; end
  def detached=(_arg0); end
  def detached?; end
  def error_string; end
  def error_string=(_arg0); end
  def recipients; end
  def signers; end
  def to_der; end
  def to_pem; end
  def to_s; end
  def type; end
  def type=(_arg0); end
  def verify(*_arg0); end
  private def initialize_copy(_arg0); end
  def self.encrypt(*_arg0); end
  def self.read_smime(_arg0); end
  def self.sign(*_arg0); end
  def self.write_smime(*_arg0); end
end

module OpenSSL::PKey
  private def read(*_arg0); end
  def self.read(*_arg0); end
end

module OpenSSL::Random
  private def load_random_file(_arg0); end
  private def random_add(_arg0, _arg1); end
  private def random_bytes(_arg0); end
  private def seed(_arg0); end
  private def status?; end
  private def write_random_file(_arg0); end
  def self.load_random_file(_arg0); end
  def self.random_add(_arg0, _arg1); end
  def self.random_bytes(_arg0); end
  def self.seed(_arg0); end
  def self.status?; end
  def self.write_random_file(_arg0); end
end

module OpenSSL::SSL
  private def verify_certificate_identity(cert, hostname); end
  private def verify_hostname(hostname, san); end
  private def verify_wildcard(domain_component, san_component); end
  def self.verify_certificate_identity(cert, hostname); end
  def self.verify_hostname(hostname, san); end
  def self.verify_wildcard(domain_component, san_component); end
end

module OpenSSL::Timestamp; end
OpenSSL::VERSION = T.let(T.unsafe(nil), String)
module OpenSSL::X509; end
StringIO::VERSION = T.let(T.unsafe(nil), String)

module Comparable
  def <(_arg0); end
  def <=(_arg0); end
  def ==(_arg0); end
  def >(_arg0); end
  def >=(_arg0); end
  def between?(_arg0, _arg1); end
  def clamp(*_arg0); end
end

module Enumerable
  def all?(*_arg0); end
  def any?(*_arg0); end
  def chain(*_arg0); end
  def chunk; end
  def chunk_while; end
  def collect; end
  def collect_concat; end
  def count(*_arg0); end
  def cycle(*_arg0); end
  def detect(*_arg0); end
  def drop(_arg0); end
  def drop_while; end
  def each_cons(_arg0); end
  def each_entry(*_arg0); end
  def each_slice(_arg0); end
  def each_with_index(*_arg0); end
  def each_with_object(_arg0); end
  def entries(*_arg0); end
  def filter; end
  def filter_map; end
  def find(*_arg0); end
  def find_all; end
  def find_index(*_arg0); end
  def first(*_arg0); end
  def flat_map; end
  def grep(_arg0); end
  def grep_v(_arg0); end
  def group_by; end
  def include?(_arg0); end
  def inject(*_arg0); end
  def lazy; end
  def map; end
  def max(*_arg0); end
  def max_by(*_arg0); end
  def member?(_arg0); end
  def min(*_arg0); end
  def min_by(*_arg0); end
  def minmax; end
  def minmax_by; end
  def none?(*_arg0); end
  def one?(*_arg0); end
  def partition; end
  def reduce(*_arg0); end
  def reject; end
  def reverse_each(*_arg0); end
  def select; end
  def slice_after(*_arg0); end
  def slice_before(*_arg0); end
  def slice_when; end
  def sort; end
  def sort_by; end
  def sum(*_arg0); end
  def take(_arg0); end
  def take_while; end
  def tally; end
  def to_a(*_arg0); end
  def to_h(*_arg0); end
  def to_set(klass = T.unsafe(nil), *args, &block); end
  def uniq; end
  def zip(*_arg0); end
end

class RuntimeError < ::StandardError; end
Socket::Constants::AF_APPLETALK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_CCITT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_CHAOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_CNT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_COIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_DATAKIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_DLI = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_E164 = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_ECMA = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_HYLINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_IMPLINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_INET = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_INET6 = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_IPX = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_ISDN = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_ISO = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_LAT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_LINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_LOCAL = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_MAX = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_NATM = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_NDRV = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_NETBIOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_NS = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_OSI = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_PPP = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_PUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_ROUTE = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_SIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_SNA = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_UNIX = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_UNSPEC = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_ADDRCONFIG = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_ALL = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_CANONNAME = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_DEFAULT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_MASK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_NUMERICHOST = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_NUMERICSERV = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_PASSIVE = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_V4MAPPED = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_V4MAPPED_CFG = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_ADDRFAMILY = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_AGAIN = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_BADFLAGS = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_BADHINTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_FAIL = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_FAMILY = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_MAX = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_MEMORY = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_NODATA = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_NONAME = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_OVERFLOW = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_PROTOCOL = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_SERVICE = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_SOCKTYPE = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_ALLMULTI = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_ALTPHYS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_DEBUG = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_LINK0 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_LINK1 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_LINK2 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_LOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_MULTICAST = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_NOARP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_NOTRAILERS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_OACTIVE = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_POINTOPOINT = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_PROMISC = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_RUNNING = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_SIMPLEX = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_UP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFNAMSIZ = T.let(T.unsafe(nil), Integer)
Socket::Constants::IF_NAMESIZE = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_ALLHOSTS_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_ANY = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_LOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_MAX_LOCAL_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_NONE = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_UNSPEC_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::INET6_ADDRSTRLEN = T.let(T.unsafe(nil), Integer)
Socket::Constants::INET_ADDRSTRLEN = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPORT_RESERVED = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPORT_USERRESERVED = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_AH = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_DSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_EGP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_EON = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ESP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_FRAGMENT = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_GGP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_HELLO = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_HOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ICMP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ICMPV6 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_IDP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_IGMP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_IP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_IPV6 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_MAX = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ND = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_NONE = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_PUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_RAW = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ROUTING = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_TCP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_TP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_UDP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_XTP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_CHECKSUM = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_DONTFRAG = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_DSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_HOPLIMIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_HOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_JOIN_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_LEAVE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_MULTICAST_HOPS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_MULTICAST_IF = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_NEXTHOP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_PATHMTU = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_PKTINFO = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVDSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVHOPLIMIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVHOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVPATHMTU = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVPKTINFO = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVRTHDR = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVTCLASS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RTHDR = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RTHDRDSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RTHDR_TYPE_0 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_TCLASS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_UNICAST_HOPS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_USE_MIN_MTU = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_V6ONLY = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_ADD_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_ADD_SOURCE_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_BLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DEFAULT_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DEFAULT_MULTICAST_TTL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DONTFRAG = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DROP_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DROP_SOURCE_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_HDRINCL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_IPSEC_POLICY = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MAX_MEMBERSHIPS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MSFILTER = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MULTICAST_IF = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MULTICAST_TTL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_OPTIONS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_PKTINFO = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_PORTRANGE = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVDSTADDR = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVIF = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVRETOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVTOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVTTL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RETOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_TOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_TTL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_UNBLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::Constants::LOCAL_PEERCRED = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_BLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_EXCLUDE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_INCLUDE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_JOIN_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_JOIN_SOURCE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_LEAVE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_LEAVE_SOURCE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_UNBLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_CTRUNC = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_DONTROUTE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_DONTWAIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_EOF = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_EOR = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_FLUSH = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_HAVEMORE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_HOLD = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_NOSIGNAL = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_OOB = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_PEEK = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_RCVMORE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_SEND = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_TRUNC = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_WAITALL = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_DGRAM = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_MAXHOST = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_MAXSERV = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_NAMEREQD = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_NOFQDN = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_NUMERICHOST = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_NUMERICSERV = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_APPLETALK = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_CCITT = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_CHAOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_CNT = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_COIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_DATAKIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_DLI = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_ECMA = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_HYLINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_IMPLINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_INET = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_INET6 = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_IPX = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_ISDN = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_ISO = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_KEY = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_LAT = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_LINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_LOCAL = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_MAX = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_NATM = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_NDRV = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_NETBIOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_NS = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_OSI = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_PIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_PPP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_PUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_ROUTE = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_RTIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_SIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_SNA = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_UNIX = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_UNSPEC = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_XTP = T.let(T.unsafe(nil), Integer)
Socket::Constants::SCM_CREDS = T.let(T.unsafe(nil), Integer)
Socket::Constants::SCM_RIGHTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::SCM_TIMESTAMP = T.let(T.unsafe(nil), Integer)
Socket::Constants::SHUT_RD = T.let(T.unsafe(nil), Integer)
Socket::Constants::SHUT_RDWR = T.let(T.unsafe(nil), Integer)
Socket::Constants::SHUT_WR = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_DGRAM = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_RAW = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_RDM = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_SEQPACKET = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_STREAM = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOL_SOCKET = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOMAXCONN = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_ACCEPTCONN = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_DEBUG = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_DONTROUTE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_DONTTRUNC = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_ERROR = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_KEEPALIVE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_LINGER = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_NKE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_NOSIGPIPE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_NREAD = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_OOBINLINE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_RCVBUF = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_RCVLOWAT = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_RCVTIMEO = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_REUSEADDR = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_REUSEPORT = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_SNDBUF = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_SNDLOWAT = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_SNDTIMEO = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_TIMESTAMP = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_TYPE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_USELOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_WANTMORE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_WANTOOBFLAG = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_FASTOPEN = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_KEEPCNT = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_KEEPINTVL = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_MAXSEG = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_NODELAY = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_NOOPT = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_NOPUSH = T.let(T.unsafe(nil), Integer)
class ArgumentError < ::StandardError; end
URI::FTP::COMPONENT = T.let(T.unsafe(nil), Array)
URI::FTP::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
URI::FTP::TYPECODE = T.let(T.unsafe(nil), Array)
URI::FTP::TYPECODE_PREFIX = T.let(T.unsafe(nil), String)
URI::File::COMPONENT = T.let(T.unsafe(nil), Array)
URI::Generic::COMPONENT = T.let(T.unsafe(nil), Array)
URI::HTTP::COMPONENT = T.let(T.unsafe(nil), Array)
URI::HTTP::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
URI::HTTPS::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
URI::LDAP::COMPONENT = T.let(T.unsafe(nil), Array)
URI::LDAP::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
URI::LDAP::SCOPE = T.let(T.unsafe(nil), Array)
URI::LDAP::SCOPE_BASE = T.let(T.unsafe(nil), String)
URI::LDAP::SCOPE_ONE = T.let(T.unsafe(nil), String)
URI::LDAP::SCOPE_SUB = T.let(T.unsafe(nil), String)
URI::LDAPS::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
URI::MailTo::COMPONENT = T.let(T.unsafe(nil), Array)
URI::MailTo::EMAIL_REGEXP = T.let(T.unsafe(nil), Regexp)
URI::MailTo::HEADER_REGEXP = T.let(T.unsafe(nil), Regexp)
module URI::RFC2396_REGEXP::PATTERN; end
URI::RFC3986_Parser::RFC3986_URI = T.let(T.unsafe(nil), Regexp)
URI::RFC3986_Parser::RFC3986_relative_ref = T.let(T.unsafe(nil), Regexp)
class Zlib::GzipFile::CRCError < ::Zlib::GzipFile::Error; end

class Zlib::GzipFile::Error < ::Zlib::Error
  def input; end
  def inspect; end
end

class Zlib::GzipFile::LengthError < ::Zlib::GzipFile::Error; end
class Zlib::GzipFile::NoFooter < ::Zlib::GzipFile::Error; end

class Numeric
  include ::Comparable
  def %(_arg0); end
  def +@; end
  def -@; end
  def <=>(_arg0); end
  def abs; end
  def abs2; end
  def angle; end
  def arg; end
  def ceil(*_arg0); end
  def clone(*_arg0); end
  def coerce(_arg0); end
  def conj; end
  def conjugate; end
  def denominator; end
  def div(_arg0); end
  def divmod(_arg0); end
  def dup; end
  def eql?(_arg0); end
  def fdiv(_arg0); end
  def finite?; end
  def floor(*_arg0); end
  def i; end
  def imag; end
  def imaginary; end
  def infinite?; end
  def integer?; end
  def magnitude; end
  def modulo(_arg0); end
  def negative?; end
  def nonzero?; end
  def numerator; end
  def phase; end
  def polar; end
  def positive?; end
  def quo(_arg0); end
  def real; end
  def real?; end
  def rect; end
  def rectangular; end
  def remainder(_arg0); end
  def round(*_arg0); end
  def singleton_method_added(_arg0); end
  def step(*_arg0); end
  def to_c; end
  def to_int; end
  def truncate(*_arg0); end
  def zero?; end
end

class IO::ConsoleMode
  def echo=(_arg0); end
  def raw(*_arg0); end
  def raw!(*_arg0); end
  private def initialize_copy(_arg0); end
end

class IO::EAGAINWaitReadable < ::Errno::EAGAIN
  include ::IO::WaitReadable
end

class IO::EAGAINWaitWritable < ::Errno::EAGAIN
  include ::IO::WaitWritable
end

class IO::EINPROGRESSWaitReadable < ::Errno::EINPROGRESS
  include ::IO::WaitReadable
end

class IO::EINPROGRESSWaitWritable < ::Errno::EINPROGRESS
  include ::IO::WaitWritable
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable
IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable
IO::PRIORITY = T.let(T.unsafe(nil), Integer)
IO::READABLE = T.let(T.unsafe(nil), Integer)
IO::SEEK_CUR = T.let(T.unsafe(nil), Integer)
IO::SEEK_DATA = T.let(T.unsafe(nil), Integer)
IO::SEEK_END = T.let(T.unsafe(nil), Integer)
IO::SEEK_HOLE = T.let(T.unsafe(nil), Integer)
IO::SEEK_SET = T.let(T.unsafe(nil), Integer)
IO::WRITABLE = T.let(T.unsafe(nil), Integer)
module IO::WaitReadable; end
module IO::WaitWritable; end

class Exception
  def initialize(*_arg0); end
  def ==(_arg0); end
  def backtrace; end
  def backtrace_locations; end
  def cause; end
  def exception(*_arg0); end
  def full_message(*_arg0); end
  def inspect; end
  def message; end
  def respond_to?(*_arg0); end
  def set_backtrace(_arg0); end
  def to_s; end
  private def method_missing(*_arg0); end
  private def respond_to_missing?(_arg0, _arg1); end
  def self.exception(*_arg0); end
  def self.to_tty?; end
end

Net::BufferedIO::BUFSIZE = T.let(T.unsafe(nil), Integer)

class Net::FTP::BufferedSSLSocket < ::Net::FTP::BufferedSocket
  def initialize(*args, **options); end
  def send(mesg, flags, dest = T.unsafe(nil)); end
  def shutdown(*args); end
  private def rbuf_fill; end
end

class Net::FTP::BufferedSocket < ::Net::BufferedIO
  def addr(*args); end
  def gets; end
  def local_address(*args); end
  def peeraddr(*args); end
  def read(len = T.unsafe(nil)); end
  def readline; end
  def remote_address(*args); end
  def send(*args); end
  def shutdown(*args); end
end

Net::FTP::CASE_DEPENDENT_PARSER = T.let(T.unsafe(nil), Proc)
Net::FTP::CASE_INDEPENDENT_PARSER = T.let(T.unsafe(nil), Proc)
Net::FTP::CRLF = T.let(T.unsafe(nil), String)
Net::FTP::DECIMAL_PARSER = T.let(T.unsafe(nil), Proc)
Net::FTP::DEFAULT_BLOCKSIZE = T.let(T.unsafe(nil), Integer)
Net::FTP::FACT_PARSERS = T.let(T.unsafe(nil), Hash)
Net::FTP::FTP_PORT = T.let(T.unsafe(nil), Integer)

class Net::FTP::MLSxEntry
  def initialize(facts, pathname); end
  def appendable?; end
  def charset; end
  def creatable?; end
  def create; end
  def deletable?; end
  def directory?; end
  def directory_makable?; end
  def enterable?; end
  def facts; end
  def file?; end
  def lang; end
  def listable?; end
  def media_type; end
  def modify; end
  def pathname; end
  def perm; end
  def purgeable?; end
  def readable?; end
  def renamable?; end
  def size; end
  def type; end
  def unique; end
  def writable?; end
end

class Net::FTP::NullSocket
  def close; end
  def closed?; end
  def method_missing(mid, *args); end
  def read_timeout=(sec); end
end

Net::FTP::OCTAL_PARSER = T.let(T.unsafe(nil), Proc)
Net::FTP::TIME_PARSER = T.let(T.unsafe(nil), Proc)
Net::FTP::VERSION = T.let(T.unsafe(nil), String)
class Net::HTTP::Copy < ::Net::HTTPRequest; end
class Net::HTTP::Delete < ::Net::HTTPRequest; end
Net::HTTP::ENVIRONMENT_VARIABLE_IS_MULTIUSER_SAFE = T.let(T.unsafe(nil), TrueClass)
class Net::HTTP::Get < ::Net::HTTPRequest; end
Net::HTTP::HAVE_ZLIB = T.let(T.unsafe(nil), TrueClass)
Net::HTTP::HTTPVersion = T.let(T.unsafe(nil), String)
class Net::HTTP::Head < ::Net::HTTPRequest; end
Net::HTTP::IDEMPOTENT_METHODS_ = T.let(T.unsafe(nil), Array)
class Net::HTTP::Lock < ::Net::HTTPRequest; end
class Net::HTTP::Mkcol < ::Net::HTTPRequest; end
class Net::HTTP::Move < ::Net::HTTPRequest; end
class Net::HTTP::Options < ::Net::HTTPRequest; end
class Net::HTTP::Patch < ::Net::HTTPRequest; end
class Net::HTTP::Post < ::Net::HTTPRequest; end
class Net::HTTP::Propfind < ::Net::HTTPRequest; end
class Net::HTTP::Proppatch < ::Net::HTTPRequest; end

module Net::HTTP::ProxyDelta
  private def conn_address; end
  private def conn_port; end
  private def edit_path(path); end
end

Net::HTTP::ProxyMod = Net::HTTP::ProxyDelta
class Net::HTTP::Put < ::Net::HTTPRequest; end
Net::HTTP::SSL_ATTRIBUTES = T.let(T.unsafe(nil), Array)
Net::HTTP::SSL_IVNAMES = T.let(T.unsafe(nil), Array)
class Net::HTTP::Trace < ::Net::HTTPRequest; end
class Net::HTTP::Unlock < ::Net::HTTPRequest; end
Net::HTTP::VERSION = T.let(T.unsafe(nil), String)
Net::HTTPAccepted::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPAlreadyReported::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPBadGateway::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPBadRequest::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPClientError::EXCEPTION_TYPE = Net::HTTPServerException
Net::HTTPClientError::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPConflict::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPCreated::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPExpectationFailed::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPFailedDependency::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPForbidden::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPFound::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPGatewayTimeout::HAS_BODY = T.let(T.unsafe(nil), TrueClass)

class Net::HTTPGenericRequest::Chunker
  def initialize(sock); end
  def finish; end
  def write(buf); end
end

Net::HTTPGone::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPIMUsed::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPInformation::EXCEPTION_TYPE = Net::HTTPError
Net::HTTPInsufficientStorage::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPInternalServerError::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPLengthRequired::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPLocked::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPLoopDetected::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPMethodNotAllowed::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPMisdirectedRequest::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPMovedPermanently::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPMultiStatus::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPMultipleChoices::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPNetworkAuthenticationRequired::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPNonAuthoritativeInformation::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPNotAcceptable::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPNotExtended::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPNotFound::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPNotImplemented::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPOK::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPPartialContent::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPPayloadTooLarge::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPPaymentRequired::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPPermanentRedirect::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPPreconditionFailed::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPPreconditionRequired::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPProxyAuthenticationRequired::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPRangeNotSatisfiable::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPRedirection::EXCEPTION_TYPE = Net::HTTPRetriableError
Net::HTTPRedirection::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPRequestHeaderFieldsTooLarge::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPRequestTimeout::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPResponse::CODE_CLASS_TO_OBJ = T.let(T.unsafe(nil), Hash)
Net::HTTPResponse::CODE_TO_OBJ = T.let(T.unsafe(nil), Hash)

class Net::HTTPResponse::Inflater
  def initialize(socket); end
  def finish; end
  def inflate_adapter(dest); end
  def read(clen, dest, ignore_eof = T.unsafe(nil)); end
  def read_all(dest); end
end

Net::HTTPSeeOther::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPServerError::EXCEPTION_TYPE = Net::HTTPFatalError
Net::HTTPServerError::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPServiceUnavailable::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPSuccess::EXCEPTION_TYPE = Net::HTTPError
Net::HTTPSuccess::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPTemporaryRedirect::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPTooManyRequests::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPURITooLong::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPUnauthorized::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPUnavailableForLegalReasons::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError
Net::HTTPUnknownResponse::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPUnprocessableEntity::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPUnsupportedMediaType::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPUpgradeRequired::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPVariantAlsoNegotiates::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTPVersionNotSupported::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::IMAP::ALL = T.let(T.unsafe(nil), Symbol)
Net::IMAP::ANSWERED = T.let(T.unsafe(nil), Symbol)
Net::IMAP::ARCHIVE = T.let(T.unsafe(nil), Symbol)
class Net::IMAP::Address < ::Struct; end

class Net::IMAP::Atom
  def initialize(data); end
  def send_data(imap, tag); end
  def validate; end
end

module Net::IMAP::Authenticators
  def add_authenticator(auth_type, authenticator); end
  def authenticator(auth_type, *args); end
  private def authenticators; end
end

class Net::IMAP::BadResponseError < ::Net::IMAP::ResponseError; end

class Net::IMAP::BodyTypeAttachment < ::Struct
  def multipart?; end
end

class Net::IMAP::BodyTypeBasic < ::Struct
  def media_subtype; end
  def multipart?; end
end

class Net::IMAP::BodyTypeExtension < ::Struct
  def multipart?; end
end

class Net::IMAP::BodyTypeMessage < ::Struct
  def media_subtype; end
  def multipart?; end
end

class Net::IMAP::BodyTypeMultipart < ::Struct
  def media_subtype; end
  def multipart?; end
end

class Net::IMAP::BodyTypeText < ::Struct
  def media_subtype; end
  def multipart?; end
end

class Net::IMAP::ByeResponseError < ::Net::IMAP::ResponseError; end
Net::IMAP::CRLF = T.let(T.unsafe(nil), String)

class Net::IMAP::ClientID
  def initialize(data); end
  def send_data(imap, tag); end
  def validate; end
  private def format_internal(client_id); end
  private def validate_internal(client_id); end
end

class Net::IMAP::ContentDisposition < ::Struct; end
class Net::IMAP::ContinuationRequest < ::Struct; end

class Net::IMAP::CramMD5Authenticator
  def initialize(user, password); end
  def process(challenge); end
  private def hmac_md5(text, key); end
end

Net::IMAP::DATE_MONTH = T.let(T.unsafe(nil), Array)
Net::IMAP::DELETED = T.let(T.unsafe(nil), Symbol)
Net::IMAP::DRAFT = T.let(T.unsafe(nil), Symbol)
Net::IMAP::DRAFTS = T.let(T.unsafe(nil), Symbol)
class Net::IMAP::DataFormatError < ::Net::IMAP::Error; end

class Net::IMAP::DigestMD5Authenticator
  def initialize(user, password, authname = T.unsafe(nil)); end
  def process(challenge); end
  private def nc(nonce); end
  private def qdval(k, v); end
end

class Net::IMAP::Envelope < ::Struct; end
class Net::IMAP::Error < ::StandardError; end
Net::IMAP::FLAGGED = T.let(T.unsafe(nil), Symbol)
class Net::IMAP::FetchData < ::Struct; end
Net::IMAP::HAS_CHILDREN = T.let(T.unsafe(nil), Symbol)
Net::IMAP::HAS_NO_CHILDREN = T.let(T.unsafe(nil), Symbol)
class Net::IMAP::IgnoredResponse < ::Struct; end
Net::IMAP::JUNK = T.let(T.unsafe(nil), Symbol)

class Net::IMAP::Literal
  def initialize(data); end
  def send_data(imap, tag); end
  def validate; end
end

class Net::IMAP::LoginAuthenticator
  def initialize(user, password); end
  def process(data); end
end

Net::IMAP::MARKED = T.let(T.unsafe(nil), Symbol)
class Net::IMAP::MailboxACLItem < ::Struct; end
class Net::IMAP::MailboxList < ::Struct; end
class Net::IMAP::MailboxQuota < ::Struct; end
class Net::IMAP::MailboxQuotaRoot < ::Struct; end

class Net::IMAP::MessageSet
  def initialize(data); end
  def send_data(imap, tag); end
  def validate; end
  private def format_internal(data); end
  private def validate_internal(data); end
end

Net::IMAP::NOINFERIORS = T.let(T.unsafe(nil), Symbol)
Net::IMAP::NONEXISTENT = T.let(T.unsafe(nil), Symbol)
Net::IMAP::NOSELECT = T.let(T.unsafe(nil), Symbol)
class Net::IMAP::Namespace < ::Struct; end
class Net::IMAP::Namespaces < ::Struct; end
class Net::IMAP::NoResponseError < ::Net::IMAP::ResponseError; end

module Net::IMAP::NumValidator
  private def ensure_mod_sequence_value(num); end
  private def ensure_number(num); end
  private def ensure_nz_number(num); end
  private def valid_mod_sequence_value?(num); end
  private def valid_number?(num); end
  private def valid_nz_number?(num); end
  def self.ensure_mod_sequence_value(num); end
  def self.ensure_number(num); end
  def self.ensure_nz_number(num); end
  def self.valid_mod_sequence_value?(num); end
  def self.valid_number?(num); end
  def self.valid_nz_number?(num); end
end

Net::IMAP::PORT = T.let(T.unsafe(nil), Integer)

class Net::IMAP::PlainAuthenticator
  def initialize(username, password, authzid: T.unsafe(nil)); end
  def process(data); end
end

class Net::IMAP::QuotedString
  def initialize(data); end
  def send_data(imap, tag); end
  def validate; end
end

Net::IMAP::RECENT = T.let(T.unsafe(nil), Symbol)
Net::IMAP::REMOTE = T.let(T.unsafe(nil), Symbol)
Net::IMAP::RESPONSE_ERRORS = T.let(T.unsafe(nil), Hash)

class Net::IMAP::RawData
  def initialize(data); end
  def send_data(imap, tag); end
  def validate; end
end

class Net::IMAP::ResponseCode < ::Struct; end

class Net::IMAP::ResponseError < ::Net::IMAP::Error
  def initialize(response); end
  def response; end
  def response=(_arg0); end
end

class Net::IMAP::ResponseParseError < ::Net::IMAP::Error; end

class Net::IMAP::ResponseParser
  def initialize; end
  def parse(str); end
  private def accept(*args); end
  private def accept_space; end
  private def accept_spaces; end
  private def address; end
  private def address_list; end
  private def astring; end
  private def astring_chars; end
  private def atom; end
  private def body; end
  private def body_data; end
  private def body_ext_1part; end
  private def body_ext_mpart; end
  private def body_extension; end
  private def body_extensions; end
  private def body_fields; end
  private def body_fld_dsp; end
  private def body_fld_lang; end
  private def body_fld_param; end
  private def body_type_1part; end
  private def body_type_attachment; end
  private def body_type_basic; end
  private def body_type_mixed; end
  private def body_type_mpart; end
  private def body_type_msg; end
  private def body_type_text; end
  private def capability_data; end
  private def capability_response; end
  private def case_insensitive_string; end
  private def charset; end
  private def charset_list; end
  private def combine_adjacent(*tokens); end
  private def continue_req; end
  private def envelope; end
  private def envelope_data; end
  private def flag_list; end
  private def flags_data; end
  private def flags_response; end
  private def format_string(str); end
  private def getacl_response; end
  private def getquota_response; end
  private def getquotaroot_response; end
  private def id_response; end
  private def ignored_response; end
  private def internaldate_data; end
  private def list_response; end
  private def lookahead; end
  private def mailbox_list; end
  private def match(*args, lex_state: T.unsafe(nil)); end
  private def media_type; end
  private def modseq_data; end
  private def msg_att(n); end
  private def namespace; end
  private def namespace_response; end
  private def namespace_response_extensions; end
  private def namespaces; end
  private def next_token; end
  private def nil_atom; end
  private def nstring; end
  private def number; end
  private def numeric_response; end
  private def parse_error(fmt, *args); end
  private def resp_text; end
  private def resp_text_code; end
  private def response; end
  private def response_cond; end
  private def response_tagged; end
  private def response_untagged; end
  private def rfc822_size; end
  private def rfc822_text; end
  private def search_response; end
  private def section; end
  private def shift_token; end
  private def status_response; end
  private def string; end
  private def string_token?(token); end
  private def text; end
  private def text_response; end
  private def thread_branch(token); end
  private def thread_response; end
  private def uid_data; end
end

class Net::IMAP::ResponseText < ::Struct; end
Net::IMAP::SEEN = T.let(T.unsafe(nil), Symbol)
Net::IMAP::SENT = T.let(T.unsafe(nil), Symbol)
Net::IMAP::SSL_PORT = T.let(T.unsafe(nil), Integer)
Net::IMAP::SUBSCRIBED = T.let(T.unsafe(nil), Symbol)
class Net::IMAP::StatusData < ::Struct; end

module Net::IMAP::StringFormatter
  private def nstring(str); end
  private def string(str); end
  private def valid_nstring?(str); end
  private def valid_string?(str); end
  def self.nstring(str); end
  def self.string(str); end
  def self.valid_nstring?(str); end
  def self.valid_string?(str); end
end

Net::IMAP::TRASH = T.let(T.unsafe(nil), Symbol)
class Net::IMAP::TaggedResponse < ::Struct; end
class Net::IMAP::ThreadMember < ::Struct; end
Net::IMAP::UNMARKED = T.let(T.unsafe(nil), Symbol)
class Net::IMAP::UnknownResponseError < ::Net::IMAP::ResponseError; end
class Net::IMAP::UntaggedResponse < ::Struct; end
Net::IMAP::VERSION = T.let(T.unsafe(nil), String)
Net::NetPrivate::HTTPRequest = Net::HTTPRequest
Net::NetPrivate::Socket = Net::InternetMessageIO
Net::POP3::VERSION = T.let(T.unsafe(nil), String)
Net::Protocol::VERSION = T.let(T.unsafe(nil), String)

class Net::SMTP::Address
  def initialize(address, *args, **kw_args); end
  def address; end
  def parameters; end
  def to_s; end
end

Net::SMTP::CRAM_BUFSIZE = T.let(T.unsafe(nil), Integer)
Net::SMTP::DEFAULT_AUTH_TYPE = T.let(T.unsafe(nil), Symbol)
Net::SMTP::IMASK = T.let(T.unsafe(nil), Integer)
Net::SMTP::OMASK = T.let(T.unsafe(nil), Integer)

class Net::SMTP::Response
  def initialize(status, string); end
  def capabilities; end
  def continue?; end
  def cram_md5_challenge; end
  def exception_class; end
  def message; end
  def status; end
  def status_type_char; end
  def string; end
  def success?; end
  def self.parse(str); end
end

Net::SMTP::VERSION = T.let(T.unsafe(nil), String)

class OpenSSL::ASN1::ASN1Data
  def initialize(_arg0, _arg1, _arg2); end
  def indefinite_length; end
  def indefinite_length=(_arg0); end
  def infinite_length; end
  def infinite_length=(_arg0); end
  def tag; end
  def tag=(_arg0); end
  def tag_class; end
  def tag_class=(_arg0); end
  def to_der; end
  def value; end
  def value=(_arg0); end
end

class OpenSSL::ASN1::ASN1Error < ::OpenSSL::OpenSSLError; end
OpenSSL::ASN1::BIT_STRING = T.let(T.unsafe(nil), Integer)
OpenSSL::ASN1::BMPSTRING = T.let(T.unsafe(nil), Integer)
class OpenSSL::ASN1::BMPString < ::OpenSSL::ASN1::Primitive; end
OpenSSL::ASN1::BOOLEAN = T.let(T.unsafe(nil), Integer)

class OpenSSL::ASN1::BitString < ::OpenSSL::ASN1::Primitive
  def unused_bits; end
  def unused_bits=(_arg0); end
end

class OpenSSL::ASN1::Boolean < ::OpenSSL::ASN1::Primitive; end
OpenSSL::ASN1::CHARACTER_STRING = T.let(T.unsafe(nil), Integer)

class OpenSSL::ASN1::Constructive < ::OpenSSL::ASN1::ASN1Data
  include ::Enumerable
  def initialize(*_arg0); end
  def each; end
  def tagging; end
  def tagging=(_arg0); end
  def to_der; end
end

OpenSSL::ASN1::EMBEDDED_PDV = T.let(T.unsafe(nil), Integer)
OpenSSL::ASN1::ENUMERATED = T.let(T.unsafe(nil), Integer)
OpenSSL::ASN1::EOC = T.let(T.unsafe(nil), Integer)
OpenSSL::ASN1::EXTERNAL = T.let(T.unsafe(nil), Integer)

class OpenSSL::ASN1::EndOfContent < ::OpenSSL::ASN1::ASN1Data
  def initialize; end
  def to_der; end
end

class OpenSSL::ASN1::Enumerated < ::OpenSSL::ASN1::Primitive; end
OpenSSL::ASN1::GENERALIZEDTIME = T.let(T.unsafe(nil), Integer)
OpenSSL::ASN1::GENERALSTRING = T.let(T.unsafe(nil), Integer)
OpenSSL::ASN1::GRAPHICSTRING = T.let(T.unsafe(nil), Integer)
class OpenSSL::ASN1::GeneralString < ::OpenSSL::ASN1::Primitive; end
class OpenSSL::ASN1::GeneralizedTime < ::OpenSSL::ASN1::Primitive; end
class OpenSSL::ASN1::GraphicString < ::OpenSSL::ASN1::Primitive; end
OpenSSL::ASN1::IA5STRING = T.let(T.unsafe(nil), Integer)
class OpenSSL::ASN1::IA5String < ::OpenSSL::ASN1::Primitive; end
OpenSSL::ASN1::INTEGER = T.let(T.unsafe(nil), Integer)
OpenSSL::ASN1::ISO64STRING = T.let(T.unsafe(nil), Integer)
class OpenSSL::ASN1::ISO64String < ::OpenSSL::ASN1::Primitive; end
class OpenSSL::ASN1::Integer < ::OpenSSL::ASN1::Primitive; end
OpenSSL::ASN1::NULL = T.let(T.unsafe(nil), Integer)
OpenSSL::ASN1::NUMERICSTRING = T.let(T.unsafe(nil), Integer)
class OpenSSL::ASN1::Null < ::OpenSSL::ASN1::Primitive; end
class OpenSSL::ASN1::NumericString < ::OpenSSL::ASN1::Primitive; end
OpenSSL::ASN1::OBJECT = T.let(T.unsafe(nil), Integer)
OpenSSL::ASN1::OBJECT_DESCRIPTOR = T.let(T.unsafe(nil), Integer)
OpenSSL::ASN1::OCTET_STRING = T.let(T.unsafe(nil), Integer)

class OpenSSL::ASN1::ObjectId < ::OpenSSL::ASN1::Primitive
  def ==(_arg0); end
  def ln; end
  def long_name; end
  def oid; end
  def short_name; end
  def sn; end
  def self.register(_arg0, _arg1, _arg2); end
end

class OpenSSL::ASN1::OctetString < ::OpenSSL::ASN1::Primitive; end
OpenSSL::ASN1::PRINTABLESTRING = T.let(T.unsafe(nil), Integer)

class OpenSSL::ASN1::Primitive < ::OpenSSL::ASN1::ASN1Data
  def initialize(*_arg0); end
  def tagging; end
  def tagging=(_arg0); end
  def to_der; end
end

class OpenSSL::ASN1::PrintableString < ::OpenSSL::ASN1::Primitive; end
OpenSSL::ASN1::REAL = T.let(T.unsafe(nil), Integer)
OpenSSL::ASN1::RELATIVE_OID = T.let(T.unsafe(nil), Integer)
OpenSSL::ASN1::SEQUENCE = T.let(T.unsafe(nil), Integer)
OpenSSL::ASN1::SET = T.let(T.unsafe(nil), Integer)
class OpenSSL::ASN1::Sequence < ::OpenSSL::ASN1::Constructive; end
class OpenSSL::ASN1::Set < ::OpenSSL::ASN1::Constructive; end
OpenSSL::ASN1::T61STRING = T.let(T.unsafe(nil), Integer)
class OpenSSL::ASN1::T61String < ::OpenSSL::ASN1::Primitive; end
OpenSSL::ASN1::UNIVERSALSTRING = T.let(T.unsafe(nil), Integer)
OpenSSL::ASN1::UNIVERSAL_TAG_NAME = T.let(T.unsafe(nil), Array)
OpenSSL::ASN1::UTCTIME = T.let(T.unsafe(nil), Integer)
class OpenSSL::ASN1::UTCTime < ::OpenSSL::ASN1::Primitive; end
OpenSSL::ASN1::UTF8STRING = T.let(T.unsafe(nil), Integer)
class OpenSSL::ASN1::UTF8String < ::OpenSSL::ASN1::Primitive; end
class OpenSSL::ASN1::UniversalString < ::OpenSSL::ASN1::Primitive; end
OpenSSL::ASN1::VIDEOTEXSTRING = T.let(T.unsafe(nil), Integer)
class OpenSSL::ASN1::VideotexString < ::OpenSSL::ASN1::Primitive; end
OpenSSL::Buffering::BLOCK_SIZE = T.let(T.unsafe(nil), Integer)

class OpenSSL::Buffering::Buffer < ::String
  def initialize; end
  def <<(string); end
  def concat(string); end
end

class OpenSSL::Cipher::AES < ::OpenSSL::Cipher
  def initialize(*args); end
end

class OpenSSL::Cipher::AES128 < ::OpenSSL::Cipher
  def initialize(mode = T.unsafe(nil)); end
end

class OpenSSL::Cipher::AES192 < ::OpenSSL::Cipher
  def initialize(mode = T.unsafe(nil)); end
end

class OpenSSL::Cipher::AES256 < ::OpenSSL::Cipher
  def initialize(mode = T.unsafe(nil)); end
end

class OpenSSL::Cipher::BF < ::OpenSSL::Cipher
  def initialize(*args); end
end

class OpenSSL::Cipher::CAST5 < ::OpenSSL::Cipher
  def initialize(*args); end
end

class OpenSSL::Cipher::Cipher < ::OpenSSL::Cipher; end
class OpenSSL::Cipher::CipherError < ::OpenSSL::OpenSSLError; end

class OpenSSL::Cipher::DES < ::OpenSSL::Cipher
  def initialize(*args); end
end

class OpenSSL::Cipher::IDEA < ::OpenSSL::Cipher
  def initialize(*args); end
end

class OpenSSL::Cipher::RC2 < ::OpenSSL::Cipher
  def initialize(*args); end
end

class OpenSSL::Cipher::RC4 < ::OpenSSL::Cipher
  def initialize(*args); end
end

class OpenSSL::Cipher::RC5 < ::OpenSSL::Cipher
  def initialize(*args); end
end

OpenSSL::Config::DEFAULT_CONFIG_FILE = T.let(T.unsafe(nil), String)
class OpenSSL::Digest::Digest < ::OpenSSL::Digest; end
class OpenSSL::Digest::DigestError < ::OpenSSL::OpenSSLError; end

class OpenSSL::Digest::MD4 < ::OpenSSL::Digest
  def initialize(data = T.unsafe(nil)); end
  def self.digest(data); end
  def self.hexdigest(data); end
end

class OpenSSL::Digest::MD5 < ::OpenSSL::Digest
  def initialize(data = T.unsafe(nil)); end
  def self.digest(data); end
  def self.hexdigest(data); end
end

class OpenSSL::Digest::RIPEMD160 < ::OpenSSL::Digest
  def initialize(data = T.unsafe(nil)); end
  def self.digest(data); end
  def self.hexdigest(data); end
end

class OpenSSL::Digest::SHA1 < ::OpenSSL::Digest
  def initialize(data = T.unsafe(nil)); end
  def self.digest(data); end
  def self.hexdigest(data); end
end

class OpenSSL::Digest::SHA224 < ::OpenSSL::Digest
  def initialize(data = T.unsafe(nil)); end
  def self.digest(data); end
  def self.hexdigest(data); end
end

class OpenSSL::Digest::SHA256 < ::OpenSSL::Digest
  def initialize(data = T.unsafe(nil)); end
  def self.digest(data); end
  def self.hexdigest(data); end
end

class OpenSSL::Digest::SHA384 < ::OpenSSL::Digest
  def initialize(data = T.unsafe(nil)); end
  def self.digest(data); end
  def self.hexdigest(data); end
end

class OpenSSL::Digest::SHA512 < ::OpenSSL::Digest
  def initialize(data = T.unsafe(nil)); end
  def self.digest(data); end
  def self.hexdigest(data); end
end

class OpenSSL::Engine::EngineError < ::OpenSSL::OpenSSLError; end
OpenSSL::Engine::METHOD_ALL = T.let(T.unsafe(nil), Integer)
OpenSSL::Engine::METHOD_CIPHERS = T.let(T.unsafe(nil), Integer)
OpenSSL::Engine::METHOD_DH = T.let(T.unsafe(nil), Integer)
OpenSSL::Engine::METHOD_DIGESTS = T.let(T.unsafe(nil), Integer)
OpenSSL::Engine::METHOD_DSA = T.let(T.unsafe(nil), Integer)
OpenSSL::Engine::METHOD_NONE = T.let(T.unsafe(nil), Integer)
OpenSSL::Engine::METHOD_RAND = T.let(T.unsafe(nil), Integer)
OpenSSL::Engine::METHOD_RSA = T.let(T.unsafe(nil), Integer)
OpenSSL::ExtConfig::HAVE_TLSEXT_HOST_NAME = T.let(T.unsafe(nil), TrueClass)
class OpenSSL::KDF::KDFError < ::OpenSSL::OpenSSLError; end

module OpenSSL::Marshal::ClassMethods
  def _load(string); end
end

class OpenSSL::Netscape::SPKI
  def initialize(*_arg0); end
  def challenge; end
  def challenge=(_arg0); end
  def public_key; end
  def public_key=(_arg0); end
  def sign(_arg0, _arg1); end
  def to_der; end
  def to_pem; end
  def to_s; end
  def to_text; end
  def verify(_arg0); end
end

class OpenSSL::Netscape::SPKIError < ::OpenSSL::OpenSSLError; end

class OpenSSL::OCSP::BasicResponse
  def initialize(*_arg0); end
  def add_nonce(*_arg0); end
  def add_status(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6); end
  def copy_nonce(_arg0); end
  def find_response(_arg0); end
  def responses; end
  def sign(*_arg0); end
  def status; end
  def to_der; end
  def verify(*_arg0); end
  private def initialize_copy(_arg0); end
end

class OpenSSL::OCSP::CertificateId
  def initialize(*_arg0); end
  def cmp(_arg0); end
  def cmp_issuer(_arg0); end
  def hash_algorithm; end
  def issuer_key_hash; end
  def issuer_name_hash; end
  def serial; end
  def to_der; end
  private def initialize_copy(_arg0); end
end

OpenSSL::OCSP::NOCASIGN = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::NOCERTS = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::NOCHAIN = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::NOCHECKS = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::NODELEGATED = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::NOEXPLICIT = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::NOINTERN = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::NOSIGS = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::NOTIME = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::NOVERIFY = T.let(T.unsafe(nil), Integer)
class OpenSSL::OCSP::OCSPError < ::OpenSSL::OpenSSLError; end
OpenSSL::OCSP::RESPID_KEY = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::RESPONSE_STATUS_INTERNALERROR = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::RESPONSE_STATUS_MALFORMEDREQUEST = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::RESPONSE_STATUS_SIGREQUIRED = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::RESPONSE_STATUS_SUCCESSFUL = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::RESPONSE_STATUS_TRYLATER = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::RESPONSE_STATUS_UNAUTHORIZED = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::REVOKED_STATUS_AFFILIATIONCHANGED = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::REVOKED_STATUS_CACOMPROMISE = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::REVOKED_STATUS_CERTIFICATEHOLD = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::REVOKED_STATUS_CESSATIONOFOPERATION = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::REVOKED_STATUS_KEYCOMPROMISE = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::REVOKED_STATUS_NOSTATUS = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::REVOKED_STATUS_REMOVEFROMCRL = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::REVOKED_STATUS_SUPERSEDED = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::REVOKED_STATUS_UNSPECIFIED = T.let(T.unsafe(nil), Integer)

class OpenSSL::OCSP::Request
  def initialize(*_arg0); end
  def add_certid(_arg0); end
  def add_nonce(*_arg0); end
  def certid; end
  def check_nonce(_arg0); end
  def sign(*_arg0); end
  def signed?; end
  def to_der; end
  def verify(*_arg0); end
  private def initialize_copy(_arg0); end
end

class OpenSSL::OCSP::Response
  def initialize(*_arg0); end
  def basic; end
  def status; end
  def status_string; end
  def to_der; end
  private def initialize_copy(_arg0); end
  def self.create(_arg0, _arg1); end
end

class OpenSSL::OCSP::SingleResponse
  def initialize(_arg0); end
  def cert_status; end
  def certid; end
  def check_validity(*_arg0); end
  def extensions; end
  def next_update; end
  def revocation_reason; end
  def revocation_time; end
  def this_update; end
  def to_der; end
  private def initialize_copy(_arg0); end
end

OpenSSL::OCSP::TRUSTOTHER = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::V_CERTSTATUS_GOOD = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::V_CERTSTATUS_REVOKED = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::V_CERTSTATUS_UNKNOWN = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::V_RESPID_KEY = T.let(T.unsafe(nil), Integer)
OpenSSL::OCSP::V_RESPID_NAME = T.let(T.unsafe(nil), Integer)
class OpenSSL::PKCS12::PKCS12Error < ::OpenSSL::OpenSSLError; end
OpenSSL::PKCS7::BINARY = T.let(T.unsafe(nil), Integer)
OpenSSL::PKCS7::DETACHED = T.let(T.unsafe(nil), Integer)
OpenSSL::PKCS7::NOATTR = T.let(T.unsafe(nil), Integer)
OpenSSL::PKCS7::NOCERTS = T.let(T.unsafe(nil), Integer)
OpenSSL::PKCS7::NOCHAIN = T.let(T.unsafe(nil), Integer)
OpenSSL::PKCS7::NOINTERN = T.let(T.unsafe(nil), Integer)
OpenSSL::PKCS7::NOSIGS = T.let(T.unsafe(nil), Integer)
OpenSSL::PKCS7::NOSMIMECAP = T.let(T.unsafe(nil), Integer)
OpenSSL::PKCS7::NOVERIFY = T.let(T.unsafe(nil), Integer)
class OpenSSL::PKCS7::PKCS7Error < ::OpenSSL::OpenSSLError; end

class OpenSSL::PKCS7::RecipientInfo
  def initialize(_arg0); end
  def enc_key; end
  def issuer; end
  def serial; end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKCS7::SignerInfo
  def initialize(_arg0, _arg1, _arg2); end
  def issuer; end
  def serial; end
  def signed_time; end
end

OpenSSL::PKCS7::TEXT = T.let(T.unsafe(nil), Integer)

class OpenSSL::PKey::DH < ::OpenSSL::PKey::PKey
  include ::OpenSSL::Marshal
  extend ::OpenSSL::Marshal::ClassMethods
  def initialize(*_arg0); end
  def compute_key(_arg0); end
  def export; end
  def g; end
  def generate_key!; end
  def p; end
  def params; end
  def params_ok?; end
  def priv_key; end
  def private?; end
  def pub_key; end
  def public?; end
  def public_key; end
  def q; end
  def set_key(_arg0, _arg1); end
  def set_pqg(_arg0, _arg1, _arg2); end
  def to_der; end
  def to_pem; end
  def to_s; end
  def to_text; end
  private def initialize_copy(_arg0); end
  def self.generate(*_arg0); end
end

class OpenSSL::PKey::DHError < ::OpenSSL::PKey::PKeyError; end

class OpenSSL::PKey::DSA < ::OpenSSL::PKey::PKey
  include ::OpenSSL::Marshal
  extend ::OpenSSL::Marshal::ClassMethods
  def initialize(*_arg0); end
  def export(*_arg0); end
  def g; end
  def p; end
  def params; end
  def priv_key; end
  def private?; end
  def pub_key; end
  def public?; end
  def public_key; end
  def q; end
  def set_key(_arg0, _arg1); end
  def set_pqg(_arg0, _arg1, _arg2); end
  def syssign(_arg0); end
  def sysverify(_arg0, _arg1); end
  def to_der; end
  def to_pem(*_arg0); end
  def to_s(*_arg0); end
  def to_text; end
  private def initialize_copy(_arg0); end
  def self.generate(_arg0); end
end

class OpenSSL::PKey::DSAError < ::OpenSSL::PKey::PKeyError; end

class OpenSSL::PKey::EC < ::OpenSSL::PKey::PKey
  include ::OpenSSL::Marshal
  extend ::OpenSSL::Marshal::ClassMethods
  def initialize(*_arg0); end
  def check_key; end
  def dh_compute_key(_arg0); end
  def dsa_sign_asn1(_arg0); end
  def dsa_verify_asn1(_arg0, _arg1); end
  def export(*_arg0); end
  def generate_key; end
  def generate_key!; end
  def group; end
  def group=(_arg0); end
  def private?; end
  def private_key; end
  def private_key=(_arg0); end
  def private_key?; end
  def public?; end
  def public_key; end
  def public_key=(_arg0); end
  def public_key?; end
  def to_der; end
  def to_pem(*_arg0); end
  def to_text; end
  private def initialize_copy(_arg0); end
  def self.builtin_curves; end
  def self.generate(_arg0); end
end

class OpenSSL::PKey::ECError < ::OpenSSL::PKey::PKeyError; end

class OpenSSL::PKey::PKey
  def initialize; end
  def inspect; end
  def oid; end
  def private_to_der(*_arg0); end
  def private_to_pem(*_arg0); end
  def public_to_der; end
  def public_to_pem; end
  def sign(_arg0, _arg1); end
  def verify(_arg0, _arg1, _arg2); end
end

class OpenSSL::PKey::PKeyError < ::OpenSSL::OpenSSLError; end

class OpenSSL::PKey::RSA < ::OpenSSL::PKey::PKey
  include ::OpenSSL::Marshal
  extend ::OpenSSL::Marshal::ClassMethods
  def initialize(*_arg0); end
  def d; end
  def dmp1; end
  def dmq1; end
  def e; end
  def export(*_arg0); end
  def iqmp; end
  def n; end
  def p; end
  def params; end
  def private?; end
  def private_decrypt(*_arg0); end
  def private_encrypt(*_arg0); end
  def public?; end
  def public_decrypt(*_arg0); end
  def public_encrypt(*_arg0); end
  def public_key; end
  def q; end
  def set_crt_params(_arg0, _arg1, _arg2); end
  def set_factors(_arg0, _arg1); end
  def set_key(_arg0, _arg1, _arg2); end
  def sign_pss(*_arg0); end
  def to_der; end
  def to_pem(*_arg0); end
  def to_s(*_arg0); end
  def to_text; end
  def verify_pss(*_arg0); end
  private def initialize_copy(_arg0); end
  def self.generate(*_arg0); end
end

class OpenSSL::PKey::RSAError < ::OpenSSL::PKey::PKeyError; end
class OpenSSL::Random::RandomError < ::OpenSSL::OpenSSLError; end
OpenSSL::SSL::OP_ALL = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_ALLOW_NO_DHE_KEX = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_CIPHER_SERVER_PREFERENCE = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_CRYPTOPRO_TLSEXT_BUG = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_DONT_INSERT_EMPTY_FRAGMENTS = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_EPHEMERAL_RSA = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_LEGACY_SERVER_CONNECT = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_MICROSOFT_BIG_SSLV3_BUFFER = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_MICROSOFT_SESS_ID_BUG = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_MSIE_SSLV2_RSA_PADDING = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_NETSCAPE_CA_DN_BUG = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_NETSCAPE_CHALLENGE_BUG = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_NO_COMPRESSION = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_NO_ENCRYPT_THEN_MAC = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_NO_RENEGOTIATION = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_NO_SSLv2 = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_NO_SSLv3 = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_NO_TICKET = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_NO_TLSv1 = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_NO_TLSv1_1 = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_NO_TLSv1_2 = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_NO_TLSv1_3 = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_PKCS1_CHECK_1 = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_PKCS1_CHECK_2 = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_SAFARI_ECDHE_ECDSA_BUG = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_SINGLE_DH_USE = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_SINGLE_ECDH_USE = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_SSLEAY_080_CLIENT_DH_BUG = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_SSLREF2_REUSE_CERT_TYPE_BUG = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_TLSEXT_PADDING = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_TLS_BLOCK_PADDING_BUG = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_TLS_D5_BUG = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::OP_TLS_ROLLBACK_BUG = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::SSL2_VERSION = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::SSL3_VERSION = T.let(T.unsafe(nil), Integer)

class OpenSSL::SSL::SSLContext
  def initialize(version = T.unsafe(nil)); end
  def add_certificate(*_arg0); end
  def alpn_protocols; end
  def alpn_protocols=(_arg0); end
  def alpn_select_cb; end
  def alpn_select_cb=(_arg0); end
  def ca_file; end
  def ca_file=(_arg0); end
  def ca_path; end
  def ca_path=(_arg0); end
  def cert; end
  def cert=(_arg0); end
  def cert_store; end
  def cert_store=(_arg0); end
  def ciphers; end
  def ciphers=(_arg0); end
  def client_ca; end
  def client_ca=(_arg0); end
  def client_cert_cb; end
  def client_cert_cb=(_arg0); end
  def ecdh_curves=(_arg0); end
  def enable_fallback_scsv; end
  def extra_chain_cert; end
  def extra_chain_cert=(_arg0); end
  def flush_sessions(*_arg0); end
  def freeze; end
  def key; end
  def key=(_arg0); end
  def max_version=(version); end
  def min_version=(version); end
  def npn_protocols; end
  def npn_protocols=(_arg0); end
  def npn_select_cb; end
  def npn_select_cb=(_arg0); end
  def options; end
  def options=(_arg0); end
  def renegotiation_cb; end
  def renegotiation_cb=(_arg0); end
  def security_level; end
  def security_level=(_arg0); end
  def servername_cb; end
  def servername_cb=(_arg0); end
  def session_add(_arg0); end
  def session_cache_mode; end
  def session_cache_mode=(_arg0); end
  def session_cache_size; end
  def session_cache_size=(_arg0); end
  def session_cache_stats; end
  def session_get_cb; end
  def session_get_cb=(_arg0); end
  def session_id_context; end
  def session_id_context=(_arg0); end
  def session_new_cb; end
  def session_new_cb=(_arg0); end
  def session_remove(_arg0); end
  def session_remove_cb; end
  def session_remove_cb=(_arg0); end
  def set_params(params = T.unsafe(nil)); end
  def setup; end
  def ssl_timeout; end
  def ssl_timeout=(_arg0); end
  def ssl_version=(meth); end
  def timeout; end
  def timeout=(_arg0); end
  def tmp_dh_callback; end
  def tmp_dh_callback=(_arg0); end
  def verify_callback; end
  def verify_callback=(_arg0); end
  def verify_depth; end
  def verify_depth=(_arg0); end
  def verify_hostname; end
  def verify_hostname=(_arg0); end
  def verify_mode; end
  def verify_mode=(_arg0); end
  private def set_minmax_proto_version(_arg0, _arg1); end
end

class OpenSSL::SSL::SSLError < ::OpenSSL::OpenSSLError; end

class OpenSSL::SSL::SSLErrorWaitReadable < ::OpenSSL::SSL::SSLError
  include ::IO::WaitReadable
end

class OpenSSL::SSL::SSLErrorWaitWritable < ::OpenSSL::SSL::SSLError
  include ::IO::WaitWritable
end

class OpenSSL::SSL::SSLServer
  include ::OpenSSL::SSL::SocketForwarder
  def initialize(svr, ctx); end
  def accept; end
  def close; end
  def listen(backlog = T.unsafe(nil)); end
  def shutdown(how = T.unsafe(nil)); end
  def start_immediately; end
  def start_immediately=(_arg0); end
  def to_io; end
end

class OpenSSL::SSL::SSLSocket
  include ::Enumerable
  include ::OpenSSL::Buffering
  include ::OpenSSL::SSL::SocketForwarder
  def initialize(*_arg0); end
  def accept; end
  def accept_nonblock(*_arg0); end
  def alpn_protocol; end
  def cert; end
  def cipher; end
  def client_ca; end
  def connect; end
  def connect_nonblock(*_arg0); end
  def context; end
  def finished_message; end
  def hostname; end
  def hostname=(_arg0); end
  def io; end
  def npn_protocol; end
  def peer_cert; end
  def peer_cert_chain; end
  def peer_finished_message; end
  def pending; end
  def post_connection_check(hostname); end
  def session; end
  def session=(_arg0); end
  def session_reused?; end
  def ssl_version; end
  def state; end
  def sync_close; end
  def sync_close=(_arg0); end
  def sysclose; end
  def sysread(*_arg0); end
  def syswrite(_arg0); end
  def tmp_key; end
  def to_io; end
  def verify_result; end
  private def client_cert_cb; end
  private def session_get_cb; end
  private def session_new_cb; end
  private def stop; end
  private def sysread_nonblock(*_arg0); end
  private def syswrite_nonblock(*_arg0); end
  private def tmp_dh_callback; end
  private def tmp_ecdh_callback; end
  private def using_anon_cipher?; end
  def self.open(remote_host, remote_port, local_host = T.unsafe(nil), local_port = T.unsafe(nil), context: T.unsafe(nil)); end
end

class OpenSSL::SSL::Session
  def initialize(_arg0); end
  def ==(_arg0); end
  def id; end
  def time; end
  def time=(_arg0); end
  def timeout; end
  def timeout=(_arg0); end
  def to_der; end
  def to_pem; end
  def to_text; end
  private def initialize_copy(_arg0); end
end

module OpenSSL::SSL::SocketForwarder
  def addr; end
  def closed?; end
  def do_not_reverse_lookup=(flag); end
  def fcntl(*args); end
  def fileno; end
  def getsockopt(level, optname); end
  def peeraddr; end
  def setsockopt(level, optname, optval); end
end

OpenSSL::SSL::TLS1_1_VERSION = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::TLS1_2_VERSION = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::TLS1_3_VERSION = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::TLS1_VERSION = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::VERIFY_CLIENT_ONCE = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::VERIFY_FAIL_IF_NO_PEER_CERT = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::VERIFY_NONE = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::VERIFY_PEER = T.let(T.unsafe(nil), Integer)

class OpenSSL::Timestamp::Factory
  def additional_certs; end
  def additional_certs=(_arg0); end
  def allowed_digests; end
  def allowed_digests=(_arg0); end
  def create_timestamp(_arg0, _arg1, _arg2); end
  def default_policy_id; end
  def default_policy_id=(_arg0); end
  def gen_time; end
  def gen_time=(_arg0); end
  def serial_number; end
  def serial_number=(_arg0); end
end

class OpenSSL::Timestamp::Request
  def initialize(*_arg0); end
  def algorithm; end
  def algorithm=(_arg0); end
  def cert_requested=(_arg0); end
  def cert_requested?; end
  def message_imprint; end
  def message_imprint=(_arg0); end
  def nonce; end
  def nonce=(_arg0); end
  def policy_id; end
  def policy_id=(_arg0); end
  def to_der; end
  def version; end
  def version=(_arg0); end
end

class OpenSSL::Timestamp::Response
  def initialize(_arg0); end
  def failure_info; end
  def status; end
  def status_text; end
  def to_der; end
  def token; end
  def token_info; end
  def tsa_certificate; end
  def verify(*_arg0); end
end

class OpenSSL::Timestamp::TimestampError < ::OpenSSL::OpenSSLError; end

class OpenSSL::Timestamp::TokenInfo
  def initialize(_arg0); end
  def algorithm; end
  def gen_time; end
  def message_imprint; end
  def nonce; end
  def ordering; end
  def policy_id; end
  def serial_number; end
  def to_der; end
  def version; end
end

class OpenSSL::X509::Attribute
  include ::OpenSSL::Marshal
  extend ::OpenSSL::Marshal::ClassMethods
  def initialize(*_arg0); end
  def ==(other); end
  def oid; end
  def oid=(_arg0); end
  def to_der; end
  def value; end
  def value=(_arg0); end
  private def initialize_copy(_arg0); end
end

class OpenSSL::X509::AttributeError < ::OpenSSL::OpenSSLError; end

class OpenSSL::X509::CRL
  include ::OpenSSL::Marshal
  include ::OpenSSL::X509::Extension::Helpers
  include ::OpenSSL::X509::Extension::AuthorityKeyIdentifier
  extend ::OpenSSL::Marshal::ClassMethods
  def initialize(*_arg0); end
  def ==(other); end
  def add_extension(_arg0); end
  def add_revoked(_arg0); end
  def extensions; end
  def extensions=(_arg0); end
  def issuer; end
  def issuer=(_arg0); end
  def last_update; end
  def last_update=(_arg0); end
  def next_update; end
  def next_update=(_arg0); end
  def revoked; end
  def revoked=(_arg0); end
  def sign(_arg0, _arg1); end
  def signature_algorithm; end
  def to_der; end
  def to_pem; end
  def to_s; end
  def to_text; end
  def verify(_arg0); end
  def version; end
  def version=(_arg0); end
  private def initialize_copy(_arg0); end
end

class OpenSSL::X509::CRLError < ::OpenSSL::OpenSSLError; end

class OpenSSL::X509::Certificate
  include ::OpenSSL::Marshal
  include ::OpenSSL::X509::Extension::Helpers
  include ::OpenSSL::X509::Extension::SubjectKeyIdentifier
  include ::OpenSSL::X509::Extension::AuthorityKeyIdentifier
  include ::OpenSSL::X509::Extension::CRLDistributionPoints
  include ::OpenSSL::X509::Extension::AuthorityInfoAccess
  extend ::OpenSSL::Marshal::ClassMethods
  def initialize(*_arg0); end
  def ==(_arg0); end
  def add_extension(_arg0); end
  def check_private_key(_arg0); end
  def extensions; end
  def extensions=(_arg0); end
  def inspect; end
  def issuer; end
  def issuer=(_arg0); end
  def not_after; end
  def not_after=(_arg0); end
  def not_before; end
  def not_before=(_arg0); end
  def pretty_print(q); end
  def public_key; end
  def public_key=(_arg0); end
  def serial; end
  def serial=(_arg0); end
  def sign(_arg0, _arg1); end
  def signature_algorithm; end
  def subject; end
  def subject=(_arg0); end
  def to_der; end
  def to_pem; end
  def to_s; end
  def to_text; end
  def verify(_arg0); end
  def version; end
  def version=(_arg0); end
  private def initialize_copy(_arg0); end
end

class OpenSSL::X509::CertificateError < ::OpenSSL::OpenSSLError; end
OpenSSL::X509::DEFAULT_CERT_AREA = T.let(T.unsafe(nil), String)
OpenSSL::X509::DEFAULT_CERT_DIR = T.let(T.unsafe(nil), String)
OpenSSL::X509::DEFAULT_CERT_DIR_ENV = T.let(T.unsafe(nil), String)
OpenSSL::X509::DEFAULT_CERT_FILE = T.let(T.unsafe(nil), String)
OpenSSL::X509::DEFAULT_CERT_FILE_ENV = T.let(T.unsafe(nil), String)
OpenSSL::X509::DEFAULT_PRIVATE_DIR = T.let(T.unsafe(nil), String)

class OpenSSL::X509::Extension
  include ::OpenSSL::Marshal
  extend ::OpenSSL::Marshal::ClassMethods
  def initialize(*_arg0); end
  def ==(other); end
  def critical=(_arg0); end
  def critical?; end
  def oid; end
  def oid=(_arg0); end
  def to_a; end
  def to_der; end
  def to_h; end
  def to_s; end
  def value; end
  def value=(_arg0); end
  def value_der; end
  private def initialize_copy(_arg0); end
end

class OpenSSL::X509::ExtensionError < ::OpenSSL::OpenSSLError; end

class OpenSSL::X509::ExtensionFactory
  def initialize(*_arg0); end
  def config; end
  def config=(_arg0); end
  def create_ext(*_arg0); end
  def create_ext_from_array(ary); end
  def create_ext_from_hash(hash); end
  def create_ext_from_string(str); end
  def create_extension(*arg); end
  def crl; end
  def crl=(_arg0); end
  def issuer_certificate; end
  def issuer_certificate=(_arg0); end
  def subject_certificate; end
  def subject_certificate=(_arg0); end
  def subject_request; end
  def subject_request=(_arg0); end
end

class OpenSSL::X509::Name
  include ::Comparable
  include ::OpenSSL::Marshal
  extend ::OpenSSL::Marshal::ClassMethods
  def initialize(*_arg0); end
  def <=>(_arg0); end
  def add_entry(*_arg0); end
  def cmp(_arg0); end
  def eql?(_arg0); end
  def hash; end
  def hash_old; end
  def inspect; end
  def pretty_print(q); end
  def to_a; end
  def to_der; end
  def to_s(*_arg0); end
  def to_utf8; end
  private def initialize_copy(_arg0); end
  def self.parse(str, template = T.unsafe(nil)); end
  def self.parse_openssl(str, template = T.unsafe(nil)); end
  def self.parse_rfc2253(str, template = T.unsafe(nil)); end
end

class OpenSSL::X509::NameError < ::OpenSSL::OpenSSLError; end
OpenSSL::X509::PURPOSE_ANY = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::PURPOSE_CRL_SIGN = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::PURPOSE_NS_SSL_SERVER = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::PURPOSE_OCSP_HELPER = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::PURPOSE_SMIME_ENCRYPT = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::PURPOSE_SMIME_SIGN = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::PURPOSE_SSL_CLIENT = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::PURPOSE_SSL_SERVER = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::PURPOSE_TIMESTAMP_SIGN = T.let(T.unsafe(nil), Integer)

class OpenSSL::X509::Request
  include ::OpenSSL::Marshal
  extend ::OpenSSL::Marshal::ClassMethods
  def initialize(*_arg0); end
  def ==(other); end
  def add_attribute(_arg0); end
  def attributes; end
  def attributes=(_arg0); end
  def public_key; end
  def public_key=(_arg0); end
  def sign(_arg0, _arg1); end
  def signature_algorithm; end
  def subject; end
  def subject=(_arg0); end
  def to_der; end
  def to_pem; end
  def to_s; end
  def to_text; end
  def verify(_arg0); end
  def version; end
  def version=(_arg0); end
  private def initialize_copy(_arg0); end
end

class OpenSSL::X509::RequestError < ::OpenSSL::OpenSSLError; end

class OpenSSL::X509::Revoked
  def initialize(*_arg0); end
  def ==(other); end
  def add_extension(_arg0); end
  def extensions; end
  def extensions=(_arg0); end
  def serial; end
  def serial=(_arg0); end
  def time; end
  def time=(_arg0); end
  def to_der; end
  private def initialize_copy(_arg0); end
end

class OpenSSL::X509::RevokedError < ::OpenSSL::OpenSSLError; end

class OpenSSL::X509::Store
  def initialize(*_arg0); end
  def add_cert(_arg0); end
  def add_crl(_arg0); end
  def add_file(_arg0); end
  def add_path(_arg0); end
  def chain; end
  def error; end
  def error_string; end
  def flags=(_arg0); end
  def purpose=(_arg0); end
  def set_default_paths; end
  def time=(_arg0); end
  def trust=(_arg0); end
  def verify(*_arg0); end
  def verify_callback; end
  def verify_callback=(_arg0); end
end

class OpenSSL::X509::StoreContext
  def initialize(*_arg0); end
  def chain; end
  def cleanup; end
  def current_cert; end
  def current_crl; end
  def error; end
  def error=(_arg0); end
  def error_depth; end
  def error_string; end
  def flags=(_arg0); end
  def purpose=(_arg0); end
  def time=(_arg0); end
  def trust=(_arg0); end
  def verify; end
end

class OpenSSL::X509::StoreError < ::OpenSSL::OpenSSLError; end
OpenSSL::X509::TRUST_COMPAT = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::TRUST_EMAIL = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::TRUST_OBJECT_SIGN = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::TRUST_OCSP_REQUEST = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::TRUST_OCSP_SIGN = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::TRUST_SSL_CLIENT = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::TRUST_SSL_SERVER = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::TRUST_TSA = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_AKID_ISSUER_SERIAL_MISMATCH = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_AKID_SKID_MISMATCH = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_APPLICATION_VERIFICATION = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_CA_KEY_TOO_SMALL = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_CA_MD_TOO_WEAK = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_CERT_CHAIN_TOO_LONG = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_CERT_HAS_EXPIRED = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_CERT_NOT_YET_VALID = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_CERT_REJECTED = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_CERT_REVOKED = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_CERT_SIGNATURE_FAILURE = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_CERT_UNTRUSTED = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_CRL_HAS_EXPIRED = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_CRL_NOT_YET_VALID = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_CRL_PATH_VALIDATION_ERROR = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_CRL_SIGNATURE_FAILURE = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_DANE_NO_MATCH = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_DIFFERENT_CRL_SCOPE = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_EE_KEY_TOO_SMALL = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_EMAIL_MISMATCH = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_EXCLUDED_VIOLATION = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_HOSTNAME_MISMATCH = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_INVALID_CA = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_INVALID_CALL = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_INVALID_EXTENSION = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_INVALID_NON_CA = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_INVALID_POLICY_EXTENSION = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_INVALID_PURPOSE = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_IP_ADDRESS_MISMATCH = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_KEYUSAGE_NO_CERTSIGN = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_KEYUSAGE_NO_CRL_SIGN = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_NO_EXPLICIT_POLICY = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_NO_VALID_SCTS = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_OCSP_CERT_UNKNOWN = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_OCSP_VERIFY_FAILED = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_OCSP_VERIFY_NEEDED = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_OUT_OF_MEM = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_PATH_LENGTH_EXCEEDED = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_PATH_LOOP = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_PERMITTED_VIOLATION = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_PROXY_PATH_LENGTH_EXCEEDED = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_PROXY_SUBJECT_NAME_VIOLATION = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_SELF_SIGNED_CERT_IN_CHAIN = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_STORE_LOOKUP = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_SUBJECT_ISSUER_MISMATCH = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_SUBTREE_MINMAX = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256 = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_SUITE_B_INVALID_ALGORITHM = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_SUITE_B_INVALID_CURVE = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_SUITE_B_INVALID_VERSION = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_SUITE_B_LOS_NOT_ALLOWED = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_UNABLE_TO_GET_CRL = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_UNABLE_TO_GET_CRL_ISSUER = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_UNABLE_TO_GET_ISSUER_CERT = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_UNHANDLED_CRITICAL_EXTENSION = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_UNNESTED_RESOURCE = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_UNSPECIFIED = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_UNSUPPORTED_CONSTRAINT_TYPE = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_UNSUPPORTED_EXTENSION_FEATURE = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_ERR_UNSUPPORTED_NAME_SYNTAX = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_ALLOW_PROXY_CERTS = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_CHECK_SS_SIGNATURE = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_CRL_CHECK = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_CRL_CHECK_ALL = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_EXPLICIT_POLICY = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_EXTENDED_CRL_SUPPORT = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_IGNORE_CRITICAL = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_INHIBIT_ANY = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_INHIBIT_MAP = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_NOTIFY_POLICY = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_NO_ALT_CHAINS = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_NO_CHECK_TIME = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_PARTIAL_CHAIN = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_POLICY_CHECK = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_SUITEB_128_LOS = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_SUITEB_128_LOS_ONLY = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_SUITEB_192_LOS = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_TRUSTED_FIRST = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_USE_CHECK_TIME = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_USE_DELTAS = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_FLAG_X509_STRICT = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::V_OK = T.let(T.unsafe(nil), Integer)
module File::Constants; end

module MonitorMixin
  def initialize(*_arg0, &_arg1); end
  def mon_enter; end
  def mon_exit; end
  def mon_locked?; end
  def mon_owned?; end
  def mon_synchronize(&b); end
  def mon_try_enter; end
  def new_cond; end
  def synchronize(&b); end
  def try_mon_enter; end
  private def mon_check_owner; end
  private def mon_initialize; end
  def self.extend_object(obj); end
end

URI::RFC2396_REGEXP::PATTERN::ABS_PATH = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::ABS_URI = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::ALNUM = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::ALPHA = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::DOMLABEL = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::ESCAPED = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::FRAGMENT = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::HEX = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::HIER_PART = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::HOST = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::HOSTNAME = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::HOSTPORT = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::IPV4ADDR = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::IPV6ADDR = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::IPV6REF = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::NET_PATH = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::OPAQUE_PART = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::PATH_SEGMENTS = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::PORT = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::QUERY = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::REG_NAME = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::REL_PATH = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::REL_SEGMENT = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::REL_URI = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::RESERVED = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::SCHEME = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::TOPLABEL = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::UNRESERVED = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::URIC = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::URIC_NO_SLASH = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::URI_REF = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::USERINFO = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::X_ABS_URI = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::X_REL_URI = T.let(T.unsafe(nil), String)
class Errno::EAGAIN < ::SystemCallError; end
class Errno::EINPROGRESS < ::SystemCallError; end
Net::HTTP::Copy::METHOD = T.let(T.unsafe(nil), String)
Net::HTTP::Copy::RESPONSE_HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTP::Delete::METHOD = T.let(T.unsafe(nil), String)
Net::HTTP::Delete::RESPONSE_HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTP::Get::METHOD = T.let(T.unsafe(nil), String)
Net::HTTP::Get::RESPONSE_HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTP::Head::METHOD = T.let(T.unsafe(nil), String)
Net::HTTP::Lock::METHOD = T.let(T.unsafe(nil), String)
Net::HTTP::Lock::REQUEST_HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTP::Lock::RESPONSE_HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTP::Mkcol::METHOD = T.let(T.unsafe(nil), String)
Net::HTTP::Mkcol::REQUEST_HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTP::Mkcol::RESPONSE_HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTP::Move::METHOD = T.let(T.unsafe(nil), String)
Net::HTTP::Move::RESPONSE_HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTP::Options::METHOD = T.let(T.unsafe(nil), String)
Net::HTTP::Options::RESPONSE_HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTP::Patch::METHOD = T.let(T.unsafe(nil), String)
Net::HTTP::Patch::REQUEST_HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTP::Patch::RESPONSE_HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTP::Post::METHOD = T.let(T.unsafe(nil), String)
Net::HTTP::Post::REQUEST_HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTP::Post::RESPONSE_HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTP::Propfind::METHOD = T.let(T.unsafe(nil), String)
Net::HTTP::Propfind::REQUEST_HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTP::Propfind::RESPONSE_HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTP::Proppatch::METHOD = T.let(T.unsafe(nil), String)
Net::HTTP::Proppatch::REQUEST_HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTP::Proppatch::RESPONSE_HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTP::Put::METHOD = T.let(T.unsafe(nil), String)
Net::HTTP::Put::REQUEST_HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTP::Put::RESPONSE_HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTP::Trace::METHOD = T.let(T.unsafe(nil), String)
Net::HTTP::Trace::RESPONSE_HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTP::Unlock::METHOD = T.let(T.unsafe(nil), String)
Net::HTTP::Unlock::REQUEST_HAS_BODY = T.let(T.unsafe(nil), TrueClass)
Net::HTTP::Unlock::RESPONSE_HAS_BODY = T.let(T.unsafe(nil), TrueClass)

class Struct
  include ::Enumerable
  def initialize(*_arg0); end
  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def deconstruct; end
  def deconstruct_keys(_arg0); end
  def dig(*_arg0); end
  def each; end
  def each_pair; end
  def eql?(_arg0); end
  def filter(*_arg0); end
  def hash; end
  def inspect; end
  def length; end
  def members; end
  def select(*_arg0); end
  def size; end
  def to_a; end
  def to_h; end
  def to_s; end
  def values; end
  def values_at(*_arg0); end
  private def initialize_copy(_arg0); end
  def self.new(*_arg0); end
end

Net::IMAP::DigestMD5Authenticator::STAGE_ONE = T.let(T.unsafe(nil), Symbol)
Net::IMAP::DigestMD5Authenticator::STAGE_TWO = T.let(T.unsafe(nil), Symbol)
Net::IMAP::LoginAuthenticator::STATE_PASSWORD = T.let(T.unsafe(nil), Symbol)
Net::IMAP::LoginAuthenticator::STATE_USER = T.let(T.unsafe(nil), Symbol)
Net::IMAP::PlainAuthenticator::NULL = T.let(T.unsafe(nil), String)
Net::IMAP::ResponseParser::ADDRESS_REGEXP = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::ASTRING_CHARS_TOKENS = T.let(T.unsafe(nil), Array)
Net::IMAP::ResponseParser::ATOM_TOKENS = T.let(T.unsafe(nil), Array)
Net::IMAP::ResponseParser::BEG_REGEXP = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::CTEXT_REGEXP = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::DATA_REGEXP = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::EXPR_BEG = T.let(T.unsafe(nil), Symbol)
Net::IMAP::ResponseParser::EXPR_CTEXT = T.let(T.unsafe(nil), Symbol)
Net::IMAP::ResponseParser::EXPR_DATA = T.let(T.unsafe(nil), Symbol)
Net::IMAP::ResponseParser::EXPR_RTEXT = T.let(T.unsafe(nil), Symbol)
Net::IMAP::ResponseParser::EXPR_TEXT = T.let(T.unsafe(nil), Symbol)
Net::IMAP::ResponseParser::FLAG_REGEXP = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::RTEXT_REGEXP = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::SPACES_REGEXP = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::STRING_TOKENS = T.let(T.unsafe(nil), Array)
Net::IMAP::ResponseParser::TEXT_REGEXP = T.let(T.unsafe(nil), Regexp)
Net::IMAP::ResponseParser::T_ATOM = T.let(T.unsafe(nil), Symbol)
Net::IMAP::ResponseParser::T_BSLASH = T.let(T.unsafe(nil), Symbol)
Net::IMAP::ResponseParser::T_CRLF = T.let(T.unsafe(nil), Symbol)
Net::IMAP::ResponseParser::T_EOF = T.let(T.unsafe(nil), Symbol)
Net::IMAP::ResponseParser::T_LBRA = T.let(T.unsafe(nil), Symbol)
Net::IMAP::ResponseParser::T_LITERAL = T.let(T.unsafe(nil), Symbol)
Net::IMAP::ResponseParser::T_LPAR = T.let(T.unsafe(nil), Symbol)
Net::IMAP::ResponseParser::T_NIL = T.let(T.unsafe(nil), Symbol)
Net::IMAP::ResponseParser::T_NUMBER = T.let(T.unsafe(nil), Symbol)
Net::IMAP::ResponseParser::T_PERCENT = T.let(T.unsafe(nil), Symbol)
Net::IMAP::ResponseParser::T_PLUS = T.let(T.unsafe(nil), Symbol)
Net::IMAP::ResponseParser::T_QUOTED = T.let(T.unsafe(nil), Symbol)
Net::IMAP::ResponseParser::T_RBRA = T.let(T.unsafe(nil), Symbol)
Net::IMAP::ResponseParser::T_RPAR = T.let(T.unsafe(nil), Symbol)
Net::IMAP::ResponseParser::T_SPACE = T.let(T.unsafe(nil), Symbol)
Net::IMAP::ResponseParser::T_STAR = T.let(T.unsafe(nil), Symbol)
Net::IMAP::ResponseParser::T_TEXT = T.let(T.unsafe(nil), Symbol)

class Net::IMAP::ResponseParser::Token < ::Struct
  def symbol; end
  def symbol=(_); end
  def value; end
  def value=(_); end
  def self.[](*_arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*_arg0); end
end

Net::IMAP::StringFormatter::LITERAL_REGEX = T.let(T.unsafe(nil), Regexp)

class String
  include ::Comparable
  include ::JSON::Ext::Generator::GeneratorMethods::String
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend
  def initialize(*_arg0); end
  def %(_arg0); end
  def *(_arg0); end
  def +(_arg0); end
  def +@; end
  def -@; end
  def <<(_arg0); end
  def <=>(_arg0); end
  def ==(_arg0); end
  def ===(_arg0); end
  def =~(_arg0); end
  def [](*_arg0); end
  def []=(*_arg0); end
  def ascii_only?; end
  def b; end
  def bytes; end
  def bytesize; end
  def byteslice(*_arg0); end
  def capitalize(*_arg0); end
  def capitalize!(*_arg0); end
  def casecmp(_arg0); end
  def casecmp?(_arg0); end
  def center(*_arg0); end
  def chars; end
  def chomp(*_arg0); end
  def chomp!(*_arg0); end
  def chop; end
  def chop!; end
  def chr; end
  def clear; end
  def codepoints; end
  def concat(*_arg0); end
  def count(*_arg0); end
  def crypt(_arg0); end
  def delete(*_arg0); end
  def delete!(*_arg0); end
  def delete_prefix(_arg0); end
  def delete_prefix!(_arg0); end
  def delete_suffix(_arg0); end
  def delete_suffix!(_arg0); end
  def downcase(*_arg0); end
  def downcase!(*_arg0); end
  def dump; end
  def each_byte; end
  def each_char; end
  def each_codepoint; end
  def each_grapheme_cluster; end
  def each_line(*_arg0); end
  def empty?; end
  def encode(*_arg0); end
  def encode!(*_arg0); end
  def encoding; end
  def end_with?(*_arg0); end
  def eql?(_arg0); end
  def force_encoding(_arg0); end
  def freeze; end
  def funcall_style; end
  def getbyte(_arg0); end
  def grapheme_clusters; end
  def gsub(*_arg0); end
  def gsub!(*_arg0); end
  def hash; end
  def hex; end
  def include?(_arg0); end
  def index(*_arg0); end
  def insert(_arg0, _arg1); end
  def inspect; end
  def intern; end
  def iseuc; end
  def isjis; end
  def issjis; end
  def isutf8; end
  def kconv(to_enc, from_enc = T.unsafe(nil)); end
  def length; end
  def lines(*_arg0); end
  def ljust(*_arg0); end
  def lstrip; end
  def lstrip!; end
  def match(*_arg0); end
  def match?(*_arg0); end
  def next; end
  def next!; end
  def oct; end
  def ord; end
  def partition(_arg0); end
  def prepend(*_arg0); end
  def quote; end
  def replace(_arg0); end
  def reverse; end
  def reverse!; end
  def rindex(*_arg0); end
  def rjust(*_arg0); end
  def rpartition(_arg0); end
  def rstrip; end
  def rstrip!; end
  def sans_arguments; end
  def scan(_arg0); end
  def scrub(*_arg0); end
  def scrub!(*_arg0); end
  def setbyte(_arg0, _arg1); end
  def shell_split; end
  def shellescape; end
  def shellsplit; end
  def size; end
  def slice(*_arg0); end
  def slice!(*_arg0); end
  def split(*_arg0); end
  def squeeze(*_arg0); end
  def squeeze!(*_arg0); end
  def start_with?(*_arg0); end
  def strip; end
  def strip!; end
  def sub(*_arg0); end
  def sub!(*_arg0); end
  def succ; end
  def succ!; end
  def sum(*_arg0); end
  def swapcase(*_arg0); end
  def swapcase!(*_arg0); end
  def to_c; end
  def to_d; end
  def to_f; end
  def to_i(*_arg0); end
  def to_r; end
  def to_s; end
  def to_str; end
  def to_sym; end
  def toeuc; end
  def tojis; end
  def tolocale; end
  def tosjis; end
  def toutf16; end
  def toutf32; end
  def toutf8; end
  def tr(_arg0, _arg1); end
  def tr!(_arg0, _arg1); end
  def tr_cpp; end
  def tr_s(_arg0, _arg1); end
  def tr_s!(_arg0, _arg1); end
  def undump; end
  def unicode_normalize(*_arg0); end
  def unicode_normalize!(*_arg0); end
  def unicode_normalized?(*_arg0); end
  def unpack(fmt); end
  def unpack1(fmt); end
  def unspace; end
  def upcase(*_arg0); end
  def upcase!(*_arg0); end
  def upto(*_arg0); end
  def valid_encoding?; end
  private def initialize_copy(_arg0); end
  def self.try_convert(_arg0); end
end

OpenSSL::Buffering::Buffer::BINARY = T.let(T.unsafe(nil), Encoding)
OpenSSL::PKey::EC::EXPLICIT_CURVE = T.let(T.unsafe(nil), Integer)

class OpenSSL::PKey::EC::Group
  def initialize(*_arg0); end
  def ==(_arg0); end
  def asn1_flag; end
  def asn1_flag=(_arg0); end
  def cofactor; end
  def curve_name; end
  def degree; end
  def eql?(_arg0); end
  def generator; end
  def order; end
  def point_conversion_form; end
  def point_conversion_form=(_arg0); end
  def seed; end
  def seed=(_arg0); end
  def set_generator(_arg0, _arg1, _arg2); end
  def to_der; end
  def to_pem; end
  def to_text; end
  private def initialize_copy(_arg0); end
end

OpenSSL::PKey::EC::NAMED_CURVE = T.let(T.unsafe(nil), Integer)

class OpenSSL::PKey::EC::Point
  def initialize(*_arg0); end
  def ==(_arg0); end
  def add(_arg0); end
  def eql?(_arg0); end
  def group; end
  def infinity?; end
  def invert!; end
  def make_affine!; end
  def mul(*_arg0); end
  def on_curve?; end
  def set_to_infinity!; end
  def to_bn(conversion_form = T.unsafe(nil)); end
  def to_octet_string(_arg0); end
  private def initialize_copy(_arg0); end
end

OpenSSL::PKey::RSA::NO_PADDING = T.let(T.unsafe(nil), Integer)
OpenSSL::PKey::RSA::PKCS1_OAEP_PADDING = T.let(T.unsafe(nil), Integer)
OpenSSL::PKey::RSA::PKCS1_PADDING = T.let(T.unsafe(nil), Integer)
OpenSSL::PKey::RSA::SSLV23_PADDING = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::SSLContext::DEFAULT_CERT_STORE = T.let(T.unsafe(nil), OpenSSL::X509::Store)
OpenSSL::SSL::SSLContext::DEFAULT_PARAMS = T.let(T.unsafe(nil), Hash)
OpenSSL::SSL::SSLContext::DEFAULT_TMP_DH_CALLBACK = T.let(T.unsafe(nil), Proc)
OpenSSL::SSL::SSLContext::METHODS = T.let(T.unsafe(nil), Array)
OpenSSL::SSL::SSLContext::SESSION_CACHE_BOTH = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::SSLContext::SESSION_CACHE_CLIENT = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::SSLContext::SESSION_CACHE_NO_AUTO_CLEAR = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::SSLContext::SESSION_CACHE_NO_INTERNAL = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::SSLContext::SESSION_CACHE_NO_INTERNAL_LOOKUP = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::SSLContext::SESSION_CACHE_NO_INTERNAL_STORE = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::SSLContext::SESSION_CACHE_OFF = T.let(T.unsafe(nil), Integer)
OpenSSL::SSL::SSLContext::SESSION_CACHE_SERVER = T.let(T.unsafe(nil), Integer)
class OpenSSL::SSL::Session::SessionError < ::OpenSSL::OpenSSLError; end
OpenSSL::Timestamp::Response::GRANTED = T.let(T.unsafe(nil), Integer)
OpenSSL::Timestamp::Response::GRANTED_WITH_MODS = T.let(T.unsafe(nil), Integer)
OpenSSL::Timestamp::Response::REJECTION = T.let(T.unsafe(nil), Integer)
OpenSSL::Timestamp::Response::REVOCATION_NOTIFICATION = T.let(T.unsafe(nil), Integer)
OpenSSL::Timestamp::Response::REVOCATION_WARNING = T.let(T.unsafe(nil), Integer)
OpenSSL::Timestamp::Response::WAITING = T.let(T.unsafe(nil), Integer)

module OpenSSL::X509::Extension::AuthorityInfoAccess
  include ::OpenSSL::X509::Extension::Helpers
  def ca_issuer_uris; end
  def ocsp_uris; end
  private def parse_aia_asn1; end
end

module OpenSSL::X509::Extension::AuthorityKeyIdentifier
  include ::OpenSSL::X509::Extension::Helpers
  def authority_key_identifier; end
end

module OpenSSL::X509::Extension::CRLDistributionPoints
  include ::OpenSSL::X509::Extension::Helpers
  def crl_uris; end
end

module OpenSSL::X509::Extension::Helpers
  def find_extension(oid); end
end

module OpenSSL::X509::Extension::SubjectKeyIdentifier
  include ::OpenSSL::X509::Extension::Helpers
  def subject_key_identifier; end
end

OpenSSL::X509::Name::COMPAT = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::Name::DEFAULT_OBJECT_TYPE = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::Name::MULTILINE = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::Name::OBJECT_TYPE_TEMPLATE = T.let(T.unsafe(nil), Hash)
OpenSSL::X509::Name::ONELINE = T.let(T.unsafe(nil), Integer)
OpenSSL::X509::Name::RFC2253 = T.let(T.unsafe(nil), Integer)

module OpenSSL::X509::Name::RFC2253DN
  private def expand_hexstring(str); end
  private def expand_pair(str); end
  private def expand_value(str1, str2, str3); end
  private def scan(dn); end
  def self.expand_hexstring(str); end
  def self.expand_pair(str); end
  def self.expand_value(str1, str2, str3); end
  def self.scan(dn); end
end

File::Constants::APPEND = T.let(T.unsafe(nil), Integer)
File::Constants::BINARY = T.let(T.unsafe(nil), Integer)
File::Constants::CREAT = T.let(T.unsafe(nil), Integer)
File::Constants::DSYNC = T.let(T.unsafe(nil), Integer)
File::Constants::EXCL = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_CASEFOLD = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_DOTMATCH = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_EXTGLOB = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_NOESCAPE = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_PATHNAME = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_SHORTNAME = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_SYSCASE = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_EX = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_NB = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_SH = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_UN = T.let(T.unsafe(nil), Integer)
File::Constants::NOCTTY = T.let(T.unsafe(nil), Integer)
File::Constants::NOFOLLOW = T.let(T.unsafe(nil), Integer)
File::Constants::NONBLOCK = T.let(T.unsafe(nil), Integer)
File::Constants::NULL = T.let(T.unsafe(nil), String)
File::Constants::RDONLY = T.let(T.unsafe(nil), Integer)
File::Constants::RDWR = T.let(T.unsafe(nil), Integer)
File::Constants::SHARE_DELETE = T.let(T.unsafe(nil), Integer)
File::Constants::SYNC = T.let(T.unsafe(nil), Integer)
File::Constants::TRUNC = T.let(T.unsafe(nil), Integer)
File::Constants::WRONLY = T.let(T.unsafe(nil), Integer)

class MonitorMixin::ConditionVariable
  def initialize(monitor); end
  def broadcast; end
  def signal; end
  def wait(timeout = T.unsafe(nil)); end
  def wait_until; end
  def wait_while; end
end

class SystemCallError < ::StandardError
  def initialize(*_arg0); end
  def errno; end
  def self.===(_arg0); end
end

Errno::EAGAIN::Errno = T.let(T.unsafe(nil), Integer)
Errno::EINPROGRESS::Errno = T.let(T.unsafe(nil), Integer)
Struct::Group = Etc::Group
Struct::Passwd = Etc::Passwd
class OpenSSL::PKey::EC::Group::Error < ::OpenSSL::OpenSSLError; end
class OpenSSL::PKey::EC::Point::Error < ::OpenSSL::OpenSSLError; end
OpenSSL::X509::Name::RFC2253DN::AttributeType = T.let(T.unsafe(nil), Regexp)
OpenSSL::X509::Name::RFC2253DN::AttributeValue = T.let(T.unsafe(nil), Regexp)
OpenSSL::X509::Name::RFC2253DN::HexChar = T.let(T.unsafe(nil), Regexp)
OpenSSL::X509::Name::RFC2253DN::HexPair = T.let(T.unsafe(nil), Regexp)
OpenSSL::X509::Name::RFC2253DN::HexString = T.let(T.unsafe(nil), Regexp)
OpenSSL::X509::Name::RFC2253DN::Pair = T.let(T.unsafe(nil), Regexp)
OpenSSL::X509::Name::RFC2253DN::QuoteChar = T.let(T.unsafe(nil), Regexp)
OpenSSL::X509::Name::RFC2253DN::Special = T.let(T.unsafe(nil), String)
OpenSSL::X509::Name::RFC2253DN::StringChar = T.let(T.unsafe(nil), Regexp)
OpenSSL::X509::Name::RFC2253DN::TypeAndValue = T.let(T.unsafe(nil), Regexp)

module JSON::Ext::Generator::GeneratorMethods::String
  mixes_in_class_methods ::JSON::Ext::Generator::GeneratorMethods::String::Extend
  def to_json(*_arg0); end
  def to_json_raw(*_arg0); end
  def to_json_raw_object; end
  def self.included(_arg0); end
end

module JSON::Ext::Generator::GeneratorMethods::String::Extend
  def json_create(_arg0); end
end
module Observable
  def add_observer(observer, func = T.unsafe(nil)); end
  def changed(state = T.unsafe(nil)); end
  def changed?; end
  def count_observers; end
  def delete_observer(observer); end
  def delete_observers; end
  def notify_observers(*arg); end
end

Observable::VERSION = T.let(T.unsafe(nil), String)
module URI
  include ::URI::RFC2396_REGEXP
  def self.decode_www_form(str, enc = T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end
  def self.decode_www_form_component(str, enc = T.unsafe(nil)); end
  def self.encode_www_form(enum, enc = T.unsafe(nil)); end
  def self.encode_www_form_component(str, enc = T.unsafe(nil)); end
  def self.extract(str, schemes = T.unsafe(nil), &block); end
  def self.for(scheme, *arguments, default: T.unsafe(nil)); end
  def self.get_encoding(label); end
  def self.join(*str); end
  def self.open(name, *rest, &block); end
  def self.parse(uri); end
  def self.regexp(schemes = T.unsafe(nil)); end
  def self.scheme_list; end
  def self.split(uri); end
end

class Date
  include ::Comparable
  def initialize(*_arg0); end
  def +(_arg0); end
  def -(_arg0); end
  def <<(_arg0); end
  def <=>(_arg0); end
  def ===(_arg0); end
  def >>(_arg0); end
  def ajd; end
  def amjd; end
  def asctime; end
  def ctime; end
  def cwday; end
  def cweek; end
  def cwyear; end
  def day; end
  def day_fraction; end
  def downto(_arg0); end
  def england; end
  def eql?(_arg0); end
  def friday?; end
  def gregorian; end
  def gregorian?; end
  def hash; end
  def httpdate; end
  def infinite?; end
  def inspect; end
  def iso8601; end
  def italy; end
  def jd; end
  def jisx0301; end
  def julian; end
  def julian?; end
  def ld; end
  def leap?; end
  def marshal_dump; end
  def marshal_load(_arg0); end
  def mday; end
  def mjd; end
  def mon; end
  def monday?; end
  def month; end
  def new_start(*_arg0); end
  def next; end
  def next_day(*_arg0); end
  def next_month(*_arg0); end
  def next_year(*_arg0); end
  def prev_day(*_arg0); end
  def prev_month(*_arg0); end
  def prev_year(*_arg0); end
  def rfc2822; end
  def rfc3339; end
  def rfc822; end
  def saturday?; end
  def start; end
  def step(*_arg0); end
  def strftime(*_arg0); end
  def succ; end
  def sunday?; end
  def thursday?; end
  def to_date; end
  def to_datetime; end
  def to_s; end
  def to_time; end
  def tuesday?; end
  def upto(_arg0); end
  def wday; end
  def wednesday?; end
  def xmlschema; end
  def yday; end
  def year; end
  private def hour; end
  private def initialize_copy(_arg0); end
  private def min; end
  private def minute; end
  private def sec; end
  private def second; end
  def self._httpdate(_arg0); end
  def self._iso8601(_arg0); end
  def self._jisx0301(_arg0); end
  def self._load(_arg0); end
  def self._parse(*_arg0); end
  def self._rfc2822(_arg0); end
  def self._rfc3339(_arg0); end
  def self._rfc822(_arg0); end
  def self._strptime(*_arg0); end
  def self._xmlschema(_arg0); end
  def self.civil(*_arg0); end
  def self.commercial(*_arg0); end
  def self.gregorian_leap?(_arg0); end
  def self.httpdate(*_arg0); end
  def self.iso8601(*_arg0); end
  def self.jd(*_arg0); end
  def self.jisx0301(*_arg0); end
  def self.julian_leap?(_arg0); end
  def self.leap?(_arg0); end
  def self.ordinal(*_arg0); end
  def self.parse(*_arg0); end
  def self.rfc2822(*_arg0); end
  def self.rfc3339(*_arg0); end
  def self.rfc822(*_arg0); end
  def self.strptime(*_arg0); end
  def self.today(*_arg0); end
  def self.valid_civil?(*_arg0); end
  def self.valid_commercial?(*_arg0); end
  def self.valid_date?(*_arg0); end
  def self.valid_jd?(*_arg0); end
  def self.valid_ordinal?(*_arg0); end
  def self.xmlschema(*_arg0); end
end

class DateTime < ::Date
  def hour; end
  def iso8601(*_arg0); end
  def jisx0301(*_arg0); end
  def min; end
  def minute; end
  def new_offset(*_arg0); end
  def offset; end
  def rfc3339(*_arg0); end
  def sec; end
  def sec_fraction; end
  def second; end
  def second_fraction; end
  def strftime(*_arg0); end
  def to_date; end
  def to_datetime; end
  def to_s; end
  def to_time; end
  def xmlschema(*_arg0); end
  def zone; end
  def self._strptime(*_arg0); end
  def self.civil(*_arg0); end
  def self.commercial(*_arg0); end
  def self.httpdate(*_arg0); end
  def self.iso8601(*_arg0); end
  def self.jd(*_arg0); end
  def self.jisx0301(*_arg0); end
  def self.new(*_arg0); end
  def self.now(*_arg0); end
  def self.ordinal(*_arg0); end
  def self.parse(*_arg0); end
  def self.rfc2822(*_arg0); end
  def self.rfc3339(*_arg0); end
  def self.rfc822(*_arg0); end
  def self.strptime(*_arg0); end
  def self.xmlschema(*_arg0); end
end

class IPSocket < ::BasicSocket
  def addr(*_arg0); end
  def inspect; end
  def peeraddr(*_arg0); end
  def recvfrom(*_arg0); end
  def self.getaddress(_arg0); end
end

module OpenURI
  def self.check_options(options); end
  def self.open_http(buf, target, proxy, options); end
  def self.open_loop(uri, options); end
  def self.open_uri(name, *rest); end
  def self.redirectable?(uri1, uri2); end
  def self.scan_open_optional_arguments(*rest); end
end

class IPAddr
  include ::Comparable
  def initialize(addr = T.unsafe(nil), family = T.unsafe(nil)); end
  def &(other); end
  def <<(num); end
  def <=>(other); end
  def ==(other); end
  def ===(other); end
  def >>(num); end
  def eql?(other); end
  def family; end
  def hash; end
  def hton; end
  def include?(other); end
  def inspect; end
  def ip6_arpa; end
  def ip6_int; end
  def ipv4?; end
  def ipv4_compat; end
  def ipv4_compat?; end
  def ipv4_mapped; end
  def ipv4_mapped?; end
  def ipv6?; end
  def link_local?; end
  def loopback?; end
  def mask(prefixlen); end
  def native; end
  def prefix; end
  def prefix=(prefix); end
  def private?; end
  def reverse; end
  def succ; end
  def to_i; end
  def to_range; end
  def to_s; end
  def to_string; end
  def |(other); end
  def ~; end
  protected def mask!(mask); end
  protected def set(addr, *family); end
  private def _ipv4_compat?; end
  private def _reverse; end
  private def _to_string(addr); end
  private def addr_mask(addr); end
  private def coerce_other(other); end
  private def in6_addr(left); end
  private def in_addr(addr); end
  def self.new_ntoh(addr); end
  def self.ntop(addr); end
end

class StringIO
  include ::Enumerable
  def initialize(*_arg0); end
  def binmode; end
  def close; end
  def close_read; end
  def close_write; end
  def closed?; end
  def closed_read?; end
  def closed_write?; end
  def each(*_arg0); end
  def each_byte; end
  def each_char; end
  def each_codepoint; end
  def each_line(*_arg0); end
  def eof; end
  def eof?; end
  def external_encoding; end
  def fcntl(*_arg0); end
  def fileno; end
  def flush; end
  def fsync; end
  def getbyte; end
  def getc; end
  def gets(*_arg0); end
  def internal_encoding; end
  def isatty; end
  def length; end
  def lineno; end
  def lineno=(_arg0); end
  def pid; end
  def pos; end
  def pos=(_arg0); end
  def putc(_arg0); end
  def read(*_arg0); end
  def readlines(*_arg0); end
  def reopen(*_arg0); end
  def rewind; end
  def seek(*_arg0); end
  def set_encoding(*_arg0); end
  def set_encoding_by_bom; end
  def size; end
  def string; end
  def string=(_arg0); end
  def sync; end
  def sync=(_arg0); end
  def tell; end
  def truncate(_arg0); end
  def tty?; end
  def ungetbyte(_arg0); end
  def ungetc(_arg0); end
  def write(*_arg0); end
  private def initialize_copy(_arg0); end
  def self.new(*_arg0); end
  def self.open(*_arg0); end
end

URI::ABS_PATH = T.let(T.unsafe(nil), Regexp)
URI::ABS_URI = T.let(T.unsafe(nil), Regexp)
URI::ABS_URI_REF = T.let(T.unsafe(nil), Regexp)
class URI::BadURIError < ::URI::Error; end
URI::DEFAULT_PARSER = T.let(T.unsafe(nil), URI::RFC2396_Parser)
URI::ESCAPED = T.let(T.unsafe(nil), Regexp)
class URI::Error < ::StandardError; end
URI::FRAGMENT = T.let(T.unsafe(nil), Regexp)

class URI::FTP < ::URI::Generic
  include ::OpenURI::OpenRead
  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser = T.unsafe(nil), arg_check = T.unsafe(nil)); end
  def buffer_open(buf, proxy, options); end
  def merge(oth); end
  def path; end
  def to_s; end
  def typecode; end
  def typecode=(typecode); end
  protected def set_path(v); end
  protected def set_typecode(v); end
  private def check_typecode(v); end
  def self.build(args); end
  def self.new2(user, password, host, port, path, typecode = T.unsafe(nil), arg_check = T.unsafe(nil)); end
end

class URI::File < ::URI::Generic
  def check_password(user); end
  def check_user(user); end
  def check_userinfo(user); end
  def set_host(v); end
  def set_password(v); end
  def set_port(v); end
  def set_user(v); end
  def set_userinfo(v); end
  def self.build(args); end
end

class URI::Generic
  include ::URI::RFC2396_REGEXP
  include ::URI
  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser = T.unsafe(nil), arg_check = T.unsafe(nil)); end
  def +(oth); end
  def -(oth); end
  def ==(oth); end
  def absolute; end
  def absolute?; end
  def coerce(oth); end
  def component; end
  def default_port; end
  def eql?(oth); end
  def find_proxy(env = T.unsafe(nil)); end
  def fragment; end
  def fragment=(v); end
  def hash; end
  def hierarchical?; end
  def host; end
  def host=(v); end
  def hostname; end
  def hostname=(v); end
  def inspect; end
  def merge(oth); end
  def merge!(oth); end
  def normalize; end
  def normalize!; end
  def opaque; end
  def opaque=(v); end
  def parser; end
  def password; end
  def password=(password); end
  def path; end
  def path=(v); end
  def port; end
  def port=(v); end
  def query; end
  def query=(v); end
  def registry; end
  def registry=(v); end
  def relative?; end
  def route_from(oth); end
  def route_to(oth); end
  def scheme; end
  def scheme=(v); end
  def select(*components); end
  def to_s; end
  def user; end
  def user=(user); end
  def userinfo; end
  def userinfo=(userinfo); end
  protected def component_ary; end
  protected def set_host(v); end
  protected def set_opaque(v); end
  protected def set_password(v); end
  protected def set_path(v); end
  protected def set_port(v); end
  protected def set_registry(v); end
  protected def set_scheme(v); end
  protected def set_user(v); end
  protected def set_userinfo(user, password = T.unsafe(nil)); end
  private def check_host(v); end
  private def check_opaque(v); end
  private def check_password(v, user = T.unsafe(nil)); end
  private def check_path(v); end
  private def check_port(v); end
  private def check_registry(v); end
  private def check_scheme(v); end
  private def check_user(v); end
  private def check_userinfo(user, password = T.unsafe(nil)); end
  private def escape_userpass(v); end
  private def merge_path(base, rel); end
  private def replace!(oth); end
  private def route_from0(oth); end
  private def route_from_path(src, dst); end
  private def split_path(path); end
  private def split_userinfo(ui); end
  def self.build(args); end
  def self.build2(args); end
  def self.component; end
  def self.default_port; end
  def self.use_proxy?(hostname, addr, port, no_proxy); end
  def self.use_registry; end
end

URI::HOST = T.let(T.unsafe(nil), Regexp)

class URI::HTTP < ::URI::Generic
  include ::OpenURI::OpenRead
  def buffer_open(buf, proxy, options); end
  def request_uri; end
  def self.build(args); end
end

class URI::HTTPS < ::URI::HTTP; end
class URI::InvalidComponentError < ::URI::Error; end
class URI::InvalidURIError < ::URI::Error; end

class URI::LDAP < ::URI::Generic
  def initialize(*arg); end
  def attributes; end
  def attributes=(val); end
  def dn; end
  def dn=(val); end
  def extensions; end
  def extensions=(val); end
  def filter; end
  def filter=(val); end
  def hierarchical?; end
  def scope; end
  def scope=(val); end
  protected def set_attributes(val); end
  protected def set_dn(val); end
  protected def set_extensions(val); end
  protected def set_filter(val); end
  protected def set_scope(val); end
  private def build_path_query; end
  private def parse_dn; end
  private def parse_query; end
  def self.build(args); end
end

class URI::LDAPS < ::URI::LDAP; end

class URI::MailTo < ::URI::Generic
  def initialize(*arg); end
  def headers; end
  def headers=(v); end
  def to; end
  def to=(v); end
  def to_mailtext; end
  def to_rfc822text; end
  def to_s; end
  protected def set_headers(v); end
  protected def set_to(v); end
  private def check_headers(v); end
  private def check_to(v); end
  def self.build(args); end
end

URI::OPAQUE = T.let(T.unsafe(nil), Regexp)
URI::PORT = T.let(T.unsafe(nil), Regexp)
URI::Parser = URI::RFC2396_Parser
URI::QUERY = T.let(T.unsafe(nil), Regexp)
URI::REGEXP = URI::RFC2396_REGEXP
URI::REGISTRY = T.let(T.unsafe(nil), Regexp)
URI::REL_PATH = T.let(T.unsafe(nil), Regexp)
URI::REL_URI = T.let(T.unsafe(nil), Regexp)
URI::REL_URI_REF = T.let(T.unsafe(nil), Regexp)

class URI::RFC2396_Parser
  include ::URI::RFC2396_REGEXP
  def initialize(opts = T.unsafe(nil)); end
  def escape(str, unsafe = T.unsafe(nil)); end
  def extract(str, schemes = T.unsafe(nil)); end
  def inspect; end
  def join(*uris); end
  def make_regexp(schemes = T.unsafe(nil)); end
  def parse(uri); end
  def pattern; end
  def regexp; end
  def split(uri); end
  def unescape(str, escaped = T.unsafe(nil)); end
  private def convert_to_uri(uri); end
  private def initialize_pattern(opts = T.unsafe(nil)); end
  private def initialize_regexp(pattern); end
end

module URI::RFC2396_REGEXP; end
URI::RFC3986_PARSER = T.let(T.unsafe(nil), URI::RFC3986_Parser)

class URI::RFC3986_Parser
  def initialize; end
  def inspect; end
  def join(*uris); end
  def parse(uri); end
  def regexp; end
  def split(uri); end
  private def convert_to_uri(uri); end
  private def default_regexp; end
end

URI::SCHEME = T.let(T.unsafe(nil), Regexp)
URI::TBLDECWWWCOMP_ = T.let(T.unsafe(nil), Hash)
URI::TBLENCWWWCOMP_ = T.let(T.unsafe(nil), Hash)
URI::UNSAFE = T.let(T.unsafe(nil), Regexp)
URI::URI_REF = T.let(T.unsafe(nil), Regexp)
URI::USERINFO = T.let(T.unsafe(nil), Regexp)

module URI::Util
  private def make_components_hash(klass, array_hash); end
  def self.make_components_hash(klass, array_hash); end
end

URI::VERSION = T.let(T.unsafe(nil), String)
URI::VERSION_CODE = T.let(T.unsafe(nil), String)
URI::WEB_ENCODINGS_ = T.let(T.unsafe(nil), Hash)
Date::ABBR_DAYNAMES = T.let(T.unsafe(nil), Array)
Date::ABBR_MONTHNAMES = T.let(T.unsafe(nil), Array)
Date::DAYNAMES = T.let(T.unsafe(nil), Array)
Date::ENGLAND = T.let(T.unsafe(nil), Integer)
class Date::Error < ::ArgumentError; end
Date::GREGORIAN = T.let(T.unsafe(nil), Float)
Date::ITALY = T.let(T.unsafe(nil), Integer)

class Date::Infinity < ::Numeric
  def initialize(d = T.unsafe(nil)); end
  def +@; end
  def -@; end
  def <=>(other); end
  def abs; end
  def coerce(other); end
  def finite?; end
  def infinite?; end
  def nan?; end
  def to_f; end
  def zero?; end
  protected def d; end
end

Date::JULIAN = T.let(T.unsafe(nil), Float)
Date::MONTHNAMES = T.let(T.unsafe(nil), Array)

class BasicSocket < ::IO
  def close_read; end
  def close_write; end
  def connect_address; end
  def do_not_reverse_lookup; end
  def do_not_reverse_lookup=(_arg0); end
  def getpeereid; end
  def getpeername; end
  def getsockname; end
  def getsockopt(_arg0, _arg1); end
  def local_address; end
  def recv(*_arg0); end
  def recv_nonblock(len, flag = T.unsafe(nil), str = T.unsafe(nil), exception: T.unsafe(nil)); end
  def recvmsg(dlen = T.unsafe(nil), flags = T.unsafe(nil), clen = T.unsafe(nil), scm_rights: T.unsafe(nil)); end
  def recvmsg_nonblock(dlen = T.unsafe(nil), flags = T.unsafe(nil), clen = T.unsafe(nil), scm_rights: T.unsafe(nil), exception: T.unsafe(nil)); end
  def remote_address; end
  def send(*_arg0); end
  def sendmsg(mesg, flags = T.unsafe(nil), dest_sockaddr = T.unsafe(nil), *controls); end
  def sendmsg_nonblock(mesg, flags = T.unsafe(nil), dest_sockaddr = T.unsafe(nil), *controls, exception: T.unsafe(nil)); end
  def setsockopt(*_arg0); end
  def shutdown(*_arg0); end
  private def __recv_nonblock(_arg0, _arg1, _arg2, _arg3); end
  private def __recvmsg(_arg0, _arg1, _arg2, _arg3); end
  private def __recvmsg_nonblock(_arg0, _arg1, _arg2, _arg3, _arg4); end
  private def __sendmsg(_arg0, _arg1, _arg2, _arg3); end
  private def __sendmsg_nonblock(_arg0, _arg1, _arg2, _arg3, _arg4); end
  def self.do_not_reverse_lookup; end
  def self.do_not_reverse_lookup=(_arg0); end
  def self.for_fd(_arg0); end
end

class OpenURI::Buffer
  def initialize; end
  def <<(str); end
  def io; end
  def size; end
end

class OpenURI::HTTPError < ::StandardError
  def initialize(message, io); end
  def io; end
end

class OpenURI::HTTPRedirect < ::OpenURI::HTTPError
  def initialize(message, io, uri); end
  def uri; end
end

module OpenURI::Meta
  def base_uri; end
  def base_uri=(_arg0); end
  def charset; end
  def content_encoding; end
  def content_type; end
  def content_type_parse; end
  def last_modified; end
  def meta; end
  def meta_add_field(name, value); end
  def meta_add_field2(name, values); end
  def meta_setup_encoding; end
  def metas; end
  def status; end
  def status=(_arg0); end
  def self.init(obj, src = T.unsafe(nil)); end
end

module OpenURI::OpenRead
  def open(*rest, &block); end
  def read(options = T.unsafe(nil)); end
end

OpenURI::Options = T.let(T.unsafe(nil), Hash)
class IPAddr::AddressFamilyError < ::IPAddr::Error; end
class IPAddr::Error < ::ArgumentError; end
IPAddr::IN4MASK = T.let(T.unsafe(nil), Integer)
IPAddr::IN6FORMAT = T.let(T.unsafe(nil), String)
IPAddr::IN6MASK = T.let(T.unsafe(nil), Integer)
class IPAddr::InvalidAddressError < ::IPAddr::Error; end
class IPAddr::InvalidPrefixError < ::IPAddr::InvalidAddressError; end
IPAddr::RE_IPV4ADDRLIKE = T.let(T.unsafe(nil), Regexp)
IPAddr::RE_IPV6ADDRLIKE_COMPRESSED = T.let(T.unsafe(nil), Regexp)
IPAddr::RE_IPV6ADDRLIKE_FULL = T.let(T.unsafe(nil), Regexp)
StringIO::VERSION = T.let(T.unsafe(nil), String)

module Comparable
  def <(_arg0); end
  def <=(_arg0); end
  def ==(_arg0); end
  def >(_arg0); end
  def >=(_arg0); end
  def between?(_arg0, _arg1); end
  def clamp(*_arg0); end
end

module Enumerable
  def all?(*_arg0); end
  def any?(*_arg0); end
  def chain(*_arg0); end
  def chunk; end
  def chunk_while; end
  def collect; end
  def collect_concat; end
  def count(*_arg0); end
  def cycle(*_arg0); end
  def detect(*_arg0); end
  def drop(_arg0); end
  def drop_while; end
  def each_cons(_arg0); end
  def each_entry(*_arg0); end
  def each_slice(_arg0); end
  def each_with_index(*_arg0); end
  def each_with_object(_arg0); end
  def entries(*_arg0); end
  def filter; end
  def filter_map; end
  def find(*_arg0); end
  def find_all; end
  def find_index(*_arg0); end
  def first(*_arg0); end
  def flat_map; end
  def grep(_arg0); end
  def grep_v(_arg0); end
  def group_by; end
  def include?(_arg0); end
  def inject(*_arg0); end
  def lazy; end
  def map; end
  def max(*_arg0); end
  def max_by(*_arg0); end
  def member?(_arg0); end
  def min(*_arg0); end
  def min_by(*_arg0); end
  def minmax; end
  def minmax_by; end
  def none?(*_arg0); end
  def one?(*_arg0); end
  def partition; end
  def reduce(*_arg0); end
  def reject; end
  def reverse_each(*_arg0); end
  def select; end
  def slice_after(*_arg0); end
  def slice_before(*_arg0); end
  def slice_when; end
  def sort; end
  def sort_by; end
  def sum(*_arg0); end
  def take(_arg0); end
  def take_while; end
  def tally; end
  def to_a(*_arg0); end
  def to_h(*_arg0); end
  def to_set(klass = T.unsafe(nil), *args, &block); end
  def uniq; end
  def zip(*_arg0); end
end

class StandardError < ::Exception; end
URI::FTP::COMPONENT = T.let(T.unsafe(nil), Array)
URI::FTP::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
URI::FTP::TYPECODE = T.let(T.unsafe(nil), Array)
URI::FTP::TYPECODE_PREFIX = T.let(T.unsafe(nil), String)
URI::File::COMPONENT = T.let(T.unsafe(nil), Array)
URI::Generic::COMPONENT = T.let(T.unsafe(nil), Array)
URI::HTTP::COMPONENT = T.let(T.unsafe(nil), Array)
URI::HTTP::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
URI::HTTPS::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
URI::LDAP::COMPONENT = T.let(T.unsafe(nil), Array)
URI::LDAP::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
URI::LDAP::SCOPE = T.let(T.unsafe(nil), Array)
URI::LDAP::SCOPE_BASE = T.let(T.unsafe(nil), String)
URI::LDAP::SCOPE_ONE = T.let(T.unsafe(nil), String)
URI::LDAP::SCOPE_SUB = T.let(T.unsafe(nil), String)
URI::LDAPS::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
URI::MailTo::COMPONENT = T.let(T.unsafe(nil), Array)
URI::MailTo::EMAIL_REGEXP = T.let(T.unsafe(nil), Regexp)
URI::MailTo::HEADER_REGEXP = T.let(T.unsafe(nil), Regexp)
module URI::RFC2396_REGEXP::PATTERN; end
URI::RFC3986_Parser::RFC3986_URI = T.let(T.unsafe(nil), Regexp)
URI::RFC3986_Parser::RFC3986_relative_ref = T.let(T.unsafe(nil), Regexp)
class ArgumentError < ::StandardError; end

class Numeric
  include ::Comparable
  def %(_arg0); end
  def +@; end
  def -@; end
  def <=>(_arg0); end
  def abs; end
  def abs2; end
  def angle; end
  def arg; end
  def ceil(*_arg0); end
  def clone(*_arg0); end
  def coerce(_arg0); end
  def conj; end
  def conjugate; end
  def denominator; end
  def div(_arg0); end
  def divmod(_arg0); end
  def dup; end
  def eql?(_arg0); end
  def fdiv(_arg0); end
  def finite?; end
  def floor(*_arg0); end
  def i; end
  def imag; end
  def imaginary; end
  def infinite?; end
  def integer?; end
  def magnitude; end
  def modulo(_arg0); end
  def negative?; end
  def nonzero?; end
  def numerator; end
  def phase; end
  def polar; end
  def positive?; end
  def quo(_arg0); end
  def real; end
  def real?; end
  def rect; end
  def rectangular; end
  def remainder(_arg0); end
  def round(*_arg0); end
  def singleton_method_added(_arg0); end
  def step(*_arg0); end
  def to_c; end
  def to_int; end
  def truncate(*_arg0); end
  def zero?; end
end

class IO
  include ::Enumerable
  include ::File::Constants
  def initialize(*_arg0); end
  def <<(_arg0); end
  def advise(*_arg0); end
  def autoclose=(_arg0); end
  def autoclose?; end
  def beep; end
  def binmode; end
  def binmode?; end
  def check_winsize_changed; end
  def clear_screen; end
  def close; end
  def close_on_exec=(_arg0); end
  def close_on_exec?; end
  def close_read; end
  def close_write; end
  def closed?; end
  def console_mode; end
  def console_mode=(_arg0); end
  def cooked; end
  def cooked!; end
  def cursor; end
  def cursor=(_arg0); end
  def cursor_down(_arg0); end
  def cursor_left(_arg0); end
  def cursor_right(_arg0); end
  def cursor_up(_arg0); end
  def each(*_arg0); end
  def each_byte; end
  def each_char; end
  def each_codepoint; end
  def each_line(*_arg0); end
  def echo=(_arg0); end
  def echo?; end
  def eof; end
  def eof?; end
  def erase_line(_arg0); end
  def erase_screen(_arg0); end
  def expect(pat, timeout = T.unsafe(nil)); end
  def external_encoding; end
  def fcntl(*_arg0); end
  def fdatasync; end
  def fileno; end
  def flush; end
  def fsync; end
  def getbyte; end
  def getc; end
  def getch(*_arg0); end
  def getpass(*_arg0); end
  def gets(*_arg0); end
  def goto(_arg0, _arg1); end
  def goto_column(_arg0); end
  def iflush; end
  def inspect; end
  def internal_encoding; end
  def ioctl(*_arg0); end
  def ioflush; end
  def isatty; end
  def lineno; end
  def lineno=(_arg0); end
  def noecho; end
  def nonblock(*_arg0); end
  def nonblock=(_arg0); end
  def nonblock?; end
  def nread; end
  def oflush; end
  def pathconf(_arg0); end
  def pid; end
  def pos; end
  def pos=(_arg0); end
  def pread(*_arg0); end
  def pressed?; end
  def print(*_arg0); end
  def printf(*_arg0); end
  def putc(_arg0); end
  def puts(*_arg0); end
  def pwrite(_arg0, _arg1); end
  def raw(*_arg0); end
  def raw!(*_arg0); end
  def read(*_arg0); end
  def read_nonblock(len, buf = T.unsafe(nil), exception: T.unsafe(nil)); end
  def readbyte; end
  def readchar; end
  def readline(*_arg0); end
  def readlines(*_arg0); end
  def readpartial(*_arg0); end
  def ready?; end
  def reopen(*_arg0); end
  def rewind; end
  def scroll_backward(_arg0); end
  def scroll_forward(_arg0); end
  def seek(*_arg0); end
  def set_encoding(*_arg0); end
  def set_encoding_by_bom; end
  def stat; end
  def sync; end
  def sync=(_arg0); end
  def sysread(*_arg0); end
  def sysseek(*_arg0); end
  def syswrite(_arg0); end
  def tell; end
  def to_i; end
  def to_io; end
  def tty?; end
  def ungetbyte(_arg0); end
  def ungetc(_arg0); end
  def wait(*_arg0); end
  def wait_priority(*_arg0); end
  def wait_readable(*_arg0); end
  def wait_writable(*_arg0); end
  def winsize; end
  def winsize=(_arg0); end
  def write(*_arg0); end
  def write_nonblock(buf, exception: T.unsafe(nil)); end
  private def initialize_copy(_arg0); end
  def self.binread(*_arg0); end
  def self.binwrite(*_arg0); end
  def self.console(*_arg0); end
  def self.copy_stream(*_arg0); end
  def self.for_fd(*_arg0); end
  def self.foreach(*_arg0); end
  def self.new(*_arg0); end
  def self.open(*_arg0); end
  def self.pipe(*_arg0); end
  def self.popen(*_arg0); end
  def self.read(*_arg0); end
  def self.readlines(*_arg0); end
  def self.select(*_arg0); end
  def self.sysopen(*_arg0); end
  def self.try_convert(_arg0); end
  def self.write(*_arg0); end
end

OpenURI::Buffer::StringMax = T.let(T.unsafe(nil), Integer)
OpenURI::Meta::RE_LWS = T.let(T.unsafe(nil), Regexp)
OpenURI::Meta::RE_PARAMETERS = T.let(T.unsafe(nil), Regexp)
OpenURI::Meta::RE_QUOTED_STRING = T.let(T.unsafe(nil), Regexp)
OpenURI::Meta::RE_TOKEN = T.let(T.unsafe(nil), Regexp)

class Exception
  def initialize(*_arg0); end
  def ==(_arg0); end
  def backtrace; end
  def backtrace_locations; end
  def cause; end
  def exception(*_arg0); end
  def full_message(*_arg0); end
  def inspect; end
  def message; end
  def respond_to?(*_arg0); end
  def set_backtrace(_arg0); end
  def to_s; end
  private def method_missing(*_arg0); end
  private def respond_to_missing?(_arg0, _arg1); end
  def self.exception(*_arg0); end
  def self.to_tty?; end
end

URI::RFC2396_REGEXP::PATTERN::ABS_PATH = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::ABS_URI = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::ALNUM = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::ALPHA = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::DOMLABEL = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::ESCAPED = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::FRAGMENT = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::HEX = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::HIER_PART = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::HOST = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::HOSTNAME = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::HOSTPORT = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::IPV4ADDR = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::IPV6ADDR = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::IPV6REF = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::NET_PATH = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::OPAQUE_PART = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::PATH_SEGMENTS = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::PORT = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::QUERY = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::REG_NAME = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::REL_PATH = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::REL_SEGMENT = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::REL_URI = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::RESERVED = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::SCHEME = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::TOPLABEL = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::UNRESERVED = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::URIC = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::URIC_NO_SLASH = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::URI_REF = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::USERINFO = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::X_ABS_URI = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::X_REL_URI = T.let(T.unsafe(nil), String)

class IO::ConsoleMode
  def echo=(_arg0); end
  def raw(*_arg0); end
  def raw!(*_arg0); end
  private def initialize_copy(_arg0); end
end

class IO::EAGAINWaitReadable < ::Errno::EAGAIN
  include ::IO::WaitReadable
end

class IO::EAGAINWaitWritable < ::Errno::EAGAIN
  include ::IO::WaitWritable
end

class IO::EINPROGRESSWaitReadable < ::Errno::EINPROGRESS
  include ::IO::WaitReadable
end

class IO::EINPROGRESSWaitWritable < ::Errno::EINPROGRESS
  include ::IO::WaitWritable
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable
IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable
IO::PRIORITY = T.let(T.unsafe(nil), Integer)
IO::READABLE = T.let(T.unsafe(nil), Integer)
IO::SEEK_CUR = T.let(T.unsafe(nil), Integer)
IO::SEEK_DATA = T.let(T.unsafe(nil), Integer)
IO::SEEK_END = T.let(T.unsafe(nil), Integer)
IO::SEEK_HOLE = T.let(T.unsafe(nil), Integer)
IO::SEEK_SET = T.let(T.unsafe(nil), Integer)
IO::WRITABLE = T.let(T.unsafe(nil), Integer)
module IO::WaitReadable; end
module IO::WaitWritable; end
module File::Constants; end
class Errno::EAGAIN < ::SystemCallError; end
class Errno::EINPROGRESS < ::SystemCallError; end
File::Constants::APPEND = T.let(T.unsafe(nil), Integer)
File::Constants::BINARY = T.let(T.unsafe(nil), Integer)
File::Constants::CREAT = T.let(T.unsafe(nil), Integer)
File::Constants::DSYNC = T.let(T.unsafe(nil), Integer)
File::Constants::EXCL = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_CASEFOLD = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_DOTMATCH = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_EXTGLOB = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_NOESCAPE = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_PATHNAME = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_SHORTNAME = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_SYSCASE = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_EX = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_NB = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_SH = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_UN = T.let(T.unsafe(nil), Integer)
File::Constants::NOCTTY = T.let(T.unsafe(nil), Integer)
File::Constants::NOFOLLOW = T.let(T.unsafe(nil), Integer)
File::Constants::NONBLOCK = T.let(T.unsafe(nil), Integer)
File::Constants::NULL = T.let(T.unsafe(nil), String)
File::Constants::RDONLY = T.let(T.unsafe(nil), Integer)
File::Constants::RDWR = T.let(T.unsafe(nil), Integer)
File::Constants::SHARE_DELETE = T.let(T.unsafe(nil), Integer)
File::Constants::SYNC = T.let(T.unsafe(nil), Integer)
File::Constants::TRUNC = T.let(T.unsafe(nil), Integer)
File::Constants::WRONLY = T.let(T.unsafe(nil), Integer)

class SystemCallError < ::StandardError
  def initialize(*_arg0); end
  def errno; end
  def self.===(_arg0); end
end

Errno::EAGAIN::Errno = T.let(T.unsafe(nil), Integer)
Errno::EINPROGRESS::Errno = T.let(T.unsafe(nil), Integer)
module Open3
  private def capture2(*cmd); end
  private def capture2e(*cmd); end
  private def capture3(*cmd); end
  private def pipeline(*cmds); end
  private def pipeline_r(*cmds, &block); end
  private def pipeline_run(cmds, pipeline_opts, child_io, parent_io); end
  private def pipeline_rw(*cmds, &block); end
  private def pipeline_start(*cmds, &block); end
  private def pipeline_w(*cmds, &block); end
  private def popen2(*cmd, &block); end
  private def popen2e(*cmd, &block); end
  private def popen3(*cmd, &block); end
  private def popen_run(cmd, opts, child_io, parent_io); end
  def self.capture2(*cmd); end
  def self.capture2e(*cmd); end
  def self.capture3(*cmd); end
  def self.pipeline(*cmds); end
  def self.pipeline_r(*cmds, &block); end
  def self.pipeline_rw(*cmds, &block); end
  def self.pipeline_start(*cmds, &block); end
  def self.pipeline_w(*cmds, &block); end
  def self.popen2(*cmd, &block); end
  def self.popen2e(*cmd, &block); end
  def self.popen3(*cmd, &block); end
  private def self.pipeline_run(cmds, pipeline_opts, child_io, parent_io); end
  private def self.popen_run(cmd, opts, child_io, parent_io); end
end

Open3::VERSION = T.let(T.unsafe(nil), String)
OptParse = OptionParser

class OptionParser
  def initialize(banner = T.unsafe(nil), width = T.unsafe(nil), indent = T.unsafe(nil)); end
  def abort(mesg = T.unsafe(nil)); end
  def accept(*args, &blk); end
  def add_officious; end
  def additional_message(typ, opt); end
  def banner; end
  def banner=(_arg0); end
  def base; end
  def candidate(word); end
  def compsys(to, name = T.unsafe(nil)); end
  def def_head_option(*opts, &block); end
  def def_option(*opts, &block); end
  def def_tail_option(*opts, &block); end
  def default_argv; end
  def default_argv=(_arg0); end
  def define(*opts, &block); end
  def define_head(*opts, &block); end
  def define_tail(*opts, &block); end
  def environment(env = T.unsafe(nil)); end
  def getopts(*args); end
  def help; end
  def inc(*args); end
  def load(filename = T.unsafe(nil)); end
  def make_switch(opts, block = T.unsafe(nil)); end
  def new; end
  def on(*opts, &block); end
  def on_head(*opts, &block); end
  def on_tail(*opts, &block); end
  def order(*argv, into: T.unsafe(nil), &nonopt); end
  def order!(argv = T.unsafe(nil), into: T.unsafe(nil), &nonopt); end
  def parse(*argv, into: T.unsafe(nil)); end
  def parse!(argv = T.unsafe(nil), into: T.unsafe(nil)); end
  def permute(*argv, into: T.unsafe(nil)); end
  def permute!(argv = T.unsafe(nil), into: T.unsafe(nil)); end
  def program_name; end
  def program_name=(_arg0); end
  def reject(*args, &blk); end
  def release; end
  def release=(_arg0); end
  def remove; end
  def separator(string); end
  def set_banner(_arg0); end
  def set_program_name(_arg0); end
  def set_summary_indent(_arg0); end
  def set_summary_width(_arg0); end
  def summarize(to = T.unsafe(nil), width = T.unsafe(nil), max = T.unsafe(nil), indent = T.unsafe(nil), &blk); end
  def summary_indent; end
  def summary_indent=(_arg0); end
  def summary_width; end
  def summary_width=(_arg0); end
  def terminate(arg = T.unsafe(nil)); end
  def to_a; end
  def to_s; end
  def top; end
  def ver; end
  def version; end
  def version=(_arg0); end
  def warn(mesg = T.unsafe(nil)); end
  private def complete(typ, opt, icase = T.unsafe(nil), *pat); end
  private def notwice(obj, prv, msg); end
  private def parse_in_order(argv = T.unsafe(nil), setter = T.unsafe(nil), &nonopt); end
  private def search(id, key); end
  private def visit(id, *args, &block); end
  def self.accept(*args, &blk); end
  def self.getopts(*args); end
  def self.inc(arg, default = T.unsafe(nil)); end
  def self.reject(*args, &blk); end
  def self.terminate(arg = T.unsafe(nil)); end
  def self.top; end
  def self.with(*args, &block); end
end

module OptionParser::Acceptables; end
class OptionParser::AmbiguousArgument < ::OptionParser::InvalidArgument; end
class OptionParser::AmbiguousOption < ::OptionParser::ParseError; end

module OptionParser::Arguable
  def initialize(*args); end
  def getopts(*args); end
  def options; end
  def options=(opt); end
  def order!(&blk); end
  def parse!; end
  def permute!; end
  def self.extend_object(obj); end
end

OptionParser::ArgumentStyle = T.let(T.unsafe(nil), Hash)
OptionParser::COMPSYS_HEADER = T.let(T.unsafe(nil), String)

class OptionParser::CompletingHash < ::Hash
  include ::OptionParser::Completion
  def match(key); end
end

module OptionParser::Completion
  def candidate(key, icase = T.unsafe(nil), pat = T.unsafe(nil)); end
  def complete(key, icase = T.unsafe(nil), pat = T.unsafe(nil)); end
  def convert(opt = T.unsafe(nil), val = T.unsafe(nil), *_arg2); end
  def self.candidate(key, icase = T.unsafe(nil), pat = T.unsafe(nil), &block); end
  def self.regexp(key, icase); end
end

OptionParser::DecimalInteger = T.let(T.unsafe(nil), Regexp)
OptionParser::DecimalNumeric = T.let(T.unsafe(nil), Regexp)
OptionParser::DefaultList = T.let(T.unsafe(nil), OptionParser::List)
class OptionParser::InvalidArgument < ::OptionParser::ParseError; end
class OptionParser::InvalidOption < ::OptionParser::ParseError; end

class OptionParser::List
  def initialize; end
  def accept(t, pat = T.unsafe(nil), &block); end
  def add_banner(to); end
  def append(*args); end
  def atype; end
  def complete(id, opt, icase = T.unsafe(nil), *pat, &block); end
  def compsys(*args, &block); end
  def each_option(&block); end
  def get_candidates(id); end
  def list; end
  def long; end
  def prepend(*args); end
  def reject(t); end
  def search(id, key); end
  def short; end
  def summarize(*args, &block); end
  private def update(sw, sopts, lopts, nsw = T.unsafe(nil), nlopts = T.unsafe(nil)); end
end

class OptionParser::MissingArgument < ::OptionParser::ParseError; end
OptionParser::NO_ARGUMENT = T.let(T.unsafe(nil), Symbol)
class OptionParser::NeedlessArgument < ::OptionParser::ParseError; end
OptionParser::NoArgument = T.let(T.unsafe(nil), Array)
OptionParser::OPTIONAL_ARGUMENT = T.let(T.unsafe(nil), Symbol)
OptionParser::OctalInteger = T.let(T.unsafe(nil), Regexp)
OptionParser::Officious = T.let(T.unsafe(nil), Hash)

class OptionParser::OptionMap < ::Hash
  include ::OptionParser::Completion
end

OptionParser::OptionalArgument = T.let(T.unsafe(nil), Array)

class OptionParser::ParseError < ::RuntimeError
  def initialize(*args, additional: T.unsafe(nil)); end
  def additional; end
  def additional=(_arg0); end
  def args; end
  def inspect; end
  def message; end
  def reason; end
  def reason=(_arg0); end
  def recover(argv); end
  def set_backtrace(array); end
  def set_option(opt, eq); end
  def to_s; end
  def self.filter_backtrace(array); end
end

OptionParser::REQUIRED_ARGUMENT = T.let(T.unsafe(nil), Symbol)
OptionParser::RequiredArgument = T.let(T.unsafe(nil), Array)
OptionParser::SPLAT_PROC = T.let(T.unsafe(nil), Proc)

class OptionParser::Switch
  def initialize(pattern = T.unsafe(nil), conv = T.unsafe(nil), short = T.unsafe(nil), long = T.unsafe(nil), arg = T.unsafe(nil), desc = T.unsafe(nil), block = T.unsafe(nil), &_block); end
  def add_banner(to); end
  def arg; end
  def block; end
  def compsys(sdone, ldone); end
  def conv; end
  def desc; end
  def long; end
  def match_nonswitch?(str); end
  def pattern; end
  def short; end
  def summarize(sdone = T.unsafe(nil), ldone = T.unsafe(nil), width = T.unsafe(nil), max = T.unsafe(nil), indent = T.unsafe(nil)); end
  def switch_name; end
  private def conv_arg(arg, val = T.unsafe(nil)); end
  private def parse_arg(arg); end
  def self.guess(arg); end
  def self.incompatible_argument_styles(arg, t); end
  def self.pattern; end
end

OptionParser::Version = T.let(T.unsafe(nil), String)
OptionParser::Acceptables::DecimalInteger = T.let(T.unsafe(nil), Regexp)
OptionParser::Acceptables::DecimalNumeric = T.let(T.unsafe(nil), Regexp)
OptionParser::Acceptables::OctalInteger = T.let(T.unsafe(nil), Regexp)
OptionParser::AmbiguousArgument::Reason = T.let(T.unsafe(nil), String)
OptionParser::AmbiguousOption::Reason = T.let(T.unsafe(nil), String)

class Hash
  include ::Enumerable
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  def initialize(*_arg0); end
  def <(_arg0); end
  def <=(_arg0); end
  def ==(_arg0); end
  def >(_arg0); end
  def >=(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def any?(*_arg0); end
  def assoc(_arg0); end
  def clear; end
  def compact; end
  def compact!; end
  def compare_by_identity; end
  def compare_by_identity?; end
  def deconstruct_keys(_arg0); end
  def default(*_arg0); end
  def default=(_arg0); end
  def default_proc; end
  def default_proc=(_arg0); end
  def delete(_arg0); end
  def delete_if; end
  def dig(*_arg0); end
  def each; end
  def each_key; end
  def each_pair; end
  def each_value; end
  def empty?; end
  def eql?(_arg0); end
  def except(*_arg0); end
  def fetch(*_arg0); end
  def fetch_values(*_arg0); end
  def filter; end
  def filter!; end
  def flatten(*_arg0); end
  def has_key?(_arg0); end
  def has_value?(_arg0); end
  def hash; end
  def include?(_arg0); end
  def inspect; end
  def invert; end
  def keep_if; end
  def key(_arg0); end
  def key?(_arg0); end
  def keys; end
  def length; end
  def member?(_arg0); end
  def merge(*_arg0); end
  def merge!(*_arg0); end
  def rassoc(_arg0); end
  def rehash; end
  def reject; end
  def reject!; end
  def replace(_arg0); end
  def select; end
  def select!; end
  def shift; end
  def size; end
  def slice(*_arg0); end
  def store(_arg0, _arg1); end
  def to_a; end
  def to_h; end
  def to_hash; end
  def to_proc; end
  def to_s; end
  def transform_keys(*_arg0); end
  def transform_keys!(*_arg0); end
  def transform_values; end
  def transform_values!; end
  def update(*_arg0); end
  def value?(_arg0); end
  def values; end
  def values_at(*_arg0); end
  private def initialize_copy(_arg0); end
  def self.[](*_arg0); end
  def self.ruby2_keywords_hash(_arg0); end
  def self.ruby2_keywords_hash?(_arg0); end
  def self.try_convert(_arg0); end
end

OptionParser::InvalidArgument::Reason = T.let(T.unsafe(nil), String)
OptionParser::InvalidOption::Reason = T.let(T.unsafe(nil), String)
OptionParser::MissingArgument::Reason = T.let(T.unsafe(nil), String)
OptionParser::NeedlessArgument::Reason = T.let(T.unsafe(nil), String)
class RuntimeError < ::StandardError; end
OptionParser::ParseError::Reason = T.let(T.unsafe(nil), String)

class OptionParser::Switch::NoArgument < ::OptionParser::Switch
  def parse(arg, argv); end
  def self.incompatible_argument_styles(*_arg0); end
  def self.pattern; end
end

class OptionParser::Switch::OptionalArgument < ::OptionParser::Switch
  def parse(arg, argv, &error); end
end

class OptionParser::Switch::PlacedArgument < ::OptionParser::Switch
  def parse(arg, argv, &error); end
end

class OptionParser::Switch::RequiredArgument < ::OptionParser::Switch
  def parse(arg, argv); end
end

class StandardError < ::Exception; end

module Enumerable
  def all?(*_arg0); end
  def any?(*_arg0); end
  def chain(*_arg0); end
  def chunk; end
  def chunk_while; end
  def collect; end
  def collect_concat; end
  def count(*_arg0); end
  def cycle(*_arg0); end
  def detect(*_arg0); end
  def drop(_arg0); end
  def drop_while; end
  def each_cons(_arg0); end
  def each_entry(*_arg0); end
  def each_slice(_arg0); end
  def each_with_index(*_arg0); end
  def each_with_object(_arg0); end
  def entries(*_arg0); end
  def filter; end
  def filter_map; end
  def find(*_arg0); end
  def find_all; end
  def find_index(*_arg0); end
  def first(*_arg0); end
  def flat_map; end
  def grep(_arg0); end
  def grep_v(_arg0); end
  def group_by; end
  def include?(_arg0); end
  def inject(*_arg0); end
  def lazy; end
  def map; end
  def max(*_arg0); end
  def max_by(*_arg0); end
  def member?(_arg0); end
  def min(*_arg0); end
  def min_by(*_arg0); end
  def minmax; end
  def minmax_by; end
  def none?(*_arg0); end
  def one?(*_arg0); end
  def partition; end
  def reduce(*_arg0); end
  def reject; end
  def reverse_each(*_arg0); end
  def select; end
  def slice_after(*_arg0); end
  def slice_before(*_arg0); end
  def slice_when; end
  def sort; end
  def sort_by; end
  def sum(*_arg0); end
  def take(_arg0); end
  def take_while; end
  def tally; end
  def to_a(*_arg0); end
  def to_h(*_arg0); end
  def to_set(klass = T.unsafe(nil), *args, &block); end
  def uniq; end
  def zip(*_arg0); end
end

module JSON::Ext::Generator::GeneratorMethods::Hash
  def to_json(*_arg0); end
end

class Exception
  def initialize(*_arg0); end
  def ==(_arg0); end
  def backtrace; end
  def backtrace_locations; end
  def cause; end
  def exception(*_arg0); end
  def full_message(*_arg0); end
  def inspect; end
  def message; end
  def respond_to?(*_arg0); end
  def set_backtrace(_arg0); end
  def to_s; end
  private def method_missing(*_arg0); end
  private def respond_to_missing?(_arg0, _arg1); end
  def self.exception(*_arg0); end
  def self.to_tty?; end
end
module URI
  include ::URI::RFC2396_REGEXP
  def self.decode_www_form(str, enc = T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end
  def self.decode_www_form_component(str, enc = T.unsafe(nil)); end
  def self.encode_www_form(enum, enc = T.unsafe(nil)); end
  def self.encode_www_form_component(str, enc = T.unsafe(nil)); end
  def self.extract(str, schemes = T.unsafe(nil), &block); end
  def self.for(scheme, *arguments, default: T.unsafe(nil)); end
  def self.get_encoding(label); end
  def self.join(*str); end
  def self.open(name, *rest, &block); end
  def self.parse(uri); end
  def self.regexp(schemes = T.unsafe(nil)); end
  def self.scheme_list; end
  def self.split(uri); end
end

class IPSocket < ::BasicSocket
  def addr(*_arg0); end
  def inspect; end
  def peeraddr(*_arg0); end
  def recvfrom(*_arg0); end
  def self.getaddress(_arg0); end
end

class IPAddr
  include ::Comparable
  def initialize(addr = T.unsafe(nil), family = T.unsafe(nil)); end
  def &(other); end
  def <<(num); end
  def <=>(other); end
  def ==(other); end
  def ===(other); end
  def >>(num); end
  def eql?(other); end
  def family; end
  def hash; end
  def hton; end
  def include?(other); end
  def inspect; end
  def ip6_arpa; end
  def ip6_int; end
  def ipv4?; end
  def ipv4_compat; end
  def ipv4_compat?; end
  def ipv4_mapped; end
  def ipv4_mapped?; end
  def ipv6?; end
  def link_local?; end
  def loopback?; end
  def mask(prefixlen); end
  def native; end
  def prefix; end
  def prefix=(prefix); end
  def private?; end
  def reverse; end
  def succ; end
  def to_i; end
  def to_range; end
  def to_s; end
  def to_string; end
  def |(other); end
  def ~; end
  protected def mask!(mask); end
  protected def set(addr, *family); end
  private def _ipv4_compat?; end
  private def _reverse; end
  private def _to_string(addr); end
  private def addr_mask(addr); end
  private def coerce_other(other); end
  private def in6_addr(left); end
  private def in_addr(addr); end
  def self.new_ntoh(addr); end
  def self.ntop(addr); end
end

module Shellwords
  private def shellescape(str); end
  private def shelljoin(array); end
  private def shellsplit(line); end
  private def shellwords(line); end
  def self.escape(str); end
  def self.join(array); end
  def self.shellescape(str); end
  def self.shelljoin(array); end
  def self.shellsplit(line); end
  def self.shellwords(line); end
  def self.split(line); end
end

OptParse = OptionParser

class DateTime < ::Date
  def hour; end
  def iso8601(*_arg0); end
  def jisx0301(*_arg0); end
  def min; end
  def minute; end
  def new_offset(*_arg0); end
  def offset; end
  def rfc3339(*_arg0); end
  def sec; end
  def sec_fraction; end
  def second; end
  def second_fraction; end
  def strftime(*_arg0); end
  def to_date; end
  def to_datetime; end
  def to_s; end
  def to_time; end
  def xmlschema(*_arg0); end
  def zone; end
  def self._strptime(*_arg0); end
  def self.civil(*_arg0); end
  def self.commercial(*_arg0); end
  def self.httpdate(*_arg0); end
  def self.iso8601(*_arg0); end
  def self.jd(*_arg0); end
  def self.jisx0301(*_arg0); end
  def self.new(*_arg0); end
  def self.now(*_arg0); end
  def self.ordinal(*_arg0); end
  def self.parse(*_arg0); end
  def self.rfc2822(*_arg0); end
  def self.rfc3339(*_arg0); end
  def self.rfc822(*_arg0); end
  def self.strptime(*_arg0); end
  def self.xmlschema(*_arg0); end
end

class Date
  include ::Comparable
  def initialize(*_arg0); end
  def +(_arg0); end
  def -(_arg0); end
  def <<(_arg0); end
  def <=>(_arg0); end
  def ===(_arg0); end
  def >>(_arg0); end
  def ajd; end
  def amjd; end
  def asctime; end
  def ctime; end
  def cwday; end
  def cweek; end
  def cwyear; end
  def day; end
  def day_fraction; end
  def downto(_arg0); end
  def england; end
  def eql?(_arg0); end
  def friday?; end
  def gregorian; end
  def gregorian?; end
  def hash; end
  def httpdate; end
  def infinite?; end
  def inspect; end
  def iso8601; end
  def italy; end
  def jd; end
  def jisx0301; end
  def julian; end
  def julian?; end
  def ld; end
  def leap?; end
  def marshal_dump; end
  def marshal_load(_arg0); end
  def mday; end
  def mjd; end
  def mon; end
  def monday?; end
  def month; end
  def new_start(*_arg0); end
  def next; end
  def next_day(*_arg0); end
  def next_month(*_arg0); end
  def next_year(*_arg0); end
  def prev_day(*_arg0); end
  def prev_month(*_arg0); end
  def prev_year(*_arg0); end
  def rfc2822; end
  def rfc3339; end
  def rfc822; end
  def saturday?; end
  def start; end
  def step(*_arg0); end
  def strftime(*_arg0); end
  def succ; end
  def sunday?; end
  def thursday?; end
  def to_date; end
  def to_datetime; end
  def to_s; end
  def to_time; end
  def tuesday?; end
  def upto(_arg0); end
  def wday; end
  def wednesday?; end
  def xmlschema; end
  def yday; end
  def year; end
  private def hour; end
  private def initialize_copy(_arg0); end
  private def min; end
  private def minute; end
  private def sec; end
  private def second; end
  def self._httpdate(_arg0); end
  def self._iso8601(_arg0); end
  def self._jisx0301(_arg0); end
  def self._load(_arg0); end
  def self._parse(*_arg0); end
  def self._rfc2822(_arg0); end
  def self._rfc3339(_arg0); end
  def self._rfc822(_arg0); end
  def self._strptime(*_arg0); end
  def self._xmlschema(_arg0); end
  def self.civil(*_arg0); end
  def self.commercial(*_arg0); end
  def self.gregorian_leap?(_arg0); end
  def self.httpdate(*_arg0); end
  def self.iso8601(*_arg0); end
  def self.jd(*_arg0); end
  def self.jisx0301(*_arg0); end
  def self.julian_leap?(_arg0); end
  def self.leap?(_arg0); end
  def self.ordinal(*_arg0); end
  def self.parse(*_arg0); end
  def self.rfc2822(*_arg0); end
  def self.rfc3339(*_arg0); end
  def self.rfc822(*_arg0); end
  def self.strptime(*_arg0); end
  def self.today(*_arg0); end
  def self.valid_civil?(*_arg0); end
  def self.valid_commercial?(*_arg0); end
  def self.valid_date?(*_arg0); end
  def self.valid_jd?(*_arg0); end
  def self.valid_ordinal?(*_arg0); end
  def self.xmlschema(*_arg0); end
end

class OptionParser
  def initialize(banner = T.unsafe(nil), width = T.unsafe(nil), indent = T.unsafe(nil)); end
  def abort(mesg = T.unsafe(nil)); end
  def accept(*args, &blk); end
  def add_officious; end
  def additional_message(typ, opt); end
  def banner; end
  def banner=(_arg0); end
  def base; end
  def candidate(word); end
  def compsys(to, name = T.unsafe(nil)); end
  def def_head_option(*opts, &block); end
  def def_option(*opts, &block); end
  def def_tail_option(*opts, &block); end
  def default_argv; end
  def default_argv=(_arg0); end
  def define(*opts, &block); end
  def define_by_keywords(options, meth, **opts); end
  def define_head(*opts, &block); end
  def define_tail(*opts, &block); end
  def environment(env = T.unsafe(nil)); end
  def getopts(*args); end
  def help; end
  def inc(*args); end
  def load(filename = T.unsafe(nil)); end
  def make_switch(opts, block = T.unsafe(nil)); end
  def new; end
  def on(*opts, &block); end
  def on_head(*opts, &block); end
  def on_tail(*opts, &block); end
  def order(*argv, into: T.unsafe(nil), &nonopt); end
  def order!(argv = T.unsafe(nil), into: T.unsafe(nil), &nonopt); end
  def parse(*argv, into: T.unsafe(nil)); end
  def parse!(argv = T.unsafe(nil), into: T.unsafe(nil)); end
  def permute(*argv, into: T.unsafe(nil)); end
  def permute!(argv = T.unsafe(nil), into: T.unsafe(nil)); end
  def program_name; end
  def program_name=(_arg0); end
  def reject(*args, &blk); end
  def release; end
  def release=(_arg0); end
  def remove; end
  def separator(string); end
  def set_banner(_arg0); end
  def set_program_name(_arg0); end
  def set_summary_indent(_arg0); end
  def set_summary_width(_arg0); end
  def summarize(to = T.unsafe(nil), width = T.unsafe(nil), max = T.unsafe(nil), indent = T.unsafe(nil), &blk); end
  def summary_indent; end
  def summary_indent=(_arg0); end
  def summary_width; end
  def summary_width=(_arg0); end
  def terminate(arg = T.unsafe(nil)); end
  def to_a; end
  def to_s; end
  def top; end
  def ver; end
  def version; end
  def version=(_arg0); end
  def warn(mesg = T.unsafe(nil)); end
  private def complete(typ, opt, icase = T.unsafe(nil), *pat); end
  private def notwice(obj, prv, msg); end
  private def parse_in_order(argv = T.unsafe(nil), setter = T.unsafe(nil), &nonopt); end
  private def search(id, key); end
  private def visit(id, *args, &block); end
  def self.accept(*args, &blk); end
  def self.each_const(path, base = T.unsafe(nil)); end
  def self.getopts(*args); end
  def self.inc(arg, default = T.unsafe(nil)); end
  def self.reject(*args, &blk); end
  def self.search_const(klass, name); end
  def self.show_version(*pkgs); end
  def self.terminate(arg = T.unsafe(nil)); end
  def self.top; end
  def self.with(*args, &block); end
end

URI::ABS_PATH = T.let(T.unsafe(nil), Regexp)
URI::ABS_URI = T.let(T.unsafe(nil), Regexp)
URI::ABS_URI_REF = T.let(T.unsafe(nil), Regexp)
class URI::BadURIError < ::URI::Error; end
URI::DEFAULT_PARSER = T.let(T.unsafe(nil), URI::RFC2396_Parser)
URI::ESCAPED = T.let(T.unsafe(nil), Regexp)
class URI::Error < ::StandardError; end
URI::FRAGMENT = T.let(T.unsafe(nil), Regexp)

class URI::FTP < ::URI::Generic
  include ::OpenURI::OpenRead
  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser = T.unsafe(nil), arg_check = T.unsafe(nil)); end
  def buffer_open(buf, proxy, options); end
  def merge(oth); end
  def path; end
  def to_s; end
  def typecode; end
  def typecode=(typecode); end
  protected def set_path(v); end
  protected def set_typecode(v); end
  private def check_typecode(v); end
  def self.build(args); end
  def self.new2(user, password, host, port, path, typecode = T.unsafe(nil), arg_check = T.unsafe(nil)); end
end

class URI::File < ::URI::Generic
  def check_password(user); end
  def check_user(user); end
  def check_userinfo(user); end
  def set_host(v); end
  def set_password(v); end
  def set_port(v); end
  def set_user(v); end
  def set_userinfo(v); end
  def self.build(args); end
end

class URI::Generic
  include ::URI::RFC2396_REGEXP
  include ::URI
  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser = T.unsafe(nil), arg_check = T.unsafe(nil)); end
  def +(oth); end
  def -(oth); end
  def ==(oth); end
  def absolute; end
  def absolute?; end
  def coerce(oth); end
  def component; end
  def default_port; end
  def eql?(oth); end
  def find_proxy(env = T.unsafe(nil)); end
  def fragment; end
  def fragment=(v); end
  def hash; end
  def hierarchical?; end
  def host; end
  def host=(v); end
  def hostname; end
  def hostname=(v); end
  def inspect; end
  def merge(oth); end
  def merge!(oth); end
  def normalize; end
  def normalize!; end
  def opaque; end
  def opaque=(v); end
  def parser; end
  def password; end
  def password=(password); end
  def path; end
  def path=(v); end
  def port; end
  def port=(v); end
  def query; end
  def query=(v); end
  def registry; end
  def registry=(v); end
  def relative?; end
  def route_from(oth); end
  def route_to(oth); end
  def scheme; end
  def scheme=(v); end
  def select(*components); end
  def to_s; end
  def user; end
  def user=(user); end
  def userinfo; end
  def userinfo=(userinfo); end
  protected def component_ary; end
  protected def set_host(v); end
  protected def set_opaque(v); end
  protected def set_password(v); end
  protected def set_path(v); end
  protected def set_port(v); end
  protected def set_registry(v); end
  protected def set_scheme(v); end
  protected def set_user(v); end
  protected def set_userinfo(user, password = T.unsafe(nil)); end
  private def check_host(v); end
  private def check_opaque(v); end
  private def check_password(v, user = T.unsafe(nil)); end
  private def check_path(v); end
  private def check_port(v); end
  private def check_registry(v); end
  private def check_scheme(v); end
  private def check_user(v); end
  private def check_userinfo(user, password = T.unsafe(nil)); end
  private def escape_userpass(v); end
  private def merge_path(base, rel); end
  private def replace!(oth); end
  private def route_from0(oth); end
  private def route_from_path(src, dst); end
  private def split_path(path); end
  private def split_userinfo(ui); end
  def self.build(args); end
  def self.build2(args); end
  def self.component; end
  def self.default_port; end
  def self.use_proxy?(hostname, addr, port, no_proxy); end
  def self.use_registry; end
end

URI::HOST = T.let(T.unsafe(nil), Regexp)

class URI::HTTP < ::URI::Generic
  include ::OpenURI::OpenRead
  def buffer_open(buf, proxy, options); end
  def request_uri; end
  def self.build(args); end
end

class URI::HTTPS < ::URI::HTTP; end
class URI::InvalidComponentError < ::URI::Error; end
class URI::InvalidURIError < ::URI::Error; end

class URI::LDAP < ::URI::Generic
  def initialize(*arg); end
  def attributes; end
  def attributes=(val); end
  def dn; end
  def dn=(val); end
  def extensions; end
  def extensions=(val); end
  def filter; end
  def filter=(val); end
  def hierarchical?; end
  def scope; end
  def scope=(val); end
  protected def set_attributes(val); end
  protected def set_dn(val); end
  protected def set_extensions(val); end
  protected def set_filter(val); end
  protected def set_scope(val); end
  private def build_path_query; end
  private def parse_dn; end
  private def parse_query; end
  def self.build(args); end
end

class URI::LDAPS < ::URI::LDAP; end

class URI::MailTo < ::URI::Generic
  def initialize(*arg); end
  def headers; end
  def headers=(v); end
  def to; end
  def to=(v); end
  def to_mailtext; end
  def to_rfc822text; end
  def to_s; end
  protected def set_headers(v); end
  protected def set_to(v); end
  private def check_headers(v); end
  private def check_to(v); end
  def self.build(args); end
end

URI::OPAQUE = T.let(T.unsafe(nil), Regexp)
URI::PORT = T.let(T.unsafe(nil), Regexp)
URI::Parser = URI::RFC2396_Parser
URI::QUERY = T.let(T.unsafe(nil), Regexp)
URI::REGEXP = URI::RFC2396_REGEXP
URI::REGISTRY = T.let(T.unsafe(nil), Regexp)
URI::REL_PATH = T.let(T.unsafe(nil), Regexp)
URI::REL_URI = T.let(T.unsafe(nil), Regexp)
URI::REL_URI_REF = T.let(T.unsafe(nil), Regexp)

class URI::RFC2396_Parser
  include ::URI::RFC2396_REGEXP
  def initialize(opts = T.unsafe(nil)); end
  def escape(str, unsafe = T.unsafe(nil)); end
  def extract(str, schemes = T.unsafe(nil)); end
  def inspect; end
  def join(*uris); end
  def make_regexp(schemes = T.unsafe(nil)); end
  def parse(uri); end
  def pattern; end
  def regexp; end
  def split(uri); end
  def unescape(str, escaped = T.unsafe(nil)); end
  private def convert_to_uri(uri); end
  private def initialize_pattern(opts = T.unsafe(nil)); end
  private def initialize_regexp(pattern); end
end

module URI::RFC2396_REGEXP; end
URI::RFC3986_PARSER = T.let(T.unsafe(nil), URI::RFC3986_Parser)

class URI::RFC3986_Parser
  def initialize; end
  def inspect; end
  def join(*uris); end
  def parse(uri); end
  def regexp; end
  def split(uri); end
  private def convert_to_uri(uri); end
  private def default_regexp; end
end

URI::SCHEME = T.let(T.unsafe(nil), Regexp)
URI::TBLDECWWWCOMP_ = T.let(T.unsafe(nil), Hash)
URI::TBLENCWWWCOMP_ = T.let(T.unsafe(nil), Hash)
URI::UNSAFE = T.let(T.unsafe(nil), Regexp)
URI::URI_REF = T.let(T.unsafe(nil), Regexp)
URI::USERINFO = T.let(T.unsafe(nil), Regexp)

module URI::Util
  private def make_components_hash(klass, array_hash); end
  def self.make_components_hash(klass, array_hash); end
end

URI::VERSION = T.let(T.unsafe(nil), String)
URI::VERSION_CODE = T.let(T.unsafe(nil), String)
URI::WEB_ENCODINGS_ = T.let(T.unsafe(nil), Hash)

class BasicSocket < ::IO
  def close_read; end
  def close_write; end
  def connect_address; end
  def do_not_reverse_lookup; end
  def do_not_reverse_lookup=(_arg0); end
  def getpeereid; end
  def getpeername; end
  def getsockname; end
  def getsockopt(_arg0, _arg1); end
  def local_address; end
  def recv(*_arg0); end
  def recv_nonblock(len, flag = T.unsafe(nil), str = T.unsafe(nil), exception: T.unsafe(nil)); end
  def recvmsg(dlen = T.unsafe(nil), flags = T.unsafe(nil), clen = T.unsafe(nil), scm_rights: T.unsafe(nil)); end
  def recvmsg_nonblock(dlen = T.unsafe(nil), flags = T.unsafe(nil), clen = T.unsafe(nil), scm_rights: T.unsafe(nil), exception: T.unsafe(nil)); end
  def remote_address; end
  def send(*_arg0); end
  def sendmsg(mesg, flags = T.unsafe(nil), dest_sockaddr = T.unsafe(nil), *controls); end
  def sendmsg_nonblock(mesg, flags = T.unsafe(nil), dest_sockaddr = T.unsafe(nil), *controls, exception: T.unsafe(nil)); end
  def setsockopt(*_arg0); end
  def shutdown(*_arg0); end
  private def __recv_nonblock(_arg0, _arg1, _arg2, _arg3); end
  private def __recvmsg(_arg0, _arg1, _arg2, _arg3); end
  private def __recvmsg_nonblock(_arg0, _arg1, _arg2, _arg3, _arg4); end
  private def __sendmsg(_arg0, _arg1, _arg2, _arg3); end
  private def __sendmsg_nonblock(_arg0, _arg1, _arg2, _arg3, _arg4); end
  def self.do_not_reverse_lookup; end
  def self.do_not_reverse_lookup=(_arg0); end
  def self.for_fd(_arg0); end
end

class IPAddr::AddressFamilyError < ::IPAddr::Error; end
class IPAddr::Error < ::ArgumentError; end
IPAddr::IN4MASK = T.let(T.unsafe(nil), Integer)
IPAddr::IN6FORMAT = T.let(T.unsafe(nil), String)
IPAddr::IN6MASK = T.let(T.unsafe(nil), Integer)
class IPAddr::InvalidAddressError < ::IPAddr::Error; end
class IPAddr::InvalidPrefixError < ::IPAddr::InvalidAddressError; end
IPAddr::RE_IPV4ADDRLIKE = T.let(T.unsafe(nil), Regexp)
IPAddr::RE_IPV6ADDRLIKE_COMPRESSED = T.let(T.unsafe(nil), Regexp)
IPAddr::RE_IPV6ADDRLIKE_FULL = T.let(T.unsafe(nil), Regexp)
Date::ABBR_DAYNAMES = T.let(T.unsafe(nil), Array)
Date::ABBR_MONTHNAMES = T.let(T.unsafe(nil), Array)
Date::DAYNAMES = T.let(T.unsafe(nil), Array)
Date::ENGLAND = T.let(T.unsafe(nil), Integer)
class Date::Error < ::ArgumentError; end
Date::GREGORIAN = T.let(T.unsafe(nil), Float)
Date::ITALY = T.let(T.unsafe(nil), Integer)

class Date::Infinity < ::Numeric
  def initialize(d = T.unsafe(nil)); end
  def +@; end
  def -@; end
  def <=>(other); end
  def abs; end
  def coerce(other); end
  def finite?; end
  def infinite?; end
  def nan?; end
  def to_f; end
  def zero?; end
  protected def d; end
end

Date::JULIAN = T.let(T.unsafe(nil), Float)
Date::MONTHNAMES = T.let(T.unsafe(nil), Array)

class OptionParser::AC < ::OptionParser
  def ac_arg_disable(name, help_string, &block); end
  def ac_arg_enable(name, help_string, &block); end
  def ac_arg_with(name, help_string, &block); end
  private def _ac_arg_enable(prefix, name, help_string, block); end
  private def _check_ac_args(name, block); end
end

module OptionParser::Acceptables; end
class OptionParser::AmbiguousArgument < ::OptionParser::InvalidArgument; end
class OptionParser::AmbiguousOption < ::OptionParser::ParseError; end

module OptionParser::Arguable
  def initialize(*args); end
  def getopts(*args); end
  def options; end
  def options=(opt); end
  def order!(&blk); end
  def parse!; end
  def permute!; end
  def self.extend_object(obj); end
end

OptionParser::ArgumentStyle = T.let(T.unsafe(nil), Hash)
OptionParser::COMPSYS_HEADER = T.let(T.unsafe(nil), String)

class OptionParser::CompletingHash < ::Hash
  include ::OptionParser::Completion
  def match(key); end
end

module OptionParser::Completion
  def candidate(key, icase = T.unsafe(nil), pat = T.unsafe(nil)); end
  def complete(key, icase = T.unsafe(nil), pat = T.unsafe(nil)); end
  def convert(opt = T.unsafe(nil), val = T.unsafe(nil), *_arg2); end
  def self.candidate(key, icase = T.unsafe(nil), pat = T.unsafe(nil), &block); end
  def self.regexp(key, icase); end
end

OptionParser::DecimalInteger = T.let(T.unsafe(nil), Regexp)
OptionParser::DecimalNumeric = T.let(T.unsafe(nil), Regexp)
OptionParser::DefaultList = T.let(T.unsafe(nil), OptionParser::List)
class OptionParser::InvalidArgument < ::OptionParser::ParseError; end
class OptionParser::InvalidOption < ::OptionParser::ParseError; end

class OptionParser::List
  def initialize; end
  def accept(t, pat = T.unsafe(nil), &block); end
  def add_banner(to); end
  def append(*args); end
  def atype; end
  def complete(id, opt, icase = T.unsafe(nil), *pat, &block); end
  def compsys(*args, &block); end
  def each_option(&block); end
  def get_candidates(id); end
  def list; end
  def long; end
  def prepend(*args); end
  def reject(t); end
  def search(id, key); end
  def short; end
  def summarize(*args, &block); end
  private def update(sw, sopts, lopts, nsw = T.unsafe(nil), nlopts = T.unsafe(nil)); end
end

class OptionParser::MissingArgument < ::OptionParser::ParseError; end
OptionParser::NO_ARGUMENT = T.let(T.unsafe(nil), Symbol)
class OptionParser::NeedlessArgument < ::OptionParser::ParseError; end
OptionParser::NoArgument = T.let(T.unsafe(nil), Array)
OptionParser::OPTIONAL_ARGUMENT = T.let(T.unsafe(nil), Symbol)
OptionParser::OctalInteger = T.let(T.unsafe(nil), Regexp)
OptionParser::Officious = T.let(T.unsafe(nil), Hash)

class OptionParser::OptionMap < ::Hash
  include ::OptionParser::Completion
end

OptionParser::OptionalArgument = T.let(T.unsafe(nil), Array)

class OptionParser::ParseError < ::RuntimeError
  def initialize(*args, additional: T.unsafe(nil)); end
  def additional; end
  def additional=(_arg0); end
  def args; end
  def inspect; end
  def message; end
  def reason; end
  def reason=(_arg0); end
  def recover(argv); end
  def set_backtrace(array); end
  def set_option(opt, eq); end
  def to_s; end
  def self.filter_backtrace(array); end
end

OptionParser::REQUIRED_ARGUMENT = T.let(T.unsafe(nil), Symbol)
OptionParser::RequiredArgument = T.let(T.unsafe(nil), Array)
OptionParser::SPLAT_PROC = T.let(T.unsafe(nil), Proc)

class OptionParser::Switch
  def initialize(pattern = T.unsafe(nil), conv = T.unsafe(nil), short = T.unsafe(nil), long = T.unsafe(nil), arg = T.unsafe(nil), desc = T.unsafe(nil), block = T.unsafe(nil), &_block); end
  def add_banner(to); end
  def arg; end
  def block; end
  def compsys(sdone, ldone); end
  def conv; end
  def desc; end
  def long; end
  def match_nonswitch?(str); end
  def pattern; end
  def short; end
  def summarize(sdone = T.unsafe(nil), ldone = T.unsafe(nil), width = T.unsafe(nil), max = T.unsafe(nil), indent = T.unsafe(nil)); end
  def switch_name; end
  private def conv_arg(arg, val = T.unsafe(nil)); end
  private def parse_arg(arg); end
  def self.guess(arg); end
  def self.incompatible_argument_styles(arg, t); end
  def self.pattern; end
end

OptionParser::Version = T.let(T.unsafe(nil), String)

module Comparable
  def <(_arg0); end
  def <=(_arg0); end
  def ==(_arg0); end
  def >(_arg0); end
  def >=(_arg0); end
  def between?(_arg0, _arg1); end
  def clamp(*_arg0); end
end

class StandardError < ::Exception; end
URI::FTP::COMPONENT = T.let(T.unsafe(nil), Array)
URI::FTP::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
URI::FTP::TYPECODE = T.let(T.unsafe(nil), Array)
URI::FTP::TYPECODE_PREFIX = T.let(T.unsafe(nil), String)
URI::File::COMPONENT = T.let(T.unsafe(nil), Array)
URI::Generic::COMPONENT = T.let(T.unsafe(nil), Array)
URI::HTTP::COMPONENT = T.let(T.unsafe(nil), Array)
URI::HTTP::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
URI::HTTPS::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
URI::LDAP::COMPONENT = T.let(T.unsafe(nil), Array)
URI::LDAP::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
URI::LDAP::SCOPE = T.let(T.unsafe(nil), Array)
URI::LDAP::SCOPE_BASE = T.let(T.unsafe(nil), String)
URI::LDAP::SCOPE_ONE = T.let(T.unsafe(nil), String)
URI::LDAP::SCOPE_SUB = T.let(T.unsafe(nil), String)
URI::LDAPS::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
URI::MailTo::COMPONENT = T.let(T.unsafe(nil), Array)
URI::MailTo::EMAIL_REGEXP = T.let(T.unsafe(nil), Regexp)
URI::MailTo::HEADER_REGEXP = T.let(T.unsafe(nil), Regexp)
module URI::RFC2396_REGEXP::PATTERN; end
URI::RFC3986_Parser::RFC3986_URI = T.let(T.unsafe(nil), Regexp)
URI::RFC3986_Parser::RFC3986_relative_ref = T.let(T.unsafe(nil), Regexp)

class IO
  include ::Enumerable
  include ::File::Constants
  def initialize(*_arg0); end
  def <<(_arg0); end
  def advise(*_arg0); end
  def autoclose=(_arg0); end
  def autoclose?; end
  def beep; end
  def binmode; end
  def binmode?; end
  def check_winsize_changed; end
  def clear_screen; end
  def close; end
  def close_on_exec=(_arg0); end
  def close_on_exec?; end
  def close_read; end
  def close_write; end
  def closed?; end
  def console_mode; end
  def console_mode=(_arg0); end
  def cooked; end
  def cooked!; end
  def cursor; end
  def cursor=(_arg0); end
  def cursor_down(_arg0); end
  def cursor_left(_arg0); end
  def cursor_right(_arg0); end
  def cursor_up(_arg0); end
  def each(*_arg0); end
  def each_byte; end
  def each_char; end
  def each_codepoint; end
  def each_line(*_arg0); end
  def echo=(_arg0); end
  def echo?; end
  def eof; end
  def eof?; end
  def erase_line(_arg0); end
  def erase_screen(_arg0); end
  def expect(pat, timeout = T.unsafe(nil)); end
  def external_encoding; end
  def fcntl(*_arg0); end
  def fdatasync; end
  def fileno; end
  def flush; end
  def fsync; end
  def getbyte; end
  def getc; end
  def getch(*_arg0); end
  def getpass(*_arg0); end
  def gets(*_arg0); end
  def goto(_arg0, _arg1); end
  def goto_column(_arg0); end
  def iflush; end
  def inspect; end
  def internal_encoding; end
  def ioctl(*_arg0); end
  def ioflush; end
  def isatty; end
  def lineno; end
  def lineno=(_arg0); end
  def noecho; end
  def nonblock(*_arg0); end
  def nonblock=(_arg0); end
  def nonblock?; end
  def nread; end
  def oflush; end
  def pathconf(_arg0); end
  def pid; end
  def pos; end
  def pos=(_arg0); end
  def pread(*_arg0); end
  def pressed?; end
  def print(*_arg0); end
  def printf(*_arg0); end
  def putc(_arg0); end
  def puts(*_arg0); end
  def pwrite(_arg0, _arg1); end
  def raw(*_arg0); end
  def raw!(*_arg0); end
  def read(*_arg0); end
  def read_nonblock(len, buf = T.unsafe(nil), exception: T.unsafe(nil)); end
  def readbyte; end
  def readchar; end
  def readline(*_arg0); end
  def readlines(*_arg0); end
  def readpartial(*_arg0); end
  def ready?; end
  def reopen(*_arg0); end
  def rewind; end
  def scroll_backward(_arg0); end
  def scroll_forward(_arg0); end
  def seek(*_arg0); end
  def set_encoding(*_arg0); end
  def set_encoding_by_bom; end
  def stat; end
  def sync; end
  def sync=(_arg0); end
  def sysread(*_arg0); end
  def sysseek(*_arg0); end
  def syswrite(_arg0); end
  def tell; end
  def to_i; end
  def to_io; end
  def tty?; end
  def ungetbyte(_arg0); end
  def ungetc(_arg0); end
  def wait(*_arg0); end
  def wait_priority(*_arg0); end
  def wait_readable(*_arg0); end
  def wait_writable(*_arg0); end
  def winsize; end
  def winsize=(_arg0); end
  def write(*_arg0); end
  def write_nonblock(buf, exception: T.unsafe(nil)); end
  private def initialize_copy(_arg0); end
  def self.binread(*_arg0); end
  def self.binwrite(*_arg0); end
  def self.console(*_arg0); end
  def self.copy_stream(*_arg0); end
  def self.for_fd(*_arg0); end
  def self.foreach(*_arg0); end
  def self.new(*_arg0); end
  def self.open(*_arg0); end
  def self.pipe(*_arg0); end
  def self.popen(*_arg0); end
  def self.read(*_arg0); end
  def self.readlines(*_arg0); end
  def self.select(*_arg0); end
  def self.sysopen(*_arg0); end
  def self.try_convert(_arg0); end
  def self.write(*_arg0); end
end

class ArgumentError < ::StandardError; end

class Numeric
  include ::Comparable
  def %(_arg0); end
  def +@; end
  def -@; end
  def <=>(_arg0); end
  def abs; end
  def abs2; end
  def angle; end
  def arg; end
  def ceil(*_arg0); end
  def clone(*_arg0); end
  def coerce(_arg0); end
  def conj; end
  def conjugate; end
  def denominator; end
  def div(_arg0); end
  def divmod(_arg0); end
  def dup; end
  def eql?(_arg0); end
  def fdiv(_arg0); end
  def finite?; end
  def floor(*_arg0); end
  def i; end
  def imag; end
  def imaginary; end
  def infinite?; end
  def integer?; end
  def magnitude; end
  def modulo(_arg0); end
  def negative?; end
  def nonzero?; end
  def numerator; end
  def phase; end
  def polar; end
  def positive?; end
  def quo(_arg0); end
  def real; end
  def real?; end
  def rect; end
  def rectangular; end
  def remainder(_arg0); end
  def round(*_arg0); end
  def singleton_method_added(_arg0); end
  def step(*_arg0); end
  def to_c; end
  def to_int; end
  def truncate(*_arg0); end
  def zero?; end
end

OptionParser::AC::ARG_CONV = T.let(T.unsafe(nil), Proc)
OptionParser::Acceptables::DecimalInteger = T.let(T.unsafe(nil), Regexp)
OptionParser::Acceptables::DecimalNumeric = T.let(T.unsafe(nil), Regexp)
OptionParser::Acceptables::OctalInteger = T.let(T.unsafe(nil), Regexp)
OptionParser::AmbiguousArgument::Reason = T.let(T.unsafe(nil), String)
OptionParser::AmbiguousOption::Reason = T.let(T.unsafe(nil), String)

class Hash
  include ::Enumerable
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  def initialize(*_arg0); end
  def <(_arg0); end
  def <=(_arg0); end
  def ==(_arg0); end
  def >(_arg0); end
  def >=(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def any?(*_arg0); end
  def assoc(_arg0); end
  def clear; end
  def compact; end
  def compact!; end
  def compare_by_identity; end
  def compare_by_identity?; end
  def deconstruct_keys(_arg0); end
  def default(*_arg0); end
  def default=(_arg0); end
  def default_proc; end
  def default_proc=(_arg0); end
  def delete(_arg0); end
  def delete_if; end
  def dig(*_arg0); end
  def each; end
  def each_key; end
  def each_pair; end
  def each_value; end
  def empty?; end
  def eql?(_arg0); end
  def except(*_arg0); end
  def fetch(*_arg0); end
  def fetch_values(*_arg0); end
  def filter; end
  def filter!; end
  def flatten(*_arg0); end
  def has_key?(_arg0); end
  def has_value?(_arg0); end
  def hash; end
  def include?(_arg0); end
  def inspect; end
  def invert; end
  def keep_if; end
  def key(_arg0); end
  def key?(_arg0); end
  def keys; end
  def length; end
  def member?(_arg0); end
  def merge(*_arg0); end
  def merge!(*_arg0); end
  def rassoc(_arg0); end
  def rehash; end
  def reject; end
  def reject!; end
  def replace(_arg0); end
  def select; end
  def select!; end
  def shift; end
  def size; end
  def slice(*_arg0); end
  def store(_arg0, _arg1); end
  def to_a; end
  def to_h; end
  def to_hash; end
  def to_proc; end
  def to_s; end
  def transform_keys(*_arg0); end
  def transform_keys!(*_arg0); end
  def transform_values; end
  def transform_values!; end
  def update(*_arg0); end
  def value?(_arg0); end
  def values; end
  def values_at(*_arg0); end
  private def initialize_copy(_arg0); end
  def self.[](*_arg0); end
  def self.ruby2_keywords_hash(_arg0); end
  def self.ruby2_keywords_hash?(_arg0); end
  def self.try_convert(_arg0); end
end

OptionParser::InvalidArgument::Reason = T.let(T.unsafe(nil), String)
OptionParser::InvalidOption::Reason = T.let(T.unsafe(nil), String)
OptionParser::MissingArgument::Reason = T.let(T.unsafe(nil), String)
OptionParser::NeedlessArgument::Reason = T.let(T.unsafe(nil), String)
class RuntimeError < ::StandardError; end
OptionParser::ParseError::Reason = T.let(T.unsafe(nil), String)

class OptionParser::Switch::NoArgument < ::OptionParser::Switch
  def parse(arg, argv); end
  def self.incompatible_argument_styles(*_arg0); end
  def self.pattern; end
end

class OptionParser::Switch::OptionalArgument < ::OptionParser::Switch
  def parse(arg, argv, &error); end
end

class OptionParser::Switch::PlacedArgument < ::OptionParser::Switch
  def parse(arg, argv, &error); end
end

class OptionParser::Switch::RequiredArgument < ::OptionParser::Switch
  def parse(arg, argv); end
end

module OpenURI::OpenRead
  def open(*rest, &block); end
  def read(options = T.unsafe(nil)); end
end

class Exception
  def initialize(*_arg0); end
  def ==(_arg0); end
  def backtrace; end
  def backtrace_locations; end
  def cause; end
  def exception(*_arg0); end
  def full_message(*_arg0); end
  def inspect; end
  def message; end
  def respond_to?(*_arg0); end
  def set_backtrace(_arg0); end
  def to_s; end
  private def method_missing(*_arg0); end
  private def respond_to_missing?(_arg0, _arg1); end
  def self.exception(*_arg0); end
  def self.to_tty?; end
end

URI::RFC2396_REGEXP::PATTERN::ABS_PATH = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::ABS_URI = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::ALNUM = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::ALPHA = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::DOMLABEL = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::ESCAPED = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::FRAGMENT = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::HEX = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::HIER_PART = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::HOST = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::HOSTNAME = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::HOSTPORT = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::IPV4ADDR = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::IPV6ADDR = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::IPV6REF = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::NET_PATH = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::OPAQUE_PART = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::PATH_SEGMENTS = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::PORT = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::QUERY = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::REG_NAME = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::REL_PATH = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::REL_SEGMENT = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::REL_URI = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::RESERVED = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::SCHEME = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::TOPLABEL = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::UNRESERVED = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::URIC = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::URIC_NO_SLASH = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::URI_REF = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::USERINFO = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::X_ABS_URI = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::X_REL_URI = T.let(T.unsafe(nil), String)

class IO::ConsoleMode
  def echo=(_arg0); end
  def raw(*_arg0); end
  def raw!(*_arg0); end
  private def initialize_copy(_arg0); end
end

class IO::EAGAINWaitReadable < ::Errno::EAGAIN
  include ::IO::WaitReadable
end

class IO::EAGAINWaitWritable < ::Errno::EAGAIN
  include ::IO::WaitWritable
end

class IO::EINPROGRESSWaitReadable < ::Errno::EINPROGRESS
  include ::IO::WaitReadable
end

class IO::EINPROGRESSWaitWritable < ::Errno::EINPROGRESS
  include ::IO::WaitWritable
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable
IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable
IO::PRIORITY = T.let(T.unsafe(nil), Integer)
IO::READABLE = T.let(T.unsafe(nil), Integer)
IO::SEEK_CUR = T.let(T.unsafe(nil), Integer)
IO::SEEK_DATA = T.let(T.unsafe(nil), Integer)
IO::SEEK_END = T.let(T.unsafe(nil), Integer)
IO::SEEK_HOLE = T.let(T.unsafe(nil), Integer)
IO::SEEK_SET = T.let(T.unsafe(nil), Integer)
IO::WRITABLE = T.let(T.unsafe(nil), Integer)
module IO::WaitReadable; end
module IO::WaitWritable; end

module Enumerable
  def all?(*_arg0); end
  def any?(*_arg0); end
  def chain(*_arg0); end
  def chunk; end
  def chunk_while; end
  def collect; end
  def collect_concat; end
  def count(*_arg0); end
  def cycle(*_arg0); end
  def detect(*_arg0); end
  def drop(_arg0); end
  def drop_while; end
  def each_cons(_arg0); end
  def each_entry(*_arg0); end
  def each_slice(_arg0); end
  def each_with_index(*_arg0); end
  def each_with_object(_arg0); end
  def entries(*_arg0); end
  def filter; end
  def filter_map; end
  def find(*_arg0); end
  def find_all; end
  def find_index(*_arg0); end
  def first(*_arg0); end
  def flat_map; end
  def grep(_arg0); end
  def grep_v(_arg0); end
  def group_by; end
  def include?(_arg0); end
  def inject(*_arg0); end
  def lazy; end
  def map; end
  def max(*_arg0); end
  def max_by(*_arg0); end
  def member?(_arg0); end
  def min(*_arg0); end
  def min_by(*_arg0); end
  def minmax; end
  def minmax_by; end
  def none?(*_arg0); end
  def one?(*_arg0); end
  def partition; end
  def reduce(*_arg0); end
  def reject; end
  def reverse_each(*_arg0); end
  def select; end
  def slice_after(*_arg0); end
  def slice_before(*_arg0); end
  def slice_when; end
  def sort; end
  def sort_by; end
  def sum(*_arg0); end
  def take(_arg0); end
  def take_while; end
  def tally; end
  def to_a(*_arg0); end
  def to_h(*_arg0); end
  def to_set(klass = T.unsafe(nil), *args, &block); end
  def uniq; end
  def zip(*_arg0); end
end

module File::Constants; end

module JSON::Ext::Generator::GeneratorMethods::Hash
  def to_json(*_arg0); end
end

class Errno::EAGAIN < ::SystemCallError; end
class Errno::EINPROGRESS < ::SystemCallError; end
File::Constants::APPEND = T.let(T.unsafe(nil), Integer)
File::Constants::BINARY = T.let(T.unsafe(nil), Integer)
File::Constants::CREAT = T.let(T.unsafe(nil), Integer)
File::Constants::DSYNC = T.let(T.unsafe(nil), Integer)
File::Constants::EXCL = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_CASEFOLD = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_DOTMATCH = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_EXTGLOB = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_NOESCAPE = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_PATHNAME = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_SHORTNAME = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_SYSCASE = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_EX = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_NB = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_SH = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_UN = T.let(T.unsafe(nil), Integer)
File::Constants::NOCTTY = T.let(T.unsafe(nil), Integer)
File::Constants::NOFOLLOW = T.let(T.unsafe(nil), Integer)
File::Constants::NONBLOCK = T.let(T.unsafe(nil), Integer)
File::Constants::NULL = T.let(T.unsafe(nil), String)
File::Constants::RDONLY = T.let(T.unsafe(nil), Integer)
File::Constants::RDWR = T.let(T.unsafe(nil), Integer)
File::Constants::SHARE_DELETE = T.let(T.unsafe(nil), Integer)
File::Constants::SYNC = T.let(T.unsafe(nil), Integer)
File::Constants::TRUNC = T.let(T.unsafe(nil), Integer)
File::Constants::WRONLY = T.let(T.unsafe(nil), Integer)

class SystemCallError < ::StandardError
  def initialize(*_arg0); end
  def errno; end
  def self.===(_arg0); end
end

Errno::EAGAIN::Errno = T.let(T.unsafe(nil), Integer)
Errno::EINPROGRESS::Errno = T.let(T.unsafe(nil), Integer)
class OpenStruct
  def initialize(hash = T.unsafe(nil)); end
  def ==(other); end
  def [](name); end
  def []=(name, value); end
  def __id__!; end
  def __send__!(*_arg0); end
  def class!; end
  def clone!(freeze: T.unsafe(nil)); end
  def define_singleton_method!(*_arg0); end
  def delete_field(name); end
  def delete_field!(name); end
  def dig(name, *names); end
  def dig!(name, *names); end
  def display!(*_arg0); end
  def dup!; end
  def each_pair; end
  def each_pair!; end
  def encode_with(coder); end
  def encode_with!(coder); end
  def enum_for!(*_arg0); end
  def eql?(other); end
  def extend!(*_arg0); end
  def freeze; end
  def freeze!; end
  def gem!(dep, *reqs); end
  def hash; end
  def hash!; end
  def init_with(coder); end
  def init_with!(coder); end
  def inspect; end
  def inspect!; end
  def instance_eval!(*_arg0); end
  def instance_exec!(*_arg0); end
  def instance_variable_get!(_arg0); end
  def instance_variable_set!(_arg0, _arg1); end
  def instance_variables!; end
  def itself!; end
  def marshal_dump; end
  def marshal_dump!; end
  def method!(_arg0); end
  def methods!(*_arg0); end
  def object_id!; end
  def private_methods!(*_arg0); end
  def protected_methods!(*_arg0); end
  def public_method!(_arg0); end
  def public_methods!(*_arg0); end
  def public_send!(*_arg0); end
  def remove_instance_variable!(_arg0); end
  def send!(*_arg0); end
  def singleton_class!; end
  def singleton_method!(_arg0); end
  def singleton_methods!(*_arg0); end
  def table; end
  def taint!; end
  def tap!; end
  def then!; end
  def to_enum!(*_arg0); end
  def to_h(&block); end
  def to_h!(&block); end
  def to_s; end
  def to_s!; end
  def trust!; end
  def untaint!; end
  def untrust!; end
  def yield_self!; end
  protected def table!; end
  private def initialize_clone(orig); end
  private def initialize_dup(orig); end
  private def is_method_protected!(name); end
  private def marshal_load(hash); end
  private def method_missing(mid, *args); end
  private def new_ostruct_member!(name); end
  private def raise!(*_arg0); end
  private def set_ostruct_member_value!(name, value); end
  private def update_to_values!(hash); end
end

OpenStruct::InspectKey = T.let(T.unsafe(nil), Symbol)
OpenStruct::VERSION = T.let(T.unsafe(nil), String)
class PrettyPrint
  def initialize(output = T.unsafe(nil), maxwidth = T.unsafe(nil), newline = T.unsafe(nil), &genspace); end
  def break_outmost_groups; end
  def breakable(sep = T.unsafe(nil), width = T.unsafe(nil)); end
  def current_group; end
  def fill_breakable(sep = T.unsafe(nil), width = T.unsafe(nil)); end
  def flush; end
  def genspace; end
  def group(indent = T.unsafe(nil), open_obj = T.unsafe(nil), close_obj = T.unsafe(nil), open_width = T.unsafe(nil), close_width = T.unsafe(nil)); end
  def group_queue; end
  def group_sub; end
  def indent; end
  def maxwidth; end
  def nest(indent); end
  def newline; end
  def output; end
  def text(obj, width = T.unsafe(nil)); end
  def self.format(output = T.unsafe(nil), maxwidth = T.unsafe(nil), newline = T.unsafe(nil), genspace = T.unsafe(nil)); end
  def self.singleline_format(output = T.unsafe(nil), maxwidth = T.unsafe(nil), newline = T.unsafe(nil), genspace = T.unsafe(nil)); end
end

class PP < ::PrettyPrint
  include ::PP::PPMethods
  def self.mcall(obj, mod, meth, *args, &block); end
  def self.pp(obj, out = T.unsafe(nil), width = T.unsafe(nil)); end
  def self.sharing_detection; end
  def self.sharing_detection=(b); end
  def self.singleline_pp(obj, out = T.unsafe(nil)); end
end

class PrettyPrint::Breakable
  def initialize(sep, width, q); end
  def indent; end
  def obj; end
  def output(out, output_width); end
  def width; end
end

class PrettyPrint::Group
  def initialize(depth); end
  def break; end
  def break?; end
  def breakables; end
  def depth; end
  def first?; end
end

class PrettyPrint::GroupQueue
  def initialize(*groups); end
  def delete(group); end
  def deq; end
  def enq(group); end
end

class PrettyPrint::SingleLine
  def initialize(output, maxwidth = T.unsafe(nil), newline = T.unsafe(nil)); end
  def breakable(sep = T.unsafe(nil), width = T.unsafe(nil)); end
  def first?; end
  def flush; end
  def group(indent = T.unsafe(nil), open_obj = T.unsafe(nil), close_obj = T.unsafe(nil), open_width = T.unsafe(nil), close_width = T.unsafe(nil)); end
  def nest(indent); end
  def text(obj, width = T.unsafe(nil)); end
end

class PrettyPrint::Text
  def initialize; end
  def add(obj, width); end
  def output(out, output_width); end
  def width; end
end

module PP::ObjectMixin
  def pretty_print(q); end
  def pretty_print_cycle(q); end
  def pretty_print_inspect; end
  def pretty_print_instance_variables; end
end

module PP::PPMethods
  def check_inspect_key(id); end
  def comma_breakable; end
  def guard_inspect_key; end
  def object_address_group(obj, &block); end
  def object_group(obj, &block); end
  def pop_inspect_key(id); end
  def pp(obj); end
  def pp_hash(obj); end
  def pp_object(obj); end
  def push_inspect_key(id); end
  def seplist(list, sep = T.unsafe(nil), iter_method = T.unsafe(nil)); end
end

class PP::SingleLine < ::PrettyPrint::SingleLine
  include ::PP::PPMethods
end
class PrettyPrint
  def initialize(output = T.unsafe(nil), maxwidth = T.unsafe(nil), newline = T.unsafe(nil), &genspace); end
  def break_outmost_groups; end
  def breakable(sep = T.unsafe(nil), width = T.unsafe(nil)); end
  def current_group; end
  def fill_breakable(sep = T.unsafe(nil), width = T.unsafe(nil)); end
  def flush; end
  def genspace; end
  def group(indent = T.unsafe(nil), open_obj = T.unsafe(nil), close_obj = T.unsafe(nil), open_width = T.unsafe(nil), close_width = T.unsafe(nil)); end
  def group_queue; end
  def group_sub; end
  def indent; end
  def maxwidth; end
  def nest(indent); end
  def newline; end
  def output; end
  def text(obj, width = T.unsafe(nil)); end
  def self.format(output = T.unsafe(nil), maxwidth = T.unsafe(nil), newline = T.unsafe(nil), genspace = T.unsafe(nil)); end
  def self.singleline_format(output = T.unsafe(nil), maxwidth = T.unsafe(nil), newline = T.unsafe(nil), genspace = T.unsafe(nil)); end
end

class PrettyPrint::Breakable
  def initialize(sep, width, q); end
  def indent; end
  def obj; end
  def output(out, output_width); end
  def width; end
end

class PrettyPrint::Group
  def initialize(depth); end
  def break; end
  def break?; end
  def breakables; end
  def depth; end
  def first?; end
end

class PrettyPrint::GroupQueue
  def initialize(*groups); end
  def delete(group); end
  def deq; end
  def enq(group); end
end

class PrettyPrint::SingleLine
  def initialize(output, maxwidth = T.unsafe(nil), newline = T.unsafe(nil)); end
  def breakable(sep = T.unsafe(nil), width = T.unsafe(nil)); end
  def first?; end
  def flush; end
  def group(indent = T.unsafe(nil), open_obj = T.unsafe(nil), close_obj = T.unsafe(nil), open_width = T.unsafe(nil), close_width = T.unsafe(nil)); end
  def nest(indent); end
  def text(obj, width = T.unsafe(nil)); end
end

class PrettyPrint::Text
  def initialize; end
  def add(obj, width); end
  def output(out, output_width); end
  def width; end
end
module SingleForwardable
  def def_delegator(accessor, method, ali = T.unsafe(nil)); end
  def def_delegators(accessor, *methods); end
  def def_single_delegator(accessor, method, ali = T.unsafe(nil)); end
  def def_single_delegators(accessor, *methods); end
  def delegate(hash); end
  def single_delegate(hash); end
end

class Prime
  include ::Enumerable
  include ::Singleton
  extend ::Singleton::SingletonClassMethods
  extend ::Enumerable
  def each(ubound = T.unsafe(nil), generator = T.unsafe(nil), &block); end
  def include?(obj); end
  def int_from_prime_division(pd); end
  def prime?(value, generator = T.unsafe(nil)); end
  def prime_division(value, generator = T.unsafe(nil)); end
  def self.each(*args, &block); end
  def self.include?(*args, &block); end
  def self.int_from_prime_division(*args, &block); end
  def self.method_added(method); end
  def self.prime?(*args, &block); end
  def self.prime_division(*args, &block); end
end

module Singleton
  mixes_in_class_methods ::Singleton::SingletonClassMethods
  def _dump(depth = T.unsafe(nil)); end
  def clone; end
  def dup; end
  def self.__init__(klass); end
  private def self.append_features(mod); end
  private def self.included(klass); end
end

module Forwardable
  def def_delegator(accessor, method, ali = T.unsafe(nil)); end
  def def_delegators(accessor, *methods); end
  def def_instance_delegator(accessor, method, ali = T.unsafe(nil)); end
  def def_instance_delegators(accessor, *methods); end
  def delegate(hash); end
  def instance_delegate(hash); end
  def self._compile_method(src, file, line); end
  def self._delegator_method(obj, accessor, method, ali); end
  def self._valid_method?(method); end
  def self.debug; end
  def self.debug=(_arg0); end
end

class Prime::EratosthenesGenerator < ::Prime::PseudoPrimeGenerator
  def initialize; end
  def next; end
  def rewind; end
  def succ; end
end

class Prime::EratosthenesSieve
  include ::Singleton
  extend ::Singleton::SingletonClassMethods
  def initialize; end
  def get_nth_prime(n); end
  private def compute_primes; end
end

class Prime::Generator23 < ::Prime::PseudoPrimeGenerator
  def initialize; end
  def next; end
  def rewind; end
  def succ; end
end

class Prime::PseudoPrimeGenerator
  include ::Enumerable
  def initialize(ubound = T.unsafe(nil)); end
  def each; end
  def next; end
  def rewind; end
  def size; end
  def succ; end
  def upper_bound; end
  def upper_bound=(ubound); end
  def with_index(offset = T.unsafe(nil), &block); end
  def with_object(obj); end
end

class Prime::TrialDivision
  include ::Singleton
  extend ::Singleton::SingletonClassMethods
  def initialize; end
  def [](index); end
end

class Prime::TrialDivisionGenerator < ::Prime::PseudoPrimeGenerator
  def initialize; end
  def next; end
  def rewind; end
  def succ; end
end

Prime::VERSION = T.let(T.unsafe(nil), String)

module Singleton::SingletonClassMethods
  def _load(str); end
  def clone; end
  def instance; end
  private def inherited(sub_klass); end
end

Singleton::VERSION = T.let(T.unsafe(nil), String)
Forwardable::FORWARDABLE_VERSION = T.let(T.unsafe(nil), String)
Forwardable::VERSION = T.let(T.unsafe(nil), String)

module Enumerable
  def all?(*_arg0); end
  def any?(*_arg0); end
  def chain(*_arg0); end
  def chunk; end
  def chunk_while; end
  def collect; end
  def collect_concat; end
  def count(*_arg0); end
  def cycle(*_arg0); end
  def detect(*_arg0); end
  def drop(_arg0); end
  def drop_while; end
  def each_cons(_arg0); end
  def each_entry(*_arg0); end
  def each_slice(_arg0); end
  def each_with_index(*_arg0); end
  def each_with_object(_arg0); end
  def entries(*_arg0); end
  def filter; end
  def filter_map; end
  def find(*_arg0); end
  def find_all; end
  def find_index(*_arg0); end
  def first(*_arg0); end
  def flat_map; end
  def grep(_arg0); end
  def grep_v(_arg0); end
  def group_by; end
  def include?(_arg0); end
  def inject(*_arg0); end
  def lazy; end
  def map; end
  def max(*_arg0); end
  def max_by(*_arg0); end
  def member?(_arg0); end
  def min(*_arg0); end
  def min_by(*_arg0); end
  def minmax; end
  def minmax_by; end
  def none?(*_arg0); end
  def one?(*_arg0); end
  def partition; end
  def reduce(*_arg0); end
  def reject; end
  def reverse_each(*_arg0); end
  def select; end
  def slice_after(*_arg0); end
  def slice_before(*_arg0); end
  def slice_when; end
  def sort; end
  def sort_by; end
  def sum(*_arg0); end
  def take(_arg0); end
  def take_while; end
  def tally; end
  def to_a(*_arg0); end
  def to_h(*_arg0); end
  def to_set(klass = T.unsafe(nil), *args, &block); end
  def uniq; end
  def zip(*_arg0); end
end
class PStore
  def initialize(file, thread_safe = T.unsafe(nil)); end
  def [](name); end
  def []=(name, value); end
  def abort; end
  def commit; end
  def delete(name); end
  def fetch(name, default = T.unsafe(nil)); end
  def path; end
  def root?(name); end
  def roots; end
  def transaction(read_only = T.unsafe(nil)); end
  def ultra_safe; end
  def ultra_safe=(_arg0); end
  private def dump(table); end
  private def empty_marshal_checksum; end
  private def empty_marshal_data; end
  private def in_transaction; end
  private def in_transaction_wr; end
  private def load(content); end
  private def load_data(file, read_only); end
  private def on_windows?; end
  private def open_and_lock_file(filename, read_only); end
  private def save_data(original_checksum, original_file_size, file); end
  private def save_data_with_atomic_file_rename_strategy(data, file); end
  private def save_data_with_fast_strategy(data, file); end
end

module Digest
  private def hexencode(_arg0); end
  def self.const_missing(name); end
  def self.hexencode(_arg0); end
end

PStore::CHECKSUM_ALGO = Digest::SHA512
PStore::EMPTY_MARSHAL_CHECKSUM = T.let(T.unsafe(nil), String)
PStore::EMPTY_MARSHAL_DATA = T.let(T.unsafe(nil), String)
PStore::EMPTY_STRING = T.let(T.unsafe(nil), String)
class PStore::Error < ::StandardError; end
PStore::RDWR_ACCESS = T.let(T.unsafe(nil), Hash)
PStore::RD_ACCESS = T.let(T.unsafe(nil), Hash)
PStore::VERSION = T.let(T.unsafe(nil), String)
PStore::WR_ACCESS = T.let(T.unsafe(nil), Hash)

class Digest::Base < ::Digest::Class
  def <<(_arg0); end
  def block_length; end
  def digest_length; end
  def reset; end
  def update(_arg0); end
  private def finish; end
  private def initialize_copy(_arg0); end
end

class Digest::Class
  include ::Digest::Instance
  def initialize; end
  def self.base64digest(str, *args); end
  def self.digest(*_arg0); end
  def self.file(name, *args); end
  def self.hexdigest(*_arg0); end
end

module Digest::Instance
  def <<(_arg0); end
  def ==(_arg0); end
  def base64digest(str = T.unsafe(nil)); end
  def base64digest!; end
  def block_length; end
  def digest(*_arg0); end
  def digest!; end
  def digest_length; end
  def file(name); end
  def hexdigest(*_arg0); end
  def hexdigest!; end
  def inspect; end
  def length; end
  def new; end
  def reset; end
  def size; end
  def to_s; end
  def update(_arg0); end
  private def finish; end
end

class Digest::MD5 < ::Digest::Base; end
Digest::REQUIRE_MUTEX = T.let(T.unsafe(nil), Thread::Mutex)
class Digest::SHA1 < ::Digest::Base; end

class Digest::SHA2 < ::Digest::Class
  def initialize(bitlen = T.unsafe(nil)); end
  def <<(str); end
  def block_length; end
  def digest_length; end
  def inspect; end
  def reset; end
  def update(str); end
  private def finish; end
  private def initialize_copy(other); end
end

class Digest::SHA256 < ::Digest::Base; end
class Digest::SHA384 < ::Digest::Base; end
class Digest::SHA512 < ::Digest::Base; end
Digest::VERSION = T.let(T.unsafe(nil), String)
class StandardError < ::Exception; end

class Exception
  def initialize(*_arg0); end
  def ==(_arg0); end
  def backtrace; end
  def backtrace_locations; end
  def cause; end
  def exception(*_arg0); end
  def full_message(*_arg0); end
  def inspect; end
  def message; end
  def respond_to?(*_arg0); end
  def set_backtrace(_arg0); end
  def to_s; end
  private def method_missing(*_arg0); end
  private def respond_to_missing?(_arg0, _arg1); end
  def self.exception(*_arg0); end
  def self.to_tty?; end
end


class BasicSocket < ::IO
  def close_read; end
  def close_write; end
  def connect_address; end
  def do_not_reverse_lookup; end
  def do_not_reverse_lookup=(_arg0); end
  def getpeereid; end
  def getpeername; end
  def getsockname; end
  def getsockopt(_arg0, _arg1); end
  def local_address; end
  def recv(*_arg0); end
  def recv_nonblock(len, flag = T.unsafe(nil), str = T.unsafe(nil), exception: T.unsafe(nil)); end
  def recvmsg(dlen = T.unsafe(nil), flags = T.unsafe(nil), clen = T.unsafe(nil), scm_rights: T.unsafe(nil)); end
  def recvmsg_nonblock(dlen = T.unsafe(nil), flags = T.unsafe(nil), clen = T.unsafe(nil), scm_rights: T.unsafe(nil), exception: T.unsafe(nil)); end
  def remote_address; end
  def send(*_arg0); end
  def sendmsg(mesg, flags = T.unsafe(nil), dest_sockaddr = T.unsafe(nil), *controls); end
  def sendmsg_nonblock(mesg, flags = T.unsafe(nil), dest_sockaddr = T.unsafe(nil), *controls, exception: T.unsafe(nil)); end
  def setsockopt(*_arg0); end
  def shutdown(*_arg0); end
  private def __recv_nonblock(_arg0, _arg1, _arg2, _arg3); end
  private def __recvmsg(_arg0, _arg1, _arg2, _arg3); end
  private def __recvmsg_nonblock(_arg0, _arg1, _arg2, _arg3, _arg4); end
  private def __sendmsg(_arg0, _arg1, _arg2, _arg3); end
  private def __sendmsg_nonblock(_arg0, _arg1, _arg2, _arg3, _arg4); end
  def self.do_not_reverse_lookup; end
  def self.do_not_reverse_lookup=(_arg0); end
  def self.for_fd(_arg0); end
end

module Timeout
  private def timeout(sec, klass = T.unsafe(nil), message = T.unsafe(nil), &block); end
  def self.timeout(sec, klass = T.unsafe(nil), message = T.unsafe(nil), &block); end
end

class TCPServer < ::TCPSocket
  def initialize(*_arg0); end
  def accept; end
  def accept_nonblock(exception: T.unsafe(nil)); end
  def listen(_arg0); end
  def sysaccept; end
  private def __accept_nonblock(_arg0); end
end

class UNIXServer < ::UNIXSocket
  def initialize(_arg0); end
  def accept; end
  def accept_nonblock(exception: T.unsafe(nil)); end
  def listen(_arg0); end
  def sysaccept; end
  private def __accept_nonblock(_arg0); end
end

class UNIXSocket < ::BasicSocket
  def initialize(_arg0); end
  def addr; end
  def path; end
  def peeraddr; end
  def recv_io(*_arg0); end
  def recvfrom(*_arg0); end
  def send_io(_arg0); end
  def self.pair(*_arg0); end
  def self.socketpair(*_arg0); end
end

module SecureRandom
  extend ::Random::Formatter
  def self.bytes(n); end
  def self.gen_random(n); end
  private def self.gen_random_openssl(n); end
  private def self.gen_random_urandom(n); end
end

class IPSocket < ::BasicSocket
  def addr(*_arg0); end
  def inspect; end
  def peeraddr(*_arg0); end
  def recvfrom(*_arg0); end
  def self.getaddress(host); end
  def self.original_resolv_getaddress(_arg0); end
end

class Resolv
  def initialize(resolvers = T.unsafe(nil)); end
  def each_address(name); end
  def each_name(address); end
  def getaddress(name); end
  def getaddresses(name); end
  def getname(address); end
  def getnames(address); end
  def self.each_address(name, &block); end
  def self.each_name(address, &proc); end
  def self.getaddress(name); end
  def self.getaddresses(name); end
  def self.getname(address); end
  def self.getnames(address); end
end

class SocketError < ::StandardError; end

class TCPSocket < ::IPSocket
  def initialize(host, serv, *rest); end
  private def original_resolv_initialize(*_arg0); end
  def self.gethostbyname(_arg0); end
end

class UDPSocket < ::IPSocket
  def initialize(*_arg0); end
  def bind(host, port); end
  def connect(host, port); end
  def original_resolv_bind(_arg0, _arg1); end
  def original_resolv_connect(_arg0, _arg1); end
  def original_resolv_send(*_arg0); end
  def recvfrom_nonblock(len, flag = T.unsafe(nil), outbuf = T.unsafe(nil), exception: T.unsafe(nil)); end
  def send(mesg, flags, *rest); end
  private def __recvfrom_nonblock(_arg0, _arg1, _arg2, _arg3); end
end

class Addrinfo
  def initialize(*_arg0); end
  def afamily; end
  def bind; end
  def canonname; end
  def connect(timeout: T.unsafe(nil), &block); end
  def connect_from(*args, timeout: T.unsafe(nil), &block); end
  def connect_to(*args, timeout: T.unsafe(nil), &block); end
  def family_addrinfo(*args); end
  def getnameinfo(*_arg0); end
  def inspect; end
  def inspect_sockaddr; end
  def ip?; end
  def ip_address; end
  def ip_port; end
  def ip_unpack; end
  def ipv4?; end
  def ipv4_loopback?; end
  def ipv4_multicast?; end
  def ipv4_private?; end
  def ipv6?; end
  def ipv6_linklocal?; end
  def ipv6_loopback?; end
  def ipv6_mc_global?; end
  def ipv6_mc_linklocal?; end
  def ipv6_mc_nodelocal?; end
  def ipv6_mc_orglocal?; end
  def ipv6_mc_sitelocal?; end
  def ipv6_multicast?; end
  def ipv6_sitelocal?; end
  def ipv6_to_ipv4; end
  def ipv6_unique_local?; end
  def ipv6_unspecified?; end
  def ipv6_v4compat?; end
  def ipv6_v4mapped?; end
  def listen(backlog = T.unsafe(nil)); end
  def marshal_dump; end
  def marshal_load(_arg0); end
  def pfamily; end
  def protocol; end
  def socktype; end
  def to_s; end
  def to_sockaddr; end
  def unix?; end
  def unix_path; end
  protected def connect_internal(local_addrinfo, timeout = T.unsafe(nil)); end
  def self.foreach(nodename, service, family = T.unsafe(nil), socktype = T.unsafe(nil), protocol = T.unsafe(nil), flags = T.unsafe(nil), timeout: T.unsafe(nil), &block); end
  def self.getaddrinfo(*_arg0); end
  def self.ip(_arg0); end
  def self.tcp(_arg0, _arg1); end
  def self.udp(_arg0, _arg1); end
  def self.unix(*_arg0); end
end

class Socket < ::BasicSocket
  def initialize(*_arg0); end
  def accept; end
  def accept_nonblock(exception: T.unsafe(nil)); end
  def bind(_arg0); end
  def connect(_arg0); end
  def connect_nonblock(addr, exception: T.unsafe(nil)); end
  def ipv6only!; end
  def listen(_arg0); end
  def recvfrom(*_arg0); end
  def recvfrom_nonblock(len, flag = T.unsafe(nil), str = T.unsafe(nil), exception: T.unsafe(nil)); end
  def sysaccept; end
  private def __accept_nonblock(_arg0); end
  private def __connect_nonblock(_arg0, _arg1); end
  private def __recvfrom_nonblock(_arg0, _arg1, _arg2, _arg3); end
  def self.accept_loop(*sockets); end
  def self.getaddrinfo(*_arg0); end
  def self.gethostbyaddr(*_arg0); end
  def self.gethostbyname(_arg0); end
  def self.gethostname; end
  def self.getifaddrs; end
  def self.getnameinfo(*_arg0); end
  def self.getservbyname(*_arg0); end
  def self.getservbyport(*_arg0); end
  def self.ip_address_list; end
  def self.pack_sockaddr_in(_arg0, _arg1); end
  def self.pack_sockaddr_un(_arg0); end
  def self.pair(*_arg0); end
  def self.sockaddr_in(_arg0, _arg1); end
  def self.sockaddr_un(_arg0); end
  def self.socketpair(*_arg0); end
  def self.tcp(host, port, local_host = T.unsafe(nil), local_port = T.unsafe(nil), connect_timeout: T.unsafe(nil), resolv_timeout: T.unsafe(nil)); end
  def self.tcp_server_loop(host = T.unsafe(nil), port, &b); end
  def self.tcp_server_sockets(host = T.unsafe(nil), port); end
  def self.udp_server_loop(host = T.unsafe(nil), port, &b); end
  def self.udp_server_loop_on(sockets, &b); end
  def self.udp_server_recv(sockets); end
  def self.udp_server_sockets(host = T.unsafe(nil), port); end
  def self.unix(path); end
  def self.unix_server_loop(path, &b); end
  def self.unix_server_socket(path); end
  def self.unpack_sockaddr_in(_arg0); end
  def self.unpack_sockaddr_un(_arg0); end
  private def self.ip_sockets_port0(ai_list, reuseaddr); end
  private def self.tcp_server_sockets_port0(host); end
  private def self.unix_socket_abstract_name?(path); end
end

class IO
  include ::Enumerable
  include ::File::Constants
  def initialize(*_arg0); end
  def <<(_arg0); end
  def advise(*_arg0); end
  def autoclose=(_arg0); end
  def autoclose?; end
  def beep; end
  def binmode; end
  def binmode?; end
  def check_winsize_changed; end
  def clear_screen; end
  def close; end
  def close_on_exec=(_arg0); end
  def close_on_exec?; end
  def close_read; end
  def close_write; end
  def closed?; end
  def console_mode; end
  def console_mode=(_arg0); end
  def cooked; end
  def cooked!; end
  def cursor; end
  def cursor=(_arg0); end
  def cursor_down(_arg0); end
  def cursor_left(_arg0); end
  def cursor_right(_arg0); end
  def cursor_up(_arg0); end
  def each(*_arg0); end
  def each_byte; end
  def each_char; end
  def each_codepoint; end
  def each_line(*_arg0); end
  def echo=(_arg0); end
  def echo?; end
  def eof; end
  def eof?; end
  def erase_line(_arg0); end
  def erase_screen(_arg0); end
  def expect(pat, timeout = T.unsafe(nil)); end
  def external_encoding; end
  def fcntl(*_arg0); end
  def fdatasync; end
  def fileno; end
  def flush; end
  def fsync; end
  def getbyte; end
  def getc; end
  def getch(*_arg0); end
  def getpass(*_arg0); end
  def gets(*_arg0); end
  def goto(_arg0, _arg1); end
  def goto_column(_arg0); end
  def iflush; end
  def inspect; end
  def internal_encoding; end
  def ioctl(*_arg0); end
  def ioflush; end
  def isatty; end
  def lineno; end
  def lineno=(_arg0); end
  def noecho; end
  def nonblock(*_arg0); end
  def nonblock=(_arg0); end
  def nonblock?; end
  def nread; end
  def oflush; end
  def pathconf(_arg0); end
  def pid; end
  def pos; end
  def pos=(_arg0); end
  def pread(*_arg0); end
  def pressed?; end
  def print(*_arg0); end
  def printf(*_arg0); end
  def putc(_arg0); end
  def puts(*_arg0); end
  def pwrite(_arg0, _arg1); end
  def raw(*_arg0); end
  def raw!(*_arg0); end
  def read(*_arg0); end
  def read_nonblock(len, buf = T.unsafe(nil), exception: T.unsafe(nil)); end
  def readbyte; end
  def readchar; end
  def readline(*_arg0); end
  def readlines(*_arg0); end
  def readpartial(*_arg0); end
  def ready?; end
  def reopen(*_arg0); end
  def rewind; end
  def scroll_backward(_arg0); end
  def scroll_forward(_arg0); end
  def seek(*_arg0); end
  def set_encoding(*_arg0); end
  def set_encoding_by_bom; end
  def stat; end
  def sync; end
  def sync=(_arg0); end
  def sysread(*_arg0); end
  def sysseek(*_arg0); end
  def syswrite(_arg0); end
  def tell; end
  def to_i; end
  def to_io; end
  def tty?; end
  def ungetbyte(_arg0); end
  def ungetc(_arg0); end
  def wait(*_arg0); end
  def wait_priority(*_arg0); end
  def wait_readable(*_arg0); end
  def wait_writable(*_arg0); end
  def winsize; end
  def winsize=(_arg0); end
  def write(*_arg0); end
  def write_nonblock(buf, exception: T.unsafe(nil)); end
  private def initialize_copy(_arg0); end
  def self.binread(*_arg0); end
  def self.binwrite(*_arg0); end
  def self.console(*_arg0); end
  def self.copy_stream(*_arg0); end
  def self.for_fd(*_arg0); end
  def self.foreach(*_arg0); end
  def self.new(*_arg0); end
  def self.open(*_arg0); end
  def self.pipe(*_arg0); end
  def self.popen(*_arg0); end
  def self.read(*_arg0); end
  def self.readlines(*_arg0); end
  def self.select(*_arg0); end
  def self.sysopen(*_arg0); end
  def self.try_convert(_arg0); end
  def self.write(*_arg0); end
end

class Timeout::Error < ::RuntimeError
  def exception(*_arg0); end
  def thread; end
  def self.catch(*args); end
end

Timeout::VERSION = T.let(T.unsafe(nil), String)
Resolv::AddressRegex = T.let(T.unsafe(nil), Regexp)

class Resolv::DNS
  def initialize(config_info = T.unsafe(nil)); end
  def close; end
  def each_address(name); end
  def each_name(address); end
  def each_resource(name, typeclass, &proc); end
  def extract_resources(msg, name, typeclass); end
  def fetch_resource(name, typeclass); end
  def getaddress(name); end
  def getaddresses(name); end
  def getname(address); end
  def getnames(address); end
  def getresource(name, typeclass); end
  def getresources(name, typeclass); end
  def lazy_initialize; end
  def make_tcp_requester(host, port); end
  def make_udp_requester; end
  def timeouts=(values); end
  private def use_ipv6?; end
  def self.allocate_request_id(host, port); end
  def self.bind_random_port(udpsock, bind_host = T.unsafe(nil)); end
  def self.free_request_id(host, port, id); end
  def self.open(*args); end
  def self.random(arg); end
end

Resolv::DefaultResolver = T.let(T.unsafe(nil), Resolv)

class Resolv::Hosts
  def initialize(filename = T.unsafe(nil)); end
  def each_address(name, &proc); end
  def each_name(address, &proc); end
  def getaddress(name); end
  def getaddresses(name); end
  def getname(address); end
  def getnames(address); end
  def lazy_initialize; end
end

class Resolv::IPv4
  def initialize(address); end
  def ==(other); end
  def address; end
  def eql?(other); end
  def hash; end
  def inspect; end
  def to_name; end
  def to_s; end
  def self.create(arg); end
end

class Resolv::IPv6
  def initialize(address); end
  def ==(other); end
  def address; end
  def eql?(other); end
  def hash; end
  def inspect; end
  def to_name; end
  def to_s; end
  def self.create(arg); end
end

module Resolv::LOC; end

class Resolv::MDNS < ::Resolv::DNS
  def initialize(config_info = T.unsafe(nil)); end
  def each_address(name); end
  def make_udp_requester; end
end

class Resolv::ResolvError < ::StandardError; end
class Resolv::ResolvTimeout < ::Timeout::Error; end
class StandardError < ::Exception; end
Socket::AF_APPLETALK = T.let(T.unsafe(nil), Integer)
Socket::AF_CCITT = T.let(T.unsafe(nil), Integer)
Socket::AF_CHAOS = T.let(T.unsafe(nil), Integer)
Socket::AF_CNT = T.let(T.unsafe(nil), Integer)
Socket::AF_COIP = T.let(T.unsafe(nil), Integer)
Socket::AF_DATAKIT = T.let(T.unsafe(nil), Integer)
Socket::AF_DLI = T.let(T.unsafe(nil), Integer)
Socket::AF_E164 = T.let(T.unsafe(nil), Integer)
Socket::AF_ECMA = T.let(T.unsafe(nil), Integer)
Socket::AF_HYLINK = T.let(T.unsafe(nil), Integer)
Socket::AF_IMPLINK = T.let(T.unsafe(nil), Integer)
Socket::AF_INET = T.let(T.unsafe(nil), Integer)
Socket::AF_INET6 = T.let(T.unsafe(nil), Integer)
Socket::AF_IPX = T.let(T.unsafe(nil), Integer)
Socket::AF_ISDN = T.let(T.unsafe(nil), Integer)
Socket::AF_ISO = T.let(T.unsafe(nil), Integer)
Socket::AF_LAT = T.let(T.unsafe(nil), Integer)
Socket::AF_LINK = T.let(T.unsafe(nil), Integer)
Socket::AF_LOCAL = T.let(T.unsafe(nil), Integer)
Socket::AF_MAX = T.let(T.unsafe(nil), Integer)
Socket::AF_NATM = T.let(T.unsafe(nil), Integer)
Socket::AF_NDRV = T.let(T.unsafe(nil), Integer)
Socket::AF_NETBIOS = T.let(T.unsafe(nil), Integer)
Socket::AF_NS = T.let(T.unsafe(nil), Integer)
Socket::AF_OSI = T.let(T.unsafe(nil), Integer)
Socket::AF_PPP = T.let(T.unsafe(nil), Integer)
Socket::AF_PUP = T.let(T.unsafe(nil), Integer)
Socket::AF_ROUTE = T.let(T.unsafe(nil), Integer)
Socket::AF_SIP = T.let(T.unsafe(nil), Integer)
Socket::AF_SNA = T.let(T.unsafe(nil), Integer)
Socket::AF_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::AF_UNIX = T.let(T.unsafe(nil), Integer)
Socket::AF_UNSPEC = T.let(T.unsafe(nil), Integer)
Socket::AI_ADDRCONFIG = T.let(T.unsafe(nil), Integer)
Socket::AI_ALL = T.let(T.unsafe(nil), Integer)
Socket::AI_CANONNAME = T.let(T.unsafe(nil), Integer)
Socket::AI_DEFAULT = T.let(T.unsafe(nil), Integer)
Socket::AI_MASK = T.let(T.unsafe(nil), Integer)
Socket::AI_NUMERICHOST = T.let(T.unsafe(nil), Integer)
Socket::AI_NUMERICSERV = T.let(T.unsafe(nil), Integer)
Socket::AI_PASSIVE = T.let(T.unsafe(nil), Integer)
Socket::AI_V4MAPPED = T.let(T.unsafe(nil), Integer)
Socket::AI_V4MAPPED_CFG = T.let(T.unsafe(nil), Integer)

class Socket::AncillaryData
  def initialize(_arg0, _arg1, _arg2, _arg3); end
  def cmsg_is?(_arg0, _arg1); end
  def data; end
  def family; end
  def inspect; end
  def int; end
  def ip_pktinfo; end
  def ipv6_pktinfo; end
  def ipv6_pktinfo_addr; end
  def ipv6_pktinfo_ifindex; end
  def level; end
  def timestamp; end
  def type; end
  def unix_rights; end
  def self.int(_arg0, _arg1, _arg2, _arg3); end
  def self.ip_pktinfo(*_arg0); end
  def self.ipv6_pktinfo(_arg0, _arg1); end
  def self.unix_rights(*_arg0); end
end

module Socket::Constants; end
Socket::EAI_ADDRFAMILY = T.let(T.unsafe(nil), Integer)
Socket::EAI_AGAIN = T.let(T.unsafe(nil), Integer)
Socket::EAI_BADFLAGS = T.let(T.unsafe(nil), Integer)
Socket::EAI_BADHINTS = T.let(T.unsafe(nil), Integer)
Socket::EAI_FAIL = T.let(T.unsafe(nil), Integer)
Socket::EAI_FAMILY = T.let(T.unsafe(nil), Integer)
Socket::EAI_MAX = T.let(T.unsafe(nil), Integer)
Socket::EAI_MEMORY = T.let(T.unsafe(nil), Integer)
Socket::EAI_NODATA = T.let(T.unsafe(nil), Integer)
Socket::EAI_NONAME = T.let(T.unsafe(nil), Integer)
Socket::EAI_OVERFLOW = T.let(T.unsafe(nil), Integer)
Socket::EAI_PROTOCOL = T.let(T.unsafe(nil), Integer)
Socket::EAI_SERVICE = T.let(T.unsafe(nil), Integer)
Socket::EAI_SOCKTYPE = T.let(T.unsafe(nil), Integer)
Socket::EAI_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::IFF_ALLMULTI = T.let(T.unsafe(nil), Integer)
Socket::IFF_ALTPHYS = T.let(T.unsafe(nil), Integer)
Socket::IFF_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::IFF_DEBUG = T.let(T.unsafe(nil), Integer)
Socket::IFF_LINK0 = T.let(T.unsafe(nil), Integer)
Socket::IFF_LINK1 = T.let(T.unsafe(nil), Integer)
Socket::IFF_LINK2 = T.let(T.unsafe(nil), Integer)
Socket::IFF_LOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::IFF_MULTICAST = T.let(T.unsafe(nil), Integer)
Socket::IFF_NOARP = T.let(T.unsafe(nil), Integer)
Socket::IFF_NOTRAILERS = T.let(T.unsafe(nil), Integer)
Socket::IFF_OACTIVE = T.let(T.unsafe(nil), Integer)
Socket::IFF_POINTOPOINT = T.let(T.unsafe(nil), Integer)
Socket::IFF_PROMISC = T.let(T.unsafe(nil), Integer)
Socket::IFF_RUNNING = T.let(T.unsafe(nil), Integer)
Socket::IFF_SIMPLEX = T.let(T.unsafe(nil), Integer)
Socket::IFF_UP = T.let(T.unsafe(nil), Integer)
Socket::IFNAMSIZ = T.let(T.unsafe(nil), Integer)
Socket::IF_NAMESIZE = T.let(T.unsafe(nil), Integer)
Socket::INADDR_ALLHOSTS_GROUP = T.let(T.unsafe(nil), Integer)
Socket::INADDR_ANY = T.let(T.unsafe(nil), Integer)
Socket::INADDR_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::INADDR_LOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::INADDR_MAX_LOCAL_GROUP = T.let(T.unsafe(nil), Integer)
Socket::INADDR_NONE = T.let(T.unsafe(nil), Integer)
Socket::INADDR_UNSPEC_GROUP = T.let(T.unsafe(nil), Integer)
Socket::INET6_ADDRSTRLEN = T.let(T.unsafe(nil), Integer)
Socket::INET_ADDRSTRLEN = T.let(T.unsafe(nil), Integer)
Socket::IPPORT_RESERVED = T.let(T.unsafe(nil), Integer)
Socket::IPPORT_USERRESERVED = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_AH = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_DSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_EGP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_EON = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ESP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_FRAGMENT = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_GGP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_HELLO = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_HOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ICMP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ICMPV6 = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_IDP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_IGMP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_IP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_IPV6 = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_MAX = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ND = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_NONE = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_PUP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_RAW = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ROUTING = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_TCP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_TP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_UDP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_XTP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_CHECKSUM = T.let(T.unsafe(nil), Integer)
Socket::IPV6_DONTFRAG = T.let(T.unsafe(nil), Integer)
Socket::IPV6_DSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_HOPLIMIT = T.let(T.unsafe(nil), Integer)
Socket::IPV6_HOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_JOIN_GROUP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_LEAVE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_MULTICAST_HOPS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_MULTICAST_IF = T.let(T.unsafe(nil), Integer)
Socket::IPV6_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_NEXTHOP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_PATHMTU = T.let(T.unsafe(nil), Integer)
Socket::IPV6_PKTINFO = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVDSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVHOPLIMIT = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVHOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVPATHMTU = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVPKTINFO = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVRTHDR = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVTCLASS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RTHDR = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RTHDRDSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RTHDR_TYPE_0 = T.let(T.unsafe(nil), Integer)
Socket::IPV6_TCLASS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_UNICAST_HOPS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_USE_MIN_MTU = T.let(T.unsafe(nil), Integer)
Socket::IPV6_V6ONLY = T.let(T.unsafe(nil), Integer)
Socket::IP_ADD_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::IP_ADD_SOURCE_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::IP_BLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::IP_DEFAULT_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::IP_DEFAULT_MULTICAST_TTL = T.let(T.unsafe(nil), Integer)
Socket::IP_DONTFRAG = T.let(T.unsafe(nil), Integer)
Socket::IP_DROP_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::IP_DROP_SOURCE_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::IP_HDRINCL = T.let(T.unsafe(nil), Integer)
Socket::IP_IPSEC_POLICY = T.let(T.unsafe(nil), Integer)
Socket::IP_MAX_MEMBERSHIPS = T.let(T.unsafe(nil), Integer)
Socket::IP_MSFILTER = T.let(T.unsafe(nil), Integer)
Socket::IP_MULTICAST_IF = T.let(T.unsafe(nil), Integer)
Socket::IP_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::IP_MULTICAST_TTL = T.let(T.unsafe(nil), Integer)
Socket::IP_OPTIONS = T.let(T.unsafe(nil), Integer)
Socket::IP_PKTINFO = T.let(T.unsafe(nil), Integer)
Socket::IP_PORTRANGE = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVDSTADDR = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVIF = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVOPTS = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVRETOPTS = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVTOS = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVTTL = T.let(T.unsafe(nil), Integer)
Socket::IP_RETOPTS = T.let(T.unsafe(nil), Integer)
Socket::IP_TOS = T.let(T.unsafe(nil), Integer)
Socket::IP_TTL = T.let(T.unsafe(nil), Integer)
Socket::IP_UNBLOCK_SOURCE = T.let(T.unsafe(nil), Integer)

class Socket::Ifaddr
  def addr; end
  def broadaddr; end
  def dstaddr; end
  def flags; end
  def ifindex; end
  def inspect; end
  def name; end
  def netmask; end
end

Socket::LOCAL_PEERCRED = T.let(T.unsafe(nil), Integer)
Socket::MCAST_BLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::MCAST_EXCLUDE = T.let(T.unsafe(nil), Integer)
Socket::MCAST_INCLUDE = T.let(T.unsafe(nil), Integer)
Socket::MCAST_JOIN_GROUP = T.let(T.unsafe(nil), Integer)
Socket::MCAST_JOIN_SOURCE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::MCAST_LEAVE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::MCAST_LEAVE_SOURCE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::MCAST_UNBLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::MSG_CTRUNC = T.let(T.unsafe(nil), Integer)
Socket::MSG_DONTROUTE = T.let(T.unsafe(nil), Integer)
Socket::MSG_DONTWAIT = T.let(T.unsafe(nil), Integer)
Socket::MSG_EOF = T.let(T.unsafe(nil), Integer)
Socket::MSG_EOR = T.let(T.unsafe(nil), Integer)
Socket::MSG_FLUSH = T.let(T.unsafe(nil), Integer)
Socket::MSG_HAVEMORE = T.let(T.unsafe(nil), Integer)
Socket::MSG_HOLD = T.let(T.unsafe(nil), Integer)
Socket::MSG_NOSIGNAL = T.let(T.unsafe(nil), Integer)
Socket::MSG_OOB = T.let(T.unsafe(nil), Integer)
Socket::MSG_PEEK = T.let(T.unsafe(nil), Integer)
Socket::MSG_RCVMORE = T.let(T.unsafe(nil), Integer)
Socket::MSG_SEND = T.let(T.unsafe(nil), Integer)
Socket::MSG_TRUNC = T.let(T.unsafe(nil), Integer)
Socket::MSG_WAITALL = T.let(T.unsafe(nil), Integer)
Socket::NI_DGRAM = T.let(T.unsafe(nil), Integer)
Socket::NI_MAXHOST = T.let(T.unsafe(nil), Integer)
Socket::NI_MAXSERV = T.let(T.unsafe(nil), Integer)
Socket::NI_NAMEREQD = T.let(T.unsafe(nil), Integer)
Socket::NI_NOFQDN = T.let(T.unsafe(nil), Integer)
Socket::NI_NUMERICHOST = T.let(T.unsafe(nil), Integer)
Socket::NI_NUMERICSERV = T.let(T.unsafe(nil), Integer)

class Socket::Option
  def initialize(_arg0, _arg1, _arg2, _arg3); end
  def bool; end
  def byte; end
  def data; end
  def family; end
  def inspect; end
  def int; end
  def ipv4_multicast_loop; end
  def ipv4_multicast_ttl; end
  def level; end
  def linger; end
  def optname; end
  def to_s; end
  def unpack(_arg0); end
  def self.bool(_arg0, _arg1, _arg2, _arg3); end
  def self.byte(_arg0, _arg1, _arg2, _arg3); end
  def self.int(_arg0, _arg1, _arg2, _arg3); end
  def self.ipv4_multicast_loop(_arg0); end
  def self.ipv4_multicast_ttl(_arg0); end
  def self.linger(_arg0, _arg1); end
end

Socket::PF_APPLETALK = T.let(T.unsafe(nil), Integer)
Socket::PF_CCITT = T.let(T.unsafe(nil), Integer)
Socket::PF_CHAOS = T.let(T.unsafe(nil), Integer)
Socket::PF_CNT = T.let(T.unsafe(nil), Integer)
Socket::PF_COIP = T.let(T.unsafe(nil), Integer)
Socket::PF_DATAKIT = T.let(T.unsafe(nil), Integer)
Socket::PF_DLI = T.let(T.unsafe(nil), Integer)
Socket::PF_ECMA = T.let(T.unsafe(nil), Integer)
Socket::PF_HYLINK = T.let(T.unsafe(nil), Integer)
Socket::PF_IMPLINK = T.let(T.unsafe(nil), Integer)
Socket::PF_INET = T.let(T.unsafe(nil), Integer)
Socket::PF_INET6 = T.let(T.unsafe(nil), Integer)
Socket::PF_IPX = T.let(T.unsafe(nil), Integer)
Socket::PF_ISDN = T.let(T.unsafe(nil), Integer)
Socket::PF_ISO = T.let(T.unsafe(nil), Integer)
Socket::PF_KEY = T.let(T.unsafe(nil), Integer)
Socket::PF_LAT = T.let(T.unsafe(nil), Integer)
Socket::PF_LINK = T.let(T.unsafe(nil), Integer)
Socket::PF_LOCAL = T.let(T.unsafe(nil), Integer)
Socket::PF_MAX = T.let(T.unsafe(nil), Integer)
Socket::PF_NATM = T.let(T.unsafe(nil), Integer)
Socket::PF_NDRV = T.let(T.unsafe(nil), Integer)
Socket::PF_NETBIOS = T.let(T.unsafe(nil), Integer)
Socket::PF_NS = T.let(T.unsafe(nil), Integer)
Socket::PF_OSI = T.let(T.unsafe(nil), Integer)
Socket::PF_PIP = T.let(T.unsafe(nil), Integer)
Socket::PF_PPP = T.let(T.unsafe(nil), Integer)
Socket::PF_PUP = T.let(T.unsafe(nil), Integer)
Socket::PF_ROUTE = T.let(T.unsafe(nil), Integer)
Socket::PF_RTIP = T.let(T.unsafe(nil), Integer)
Socket::PF_SIP = T.let(T.unsafe(nil), Integer)
Socket::PF_SNA = T.let(T.unsafe(nil), Integer)
Socket::PF_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::PF_UNIX = T.let(T.unsafe(nil), Integer)
Socket::PF_UNSPEC = T.let(T.unsafe(nil), Integer)
Socket::PF_XTP = T.let(T.unsafe(nil), Integer)
Socket::SCM_CREDS = T.let(T.unsafe(nil), Integer)
Socket::SCM_RIGHTS = T.let(T.unsafe(nil), Integer)
Socket::SCM_TIMESTAMP = T.let(T.unsafe(nil), Integer)
Socket::SHUT_RD = T.let(T.unsafe(nil), Integer)
Socket::SHUT_RDWR = T.let(T.unsafe(nil), Integer)
Socket::SHUT_WR = T.let(T.unsafe(nil), Integer)
Socket::SOCK_DGRAM = T.let(T.unsafe(nil), Integer)
Socket::SOCK_RAW = T.let(T.unsafe(nil), Integer)
Socket::SOCK_RDM = T.let(T.unsafe(nil), Integer)
Socket::SOCK_SEQPACKET = T.let(T.unsafe(nil), Integer)
Socket::SOCK_STREAM = T.let(T.unsafe(nil), Integer)
Socket::SOL_SOCKET = T.let(T.unsafe(nil), Integer)
Socket::SOMAXCONN = T.let(T.unsafe(nil), Integer)
Socket::SO_ACCEPTCONN = T.let(T.unsafe(nil), Integer)
Socket::SO_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::SO_DEBUG = T.let(T.unsafe(nil), Integer)
Socket::SO_DONTROUTE = T.let(T.unsafe(nil), Integer)
Socket::SO_DONTTRUNC = T.let(T.unsafe(nil), Integer)
Socket::SO_ERROR = T.let(T.unsafe(nil), Integer)
Socket::SO_KEEPALIVE = T.let(T.unsafe(nil), Integer)
Socket::SO_LINGER = T.let(T.unsafe(nil), Integer)
Socket::SO_NKE = T.let(T.unsafe(nil), Integer)
Socket::SO_NOSIGPIPE = T.let(T.unsafe(nil), Integer)
Socket::SO_NREAD = T.let(T.unsafe(nil), Integer)
Socket::SO_OOBINLINE = T.let(T.unsafe(nil), Integer)
Socket::SO_RCVBUF = T.let(T.unsafe(nil), Integer)
Socket::SO_RCVLOWAT = T.let(T.unsafe(nil), Integer)
Socket::SO_RCVTIMEO = T.let(T.unsafe(nil), Integer)
Socket::SO_REUSEADDR = T.let(T.unsafe(nil), Integer)
Socket::SO_REUSEPORT = T.let(T.unsafe(nil), Integer)
Socket::SO_SNDBUF = T.let(T.unsafe(nil), Integer)
Socket::SO_SNDLOWAT = T.let(T.unsafe(nil), Integer)
Socket::SO_SNDTIMEO = T.let(T.unsafe(nil), Integer)
Socket::SO_TIMESTAMP = T.let(T.unsafe(nil), Integer)
Socket::SO_TYPE = T.let(T.unsafe(nil), Integer)
Socket::SO_USELOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::SO_WANTMORE = T.let(T.unsafe(nil), Integer)
Socket::SO_WANTOOBFLAG = T.let(T.unsafe(nil), Integer)
Socket::TCP_FASTOPEN = T.let(T.unsafe(nil), Integer)
Socket::TCP_KEEPCNT = T.let(T.unsafe(nil), Integer)
Socket::TCP_KEEPINTVL = T.let(T.unsafe(nil), Integer)
Socket::TCP_MAXSEG = T.let(T.unsafe(nil), Integer)
Socket::TCP_NODELAY = T.let(T.unsafe(nil), Integer)
Socket::TCP_NOOPT = T.let(T.unsafe(nil), Integer)
Socket::TCP_NOPUSH = T.let(T.unsafe(nil), Integer)

class Socket::UDPSource
  def initialize(remote_address, local_address, &reply_proc); end
  def inspect; end
  def local_address; end
  def remote_address; end
  def reply(msg); end
end

module Random::Formatter
  def alphanumeric(n = T.unsafe(nil)); end
  def base64(n = T.unsafe(nil)); end
  def hex(n = T.unsafe(nil)); end
  def rand(*_arg0); end
  def random_bytes(n = T.unsafe(nil)); end
  def random_number(*_arg0); end
  def urlsafe_base64(n = T.unsafe(nil), padding = T.unsafe(nil)); end
  def uuid; end
  private def choose(source, n); end
  private def gen_random(n); end
end

class IO::ConsoleMode
  def echo=(_arg0); end
  def raw(*_arg0); end
  def raw!(*_arg0); end
  private def initialize_copy(_arg0); end
end

class IO::EAGAINWaitReadable < ::Errno::EAGAIN
  include ::IO::WaitReadable
end

class IO::EAGAINWaitWritable < ::Errno::EAGAIN
  include ::IO::WaitWritable
end

class IO::EINPROGRESSWaitReadable < ::Errno::EINPROGRESS
  include ::IO::WaitReadable
end

class IO::EINPROGRESSWaitWritable < ::Errno::EINPROGRESS
  include ::IO::WaitWritable
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable
IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable
IO::PRIORITY = T.let(T.unsafe(nil), Integer)
IO::READABLE = T.let(T.unsafe(nil), Integer)
IO::SEEK_CUR = T.let(T.unsafe(nil), Integer)
IO::SEEK_DATA = T.let(T.unsafe(nil), Integer)
IO::SEEK_END = T.let(T.unsafe(nil), Integer)
IO::SEEK_HOLE = T.let(T.unsafe(nil), Integer)
IO::SEEK_SET = T.let(T.unsafe(nil), Integer)
IO::WRITABLE = T.let(T.unsafe(nil), Integer)
module IO::WaitReadable; end
module IO::WaitWritable; end
class RuntimeError < ::StandardError; end

class Resolv::DNS::Config
  def initialize(config_info = T.unsafe(nil)); end
  def generate_candidates(name); end
  def generate_timeouts; end
  def lazy_initialize; end
  def nameserver_port; end
  def resolv(name); end
  def single?; end
  def timeouts=(values); end
  def self.default_config_hash(filename = T.unsafe(nil)); end
  def self.parse_resolv_conf(filename); end
end

class Resolv::DNS::DecodeError < ::StandardError; end
class Resolv::DNS::EncodeError < ::StandardError; end

module Resolv::DNS::Label
  def self.split(arg); end
end

class Resolv::DNS::Message
  def initialize(id = T.unsafe(nil)); end
  def ==(other); end
  def aa; end
  def aa=(_arg0); end
  def add_additional(name, ttl, data); end
  def add_answer(name, ttl, data); end
  def add_authority(name, ttl, data); end
  def add_question(name, typeclass); end
  def additional; end
  def answer; end
  def authority; end
  def each_additional; end
  def each_answer; end
  def each_authority; end
  def each_question; end
  def each_resource; end
  def encode; end
  def id; end
  def id=(_arg0); end
  def opcode; end
  def opcode=(_arg0); end
  def qr; end
  def qr=(_arg0); end
  def question; end
  def ra; end
  def ra=(_arg0); end
  def rcode; end
  def rcode=(_arg0); end
  def rd; end
  def rd=(_arg0); end
  def tc; end
  def tc=(_arg0); end
  def self.decode(m); end
end

class Resolv::DNS::Name
  def initialize(labels, absolute = T.unsafe(nil)); end
  def ==(other); end
  def [](i); end
  def absolute?; end
  def eql?(other); end
  def hash; end
  def inspect; end
  def length; end
  def subdomain_of?(other); end
  def to_a; end
  def to_s; end
  def self.create(arg); end
end

module Resolv::DNS::OpCode; end
Resolv::DNS::Port = T.let(T.unsafe(nil), Integer)

class Resolv::DNS::Query
  def encode_rdata(msg); end
  def self.decode_rdata(msg); end
end

module Resolv::DNS::RCode; end
Resolv::DNS::RequestID = T.let(T.unsafe(nil), Hash)
Resolv::DNS::RequestIDMutex = T.let(T.unsafe(nil), Thread::Mutex)

class Resolv::DNS::Requester
  def initialize; end
  def close; end
  def request(sender, tout); end
  def sender_for(addr, msg); end
end

class Resolv::DNS::Resource < ::Resolv::DNS::Query
  def ==(other); end
  def encode_rdata(msg); end
  def eql?(other); end
  def hash; end
  def ttl; end
  def self.decode_rdata(msg); end
  def self.get_class(type_value, class_value); end
end

Resolv::DNS::UDPSize = T.let(T.unsafe(nil), Integer)
Resolv::Hosts::DefaultFileName = T.let(T.unsafe(nil), String)
Resolv::IPv4::Regex = T.let(T.unsafe(nil), Regexp)
Resolv::IPv4::Regex256 = T.let(T.unsafe(nil), Regexp)
Resolv::IPv6::Regex = T.let(T.unsafe(nil), Regexp)
Resolv::IPv6::Regex_6Hex4Dec = T.let(T.unsafe(nil), Regexp)
Resolv::IPv6::Regex_8Hex = T.let(T.unsafe(nil), Regexp)
Resolv::IPv6::Regex_8HexLinkLocal = T.let(T.unsafe(nil), Regexp)
Resolv::IPv6::Regex_CompressedHex = T.let(T.unsafe(nil), Regexp)
Resolv::IPv6::Regex_CompressedHex4Dec = T.let(T.unsafe(nil), Regexp)
Resolv::IPv6::Regex_CompressedHexLinkLocal = T.let(T.unsafe(nil), Regexp)

class Resolv::LOC::Alt
  def initialize(altitude); end
  def ==(other); end
  def altitude; end
  def eql?(other); end
  def hash; end
  def inspect; end
  def to_s; end
  def self.create(arg); end
end

class Resolv::LOC::Coord
  def initialize(coordinates, orientation); end
  def ==(other); end
  def coordinates; end
  def eql?(other); end
  def hash; end
  def inspect; end
  def orientation; end
  def to_s; end
  def self.create(arg); end
end

class Resolv::LOC::Size
  def initialize(scalar); end
  def ==(other); end
  def eql?(other); end
  def hash; end
  def inspect; end
  def scalar; end
  def to_s; end
  def self.create(arg); end
end

Resolv::MDNS::AddressV4 = T.let(T.unsafe(nil), String)
Resolv::MDNS::AddressV6 = T.let(T.unsafe(nil), String)
Resolv::MDNS::Addresses = T.let(T.unsafe(nil), Array)
Resolv::MDNS::Port = T.let(T.unsafe(nil), Integer)

class Exception
  def initialize(*_arg0); end
  def ==(_arg0); end
  def backtrace; end
  def backtrace_locations; end
  def cause; end
  def exception(*_arg0); end
  def full_message(*_arg0); end
  def inspect; end
  def message; end
  def respond_to?(*_arg0); end
  def set_backtrace(_arg0); end
  def to_s; end
  private def method_missing(*_arg0); end
  private def respond_to_missing?(_arg0, _arg1); end
  def self.exception(*_arg0); end
  def self.to_tty?; end
end

Socket::Constants::AF_APPLETALK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_CCITT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_CHAOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_CNT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_COIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_DATAKIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_DLI = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_E164 = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_ECMA = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_HYLINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_IMPLINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_INET = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_INET6 = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_IPX = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_ISDN = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_ISO = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_LAT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_LINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_LOCAL = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_MAX = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_NATM = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_NDRV = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_NETBIOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_NS = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_OSI = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_PPP = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_PUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_ROUTE = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_SIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_SNA = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_UNIX = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_UNSPEC = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_ADDRCONFIG = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_ALL = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_CANONNAME = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_DEFAULT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_MASK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_NUMERICHOST = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_NUMERICSERV = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_PASSIVE = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_V4MAPPED = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_V4MAPPED_CFG = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_ADDRFAMILY = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_AGAIN = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_BADFLAGS = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_BADHINTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_FAIL = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_FAMILY = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_MAX = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_MEMORY = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_NODATA = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_NONAME = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_OVERFLOW = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_PROTOCOL = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_SERVICE = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_SOCKTYPE = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_ALLMULTI = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_ALTPHYS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_DEBUG = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_LINK0 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_LINK1 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_LINK2 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_LOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_MULTICAST = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_NOARP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_NOTRAILERS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_OACTIVE = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_POINTOPOINT = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_PROMISC = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_RUNNING = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_SIMPLEX = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_UP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFNAMSIZ = T.let(T.unsafe(nil), Integer)
Socket::Constants::IF_NAMESIZE = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_ALLHOSTS_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_ANY = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_LOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_MAX_LOCAL_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_NONE = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_UNSPEC_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::INET6_ADDRSTRLEN = T.let(T.unsafe(nil), Integer)
Socket::Constants::INET_ADDRSTRLEN = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPORT_RESERVED = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPORT_USERRESERVED = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_AH = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_DSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_EGP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_EON = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ESP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_FRAGMENT = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_GGP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_HELLO = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_HOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ICMP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ICMPV6 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_IDP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_IGMP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_IP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_IPV6 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_MAX = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ND = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_NONE = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_PUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_RAW = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ROUTING = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_TCP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_TP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_UDP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_XTP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_CHECKSUM = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_DONTFRAG = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_DSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_HOPLIMIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_HOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_JOIN_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_LEAVE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_MULTICAST_HOPS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_MULTICAST_IF = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_NEXTHOP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_PATHMTU = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_PKTINFO = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVDSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVHOPLIMIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVHOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVPATHMTU = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVPKTINFO = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVRTHDR = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVTCLASS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RTHDR = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RTHDRDSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RTHDR_TYPE_0 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_TCLASS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_UNICAST_HOPS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_USE_MIN_MTU = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_V6ONLY = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_ADD_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_ADD_SOURCE_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_BLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DEFAULT_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DEFAULT_MULTICAST_TTL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DONTFRAG = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DROP_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DROP_SOURCE_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_HDRINCL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_IPSEC_POLICY = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MAX_MEMBERSHIPS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MSFILTER = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MULTICAST_IF = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MULTICAST_TTL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_OPTIONS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_PKTINFO = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_PORTRANGE = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVDSTADDR = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVIF = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVRETOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVTOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVTTL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RETOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_TOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_TTL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_UNBLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::Constants::LOCAL_PEERCRED = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_BLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_EXCLUDE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_INCLUDE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_JOIN_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_JOIN_SOURCE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_LEAVE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_LEAVE_SOURCE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_UNBLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_CTRUNC = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_DONTROUTE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_DONTWAIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_EOF = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_EOR = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_FLUSH = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_HAVEMORE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_HOLD = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_NOSIGNAL = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_OOB = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_PEEK = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_RCVMORE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_SEND = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_TRUNC = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_WAITALL = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_DGRAM = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_MAXHOST = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_MAXSERV = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_NAMEREQD = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_NOFQDN = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_NUMERICHOST = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_NUMERICSERV = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_APPLETALK = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_CCITT = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_CHAOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_CNT = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_COIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_DATAKIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_DLI = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_ECMA = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_HYLINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_IMPLINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_INET = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_INET6 = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_IPX = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_ISDN = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_ISO = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_KEY = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_LAT = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_LINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_LOCAL = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_MAX = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_NATM = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_NDRV = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_NETBIOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_NS = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_OSI = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_PIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_PPP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_PUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_ROUTE = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_RTIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_SIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_SNA = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_UNIX = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_UNSPEC = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_XTP = T.let(T.unsafe(nil), Integer)
Socket::Constants::SCM_CREDS = T.let(T.unsafe(nil), Integer)
Socket::Constants::SCM_RIGHTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::SCM_TIMESTAMP = T.let(T.unsafe(nil), Integer)
Socket::Constants::SHUT_RD = T.let(T.unsafe(nil), Integer)
Socket::Constants::SHUT_RDWR = T.let(T.unsafe(nil), Integer)
Socket::Constants::SHUT_WR = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_DGRAM = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_RAW = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_RDM = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_SEQPACKET = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_STREAM = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOL_SOCKET = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOMAXCONN = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_ACCEPTCONN = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_DEBUG = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_DONTROUTE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_DONTTRUNC = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_ERROR = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_KEEPALIVE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_LINGER = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_NKE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_NOSIGPIPE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_NREAD = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_OOBINLINE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_RCVBUF = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_RCVLOWAT = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_RCVTIMEO = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_REUSEADDR = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_REUSEPORT = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_SNDBUF = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_SNDLOWAT = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_SNDTIMEO = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_TIMESTAMP = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_TYPE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_USELOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_WANTMORE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_WANTOOBFLAG = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_FASTOPEN = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_KEEPCNT = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_KEEPINTVL = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_MAXSEG = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_NODELAY = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_NOOPT = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_NOPUSH = T.let(T.unsafe(nil), Integer)

module Enumerable
  def all?(*_arg0); end
  def any?(*_arg0); end
  def chain(*_arg0); end
  def chunk; end
  def chunk_while; end
  def collect; end
  def collect_concat; end
  def count(*_arg0); end
  def cycle(*_arg0); end
  def detect(*_arg0); end
  def drop(_arg0); end
  def drop_while; end
  def each_cons(_arg0); end
  def each_entry(*_arg0); end
  def each_slice(_arg0); end
  def each_with_index(*_arg0); end
  def each_with_object(_arg0); end
  def entries(*_arg0); end
  def filter; end
  def filter_map; end
  def find(*_arg0); end
  def find_all; end
  def find_index(*_arg0); end
  def first(*_arg0); end
  def flat_map; end
  def grep(_arg0); end
  def grep_v(_arg0); end
  def group_by; end
  def include?(_arg0); end
  def inject(*_arg0); end
  def lazy; end
  def map; end
  def max(*_arg0); end
  def max_by(*_arg0); end
  def member?(_arg0); end
  def min(*_arg0); end
  def min_by(*_arg0); end
  def minmax; end
  def minmax_by; end
  def none?(*_arg0); end
  def one?(*_arg0); end
  def partition; end
  def reduce(*_arg0); end
  def reject; end
  def reverse_each(*_arg0); end
  def select; end
  def slice_after(*_arg0); end
  def slice_before(*_arg0); end
  def slice_when; end
  def sort; end
  def sort_by; end
  def sum(*_arg0); end
  def take(_arg0); end
  def take_while; end
  def tally; end
  def to_a(*_arg0); end
  def to_h(*_arg0); end
  def to_set(klass = T.unsafe(nil), *args, &block); end
  def uniq; end
  def zip(*_arg0); end
end

module File::Constants; end
Random::Formatter::ALPHANUMERIC = T.let(T.unsafe(nil), Array)
class Errno::EAGAIN < ::SystemCallError; end
class Errno::EINPROGRESS < ::SystemCallError; end
Resolv::DNS::Config::InitialTimeout = T.let(T.unsafe(nil), Integer)
class Resolv::DNS::Config::NXDomain < ::Resolv::ResolvError; end
class Resolv::DNS::Config::OtherResolvError < ::Resolv::ResolvError; end

class Resolv::DNS::Label::Str
  def initialize(string); end
  def ==(other); end
  def downcase; end
  def eql?(other); end
  def hash; end
  def inspect; end
  def string; end
  def to_s; end
end

class Resolv::DNS::Message::MessageDecoder
  def initialize(data); end
  def get_bytes(len = T.unsafe(nil)); end
  def get_label; end
  def get_labels; end
  def get_length16; end
  def get_name; end
  def get_question; end
  def get_rr; end
  def get_string; end
  def get_string_list; end
  def get_unpack(template); end
  def inspect; end
end

class Resolv::DNS::Message::MessageEncoder
  def initialize; end
  def put_bytes(d); end
  def put_label(d); end
  def put_labels(d); end
  def put_length16; end
  def put_name(d); end
  def put_pack(template, *d); end
  def put_string(d); end
  def put_string_list(ds); end
  def to_s; end
end

Resolv::DNS::OpCode::IQuery = T.let(T.unsafe(nil), Integer)
Resolv::DNS::OpCode::Notify = T.let(T.unsafe(nil), Integer)
Resolv::DNS::OpCode::Query = T.let(T.unsafe(nil), Integer)
Resolv::DNS::OpCode::Status = T.let(T.unsafe(nil), Integer)
Resolv::DNS::OpCode::Update = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::BADALG = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::BADKEY = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::BADMODE = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::BADNAME = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::BADSIG = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::BADTIME = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::BADVERS = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::FormErr = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::NXDomain = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::NXRRSet = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::NoError = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::NotAuth = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::NotImp = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::NotZone = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::Refused = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::ServFail = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::YXDomain = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::YXRRSet = T.let(T.unsafe(nil), Integer)

class Resolv::DNS::Requester::ConnectedUDP < ::Resolv::DNS::Requester
  def initialize(host, port = T.unsafe(nil)); end
  def close; end
  def lazy_initialize; end
  def recv_reply(readable_socks); end
  def sender(msg, data, host = T.unsafe(nil), port = T.unsafe(nil)); end
end

class Resolv::DNS::Requester::MDNSOneShot < ::Resolv::DNS::Requester::UnconnectedUDP
  def sender(msg, data, host, port = T.unsafe(nil)); end
  def sender_for(addr, msg); end
end

class Resolv::DNS::Requester::RequestError < ::StandardError; end

class Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock); end
end

class Resolv::DNS::Requester::TCP < ::Resolv::DNS::Requester
  def initialize(host, port = T.unsafe(nil)); end
  def close; end
  def recv_reply(readable_socks); end
  def sender(msg, data, host = T.unsafe(nil), port = T.unsafe(nil)); end
end

class Resolv::DNS::Requester::UnconnectedUDP < ::Resolv::DNS::Requester
  def initialize(*nameserver_port); end
  def close; end
  def lazy_initialize; end
  def recv_reply(readable_socks); end
  def sender(msg, data, host, port = T.unsafe(nil)); end
end

class Resolv::DNS::Resource::ANY < ::Resolv::DNS::Query; end
class Resolv::DNS::Resource::CNAME < ::Resolv::DNS::Resource::DomainName; end
Resolv::DNS::Resource::ClassHash = T.let(T.unsafe(nil), Hash)
Resolv::DNS::Resource::ClassInsensitiveTypes = T.let(T.unsafe(nil), Array)

class Resolv::DNS::Resource::DomainName < ::Resolv::DNS::Resource
  def initialize(name); end
  def encode_rdata(msg); end
  def name; end
  def self.decode_rdata(msg); end
end

class Resolv::DNS::Resource::Generic < ::Resolv::DNS::Resource
  def initialize(data); end
  def data; end
  def encode_rdata(msg); end
  def self.create(type_value, class_value); end
  def self.decode_rdata(msg); end
end

class Resolv::DNS::Resource::HINFO < ::Resolv::DNS::Resource
  def initialize(cpu, os); end
  def cpu; end
  def encode_rdata(msg); end
  def os; end
  def self.decode_rdata(msg); end
end

module Resolv::DNS::Resource::IN; end

class Resolv::DNS::Resource::LOC < ::Resolv::DNS::Resource
  def initialize(version, ssize, hprecision, vprecision, latitude, longitude, altitude); end
  def altitude; end
  def encode_rdata(msg); end
  def hprecision; end
  def latitude; end
  def longitude; end
  def ssize; end
  def version; end
  def vprecision; end
  def self.decode_rdata(msg); end
end

class Resolv::DNS::Resource::MINFO < ::Resolv::DNS::Resource
  def initialize(rmailbx, emailbx); end
  def emailbx; end
  def encode_rdata(msg); end
  def rmailbx; end
  def self.decode_rdata(msg); end
end

class Resolv::DNS::Resource::MX < ::Resolv::DNS::Resource
  def initialize(preference, exchange); end
  def encode_rdata(msg); end
  def exchange; end
  def preference; end
  def self.decode_rdata(msg); end
end

class Resolv::DNS::Resource::NS < ::Resolv::DNS::Resource::DomainName; end
class Resolv::DNS::Resource::PTR < ::Resolv::DNS::Resource::DomainName; end

class Resolv::DNS::Resource::SOA < ::Resolv::DNS::Resource
  def initialize(mname, rname, serial, refresh, retry_, expire, minimum); end
  def encode_rdata(msg); end
  def expire; end
  def minimum; end
  def mname; end
  def refresh; end
  def retry; end
  def rname; end
  def serial; end
  def self.decode_rdata(msg); end
end

class Resolv::DNS::Resource::TXT < ::Resolv::DNS::Resource
  def initialize(first_string, *rest_strings); end
  def data; end
  def encode_rdata(msg); end
  def strings; end
  def self.decode_rdata(msg); end
end

Resolv::LOC::Alt::Regex = T.let(T.unsafe(nil), Regexp)
Resolv::LOC::Coord::Regex = T.let(T.unsafe(nil), Regexp)
Resolv::LOC::Size::Regex = T.let(T.unsafe(nil), Regexp)
File::Constants::APPEND = T.let(T.unsafe(nil), Integer)
File::Constants::BINARY = T.let(T.unsafe(nil), Integer)
File::Constants::CREAT = T.let(T.unsafe(nil), Integer)
File::Constants::DSYNC = T.let(T.unsafe(nil), Integer)
File::Constants::EXCL = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_CASEFOLD = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_DOTMATCH = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_EXTGLOB = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_NOESCAPE = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_PATHNAME = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_SHORTNAME = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_SYSCASE = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_EX = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_NB = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_SH = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_UN = T.let(T.unsafe(nil), Integer)
File::Constants::NOCTTY = T.let(T.unsafe(nil), Integer)
File::Constants::NOFOLLOW = T.let(T.unsafe(nil), Integer)
File::Constants::NONBLOCK = T.let(T.unsafe(nil), Integer)
File::Constants::NULL = T.let(T.unsafe(nil), String)
File::Constants::RDONLY = T.let(T.unsafe(nil), Integer)
File::Constants::RDWR = T.let(T.unsafe(nil), Integer)
File::Constants::SHARE_DELETE = T.let(T.unsafe(nil), Integer)
File::Constants::SYNC = T.let(T.unsafe(nil), Integer)
File::Constants::TRUNC = T.let(T.unsafe(nil), Integer)
File::Constants::WRONLY = T.let(T.unsafe(nil), Integer)

class SystemCallError < ::StandardError
  def initialize(*_arg0); end
  def errno; end
  def self.===(_arg0); end
end

Errno::EAGAIN::Errno = T.let(T.unsafe(nil), Integer)
Errno::EINPROGRESS::Errno = T.let(T.unsafe(nil), Integer)

class Resolv::DNS::Requester::ConnectedUDP::Sender < ::Resolv::DNS::Requester::Sender
  def data; end
  def send; end
end

class Resolv::DNS::Requester::TCP::Sender < ::Resolv::DNS::Requester::Sender
  def data; end
  def send; end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender < ::Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock, host, port); end
  def data; end
  def send; end
end

Resolv::DNS::Resource::ANY::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::CNAME::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::HINFO::TypeValue = T.let(T.unsafe(nil), Integer)

class Resolv::DNS::Resource::IN::A < ::Resolv::DNS::Resource
  def initialize(address); end
  def address; end
  def encode_rdata(msg); end
  def self.decode_rdata(msg); end
end

class Resolv::DNS::Resource::IN::AAAA < ::Resolv::DNS::Resource
  def initialize(address); end
  def address; end
  def encode_rdata(msg); end
  def self.decode_rdata(msg); end
end

class Resolv::DNS::Resource::IN::ANY < ::Resolv::DNS::Resource::ANY; end
class Resolv::DNS::Resource::IN::CNAME < ::Resolv::DNS::Resource::CNAME; end
Resolv::DNS::Resource::IN::ClassValue = T.let(T.unsafe(nil), Integer)
class Resolv::DNS::Resource::IN::HINFO < ::Resolv::DNS::Resource::HINFO; end
class Resolv::DNS::Resource::IN::LOC < ::Resolv::DNS::Resource::LOC; end
class Resolv::DNS::Resource::IN::MINFO < ::Resolv::DNS::Resource::MINFO; end
class Resolv::DNS::Resource::IN::MX < ::Resolv::DNS::Resource::MX; end
class Resolv::DNS::Resource::IN::NS < ::Resolv::DNS::Resource::NS; end
class Resolv::DNS::Resource::IN::PTR < ::Resolv::DNS::Resource::PTR; end
class Resolv::DNS::Resource::IN::SOA < ::Resolv::DNS::Resource::SOA; end

class Resolv::DNS::Resource::IN::SRV < ::Resolv::DNS::Resource
  def initialize(priority, weight, port, target); end
  def encode_rdata(msg); end
  def port; end
  def priority; end
  def target; end
  def weight; end
  def self.decode_rdata(msg); end
end

class Resolv::DNS::Resource::IN::TXT < ::Resolv::DNS::Resource::TXT; end

class Resolv::DNS::Resource::IN::WKS < ::Resolv::DNS::Resource
  def initialize(address, protocol, bitmap); end
  def address; end
  def bitmap; end
  def encode_rdata(msg); end
  def protocol; end
  def self.decode_rdata(msg); end
end

Resolv::DNS::Resource::LOC::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::MINFO::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::MX::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::NS::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::PTR::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::SOA::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::TXT::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::A::ClassValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::A::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::AAAA::ClassValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::AAAA::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::ANY::ClassValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::ANY::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::CNAME::ClassValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::CNAME::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::HINFO::ClassValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::HINFO::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::LOC::ClassValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::LOC::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::MINFO::ClassValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::MINFO::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::MX::ClassValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::MX::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::NS::ClassValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::NS::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::PTR::ClassValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::PTR::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::SOA::ClassValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::SOA::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::SRV::ClassValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::SRV::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::TXT::ClassValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::TXT::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::WKS::ClassValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::WKS::TypeValue = T.let(T.unsafe(nil), Integer)
module SecureRandom
  extend ::Random::Formatter
  def self.bytes(n); end
  def self.gen_random(n); end
  private def self.gen_random_openssl(n); end
  private def self.gen_random_urandom(n); end
end

class UDPSocket < ::IPSocket
  def initialize(*_arg0); end
  def bind(host, port); end
  def connect(host, port); end
  def original_resolv_bind(_arg0, _arg1); end
  def original_resolv_connect(_arg0, _arg1); end
  def original_resolv_send(*_arg0); end
  def recvfrom_nonblock(len, flag = T.unsafe(nil), outbuf = T.unsafe(nil), exception: T.unsafe(nil)); end
  def send(mesg, flags, *rest); end
  private def __recvfrom_nonblock(_arg0, _arg1, _arg2, _arg3); end
end

class BasicSocket < ::IO
  def close_read; end
  def close_write; end
  def connect_address; end
  def do_not_reverse_lookup; end
  def do_not_reverse_lookup=(_arg0); end
  def getpeereid; end
  def getpeername; end
  def getsockname; end
  def getsockopt(_arg0, _arg1); end
  def local_address; end
  def recv(*_arg0); end
  def recv_nonblock(len, flag = T.unsafe(nil), str = T.unsafe(nil), exception: T.unsafe(nil)); end
  def recvmsg(dlen = T.unsafe(nil), flags = T.unsafe(nil), clen = T.unsafe(nil), scm_rights: T.unsafe(nil)); end
  def recvmsg_nonblock(dlen = T.unsafe(nil), flags = T.unsafe(nil), clen = T.unsafe(nil), scm_rights: T.unsafe(nil), exception: T.unsafe(nil)); end
  def remote_address; end
  def send(*_arg0); end
  def sendmsg(mesg, flags = T.unsafe(nil), dest_sockaddr = T.unsafe(nil), *controls); end
  def sendmsg_nonblock(mesg, flags = T.unsafe(nil), dest_sockaddr = T.unsafe(nil), *controls, exception: T.unsafe(nil)); end
  def setsockopt(*_arg0); end
  def shutdown(*_arg0); end
  private def __recv_nonblock(_arg0, _arg1, _arg2, _arg3); end
  private def __recvmsg(_arg0, _arg1, _arg2, _arg3); end
  private def __recvmsg_nonblock(_arg0, _arg1, _arg2, _arg3, _arg4); end
  private def __sendmsg(_arg0, _arg1, _arg2, _arg3); end
  private def __sendmsg_nonblock(_arg0, _arg1, _arg2, _arg3, _arg4); end
  def self.do_not_reverse_lookup; end
  def self.do_not_reverse_lookup=(_arg0); end
  def self.for_fd(_arg0); end
end

class TCPSocket < ::IPSocket
  def initialize(host, serv, *rest); end
  private def original_resolv_initialize(*_arg0); end
  def self.gethostbyname(_arg0); end
end

class SocketError < ::StandardError; end

class Addrinfo
  def initialize(*_arg0); end
  def afamily; end
  def bind; end
  def canonname; end
  def connect(timeout: T.unsafe(nil), &block); end
  def connect_from(*args, timeout: T.unsafe(nil), &block); end
  def connect_to(*args, timeout: T.unsafe(nil), &block); end
  def family_addrinfo(*args); end
  def getnameinfo(*_arg0); end
  def inspect; end
  def inspect_sockaddr; end
  def ip?; end
  def ip_address; end
  def ip_port; end
  def ip_unpack; end
  def ipv4?; end
  def ipv4_loopback?; end
  def ipv4_multicast?; end
  def ipv4_private?; end
  def ipv6?; end
  def ipv6_linklocal?; end
  def ipv6_loopback?; end
  def ipv6_mc_global?; end
  def ipv6_mc_linklocal?; end
  def ipv6_mc_nodelocal?; end
  def ipv6_mc_orglocal?; end
  def ipv6_mc_sitelocal?; end
  def ipv6_multicast?; end
  def ipv6_sitelocal?; end
  def ipv6_to_ipv4; end
  def ipv6_unique_local?; end
  def ipv6_unspecified?; end
  def ipv6_v4compat?; end
  def ipv6_v4mapped?; end
  def listen(backlog = T.unsafe(nil)); end
  def marshal_dump; end
  def marshal_load(_arg0); end
  def pfamily; end
  def protocol; end
  def socktype; end
  def to_s; end
  def to_sockaddr; end
  def unix?; end
  def unix_path; end
  protected def connect_internal(local_addrinfo, timeout = T.unsafe(nil)); end
  def self.foreach(nodename, service, family = T.unsafe(nil), socktype = T.unsafe(nil), protocol = T.unsafe(nil), flags = T.unsafe(nil), timeout: T.unsafe(nil), &block); end
  def self.getaddrinfo(*_arg0); end
  def self.ip(_arg0); end
  def self.tcp(_arg0, _arg1); end
  def self.udp(_arg0, _arg1); end
  def self.unix(*_arg0); end
end

class IPSocket < ::BasicSocket
  def addr(*_arg0); end
  def inspect; end
  def peeraddr(*_arg0); end
  def recvfrom(*_arg0); end
  def self.getaddress(host); end
  def self.original_resolv_getaddress(_arg0); end
end

class TCPServer < ::TCPSocket
  def initialize(*_arg0); end
  def accept; end
  def accept_nonblock(exception: T.unsafe(nil)); end
  def listen(_arg0); end
  def sysaccept; end
  private def __accept_nonblock(_arg0); end
end

class UNIXSocket < ::BasicSocket
  def initialize(_arg0); end
  def addr; end
  def path; end
  def peeraddr; end
  def recv_io(*_arg0); end
  def recvfrom(*_arg0); end
  def send_io(_arg0); end
  def self.pair(*_arg0); end
  def self.socketpair(*_arg0); end
end

class UNIXServer < ::UNIXSocket
  def initialize(_arg0); end
  def accept; end
  def accept_nonblock(exception: T.unsafe(nil)); end
  def listen(_arg0); end
  def sysaccept; end
  private def __accept_nonblock(_arg0); end
end

class Resolv
  def initialize(resolvers = T.unsafe(nil)); end
  def each_address(name); end
  def each_name(address); end
  def getaddress(name); end
  def getaddresses(name); end
  def getname(address); end
  def getnames(address); end
  def self.each_address(name, &block); end
  def self.each_name(address, &proc); end
  def self.getaddress(name); end
  def self.getaddresses(name); end
  def self.getname(address); end
  def self.getnames(address); end
end

module Timeout
  private def timeout(sec, klass = T.unsafe(nil), message = T.unsafe(nil), &block); end
  def self.timeout(sec, klass = T.unsafe(nil), message = T.unsafe(nil), &block); end
end

class Socket < ::BasicSocket
  def initialize(*_arg0); end
  def accept; end
  def accept_nonblock(exception: T.unsafe(nil)); end
  def bind(_arg0); end
  def connect(_arg0); end
  def connect_nonblock(addr, exception: T.unsafe(nil)); end
  def ipv6only!; end
  def listen(_arg0); end
  def recvfrom(*_arg0); end
  def recvfrom_nonblock(len, flag = T.unsafe(nil), str = T.unsafe(nil), exception: T.unsafe(nil)); end
  def sysaccept; end
  private def __accept_nonblock(_arg0); end
  private def __connect_nonblock(_arg0, _arg1); end
  private def __recvfrom_nonblock(_arg0, _arg1, _arg2, _arg3); end
  def self.accept_loop(*sockets); end
  def self.getaddrinfo(*_arg0); end
  def self.gethostbyaddr(*_arg0); end
  def self.gethostbyname(_arg0); end
  def self.gethostname; end
  def self.getifaddrs; end
  def self.getnameinfo(*_arg0); end
  def self.getservbyname(*_arg0); end
  def self.getservbyport(*_arg0); end
  def self.ip_address_list; end
  def self.pack_sockaddr_in(_arg0, _arg1); end
  def self.pack_sockaddr_un(_arg0); end
  def self.pair(*_arg0); end
  def self.sockaddr_in(_arg0, _arg1); end
  def self.sockaddr_un(_arg0); end
  def self.socketpair(*_arg0); end
  def self.tcp(host, port, local_host = T.unsafe(nil), local_port = T.unsafe(nil), connect_timeout: T.unsafe(nil), resolv_timeout: T.unsafe(nil)); end
  def self.tcp_server_loop(host = T.unsafe(nil), port, &b); end
  def self.tcp_server_sockets(host = T.unsafe(nil), port); end
  def self.udp_server_loop(host = T.unsafe(nil), port, &b); end
  def self.udp_server_loop_on(sockets, &b); end
  def self.udp_server_recv(sockets); end
  def self.udp_server_sockets(host = T.unsafe(nil), port); end
  def self.unix(path); end
  def self.unix_server_loop(path, &b); end
  def self.unix_server_socket(path); end
  def self.unpack_sockaddr_in(_arg0); end
  def self.unpack_sockaddr_un(_arg0); end
  private def self.ip_sockets_port0(ai_list, reuseaddr); end
  private def self.tcp_server_sockets_port0(host); end
  private def self.unix_socket_abstract_name?(path); end
end

class IO
  include ::Enumerable
  include ::File::Constants
  def initialize(*_arg0); end
  def <<(_arg0); end
  def advise(*_arg0); end
  def autoclose=(_arg0); end
  def autoclose?; end
  def beep; end
  def binmode; end
  def binmode?; end
  def check_winsize_changed; end
  def clear_screen; end
  def close; end
  def close_on_exec=(_arg0); end
  def close_on_exec?; end
  def close_read; end
  def close_write; end
  def closed?; end
  def console_mode; end
  def console_mode=(_arg0); end
  def cooked; end
  def cooked!; end
  def cursor; end
  def cursor=(_arg0); end
  def cursor_down(_arg0); end
  def cursor_left(_arg0); end
  def cursor_right(_arg0); end
  def cursor_up(_arg0); end
  def each(*_arg0); end
  def each_byte; end
  def each_char; end
  def each_codepoint; end
  def each_line(*_arg0); end
  def echo=(_arg0); end
  def echo?; end
  def eof; end
  def eof?; end
  def erase_line(_arg0); end
  def erase_screen(_arg0); end
  def expect(pat, timeout = T.unsafe(nil)); end
  def external_encoding; end
  def fcntl(*_arg0); end
  def fdatasync; end
  def fileno; end
  def flush; end
  def fsync; end
  def getbyte; end
  def getc; end
  def getch(*_arg0); end
  def getpass(*_arg0); end
  def gets(*_arg0); end
  def goto(_arg0, _arg1); end
  def goto_column(_arg0); end
  def iflush; end
  def inspect; end
  def internal_encoding; end
  def ioctl(*_arg0); end
  def ioflush; end
  def isatty; end
  def lineno; end
  def lineno=(_arg0); end
  def noecho; end
  def nonblock(*_arg0); end
  def nonblock=(_arg0); end
  def nonblock?; end
  def nread; end
  def oflush; end
  def pathconf(_arg0); end
  def pid; end
  def pos; end
  def pos=(_arg0); end
  def pread(*_arg0); end
  def pressed?; end
  def print(*_arg0); end
  def printf(*_arg0); end
  def putc(_arg0); end
  def puts(*_arg0); end
  def pwrite(_arg0, _arg1); end
  def raw(*_arg0); end
  def raw!(*_arg0); end
  def read(*_arg0); end
  def read_nonblock(len, buf = T.unsafe(nil), exception: T.unsafe(nil)); end
  def readbyte; end
  def readchar; end
  def readline(*_arg0); end
  def readlines(*_arg0); end
  def readpartial(*_arg0); end
  def ready?; end
  def reopen(*_arg0); end
  def rewind; end
  def scroll_backward(_arg0); end
  def scroll_forward(_arg0); end
  def seek(*_arg0); end
  def set_encoding(*_arg0); end
  def set_encoding_by_bom; end
  def stat; end
  def sync; end
  def sync=(_arg0); end
  def sysread(*_arg0); end
  def sysseek(*_arg0); end
  def syswrite(_arg0); end
  def tell; end
  def to_i; end
  def to_io; end
  def tty?; end
  def ungetbyte(_arg0); end
  def ungetc(_arg0); end
  def wait(*_arg0); end
  def wait_priority(*_arg0); end
  def wait_readable(*_arg0); end
  def wait_writable(*_arg0); end
  def winsize; end
  def winsize=(_arg0); end
  def write(*_arg0); end
  def write_nonblock(buf, exception: T.unsafe(nil)); end
  private def initialize_copy(_arg0); end
  def self.binread(*_arg0); end
  def self.binwrite(*_arg0); end
  def self.console(*_arg0); end
  def self.copy_stream(*_arg0); end
  def self.for_fd(*_arg0); end
  def self.foreach(*_arg0); end
  def self.new(*_arg0); end
  def self.open(*_arg0); end
  def self.pipe(*_arg0); end
  def self.popen(*_arg0); end
  def self.read(*_arg0); end
  def self.readlines(*_arg0); end
  def self.select(*_arg0); end
  def self.sysopen(*_arg0); end
  def self.try_convert(_arg0); end
  def self.write(*_arg0); end
end

class StandardError < ::Exception; end
Resolv::AddressRegex = T.let(T.unsafe(nil), Regexp)

class Resolv::DNS
  def initialize(config_info = T.unsafe(nil)); end
  def close; end
  def each_address(name); end
  def each_name(address); end
  def each_resource(name, typeclass, &proc); end
  def extract_resources(msg, name, typeclass); end
  def fetch_resource(name, typeclass); end
  def getaddress(name); end
  def getaddresses(name); end
  def getname(address); end
  def getnames(address); end
  def getresource(name, typeclass); end
  def getresources(name, typeclass); end
  def lazy_initialize; end
  def make_tcp_requester(host, port); end
  def make_udp_requester; end
  def timeouts=(values); end
  private def use_ipv6?; end
  def self.allocate_request_id(host, port); end
  def self.bind_random_port(udpsock, bind_host = T.unsafe(nil)); end
  def self.free_request_id(host, port, id); end
  def self.open(*args); end
  def self.random(arg); end
end

Resolv::DefaultResolver = T.let(T.unsafe(nil), Resolv)

class Resolv::Hosts
  def initialize(filename = T.unsafe(nil)); end
  def each_address(name, &proc); end
  def each_name(address, &proc); end
  def getaddress(name); end
  def getaddresses(name); end
  def getname(address); end
  def getnames(address); end
  def lazy_initialize; end
end

class Resolv::IPv4
  def initialize(address); end
  def ==(other); end
  def address; end
  def eql?(other); end
  def hash; end
  def inspect; end
  def to_name; end
  def to_s; end
  def self.create(arg); end
end

class Resolv::IPv6
  def initialize(address); end
  def ==(other); end
  def address; end
  def eql?(other); end
  def hash; end
  def inspect; end
  def to_name; end
  def to_s; end
  def self.create(arg); end
end

module Resolv::LOC; end

class Resolv::MDNS < ::Resolv::DNS
  def initialize(config_info = T.unsafe(nil)); end
  def each_address(name); end
  def make_udp_requester; end
end

class Resolv::ResolvError < ::StandardError; end
class Resolv::ResolvTimeout < ::Timeout::Error; end

class Timeout::Error < ::RuntimeError
  def exception(*_arg0); end
  def thread; end
  def self.catch(*args); end
end

Timeout::VERSION = T.let(T.unsafe(nil), String)
Socket::AF_APPLETALK = T.let(T.unsafe(nil), Integer)
Socket::AF_CCITT = T.let(T.unsafe(nil), Integer)
Socket::AF_CHAOS = T.let(T.unsafe(nil), Integer)
Socket::AF_CNT = T.let(T.unsafe(nil), Integer)
Socket::AF_COIP = T.let(T.unsafe(nil), Integer)
Socket::AF_DATAKIT = T.let(T.unsafe(nil), Integer)
Socket::AF_DLI = T.let(T.unsafe(nil), Integer)
Socket::AF_E164 = T.let(T.unsafe(nil), Integer)
Socket::AF_ECMA = T.let(T.unsafe(nil), Integer)
Socket::AF_HYLINK = T.let(T.unsafe(nil), Integer)
Socket::AF_IMPLINK = T.let(T.unsafe(nil), Integer)
Socket::AF_INET = T.let(T.unsafe(nil), Integer)
Socket::AF_INET6 = T.let(T.unsafe(nil), Integer)
Socket::AF_IPX = T.let(T.unsafe(nil), Integer)
Socket::AF_ISDN = T.let(T.unsafe(nil), Integer)
Socket::AF_ISO = T.let(T.unsafe(nil), Integer)
Socket::AF_LAT = T.let(T.unsafe(nil), Integer)
Socket::AF_LINK = T.let(T.unsafe(nil), Integer)
Socket::AF_LOCAL = T.let(T.unsafe(nil), Integer)
Socket::AF_MAX = T.let(T.unsafe(nil), Integer)
Socket::AF_NATM = T.let(T.unsafe(nil), Integer)
Socket::AF_NDRV = T.let(T.unsafe(nil), Integer)
Socket::AF_NETBIOS = T.let(T.unsafe(nil), Integer)
Socket::AF_NS = T.let(T.unsafe(nil), Integer)
Socket::AF_OSI = T.let(T.unsafe(nil), Integer)
Socket::AF_PPP = T.let(T.unsafe(nil), Integer)
Socket::AF_PUP = T.let(T.unsafe(nil), Integer)
Socket::AF_ROUTE = T.let(T.unsafe(nil), Integer)
Socket::AF_SIP = T.let(T.unsafe(nil), Integer)
Socket::AF_SNA = T.let(T.unsafe(nil), Integer)
Socket::AF_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::AF_UNIX = T.let(T.unsafe(nil), Integer)
Socket::AF_UNSPEC = T.let(T.unsafe(nil), Integer)
Socket::AI_ADDRCONFIG = T.let(T.unsafe(nil), Integer)
Socket::AI_ALL = T.let(T.unsafe(nil), Integer)
Socket::AI_CANONNAME = T.let(T.unsafe(nil), Integer)
Socket::AI_DEFAULT = T.let(T.unsafe(nil), Integer)
Socket::AI_MASK = T.let(T.unsafe(nil), Integer)
Socket::AI_NUMERICHOST = T.let(T.unsafe(nil), Integer)
Socket::AI_NUMERICSERV = T.let(T.unsafe(nil), Integer)
Socket::AI_PASSIVE = T.let(T.unsafe(nil), Integer)
Socket::AI_V4MAPPED = T.let(T.unsafe(nil), Integer)
Socket::AI_V4MAPPED_CFG = T.let(T.unsafe(nil), Integer)

class Socket::AncillaryData
  def initialize(_arg0, _arg1, _arg2, _arg3); end
  def cmsg_is?(_arg0, _arg1); end
  def data; end
  def family; end
  def inspect; end
  def int; end
  def ip_pktinfo; end
  def ipv6_pktinfo; end
  def ipv6_pktinfo_addr; end
  def ipv6_pktinfo_ifindex; end
  def level; end
  def timestamp; end
  def type; end
  def unix_rights; end
  def self.int(_arg0, _arg1, _arg2, _arg3); end
  def self.ip_pktinfo(*_arg0); end
  def self.ipv6_pktinfo(_arg0, _arg1); end
  def self.unix_rights(*_arg0); end
end

module Socket::Constants; end
Socket::EAI_ADDRFAMILY = T.let(T.unsafe(nil), Integer)
Socket::EAI_AGAIN = T.let(T.unsafe(nil), Integer)
Socket::EAI_BADFLAGS = T.let(T.unsafe(nil), Integer)
Socket::EAI_BADHINTS = T.let(T.unsafe(nil), Integer)
Socket::EAI_FAIL = T.let(T.unsafe(nil), Integer)
Socket::EAI_FAMILY = T.let(T.unsafe(nil), Integer)
Socket::EAI_MAX = T.let(T.unsafe(nil), Integer)
Socket::EAI_MEMORY = T.let(T.unsafe(nil), Integer)
Socket::EAI_NODATA = T.let(T.unsafe(nil), Integer)
Socket::EAI_NONAME = T.let(T.unsafe(nil), Integer)
Socket::EAI_OVERFLOW = T.let(T.unsafe(nil), Integer)
Socket::EAI_PROTOCOL = T.let(T.unsafe(nil), Integer)
Socket::EAI_SERVICE = T.let(T.unsafe(nil), Integer)
Socket::EAI_SOCKTYPE = T.let(T.unsafe(nil), Integer)
Socket::EAI_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::IFF_ALLMULTI = T.let(T.unsafe(nil), Integer)
Socket::IFF_ALTPHYS = T.let(T.unsafe(nil), Integer)
Socket::IFF_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::IFF_DEBUG = T.let(T.unsafe(nil), Integer)
Socket::IFF_LINK0 = T.let(T.unsafe(nil), Integer)
Socket::IFF_LINK1 = T.let(T.unsafe(nil), Integer)
Socket::IFF_LINK2 = T.let(T.unsafe(nil), Integer)
Socket::IFF_LOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::IFF_MULTICAST = T.let(T.unsafe(nil), Integer)
Socket::IFF_NOARP = T.let(T.unsafe(nil), Integer)
Socket::IFF_NOTRAILERS = T.let(T.unsafe(nil), Integer)
Socket::IFF_OACTIVE = T.let(T.unsafe(nil), Integer)
Socket::IFF_POINTOPOINT = T.let(T.unsafe(nil), Integer)
Socket::IFF_PROMISC = T.let(T.unsafe(nil), Integer)
Socket::IFF_RUNNING = T.let(T.unsafe(nil), Integer)
Socket::IFF_SIMPLEX = T.let(T.unsafe(nil), Integer)
Socket::IFF_UP = T.let(T.unsafe(nil), Integer)
Socket::IFNAMSIZ = T.let(T.unsafe(nil), Integer)
Socket::IF_NAMESIZE = T.let(T.unsafe(nil), Integer)
Socket::INADDR_ALLHOSTS_GROUP = T.let(T.unsafe(nil), Integer)
Socket::INADDR_ANY = T.let(T.unsafe(nil), Integer)
Socket::INADDR_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::INADDR_LOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::INADDR_MAX_LOCAL_GROUP = T.let(T.unsafe(nil), Integer)
Socket::INADDR_NONE = T.let(T.unsafe(nil), Integer)
Socket::INADDR_UNSPEC_GROUP = T.let(T.unsafe(nil), Integer)
Socket::INET6_ADDRSTRLEN = T.let(T.unsafe(nil), Integer)
Socket::INET_ADDRSTRLEN = T.let(T.unsafe(nil), Integer)
Socket::IPPORT_RESERVED = T.let(T.unsafe(nil), Integer)
Socket::IPPORT_USERRESERVED = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_AH = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_DSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_EGP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_EON = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ESP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_FRAGMENT = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_GGP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_HELLO = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_HOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ICMP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ICMPV6 = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_IDP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_IGMP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_IP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_IPV6 = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_MAX = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ND = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_NONE = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_PUP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_RAW = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ROUTING = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_TCP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_TP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_UDP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_XTP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_CHECKSUM = T.let(T.unsafe(nil), Integer)
Socket::IPV6_DONTFRAG = T.let(T.unsafe(nil), Integer)
Socket::IPV6_DSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_HOPLIMIT = T.let(T.unsafe(nil), Integer)
Socket::IPV6_HOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_JOIN_GROUP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_LEAVE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_MULTICAST_HOPS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_MULTICAST_IF = T.let(T.unsafe(nil), Integer)
Socket::IPV6_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_NEXTHOP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_PATHMTU = T.let(T.unsafe(nil), Integer)
Socket::IPV6_PKTINFO = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVDSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVHOPLIMIT = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVHOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVPATHMTU = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVPKTINFO = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVRTHDR = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVTCLASS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RTHDR = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RTHDRDSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RTHDR_TYPE_0 = T.let(T.unsafe(nil), Integer)
Socket::IPV6_TCLASS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_UNICAST_HOPS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_USE_MIN_MTU = T.let(T.unsafe(nil), Integer)
Socket::IPV6_V6ONLY = T.let(T.unsafe(nil), Integer)
Socket::IP_ADD_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::IP_ADD_SOURCE_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::IP_BLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::IP_DEFAULT_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::IP_DEFAULT_MULTICAST_TTL = T.let(T.unsafe(nil), Integer)
Socket::IP_DONTFRAG = T.let(T.unsafe(nil), Integer)
Socket::IP_DROP_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::IP_DROP_SOURCE_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::IP_HDRINCL = T.let(T.unsafe(nil), Integer)
Socket::IP_IPSEC_POLICY = T.let(T.unsafe(nil), Integer)
Socket::IP_MAX_MEMBERSHIPS = T.let(T.unsafe(nil), Integer)
Socket::IP_MSFILTER = T.let(T.unsafe(nil), Integer)
Socket::IP_MULTICAST_IF = T.let(T.unsafe(nil), Integer)
Socket::IP_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::IP_MULTICAST_TTL = T.let(T.unsafe(nil), Integer)
Socket::IP_OPTIONS = T.let(T.unsafe(nil), Integer)
Socket::IP_PKTINFO = T.let(T.unsafe(nil), Integer)
Socket::IP_PORTRANGE = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVDSTADDR = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVIF = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVOPTS = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVRETOPTS = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVTOS = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVTTL = T.let(T.unsafe(nil), Integer)
Socket::IP_RETOPTS = T.let(T.unsafe(nil), Integer)
Socket::IP_TOS = T.let(T.unsafe(nil), Integer)
Socket::IP_TTL = T.let(T.unsafe(nil), Integer)
Socket::IP_UNBLOCK_SOURCE = T.let(T.unsafe(nil), Integer)

class Socket::Ifaddr
  def addr; end
  def broadaddr; end
  def dstaddr; end
  def flags; end
  def ifindex; end
  def inspect; end
  def name; end
  def netmask; end
end

Socket::LOCAL_PEERCRED = T.let(T.unsafe(nil), Integer)
Socket::MCAST_BLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::MCAST_EXCLUDE = T.let(T.unsafe(nil), Integer)
Socket::MCAST_INCLUDE = T.let(T.unsafe(nil), Integer)
Socket::MCAST_JOIN_GROUP = T.let(T.unsafe(nil), Integer)
Socket::MCAST_JOIN_SOURCE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::MCAST_LEAVE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::MCAST_LEAVE_SOURCE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::MCAST_UNBLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::MSG_CTRUNC = T.let(T.unsafe(nil), Integer)
Socket::MSG_DONTROUTE = T.let(T.unsafe(nil), Integer)
Socket::MSG_DONTWAIT = T.let(T.unsafe(nil), Integer)
Socket::MSG_EOF = T.let(T.unsafe(nil), Integer)
Socket::MSG_EOR = T.let(T.unsafe(nil), Integer)
Socket::MSG_FLUSH = T.let(T.unsafe(nil), Integer)
Socket::MSG_HAVEMORE = T.let(T.unsafe(nil), Integer)
Socket::MSG_HOLD = T.let(T.unsafe(nil), Integer)
Socket::MSG_NOSIGNAL = T.let(T.unsafe(nil), Integer)
Socket::MSG_OOB = T.let(T.unsafe(nil), Integer)
Socket::MSG_PEEK = T.let(T.unsafe(nil), Integer)
Socket::MSG_RCVMORE = T.let(T.unsafe(nil), Integer)
Socket::MSG_SEND = T.let(T.unsafe(nil), Integer)
Socket::MSG_TRUNC = T.let(T.unsafe(nil), Integer)
Socket::MSG_WAITALL = T.let(T.unsafe(nil), Integer)
Socket::NI_DGRAM = T.let(T.unsafe(nil), Integer)
Socket::NI_MAXHOST = T.let(T.unsafe(nil), Integer)
Socket::NI_MAXSERV = T.let(T.unsafe(nil), Integer)
Socket::NI_NAMEREQD = T.let(T.unsafe(nil), Integer)
Socket::NI_NOFQDN = T.let(T.unsafe(nil), Integer)
Socket::NI_NUMERICHOST = T.let(T.unsafe(nil), Integer)
Socket::NI_NUMERICSERV = T.let(T.unsafe(nil), Integer)

class Socket::Option
  def initialize(_arg0, _arg1, _arg2, _arg3); end
  def bool; end
  def byte; end
  def data; end
  def family; end
  def inspect; end
  def int; end
  def ipv4_multicast_loop; end
  def ipv4_multicast_ttl; end
  def level; end
  def linger; end
  def optname; end
  def to_s; end
  def unpack(_arg0); end
  def self.bool(_arg0, _arg1, _arg2, _arg3); end
  def self.byte(_arg0, _arg1, _arg2, _arg3); end
  def self.int(_arg0, _arg1, _arg2, _arg3); end
  def self.ipv4_multicast_loop(_arg0); end
  def self.ipv4_multicast_ttl(_arg0); end
  def self.linger(_arg0, _arg1); end
end

Socket::PF_APPLETALK = T.let(T.unsafe(nil), Integer)
Socket::PF_CCITT = T.let(T.unsafe(nil), Integer)
Socket::PF_CHAOS = T.let(T.unsafe(nil), Integer)
Socket::PF_CNT = T.let(T.unsafe(nil), Integer)
Socket::PF_COIP = T.let(T.unsafe(nil), Integer)
Socket::PF_DATAKIT = T.let(T.unsafe(nil), Integer)
Socket::PF_DLI = T.let(T.unsafe(nil), Integer)
Socket::PF_ECMA = T.let(T.unsafe(nil), Integer)
Socket::PF_HYLINK = T.let(T.unsafe(nil), Integer)
Socket::PF_IMPLINK = T.let(T.unsafe(nil), Integer)
Socket::PF_INET = T.let(T.unsafe(nil), Integer)
Socket::PF_INET6 = T.let(T.unsafe(nil), Integer)
Socket::PF_IPX = T.let(T.unsafe(nil), Integer)
Socket::PF_ISDN = T.let(T.unsafe(nil), Integer)
Socket::PF_ISO = T.let(T.unsafe(nil), Integer)
Socket::PF_KEY = T.let(T.unsafe(nil), Integer)
Socket::PF_LAT = T.let(T.unsafe(nil), Integer)
Socket::PF_LINK = T.let(T.unsafe(nil), Integer)
Socket::PF_LOCAL = T.let(T.unsafe(nil), Integer)
Socket::PF_MAX = T.let(T.unsafe(nil), Integer)
Socket::PF_NATM = T.let(T.unsafe(nil), Integer)
Socket::PF_NDRV = T.let(T.unsafe(nil), Integer)
Socket::PF_NETBIOS = T.let(T.unsafe(nil), Integer)
Socket::PF_NS = T.let(T.unsafe(nil), Integer)
Socket::PF_OSI = T.let(T.unsafe(nil), Integer)
Socket::PF_PIP = T.let(T.unsafe(nil), Integer)
Socket::PF_PPP = T.let(T.unsafe(nil), Integer)
Socket::PF_PUP = T.let(T.unsafe(nil), Integer)
Socket::PF_ROUTE = T.let(T.unsafe(nil), Integer)
Socket::PF_RTIP = T.let(T.unsafe(nil), Integer)
Socket::PF_SIP = T.let(T.unsafe(nil), Integer)
Socket::PF_SNA = T.let(T.unsafe(nil), Integer)
Socket::PF_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::PF_UNIX = T.let(T.unsafe(nil), Integer)
Socket::PF_UNSPEC = T.let(T.unsafe(nil), Integer)
Socket::PF_XTP = T.let(T.unsafe(nil), Integer)
Socket::SCM_CREDS = T.let(T.unsafe(nil), Integer)
Socket::SCM_RIGHTS = T.let(T.unsafe(nil), Integer)
Socket::SCM_TIMESTAMP = T.let(T.unsafe(nil), Integer)
Socket::SHUT_RD = T.let(T.unsafe(nil), Integer)
Socket::SHUT_RDWR = T.let(T.unsafe(nil), Integer)
Socket::SHUT_WR = T.let(T.unsafe(nil), Integer)
Socket::SOCK_DGRAM = T.let(T.unsafe(nil), Integer)
Socket::SOCK_RAW = T.let(T.unsafe(nil), Integer)
Socket::SOCK_RDM = T.let(T.unsafe(nil), Integer)
Socket::SOCK_SEQPACKET = T.let(T.unsafe(nil), Integer)
Socket::SOCK_STREAM = T.let(T.unsafe(nil), Integer)
Socket::SOL_SOCKET = T.let(T.unsafe(nil), Integer)
Socket::SOMAXCONN = T.let(T.unsafe(nil), Integer)
Socket::SO_ACCEPTCONN = T.let(T.unsafe(nil), Integer)
Socket::SO_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::SO_DEBUG = T.let(T.unsafe(nil), Integer)
Socket::SO_DONTROUTE = T.let(T.unsafe(nil), Integer)
Socket::SO_DONTTRUNC = T.let(T.unsafe(nil), Integer)
Socket::SO_ERROR = T.let(T.unsafe(nil), Integer)
Socket::SO_KEEPALIVE = T.let(T.unsafe(nil), Integer)
Socket::SO_LINGER = T.let(T.unsafe(nil), Integer)
Socket::SO_NKE = T.let(T.unsafe(nil), Integer)
Socket::SO_NOSIGPIPE = T.let(T.unsafe(nil), Integer)
Socket::SO_NREAD = T.let(T.unsafe(nil), Integer)
Socket::SO_OOBINLINE = T.let(T.unsafe(nil), Integer)
Socket::SO_RCVBUF = T.let(T.unsafe(nil), Integer)
Socket::SO_RCVLOWAT = T.let(T.unsafe(nil), Integer)
Socket::SO_RCVTIMEO = T.let(T.unsafe(nil), Integer)
Socket::SO_REUSEADDR = T.let(T.unsafe(nil), Integer)
Socket::SO_REUSEPORT = T.let(T.unsafe(nil), Integer)
Socket::SO_SNDBUF = T.let(T.unsafe(nil), Integer)
Socket::SO_SNDLOWAT = T.let(T.unsafe(nil), Integer)
Socket::SO_SNDTIMEO = T.let(T.unsafe(nil), Integer)
Socket::SO_TIMESTAMP = T.let(T.unsafe(nil), Integer)
Socket::SO_TYPE = T.let(T.unsafe(nil), Integer)
Socket::SO_USELOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::SO_WANTMORE = T.let(T.unsafe(nil), Integer)
Socket::SO_WANTOOBFLAG = T.let(T.unsafe(nil), Integer)
Socket::TCP_FASTOPEN = T.let(T.unsafe(nil), Integer)
Socket::TCP_KEEPCNT = T.let(T.unsafe(nil), Integer)
Socket::TCP_KEEPINTVL = T.let(T.unsafe(nil), Integer)
Socket::TCP_MAXSEG = T.let(T.unsafe(nil), Integer)
Socket::TCP_NODELAY = T.let(T.unsafe(nil), Integer)
Socket::TCP_NOOPT = T.let(T.unsafe(nil), Integer)
Socket::TCP_NOPUSH = T.let(T.unsafe(nil), Integer)

class Socket::UDPSource
  def initialize(remote_address, local_address, &reply_proc); end
  def inspect; end
  def local_address; end
  def remote_address; end
  def reply(msg); end
end

module Random::Formatter
  def alphanumeric(n = T.unsafe(nil)); end
  def base64(n = T.unsafe(nil)); end
  def hex(n = T.unsafe(nil)); end
  def rand(*_arg0); end
  def random_bytes(n = T.unsafe(nil)); end
  def random_number(*_arg0); end
  def urlsafe_base64(n = T.unsafe(nil), padding = T.unsafe(nil)); end
  def uuid; end
  private def choose(source, n); end
  private def gen_random(n); end
end

class IO::ConsoleMode
  def echo=(_arg0); end
  def raw(*_arg0); end
  def raw!(*_arg0); end
  private def initialize_copy(_arg0); end
end

class IO::EAGAINWaitReadable < ::Errno::EAGAIN
  include ::IO::WaitReadable
end

class IO::EAGAINWaitWritable < ::Errno::EAGAIN
  include ::IO::WaitWritable
end

class IO::EINPROGRESSWaitReadable < ::Errno::EINPROGRESS
  include ::IO::WaitReadable
end

class IO::EINPROGRESSWaitWritable < ::Errno::EINPROGRESS
  include ::IO::WaitWritable
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable
IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable
IO::PRIORITY = T.let(T.unsafe(nil), Integer)
IO::READABLE = T.let(T.unsafe(nil), Integer)
IO::SEEK_CUR = T.let(T.unsafe(nil), Integer)
IO::SEEK_DATA = T.let(T.unsafe(nil), Integer)
IO::SEEK_END = T.let(T.unsafe(nil), Integer)
IO::SEEK_HOLE = T.let(T.unsafe(nil), Integer)
IO::SEEK_SET = T.let(T.unsafe(nil), Integer)
IO::WRITABLE = T.let(T.unsafe(nil), Integer)
module IO::WaitReadable; end
module IO::WaitWritable; end

class Exception
  def initialize(*_arg0); end
  def ==(_arg0); end
  def backtrace; end
  def backtrace_locations; end
  def cause; end
  def exception(*_arg0); end
  def full_message(*_arg0); end
  def inspect; end
  def message; end
  def respond_to?(*_arg0); end
  def set_backtrace(_arg0); end
  def to_s; end
  private def method_missing(*_arg0); end
  private def respond_to_missing?(_arg0, _arg1); end
  def self.exception(*_arg0); end
  def self.to_tty?; end
end

class Resolv::DNS::Config
  def initialize(config_info = T.unsafe(nil)); end
  def generate_candidates(name); end
  def generate_timeouts; end
  def lazy_initialize; end
  def nameserver_port; end
  def resolv(name); end
  def single?; end
  def timeouts=(values); end
  def self.default_config_hash(filename = T.unsafe(nil)); end
  def self.parse_resolv_conf(filename); end
end

class Resolv::DNS::DecodeError < ::StandardError; end
class Resolv::DNS::EncodeError < ::StandardError; end

module Resolv::DNS::Label
  def self.split(arg); end
end

class Resolv::DNS::Message
  def initialize(id = T.unsafe(nil)); end
  def ==(other); end
  def aa; end
  def aa=(_arg0); end
  def add_additional(name, ttl, data); end
  def add_answer(name, ttl, data); end
  def add_authority(name, ttl, data); end
  def add_question(name, typeclass); end
  def additional; end
  def answer; end
  def authority; end
  def each_additional; end
  def each_answer; end
  def each_authority; end
  def each_question; end
  def each_resource; end
  def encode; end
  def id; end
  def id=(_arg0); end
  def opcode; end
  def opcode=(_arg0); end
  def qr; end
  def qr=(_arg0); end
  def question; end
  def ra; end
  def ra=(_arg0); end
  def rcode; end
  def rcode=(_arg0); end
  def rd; end
  def rd=(_arg0); end
  def tc; end
  def tc=(_arg0); end
  def self.decode(m); end
end

class Resolv::DNS::Name
  def initialize(labels, absolute = T.unsafe(nil)); end
  def ==(other); end
  def [](i); end
  def absolute?; end
  def eql?(other); end
  def hash; end
  def inspect; end
  def length; end
  def subdomain_of?(other); end
  def to_a; end
  def to_s; end
  def self.create(arg); end
end

module Resolv::DNS::OpCode; end
Resolv::DNS::Port = T.let(T.unsafe(nil), Integer)

class Resolv::DNS::Query
  def encode_rdata(msg); end
  def self.decode_rdata(msg); end
end

module Resolv::DNS::RCode; end
Resolv::DNS::RequestID = T.let(T.unsafe(nil), Hash)
Resolv::DNS::RequestIDMutex = T.let(T.unsafe(nil), Thread::Mutex)

class Resolv::DNS::Requester
  def initialize; end
  def close; end
  def request(sender, tout); end
  def sender_for(addr, msg); end
end

class Resolv::DNS::Resource < ::Resolv::DNS::Query
  def ==(other); end
  def encode_rdata(msg); end
  def eql?(other); end
  def hash; end
  def ttl; end
  def self.decode_rdata(msg); end
  def self.get_class(type_value, class_value); end
end

Resolv::DNS::UDPSize = T.let(T.unsafe(nil), Integer)
Resolv::Hosts::DefaultFileName = T.let(T.unsafe(nil), String)
Resolv::IPv4::Regex = T.let(T.unsafe(nil), Regexp)
Resolv::IPv4::Regex256 = T.let(T.unsafe(nil), Regexp)
Resolv::IPv6::Regex = T.let(T.unsafe(nil), Regexp)
Resolv::IPv6::Regex_6Hex4Dec = T.let(T.unsafe(nil), Regexp)
Resolv::IPv6::Regex_8Hex = T.let(T.unsafe(nil), Regexp)
Resolv::IPv6::Regex_8HexLinkLocal = T.let(T.unsafe(nil), Regexp)
Resolv::IPv6::Regex_CompressedHex = T.let(T.unsafe(nil), Regexp)
Resolv::IPv6::Regex_CompressedHex4Dec = T.let(T.unsafe(nil), Regexp)
Resolv::IPv6::Regex_CompressedHexLinkLocal = T.let(T.unsafe(nil), Regexp)

class Resolv::LOC::Alt
  def initialize(altitude); end
  def ==(other); end
  def altitude; end
  def eql?(other); end
  def hash; end
  def inspect; end
  def to_s; end
  def self.create(arg); end
end

class Resolv::LOC::Coord
  def initialize(coordinates, orientation); end
  def ==(other); end
  def coordinates; end
  def eql?(other); end
  def hash; end
  def inspect; end
  def orientation; end
  def to_s; end
  def self.create(arg); end
end

class Resolv::LOC::Size
  def initialize(scalar); end
  def ==(other); end
  def eql?(other); end
  def hash; end
  def inspect; end
  def scalar; end
  def to_s; end
  def self.create(arg); end
end

Resolv::MDNS::AddressV4 = T.let(T.unsafe(nil), String)
Resolv::MDNS::AddressV6 = T.let(T.unsafe(nil), String)
Resolv::MDNS::Addresses = T.let(T.unsafe(nil), Array)
Resolv::MDNS::Port = T.let(T.unsafe(nil), Integer)
class RuntimeError < ::StandardError; end
Socket::Constants::AF_APPLETALK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_CCITT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_CHAOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_CNT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_COIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_DATAKIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_DLI = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_E164 = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_ECMA = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_HYLINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_IMPLINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_INET = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_INET6 = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_IPX = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_ISDN = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_ISO = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_LAT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_LINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_LOCAL = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_MAX = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_NATM = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_NDRV = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_NETBIOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_NS = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_OSI = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_PPP = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_PUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_ROUTE = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_SIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_SNA = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_UNIX = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_UNSPEC = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_ADDRCONFIG = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_ALL = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_CANONNAME = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_DEFAULT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_MASK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_NUMERICHOST = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_NUMERICSERV = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_PASSIVE = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_V4MAPPED = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_V4MAPPED_CFG = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_ADDRFAMILY = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_AGAIN = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_BADFLAGS = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_BADHINTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_FAIL = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_FAMILY = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_MAX = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_MEMORY = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_NODATA = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_NONAME = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_OVERFLOW = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_PROTOCOL = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_SERVICE = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_SOCKTYPE = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_ALLMULTI = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_ALTPHYS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_DEBUG = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_LINK0 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_LINK1 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_LINK2 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_LOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_MULTICAST = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_NOARP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_NOTRAILERS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_OACTIVE = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_POINTOPOINT = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_PROMISC = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_RUNNING = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_SIMPLEX = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_UP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFNAMSIZ = T.let(T.unsafe(nil), Integer)
Socket::Constants::IF_NAMESIZE = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_ALLHOSTS_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_ANY = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_LOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_MAX_LOCAL_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_NONE = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_UNSPEC_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::INET6_ADDRSTRLEN = T.let(T.unsafe(nil), Integer)
Socket::Constants::INET_ADDRSTRLEN = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPORT_RESERVED = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPORT_USERRESERVED = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_AH = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_DSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_EGP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_EON = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ESP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_FRAGMENT = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_GGP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_HELLO = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_HOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ICMP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ICMPV6 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_IDP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_IGMP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_IP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_IPV6 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_MAX = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ND = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_NONE = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_PUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_RAW = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ROUTING = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_TCP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_TP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_UDP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_XTP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_CHECKSUM = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_DONTFRAG = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_DSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_HOPLIMIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_HOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_JOIN_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_LEAVE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_MULTICAST_HOPS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_MULTICAST_IF = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_NEXTHOP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_PATHMTU = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_PKTINFO = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVDSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVHOPLIMIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVHOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVPATHMTU = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVPKTINFO = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVRTHDR = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVTCLASS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RTHDR = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RTHDRDSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RTHDR_TYPE_0 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_TCLASS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_UNICAST_HOPS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_USE_MIN_MTU = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_V6ONLY = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_ADD_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_ADD_SOURCE_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_BLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DEFAULT_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DEFAULT_MULTICAST_TTL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DONTFRAG = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DROP_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DROP_SOURCE_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_HDRINCL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_IPSEC_POLICY = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MAX_MEMBERSHIPS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MSFILTER = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MULTICAST_IF = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MULTICAST_TTL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_OPTIONS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_PKTINFO = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_PORTRANGE = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVDSTADDR = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVIF = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVRETOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVTOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVTTL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RETOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_TOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_TTL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_UNBLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::Constants::LOCAL_PEERCRED = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_BLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_EXCLUDE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_INCLUDE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_JOIN_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_JOIN_SOURCE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_LEAVE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_LEAVE_SOURCE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_UNBLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_CTRUNC = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_DONTROUTE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_DONTWAIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_EOF = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_EOR = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_FLUSH = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_HAVEMORE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_HOLD = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_NOSIGNAL = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_OOB = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_PEEK = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_RCVMORE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_SEND = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_TRUNC = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_WAITALL = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_DGRAM = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_MAXHOST = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_MAXSERV = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_NAMEREQD = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_NOFQDN = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_NUMERICHOST = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_NUMERICSERV = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_APPLETALK = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_CCITT = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_CHAOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_CNT = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_COIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_DATAKIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_DLI = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_ECMA = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_HYLINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_IMPLINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_INET = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_INET6 = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_IPX = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_ISDN = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_ISO = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_KEY = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_LAT = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_LINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_LOCAL = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_MAX = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_NATM = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_NDRV = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_NETBIOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_NS = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_OSI = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_PIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_PPP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_PUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_ROUTE = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_RTIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_SIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_SNA = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_UNIX = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_UNSPEC = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_XTP = T.let(T.unsafe(nil), Integer)
Socket::Constants::SCM_CREDS = T.let(T.unsafe(nil), Integer)
Socket::Constants::SCM_RIGHTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::SCM_TIMESTAMP = T.let(T.unsafe(nil), Integer)
Socket::Constants::SHUT_RD = T.let(T.unsafe(nil), Integer)
Socket::Constants::SHUT_RDWR = T.let(T.unsafe(nil), Integer)
Socket::Constants::SHUT_WR = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_DGRAM = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_RAW = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_RDM = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_SEQPACKET = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_STREAM = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOL_SOCKET = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOMAXCONN = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_ACCEPTCONN = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_DEBUG = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_DONTROUTE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_DONTTRUNC = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_ERROR = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_KEEPALIVE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_LINGER = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_NKE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_NOSIGPIPE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_NREAD = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_OOBINLINE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_RCVBUF = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_RCVLOWAT = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_RCVTIMEO = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_REUSEADDR = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_REUSEPORT = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_SNDBUF = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_SNDLOWAT = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_SNDTIMEO = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_TIMESTAMP = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_TYPE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_USELOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_WANTMORE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_WANTOOBFLAG = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_FASTOPEN = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_KEEPCNT = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_KEEPINTVL = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_MAXSEG = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_NODELAY = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_NOOPT = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_NOPUSH = T.let(T.unsafe(nil), Integer)
Random::Formatter::ALPHANUMERIC = T.let(T.unsafe(nil), Array)

module Enumerable
  def all?(*_arg0); end
  def any?(*_arg0); end
  def chain(*_arg0); end
  def chunk; end
  def chunk_while; end
  def collect; end
  def collect_concat; end
  def count(*_arg0); end
  def cycle(*_arg0); end
  def detect(*_arg0); end
  def drop(_arg0); end
  def drop_while; end
  def each_cons(_arg0); end
  def each_entry(*_arg0); end
  def each_slice(_arg0); end
  def each_with_index(*_arg0); end
  def each_with_object(_arg0); end
  def entries(*_arg0); end
  def filter; end
  def filter_map; end
  def find(*_arg0); end
  def find_all; end
  def find_index(*_arg0); end
  def first(*_arg0); end
  def flat_map; end
  def grep(_arg0); end
  def grep_v(_arg0); end
  def group_by; end
  def include?(_arg0); end
  def inject(*_arg0); end
  def lazy; end
  def map; end
  def max(*_arg0); end
  def max_by(*_arg0); end
  def member?(_arg0); end
  def min(*_arg0); end
  def min_by(*_arg0); end
  def minmax; end
  def minmax_by; end
  def none?(*_arg0); end
  def one?(*_arg0); end
  def partition; end
  def reduce(*_arg0); end
  def reject; end
  def reverse_each(*_arg0); end
  def select; end
  def slice_after(*_arg0); end
  def slice_before(*_arg0); end
  def slice_when; end
  def sort; end
  def sort_by; end
  def sum(*_arg0); end
  def take(_arg0); end
  def take_while; end
  def tally; end
  def to_a(*_arg0); end
  def to_h(*_arg0); end
  def to_set(klass = T.unsafe(nil), *args, &block); end
  def uniq; end
  def zip(*_arg0); end
end

module File::Constants; end
class Errno::EAGAIN < ::SystemCallError; end
class Errno::EINPROGRESS < ::SystemCallError; end
Resolv::DNS::Config::InitialTimeout = T.let(T.unsafe(nil), Integer)
class Resolv::DNS::Config::NXDomain < ::Resolv::ResolvError; end
class Resolv::DNS::Config::OtherResolvError < ::Resolv::ResolvError; end

class Resolv::DNS::Label::Str
  def initialize(string); end
  def ==(other); end
  def downcase; end
  def eql?(other); end
  def hash; end
  def inspect; end
  def string; end
  def to_s; end
end

class Resolv::DNS::Message::MessageDecoder
  def initialize(data); end
  def get_bytes(len = T.unsafe(nil)); end
  def get_label; end
  def get_labels; end
  def get_length16; end
  def get_name; end
  def get_question; end
  def get_rr; end
  def get_string; end
  def get_string_list; end
  def get_unpack(template); end
  def inspect; end
end

class Resolv::DNS::Message::MessageEncoder
  def initialize; end
  def put_bytes(d); end
  def put_label(d); end
  def put_labels(d); end
  def put_length16; end
  def put_name(d); end
  def put_pack(template, *d); end
  def put_string(d); end
  def put_string_list(ds); end
  def to_s; end
end

Resolv::DNS::OpCode::IQuery = T.let(T.unsafe(nil), Integer)
Resolv::DNS::OpCode::Notify = T.let(T.unsafe(nil), Integer)
Resolv::DNS::OpCode::Query = T.let(T.unsafe(nil), Integer)
Resolv::DNS::OpCode::Status = T.let(T.unsafe(nil), Integer)
Resolv::DNS::OpCode::Update = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::BADALG = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::BADKEY = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::BADMODE = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::BADNAME = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::BADSIG = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::BADTIME = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::BADVERS = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::FormErr = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::NXDomain = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::NXRRSet = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::NoError = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::NotAuth = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::NotImp = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::NotZone = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::Refused = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::ServFail = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::YXDomain = T.let(T.unsafe(nil), Integer)
Resolv::DNS::RCode::YXRRSet = T.let(T.unsafe(nil), Integer)

class Resolv::DNS::Requester::ConnectedUDP < ::Resolv::DNS::Requester
  def initialize(host, port = T.unsafe(nil)); end
  def close; end
  def lazy_initialize; end
  def recv_reply(readable_socks); end
  def sender(msg, data, host = T.unsafe(nil), port = T.unsafe(nil)); end
end

class Resolv::DNS::Requester::MDNSOneShot < ::Resolv::DNS::Requester::UnconnectedUDP
  def sender(msg, data, host, port = T.unsafe(nil)); end
  def sender_for(addr, msg); end
end

class Resolv::DNS::Requester::RequestError < ::StandardError; end

class Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock); end
end

class Resolv::DNS::Requester::TCP < ::Resolv::DNS::Requester
  def initialize(host, port = T.unsafe(nil)); end
  def close; end
  def recv_reply(readable_socks); end
  def sender(msg, data, host = T.unsafe(nil), port = T.unsafe(nil)); end
end

class Resolv::DNS::Requester::UnconnectedUDP < ::Resolv::DNS::Requester
  def initialize(*nameserver_port); end
  def close; end
  def lazy_initialize; end
  def recv_reply(readable_socks); end
  def sender(msg, data, host, port = T.unsafe(nil)); end
end

class Resolv::DNS::Resource::ANY < ::Resolv::DNS::Query; end
class Resolv::DNS::Resource::CNAME < ::Resolv::DNS::Resource::DomainName; end
Resolv::DNS::Resource::ClassHash = T.let(T.unsafe(nil), Hash)
Resolv::DNS::Resource::ClassInsensitiveTypes = T.let(T.unsafe(nil), Array)

class Resolv::DNS::Resource::DomainName < ::Resolv::DNS::Resource
  def initialize(name); end
  def encode_rdata(msg); end
  def name; end
  def self.decode_rdata(msg); end
end

class Resolv::DNS::Resource::Generic < ::Resolv::DNS::Resource
  def initialize(data); end
  def data; end
  def encode_rdata(msg); end
  def self.create(type_value, class_value); end
  def self.decode_rdata(msg); end
end

class Resolv::DNS::Resource::HINFO < ::Resolv::DNS::Resource
  def initialize(cpu, os); end
  def cpu; end
  def encode_rdata(msg); end
  def os; end
  def self.decode_rdata(msg); end
end

module Resolv::DNS::Resource::IN; end

class Resolv::DNS::Resource::LOC < ::Resolv::DNS::Resource
  def initialize(version, ssize, hprecision, vprecision, latitude, longitude, altitude); end
  def altitude; end
  def encode_rdata(msg); end
  def hprecision; end
  def latitude; end
  def longitude; end
  def ssize; end
  def version; end
  def vprecision; end
  def self.decode_rdata(msg); end
end

class Resolv::DNS::Resource::MINFO < ::Resolv::DNS::Resource
  def initialize(rmailbx, emailbx); end
  def emailbx; end
  def encode_rdata(msg); end
  def rmailbx; end
  def self.decode_rdata(msg); end
end

class Resolv::DNS::Resource::MX < ::Resolv::DNS::Resource
  def initialize(preference, exchange); end
  def encode_rdata(msg); end
  def exchange; end
  def preference; end
  def self.decode_rdata(msg); end
end

class Resolv::DNS::Resource::NS < ::Resolv::DNS::Resource::DomainName; end
class Resolv::DNS::Resource::PTR < ::Resolv::DNS::Resource::DomainName; end

class Resolv::DNS::Resource::SOA < ::Resolv::DNS::Resource
  def initialize(mname, rname, serial, refresh, retry_, expire, minimum); end
  def encode_rdata(msg); end
  def expire; end
  def minimum; end
  def mname; end
  def refresh; end
  def retry; end
  def rname; end
  def serial; end
  def self.decode_rdata(msg); end
end

class Resolv::DNS::Resource::TXT < ::Resolv::DNS::Resource
  def initialize(first_string, *rest_strings); end
  def data; end
  def encode_rdata(msg); end
  def strings; end
  def self.decode_rdata(msg); end
end

Resolv::LOC::Alt::Regex = T.let(T.unsafe(nil), Regexp)
Resolv::LOC::Coord::Regex = T.let(T.unsafe(nil), Regexp)
Resolv::LOC::Size::Regex = T.let(T.unsafe(nil), Regexp)
File::Constants::APPEND = T.let(T.unsafe(nil), Integer)
File::Constants::BINARY = T.let(T.unsafe(nil), Integer)
File::Constants::CREAT = T.let(T.unsafe(nil), Integer)
File::Constants::DSYNC = T.let(T.unsafe(nil), Integer)
File::Constants::EXCL = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_CASEFOLD = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_DOTMATCH = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_EXTGLOB = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_NOESCAPE = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_PATHNAME = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_SHORTNAME = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_SYSCASE = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_EX = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_NB = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_SH = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_UN = T.let(T.unsafe(nil), Integer)
File::Constants::NOCTTY = T.let(T.unsafe(nil), Integer)
File::Constants::NOFOLLOW = T.let(T.unsafe(nil), Integer)
File::Constants::NONBLOCK = T.let(T.unsafe(nil), Integer)
File::Constants::NULL = T.let(T.unsafe(nil), String)
File::Constants::RDONLY = T.let(T.unsafe(nil), Integer)
File::Constants::RDWR = T.let(T.unsafe(nil), Integer)
File::Constants::SHARE_DELETE = T.let(T.unsafe(nil), Integer)
File::Constants::SYNC = T.let(T.unsafe(nil), Integer)
File::Constants::TRUNC = T.let(T.unsafe(nil), Integer)
File::Constants::WRONLY = T.let(T.unsafe(nil), Integer)

class SystemCallError < ::StandardError
  def initialize(*_arg0); end
  def errno; end
  def self.===(_arg0); end
end

Errno::EAGAIN::Errno = T.let(T.unsafe(nil), Integer)
Errno::EINPROGRESS::Errno = T.let(T.unsafe(nil), Integer)

class Resolv::DNS::Requester::ConnectedUDP::Sender < ::Resolv::DNS::Requester::Sender
  def data; end
  def send; end
end

class Resolv::DNS::Requester::TCP::Sender < ::Resolv::DNS::Requester::Sender
  def data; end
  def send; end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender < ::Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock, host, port); end
  def data; end
  def send; end
end

Resolv::DNS::Resource::ANY::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::CNAME::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::HINFO::TypeValue = T.let(T.unsafe(nil), Integer)

class Resolv::DNS::Resource::IN::A < ::Resolv::DNS::Resource
  def initialize(address); end
  def address; end
  def encode_rdata(msg); end
  def self.decode_rdata(msg); end
end

class Resolv::DNS::Resource::IN::AAAA < ::Resolv::DNS::Resource
  def initialize(address); end
  def address; end
  def encode_rdata(msg); end
  def self.decode_rdata(msg); end
end

class Resolv::DNS::Resource::IN::ANY < ::Resolv::DNS::Resource::ANY; end
class Resolv::DNS::Resource::IN::CNAME < ::Resolv::DNS::Resource::CNAME; end
Resolv::DNS::Resource::IN::ClassValue = T.let(T.unsafe(nil), Integer)
class Resolv::DNS::Resource::IN::HINFO < ::Resolv::DNS::Resource::HINFO; end
class Resolv::DNS::Resource::IN::LOC < ::Resolv::DNS::Resource::LOC; end
class Resolv::DNS::Resource::IN::MINFO < ::Resolv::DNS::Resource::MINFO; end
class Resolv::DNS::Resource::IN::MX < ::Resolv::DNS::Resource::MX; end
class Resolv::DNS::Resource::IN::NS < ::Resolv::DNS::Resource::NS; end
class Resolv::DNS::Resource::IN::PTR < ::Resolv::DNS::Resource::PTR; end
class Resolv::DNS::Resource::IN::SOA < ::Resolv::DNS::Resource::SOA; end

class Resolv::DNS::Resource::IN::SRV < ::Resolv::DNS::Resource
  def initialize(priority, weight, port, target); end
  def encode_rdata(msg); end
  def port; end
  def priority; end
  def target; end
  def weight; end
  def self.decode_rdata(msg); end
end

class Resolv::DNS::Resource::IN::TXT < ::Resolv::DNS::Resource::TXT; end

class Resolv::DNS::Resource::IN::WKS < ::Resolv::DNS::Resource
  def initialize(address, protocol, bitmap); end
  def address; end
  def bitmap; end
  def encode_rdata(msg); end
  def protocol; end
  def self.decode_rdata(msg); end
end

Resolv::DNS::Resource::LOC::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::MINFO::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::MX::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::NS::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::PTR::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::SOA::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::TXT::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::A::ClassValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::A::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::AAAA::ClassValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::AAAA::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::ANY::ClassValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::ANY::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::CNAME::ClassValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::CNAME::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::HINFO::ClassValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::HINFO::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::LOC::ClassValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::LOC::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::MINFO::ClassValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::MINFO::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::MX::ClassValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::MX::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::NS::ClassValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::NS::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::PTR::ClassValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::PTR::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::SOA::ClassValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::SOA::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::SRV::ClassValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::SRV::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::TXT::ClassValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::TXT::TypeValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::WKS::ClassValue = T.let(T.unsafe(nil), Integer)
Resolv::DNS::Resource::IN::WKS::TypeValue = T.let(T.unsafe(nil), Integer)
class IPAddr
  include ::Comparable
  def initialize(addr = T.unsafe(nil), family = T.unsafe(nil)); end
  def &(other); end
  def <<(num); end
  def <=>(other); end
  def ==(other); end
  def ===(other); end
  def >>(num); end
  def eql?(other); end
  def family; end
  def hash; end
  def hton; end
  def include?(other); end
  def inspect; end
  def ip6_arpa; end
  def ip6_int; end
  def ipv4?; end
  def ipv4_compat; end
  def ipv4_compat?; end
  def ipv4_mapped; end
  def ipv4_mapped?; end
  def ipv6?; end
  def link_local?; end
  def loopback?; end
  def mask(prefixlen); end
  def native; end
  def prefix; end
  def prefix=(prefix); end
  def private?; end
  def reverse; end
  def succ; end
  def to_i; end
  def to_range; end
  def to_s; end
  def to_string; end
  def |(other); end
  def ~; end
  protected def mask!(mask); end
  protected def set(addr, *family); end
  private def _ipv4_compat?; end
  private def _reverse; end
  private def _to_string(addr); end
  private def addr_mask(addr); end
  private def coerce_other(other); end
  private def in6_addr(left); end
  private def in_addr(addr); end
  def self.new_ntoh(addr); end
  def self.ntop(addr); end
end

class UDPSocket < ::IPSocket
  def initialize(*_arg0); end
  def bind(host, port); end
  def connect(host, port); end
  def original_resolv_bind(_arg0, _arg1); end
  def original_resolv_connect(_arg0, _arg1); end
  def original_resolv_send(*_arg0); end
  def recvfrom_nonblock(len, flag = T.unsafe(nil), outbuf = T.unsafe(nil), exception: T.unsafe(nil)); end
  def send(mesg, flags, *rest); end
  private def __recvfrom_nonblock(_arg0, _arg1, _arg2, _arg3); end
end

class TCPServer < ::TCPSocket
  def initialize(*_arg0); end
  def accept; end
  def accept_nonblock(exception: T.unsafe(nil)); end
  def listen(_arg0); end
  def sysaccept; end
  private def __accept_nonblock(_arg0); end
end

class UNIXServer < ::UNIXSocket
  def initialize(_arg0); end
  def accept; end
  def accept_nonblock(exception: T.unsafe(nil)); end
  def listen(_arg0); end
  def sysaccept; end
  private def __accept_nonblock(_arg0); end
end

class TCPSocket < ::IPSocket
  def initialize(host, serv, *rest); end
  private def original_resolv_initialize(*_arg0); end
  def self.gethostbyname(_arg0); end
end

class Socket < ::BasicSocket
  def initialize(*_arg0); end
  def accept; end
  def accept_nonblock(exception: T.unsafe(nil)); end
  def bind(_arg0); end
  def connect(_arg0); end
  def connect_nonblock(addr, exception: T.unsafe(nil)); end
  def ipv6only!; end
  def listen(_arg0); end
  def recvfrom(*_arg0); end
  def recvfrom_nonblock(len, flag = T.unsafe(nil), str = T.unsafe(nil), exception: T.unsafe(nil)); end
  def sysaccept; end
  private def __accept_nonblock(_arg0); end
  private def __connect_nonblock(_arg0, _arg1); end
  private def __recvfrom_nonblock(_arg0, _arg1, _arg2, _arg3); end
  def self.accept_loop(*sockets); end
  def self.getaddrinfo(*_arg0); end
  def self.gethostbyaddr(*_arg0); end
  def self.gethostbyname(_arg0); end
  def self.gethostname; end
  def self.getifaddrs; end
  def self.getnameinfo(*_arg0); end
  def self.getservbyname(*_arg0); end
  def self.getservbyport(*_arg0); end
  def self.ip_address_list; end
  def self.pack_sockaddr_in(_arg0, _arg1); end
  def self.pack_sockaddr_un(_arg0); end
  def self.pair(*_arg0); end
  def self.sockaddr_in(_arg0, _arg1); end
  def self.sockaddr_un(_arg0); end
  def self.socketpair(*_arg0); end
  def self.tcp(host, port, local_host = T.unsafe(nil), local_port = T.unsafe(nil), connect_timeout: T.unsafe(nil), resolv_timeout: T.unsafe(nil)); end
  def self.tcp_server_loop(host = T.unsafe(nil), port, &b); end
  def self.tcp_server_sockets(host = T.unsafe(nil), port); end
  def self.udp_server_loop(host = T.unsafe(nil), port, &b); end
  def self.udp_server_loop_on(sockets, &b); end
  def self.udp_server_recv(sockets); end
  def self.udp_server_sockets(host = T.unsafe(nil), port); end
  def self.unix(path); end
  def self.unix_server_loop(path, &b); end
  def self.unix_server_socket(path); end
  def self.unpack_sockaddr_in(_arg0); end
  def self.unpack_sockaddr_un(_arg0); end
  private def self.ip_sockets_port0(ai_list, reuseaddr); end
  private def self.tcp_server_sockets_port0(host); end
  private def self.unix_socket_abstract_name?(path); end
end

class UNIXSocket < ::BasicSocket
  def initialize(_arg0); end
  def addr; end
  def path; end
  def peeraddr; end
  def recv_io(*_arg0); end
  def recvfrom(*_arg0); end
  def send_io(_arg0); end
  def self.pair(*_arg0); end
  def self.socketpair(*_arg0); end
end

class IPSocket < ::BasicSocket
  def addr(*_arg0); end
  def inspect; end
  def peeraddr(*_arg0); end
  def recvfrom(*_arg0); end
  def self.getaddress(host); end
  def self.original_resolv_getaddress(_arg0); end
end

module Forwardable
  def def_delegator(accessor, method, ali = T.unsafe(nil)); end
  def def_delegators(accessor, *methods); end
  def def_instance_delegator(accessor, method, ali = T.unsafe(nil)); end
  def def_instance_delegators(accessor, *methods); end
  def delegate(hash); end
  def instance_delegate(hash); end
  def self._compile_method(src, file, line); end
  def self._delegator_method(obj, accessor, method, ali); end
  def self._valid_method?(method); end
  def self.debug; end
  def self.debug=(_arg0); end
end

module SingleForwardable
  def def_delegator(accessor, method, ali = T.unsafe(nil)); end
  def def_delegators(accessor, *methods); end
  def def_single_delegator(accessor, method, ali = T.unsafe(nil)); end
  def def_single_delegators(accessor, *methods); end
  def delegate(hash); end
  def single_delegate(hash); end
end

class Addrinfo
  def initialize(*_arg0); end
  def afamily; end
  def bind; end
  def canonname; end
  def connect(timeout: T.unsafe(nil), &block); end
  def connect_from(*args, timeout: T.unsafe(nil), &block); end
  def connect_to(*args, timeout: T.unsafe(nil), &block); end
  def family_addrinfo(*args); end
  def getnameinfo(*_arg0); end
  def inspect; end
  def inspect_sockaddr; end
  def ip?; end
  def ip_address; end
  def ip_port; end
  def ip_unpack; end
  def ipv4?; end
  def ipv4_loopback?; end
  def ipv4_multicast?; end
  def ipv4_private?; end
  def ipv6?; end
  def ipv6_linklocal?; end
  def ipv6_loopback?; end
  def ipv6_mc_global?; end
  def ipv6_mc_linklocal?; end
  def ipv6_mc_nodelocal?; end
  def ipv6_mc_orglocal?; end
  def ipv6_mc_sitelocal?; end
  def ipv6_multicast?; end
  def ipv6_sitelocal?; end
  def ipv6_to_ipv4; end
  def ipv6_unique_local?; end
  def ipv6_unspecified?; end
  def ipv6_v4compat?; end
  def ipv6_v4mapped?; end
  def listen(backlog = T.unsafe(nil)); end
  def marshal_dump; end
  def marshal_load(_arg0); end
  def pfamily; end
  def protocol; end
  def socktype; end
  def to_s; end
  def to_sockaddr; end
  def unix?; end
  def unix_path; end
  protected def connect_internal(local_addrinfo, timeout = T.unsafe(nil)); end
  def self.foreach(nodename, service, family = T.unsafe(nil), socktype = T.unsafe(nil), protocol = T.unsafe(nil), flags = T.unsafe(nil), timeout: T.unsafe(nil), &block); end
  def self.getaddrinfo(*_arg0); end
  def self.ip(_arg0); end
  def self.tcp(_arg0, _arg1); end
  def self.udp(_arg0, _arg1); end
  def self.unix(*_arg0); end
end

class SocketError < ::StandardError; end

class BasicSocket < ::IO
  def close_read; end
  def close_write; end
  def connect_address; end
  def do_not_reverse_lookup; end
  def do_not_reverse_lookup=(_arg0); end
  def getpeereid; end
  def getpeername; end
  def getsockname; end
  def getsockopt(_arg0, _arg1); end
  def local_address; end
  def recv(*_arg0); end
  def recv_nonblock(len, flag = T.unsafe(nil), str = T.unsafe(nil), exception: T.unsafe(nil)); end
  def recvmsg(dlen = T.unsafe(nil), flags = T.unsafe(nil), clen = T.unsafe(nil), scm_rights: T.unsafe(nil)); end
  def recvmsg_nonblock(dlen = T.unsafe(nil), flags = T.unsafe(nil), clen = T.unsafe(nil), scm_rights: T.unsafe(nil), exception: T.unsafe(nil)); end
  def remote_address; end
  def send(*_arg0); end
  def sendmsg(mesg, flags = T.unsafe(nil), dest_sockaddr = T.unsafe(nil), *controls); end
  def sendmsg_nonblock(mesg, flags = T.unsafe(nil), dest_sockaddr = T.unsafe(nil), *controls, exception: T.unsafe(nil)); end
  def setsockopt(*_arg0); end
  def shutdown(*_arg0); end
  private def __recv_nonblock(_arg0, _arg1, _arg2, _arg3); end
  private def __recvmsg(_arg0, _arg1, _arg2, _arg3); end
  private def __recvmsg_nonblock(_arg0, _arg1, _arg2, _arg3, _arg4); end
  private def __sendmsg(_arg0, _arg1, _arg2, _arg3); end
  private def __sendmsg_nonblock(_arg0, _arg1, _arg2, _arg3, _arg4); end
  def self.do_not_reverse_lookup; end
  def self.do_not_reverse_lookup=(_arg0); end
  def self.for_fd(_arg0); end
end

module Rinda; end
DRbObject = DRb::DRbObject
DRbUndumped = DRb::DRbUndumped

module DRb
  private def config; end
  private def current_server; end
  private def fetch_server(uri); end
  private def front; end
  private def here?(uri); end
  private def install_acl(acl); end
  private def install_id_conv(idconv); end
  private def mutex; end
  private def primary_server; end
  private def primary_server=(_arg0); end
  private def regist_server(server); end
  private def remove_server(server); end
  private def start_service(uri = T.unsafe(nil), front = T.unsafe(nil), config = T.unsafe(nil)); end
  private def stop_service; end
  private def thread; end
  private def to_id(obj); end
  private def to_obj(ref); end
  private def uri; end
  def self.config; end
  def self.current_server; end
  def self.fetch_server(uri); end
  def self.front; end
  def self.here?(uri); end
  def self.install_acl(acl); end
  def self.install_id_conv(idconv); end
  def self.mutex; end
  def self.primary_server; end
  def self.primary_server=(_arg0); end
  def self.regist_server(server); end
  def self.remove_server(server); end
  def self.start_service(uri = T.unsafe(nil), front = T.unsafe(nil), config = T.unsafe(nil)); end
  def self.stop_service; end
  def self.thread; end
  def self.to_id(obj); end
  def self.to_obj(ref); end
  def self.uri; end
end

DRbIdConv = DRb::DRbIdConv
class IPAddr::AddressFamilyError < ::IPAddr::Error; end
class IPAddr::Error < ::ArgumentError; end
IPAddr::IN4MASK = T.let(T.unsafe(nil), Integer)
IPAddr::IN6FORMAT = T.let(T.unsafe(nil), String)
IPAddr::IN6MASK = T.let(T.unsafe(nil), Integer)
class IPAddr::InvalidAddressError < ::IPAddr::Error; end
class IPAddr::InvalidPrefixError < ::IPAddr::InvalidAddressError; end
IPAddr::RE_IPV4ADDRLIKE = T.let(T.unsafe(nil), Regexp)
IPAddr::RE_IPV6ADDRLIKE_COMPRESSED = T.let(T.unsafe(nil), Regexp)
IPAddr::RE_IPV6ADDRLIKE_FULL = T.let(T.unsafe(nil), Regexp)
Socket::AF_APPLETALK = T.let(T.unsafe(nil), Integer)
Socket::AF_CCITT = T.let(T.unsafe(nil), Integer)
Socket::AF_CHAOS = T.let(T.unsafe(nil), Integer)
Socket::AF_CNT = T.let(T.unsafe(nil), Integer)
Socket::AF_COIP = T.let(T.unsafe(nil), Integer)
Socket::AF_DATAKIT = T.let(T.unsafe(nil), Integer)
Socket::AF_DLI = T.let(T.unsafe(nil), Integer)
Socket::AF_E164 = T.let(T.unsafe(nil), Integer)
Socket::AF_ECMA = T.let(T.unsafe(nil), Integer)
Socket::AF_HYLINK = T.let(T.unsafe(nil), Integer)
Socket::AF_IMPLINK = T.let(T.unsafe(nil), Integer)
Socket::AF_INET = T.let(T.unsafe(nil), Integer)
Socket::AF_INET6 = T.let(T.unsafe(nil), Integer)
Socket::AF_IPX = T.let(T.unsafe(nil), Integer)
Socket::AF_ISDN = T.let(T.unsafe(nil), Integer)
Socket::AF_ISO = T.let(T.unsafe(nil), Integer)
Socket::AF_LAT = T.let(T.unsafe(nil), Integer)
Socket::AF_LINK = T.let(T.unsafe(nil), Integer)
Socket::AF_LOCAL = T.let(T.unsafe(nil), Integer)
Socket::AF_MAX = T.let(T.unsafe(nil), Integer)
Socket::AF_NATM = T.let(T.unsafe(nil), Integer)
Socket::AF_NDRV = T.let(T.unsafe(nil), Integer)
Socket::AF_NETBIOS = T.let(T.unsafe(nil), Integer)
Socket::AF_NS = T.let(T.unsafe(nil), Integer)
Socket::AF_OSI = T.let(T.unsafe(nil), Integer)
Socket::AF_PPP = T.let(T.unsafe(nil), Integer)
Socket::AF_PUP = T.let(T.unsafe(nil), Integer)
Socket::AF_ROUTE = T.let(T.unsafe(nil), Integer)
Socket::AF_SIP = T.let(T.unsafe(nil), Integer)
Socket::AF_SNA = T.let(T.unsafe(nil), Integer)
Socket::AF_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::AF_UNIX = T.let(T.unsafe(nil), Integer)
Socket::AF_UNSPEC = T.let(T.unsafe(nil), Integer)
Socket::AI_ADDRCONFIG = T.let(T.unsafe(nil), Integer)
Socket::AI_ALL = T.let(T.unsafe(nil), Integer)
Socket::AI_CANONNAME = T.let(T.unsafe(nil), Integer)
Socket::AI_DEFAULT = T.let(T.unsafe(nil), Integer)
Socket::AI_MASK = T.let(T.unsafe(nil), Integer)
Socket::AI_NUMERICHOST = T.let(T.unsafe(nil), Integer)
Socket::AI_NUMERICSERV = T.let(T.unsafe(nil), Integer)
Socket::AI_PASSIVE = T.let(T.unsafe(nil), Integer)
Socket::AI_V4MAPPED = T.let(T.unsafe(nil), Integer)
Socket::AI_V4MAPPED_CFG = T.let(T.unsafe(nil), Integer)

class Socket::AncillaryData
  def initialize(_arg0, _arg1, _arg2, _arg3); end
  def cmsg_is?(_arg0, _arg1); end
  def data; end
  def family; end
  def inspect; end
  def int; end
  def ip_pktinfo; end
  def ipv6_pktinfo; end
  def ipv6_pktinfo_addr; end
  def ipv6_pktinfo_ifindex; end
  def level; end
  def timestamp; end
  def type; end
  def unix_rights; end
  def self.int(_arg0, _arg1, _arg2, _arg3); end
  def self.ip_pktinfo(*_arg0); end
  def self.ipv6_pktinfo(_arg0, _arg1); end
  def self.unix_rights(*_arg0); end
end

module Socket::Constants; end
Socket::EAI_ADDRFAMILY = T.let(T.unsafe(nil), Integer)
Socket::EAI_AGAIN = T.let(T.unsafe(nil), Integer)
Socket::EAI_BADFLAGS = T.let(T.unsafe(nil), Integer)
Socket::EAI_BADHINTS = T.let(T.unsafe(nil), Integer)
Socket::EAI_FAIL = T.let(T.unsafe(nil), Integer)
Socket::EAI_FAMILY = T.let(T.unsafe(nil), Integer)
Socket::EAI_MAX = T.let(T.unsafe(nil), Integer)
Socket::EAI_MEMORY = T.let(T.unsafe(nil), Integer)
Socket::EAI_NODATA = T.let(T.unsafe(nil), Integer)
Socket::EAI_NONAME = T.let(T.unsafe(nil), Integer)
Socket::EAI_OVERFLOW = T.let(T.unsafe(nil), Integer)
Socket::EAI_PROTOCOL = T.let(T.unsafe(nil), Integer)
Socket::EAI_SERVICE = T.let(T.unsafe(nil), Integer)
Socket::EAI_SOCKTYPE = T.let(T.unsafe(nil), Integer)
Socket::EAI_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::IFF_ALLMULTI = T.let(T.unsafe(nil), Integer)
Socket::IFF_ALTPHYS = T.let(T.unsafe(nil), Integer)
Socket::IFF_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::IFF_DEBUG = T.let(T.unsafe(nil), Integer)
Socket::IFF_LINK0 = T.let(T.unsafe(nil), Integer)
Socket::IFF_LINK1 = T.let(T.unsafe(nil), Integer)
Socket::IFF_LINK2 = T.let(T.unsafe(nil), Integer)
Socket::IFF_LOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::IFF_MULTICAST = T.let(T.unsafe(nil), Integer)
Socket::IFF_NOARP = T.let(T.unsafe(nil), Integer)
Socket::IFF_NOTRAILERS = T.let(T.unsafe(nil), Integer)
Socket::IFF_OACTIVE = T.let(T.unsafe(nil), Integer)
Socket::IFF_POINTOPOINT = T.let(T.unsafe(nil), Integer)
Socket::IFF_PROMISC = T.let(T.unsafe(nil), Integer)
Socket::IFF_RUNNING = T.let(T.unsafe(nil), Integer)
Socket::IFF_SIMPLEX = T.let(T.unsafe(nil), Integer)
Socket::IFF_UP = T.let(T.unsafe(nil), Integer)
Socket::IFNAMSIZ = T.let(T.unsafe(nil), Integer)
Socket::IF_NAMESIZE = T.let(T.unsafe(nil), Integer)
Socket::INADDR_ALLHOSTS_GROUP = T.let(T.unsafe(nil), Integer)
Socket::INADDR_ANY = T.let(T.unsafe(nil), Integer)
Socket::INADDR_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::INADDR_LOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::INADDR_MAX_LOCAL_GROUP = T.let(T.unsafe(nil), Integer)
Socket::INADDR_NONE = T.let(T.unsafe(nil), Integer)
Socket::INADDR_UNSPEC_GROUP = T.let(T.unsafe(nil), Integer)
Socket::INET6_ADDRSTRLEN = T.let(T.unsafe(nil), Integer)
Socket::INET_ADDRSTRLEN = T.let(T.unsafe(nil), Integer)
Socket::IPPORT_RESERVED = T.let(T.unsafe(nil), Integer)
Socket::IPPORT_USERRESERVED = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_AH = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_DSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_EGP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_EON = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ESP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_FRAGMENT = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_GGP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_HELLO = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_HOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ICMP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ICMPV6 = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_IDP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_IGMP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_IP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_IPV6 = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_MAX = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ND = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_NONE = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_PUP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_RAW = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_ROUTING = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_TCP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_TP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_UDP = T.let(T.unsafe(nil), Integer)
Socket::IPPROTO_XTP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_CHECKSUM = T.let(T.unsafe(nil), Integer)
Socket::IPV6_DONTFRAG = T.let(T.unsafe(nil), Integer)
Socket::IPV6_DSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_HOPLIMIT = T.let(T.unsafe(nil), Integer)
Socket::IPV6_HOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_JOIN_GROUP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_LEAVE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_MULTICAST_HOPS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_MULTICAST_IF = T.let(T.unsafe(nil), Integer)
Socket::IPV6_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_NEXTHOP = T.let(T.unsafe(nil), Integer)
Socket::IPV6_PATHMTU = T.let(T.unsafe(nil), Integer)
Socket::IPV6_PKTINFO = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVDSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVHOPLIMIT = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVHOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVPATHMTU = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVPKTINFO = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVRTHDR = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RECVTCLASS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RTHDR = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RTHDRDSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_RTHDR_TYPE_0 = T.let(T.unsafe(nil), Integer)
Socket::IPV6_TCLASS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_UNICAST_HOPS = T.let(T.unsafe(nil), Integer)
Socket::IPV6_USE_MIN_MTU = T.let(T.unsafe(nil), Integer)
Socket::IPV6_V6ONLY = T.let(T.unsafe(nil), Integer)
Socket::IP_ADD_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::IP_ADD_SOURCE_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::IP_BLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::IP_DEFAULT_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::IP_DEFAULT_MULTICAST_TTL = T.let(T.unsafe(nil), Integer)
Socket::IP_DONTFRAG = T.let(T.unsafe(nil), Integer)
Socket::IP_DROP_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::IP_DROP_SOURCE_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::IP_HDRINCL = T.let(T.unsafe(nil), Integer)
Socket::IP_IPSEC_POLICY = T.let(T.unsafe(nil), Integer)
Socket::IP_MAX_MEMBERSHIPS = T.let(T.unsafe(nil), Integer)
Socket::IP_MSFILTER = T.let(T.unsafe(nil), Integer)
Socket::IP_MULTICAST_IF = T.let(T.unsafe(nil), Integer)
Socket::IP_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::IP_MULTICAST_TTL = T.let(T.unsafe(nil), Integer)
Socket::IP_OPTIONS = T.let(T.unsafe(nil), Integer)
Socket::IP_PKTINFO = T.let(T.unsafe(nil), Integer)
Socket::IP_PORTRANGE = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVDSTADDR = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVIF = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVOPTS = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVRETOPTS = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVTOS = T.let(T.unsafe(nil), Integer)
Socket::IP_RECVTTL = T.let(T.unsafe(nil), Integer)
Socket::IP_RETOPTS = T.let(T.unsafe(nil), Integer)
Socket::IP_TOS = T.let(T.unsafe(nil), Integer)
Socket::IP_TTL = T.let(T.unsafe(nil), Integer)
Socket::IP_UNBLOCK_SOURCE = T.let(T.unsafe(nil), Integer)

class Socket::Ifaddr
  def addr; end
  def broadaddr; end
  def dstaddr; end
  def flags; end
  def ifindex; end
  def inspect; end
  def name; end
  def netmask; end
end

Socket::LOCAL_PEERCRED = T.let(T.unsafe(nil), Integer)
Socket::MCAST_BLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::MCAST_EXCLUDE = T.let(T.unsafe(nil), Integer)
Socket::MCAST_INCLUDE = T.let(T.unsafe(nil), Integer)
Socket::MCAST_JOIN_GROUP = T.let(T.unsafe(nil), Integer)
Socket::MCAST_JOIN_SOURCE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::MCAST_LEAVE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::MCAST_LEAVE_SOURCE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::MCAST_UNBLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::MSG_CTRUNC = T.let(T.unsafe(nil), Integer)
Socket::MSG_DONTROUTE = T.let(T.unsafe(nil), Integer)
Socket::MSG_DONTWAIT = T.let(T.unsafe(nil), Integer)
Socket::MSG_EOF = T.let(T.unsafe(nil), Integer)
Socket::MSG_EOR = T.let(T.unsafe(nil), Integer)
Socket::MSG_FLUSH = T.let(T.unsafe(nil), Integer)
Socket::MSG_HAVEMORE = T.let(T.unsafe(nil), Integer)
Socket::MSG_HOLD = T.let(T.unsafe(nil), Integer)
Socket::MSG_NOSIGNAL = T.let(T.unsafe(nil), Integer)
Socket::MSG_OOB = T.let(T.unsafe(nil), Integer)
Socket::MSG_PEEK = T.let(T.unsafe(nil), Integer)
Socket::MSG_RCVMORE = T.let(T.unsafe(nil), Integer)
Socket::MSG_SEND = T.let(T.unsafe(nil), Integer)
Socket::MSG_TRUNC = T.let(T.unsafe(nil), Integer)
Socket::MSG_WAITALL = T.let(T.unsafe(nil), Integer)
Socket::NI_DGRAM = T.let(T.unsafe(nil), Integer)
Socket::NI_MAXHOST = T.let(T.unsafe(nil), Integer)
Socket::NI_MAXSERV = T.let(T.unsafe(nil), Integer)
Socket::NI_NAMEREQD = T.let(T.unsafe(nil), Integer)
Socket::NI_NOFQDN = T.let(T.unsafe(nil), Integer)
Socket::NI_NUMERICHOST = T.let(T.unsafe(nil), Integer)
Socket::NI_NUMERICSERV = T.let(T.unsafe(nil), Integer)

class Socket::Option
  def initialize(_arg0, _arg1, _arg2, _arg3); end
  def bool; end
  def byte; end
  def data; end
  def family; end
  def inspect; end
  def int; end
  def ipv4_multicast_loop; end
  def ipv4_multicast_ttl; end
  def level; end
  def linger; end
  def optname; end
  def to_s; end
  def unpack(_arg0); end
  def self.bool(_arg0, _arg1, _arg2, _arg3); end
  def self.byte(_arg0, _arg1, _arg2, _arg3); end
  def self.int(_arg0, _arg1, _arg2, _arg3); end
  def self.ipv4_multicast_loop(_arg0); end
  def self.ipv4_multicast_ttl(_arg0); end
  def self.linger(_arg0, _arg1); end
end

Socket::PF_APPLETALK = T.let(T.unsafe(nil), Integer)
Socket::PF_CCITT = T.let(T.unsafe(nil), Integer)
Socket::PF_CHAOS = T.let(T.unsafe(nil), Integer)
Socket::PF_CNT = T.let(T.unsafe(nil), Integer)
Socket::PF_COIP = T.let(T.unsafe(nil), Integer)
Socket::PF_DATAKIT = T.let(T.unsafe(nil), Integer)
Socket::PF_DLI = T.let(T.unsafe(nil), Integer)
Socket::PF_ECMA = T.let(T.unsafe(nil), Integer)
Socket::PF_HYLINK = T.let(T.unsafe(nil), Integer)
Socket::PF_IMPLINK = T.let(T.unsafe(nil), Integer)
Socket::PF_INET = T.let(T.unsafe(nil), Integer)
Socket::PF_INET6 = T.let(T.unsafe(nil), Integer)
Socket::PF_IPX = T.let(T.unsafe(nil), Integer)
Socket::PF_ISDN = T.let(T.unsafe(nil), Integer)
Socket::PF_ISO = T.let(T.unsafe(nil), Integer)
Socket::PF_KEY = T.let(T.unsafe(nil), Integer)
Socket::PF_LAT = T.let(T.unsafe(nil), Integer)
Socket::PF_LINK = T.let(T.unsafe(nil), Integer)
Socket::PF_LOCAL = T.let(T.unsafe(nil), Integer)
Socket::PF_MAX = T.let(T.unsafe(nil), Integer)
Socket::PF_NATM = T.let(T.unsafe(nil), Integer)
Socket::PF_NDRV = T.let(T.unsafe(nil), Integer)
Socket::PF_NETBIOS = T.let(T.unsafe(nil), Integer)
Socket::PF_NS = T.let(T.unsafe(nil), Integer)
Socket::PF_OSI = T.let(T.unsafe(nil), Integer)
Socket::PF_PIP = T.let(T.unsafe(nil), Integer)
Socket::PF_PPP = T.let(T.unsafe(nil), Integer)
Socket::PF_PUP = T.let(T.unsafe(nil), Integer)
Socket::PF_ROUTE = T.let(T.unsafe(nil), Integer)
Socket::PF_RTIP = T.let(T.unsafe(nil), Integer)
Socket::PF_SIP = T.let(T.unsafe(nil), Integer)
Socket::PF_SNA = T.let(T.unsafe(nil), Integer)
Socket::PF_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::PF_UNIX = T.let(T.unsafe(nil), Integer)
Socket::PF_UNSPEC = T.let(T.unsafe(nil), Integer)
Socket::PF_XTP = T.let(T.unsafe(nil), Integer)
Socket::SCM_CREDS = T.let(T.unsafe(nil), Integer)
Socket::SCM_RIGHTS = T.let(T.unsafe(nil), Integer)
Socket::SCM_TIMESTAMP = T.let(T.unsafe(nil), Integer)
Socket::SHUT_RD = T.let(T.unsafe(nil), Integer)
Socket::SHUT_RDWR = T.let(T.unsafe(nil), Integer)
Socket::SHUT_WR = T.let(T.unsafe(nil), Integer)
Socket::SOCK_DGRAM = T.let(T.unsafe(nil), Integer)
Socket::SOCK_RAW = T.let(T.unsafe(nil), Integer)
Socket::SOCK_RDM = T.let(T.unsafe(nil), Integer)
Socket::SOCK_SEQPACKET = T.let(T.unsafe(nil), Integer)
Socket::SOCK_STREAM = T.let(T.unsafe(nil), Integer)
Socket::SOL_SOCKET = T.let(T.unsafe(nil), Integer)
Socket::SOMAXCONN = T.let(T.unsafe(nil), Integer)
Socket::SO_ACCEPTCONN = T.let(T.unsafe(nil), Integer)
Socket::SO_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::SO_DEBUG = T.let(T.unsafe(nil), Integer)
Socket::SO_DONTROUTE = T.let(T.unsafe(nil), Integer)
Socket::SO_DONTTRUNC = T.let(T.unsafe(nil), Integer)
Socket::SO_ERROR = T.let(T.unsafe(nil), Integer)
Socket::SO_KEEPALIVE = T.let(T.unsafe(nil), Integer)
Socket::SO_LINGER = T.let(T.unsafe(nil), Integer)
Socket::SO_NKE = T.let(T.unsafe(nil), Integer)
Socket::SO_NOSIGPIPE = T.let(T.unsafe(nil), Integer)
Socket::SO_NREAD = T.let(T.unsafe(nil), Integer)
Socket::SO_OOBINLINE = T.let(T.unsafe(nil), Integer)
Socket::SO_RCVBUF = T.let(T.unsafe(nil), Integer)
Socket::SO_RCVLOWAT = T.let(T.unsafe(nil), Integer)
Socket::SO_RCVTIMEO = T.let(T.unsafe(nil), Integer)
Socket::SO_REUSEADDR = T.let(T.unsafe(nil), Integer)
Socket::SO_REUSEPORT = T.let(T.unsafe(nil), Integer)
Socket::SO_SNDBUF = T.let(T.unsafe(nil), Integer)
Socket::SO_SNDLOWAT = T.let(T.unsafe(nil), Integer)
Socket::SO_SNDTIMEO = T.let(T.unsafe(nil), Integer)
Socket::SO_TIMESTAMP = T.let(T.unsafe(nil), Integer)
Socket::SO_TYPE = T.let(T.unsafe(nil), Integer)
Socket::SO_USELOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::SO_WANTMORE = T.let(T.unsafe(nil), Integer)
Socket::SO_WANTOOBFLAG = T.let(T.unsafe(nil), Integer)
Socket::TCP_FASTOPEN = T.let(T.unsafe(nil), Integer)
Socket::TCP_KEEPCNT = T.let(T.unsafe(nil), Integer)
Socket::TCP_KEEPINTVL = T.let(T.unsafe(nil), Integer)
Socket::TCP_MAXSEG = T.let(T.unsafe(nil), Integer)
Socket::TCP_NODELAY = T.let(T.unsafe(nil), Integer)
Socket::TCP_NOOPT = T.let(T.unsafe(nil), Integer)
Socket::TCP_NOPUSH = T.let(T.unsafe(nil), Integer)

class Socket::UDPSource
  def initialize(remote_address, local_address, &reply_proc); end
  def inspect; end
  def local_address; end
  def remote_address; end
  def reply(msg); end
end

Forwardable::FORWARDABLE_VERSION = T.let(T.unsafe(nil), String)
Forwardable::VERSION = T.let(T.unsafe(nil), String)
class StandardError < ::Exception; end

class IO
  include ::Enumerable
  include ::File::Constants
  def initialize(*_arg0); end
  def <<(_arg0); end
  def advise(*_arg0); end
  def autoclose=(_arg0); end
  def autoclose?; end
  def beep; end
  def binmode; end
  def binmode?; end
  def check_winsize_changed; end
  def clear_screen; end
  def close; end
  def close_on_exec=(_arg0); end
  def close_on_exec?; end
  def close_read; end
  def close_write; end
  def closed?; end
  def console_mode; end
  def console_mode=(_arg0); end
  def cooked; end
  def cooked!; end
  def cursor; end
  def cursor=(_arg0); end
  def cursor_down(_arg0); end
  def cursor_left(_arg0); end
  def cursor_right(_arg0); end
  def cursor_up(_arg0); end
  def each(*_arg0); end
  def each_byte; end
  def each_char; end
  def each_codepoint; end
  def each_line(*_arg0); end
  def echo=(_arg0); end
  def echo?; end
  def eof; end
  def eof?; end
  def erase_line(_arg0); end
  def erase_screen(_arg0); end
  def expect(pat, timeout = T.unsafe(nil)); end
  def external_encoding; end
  def fcntl(*_arg0); end
  def fdatasync; end
  def fileno; end
  def flush; end
  def fsync; end
  def getbyte; end
  def getc; end
  def getch(*_arg0); end
  def getpass(*_arg0); end
  def gets(*_arg0); end
  def goto(_arg0, _arg1); end
  def goto_column(_arg0); end
  def iflush; end
  def inspect; end
  def internal_encoding; end
  def ioctl(*_arg0); end
  def ioflush; end
  def isatty; end
  def lineno; end
  def lineno=(_arg0); end
  def noecho; end
  def nonblock(*_arg0); end
  def nonblock=(_arg0); end
  def nonblock?; end
  def nread; end
  def oflush; end
  def pathconf(_arg0); end
  def pid; end
  def pos; end
  def pos=(_arg0); end
  def pread(*_arg0); end
  def pressed?; end
  def print(*_arg0); end
  def printf(*_arg0); end
  def putc(_arg0); end
  def puts(*_arg0); end
  def pwrite(_arg0, _arg1); end
  def raw(*_arg0); end
  def raw!(*_arg0); end
  def read(*_arg0); end
  def read_nonblock(len, buf = T.unsafe(nil), exception: T.unsafe(nil)); end
  def readbyte; end
  def readchar; end
  def readline(*_arg0); end
  def readlines(*_arg0); end
  def readpartial(*_arg0); end
  def ready?; end
  def reopen(*_arg0); end
  def rewind; end
  def scroll_backward(_arg0); end
  def scroll_forward(_arg0); end
  def seek(*_arg0); end
  def set_encoding(*_arg0); end
  def set_encoding_by_bom; end
  def stat; end
  def sync; end
  def sync=(_arg0); end
  def sysread(*_arg0); end
  def sysseek(*_arg0); end
  def syswrite(_arg0); end
  def tell; end
  def to_i; end
  def to_io; end
  def tty?; end
  def ungetbyte(_arg0); end
  def ungetc(_arg0); end
  def wait(*_arg0); end
  def wait_priority(*_arg0); end
  def wait_readable(*_arg0); end
  def wait_writable(*_arg0); end
  def winsize; end
  def winsize=(_arg0); end
  def write(*_arg0); end
  def write_nonblock(buf, exception: T.unsafe(nil)); end
  private def initialize_copy(_arg0); end
  def self.binread(*_arg0); end
  def self.binwrite(*_arg0); end
  def self.console(*_arg0); end
  def self.copy_stream(*_arg0); end
  def self.for_fd(*_arg0); end
  def self.foreach(*_arg0); end
  def self.new(*_arg0); end
  def self.open(*_arg0); end
  def self.pipe(*_arg0); end
  def self.popen(*_arg0); end
  def self.read(*_arg0); end
  def self.readlines(*_arg0); end
  def self.select(*_arg0); end
  def self.sysopen(*_arg0); end
  def self.try_convert(_arg0); end
  def self.write(*_arg0); end
end

class Rinda::DRbObjectTemplate
  def initialize(uri = T.unsafe(nil), ref = T.unsafe(nil)); end
  def ===(ro); end
end

class Rinda::InvalidHashTupleKey < ::Rinda::RindaError; end

class Rinda::NotifyTemplateEntry < ::Rinda::TemplateEntry
  def initialize(place, event, tuple, expires = T.unsafe(nil)); end
  def each; end
  def notify(ev); end
  def pop; end
end

class Rinda::RequestCanceledError < ::ThreadError; end
class Rinda::RequestExpiredError < ::ThreadError; end
class Rinda::RindaError < ::RuntimeError; end

class Rinda::RingFinger
  def initialize(broadcast_list = T.unsafe(nil), port = T.unsafe(nil)); end
  def broadcast_list; end
  def broadcast_list=(_arg0); end
  def each; end
  def lookup_ring(timeout = T.unsafe(nil), &block); end
  def lookup_ring_any(timeout = T.unsafe(nil)); end
  def make_socket(address); end
  def multicast_hops; end
  def multicast_hops=(_arg0); end
  def multicast_interface; end
  def multicast_interface=(_arg0); end
  def port; end
  def port=(_arg0); end
  def primary; end
  def primary=(_arg0); end
  def send_message(address, message); end
  def to_a; end
  def self.finger; end
  def self.primary; end
  def self.to_a; end
end

class Rinda::RingProvider
  def initialize(klass, front, desc, renewer = T.unsafe(nil)); end
  def provide; end
end

class Rinda::RingServer
  include ::DRb::DRbUndumped
  def initialize(ts, addresses = T.unsafe(nil), port = T.unsafe(nil)); end
  def do_reply; end
  def do_write(msg); end
  def make_socket(address, interface_address = T.unsafe(nil), multicast_interface = T.unsafe(nil)); end
  def reply_service; end
  def shutdown; end
  def write_services; end
end

Rinda::Ring_PORT = T.let(T.unsafe(nil), Integer)

class Rinda::SimpleRenewer
  include ::DRb::DRbUndumped
  def initialize(sec = T.unsafe(nil)); end
  def renew; end
end

class Rinda::Template < ::Rinda::Tuple
  def ===(tuple); end
  def match(tuple); end
end

class Rinda::TemplateEntry < ::Rinda::TupleEntry
  def ===(tuple); end
  def make_tuple(ary); end
  def match(tuple); end
end

class Rinda::Tuple
  def initialize(ary_or_hash); end
  def [](k); end
  def each; end
  def fetch(k); end
  def size; end
  def value; end
  private def hash?(ary_or_hash); end
  private def init_with_ary(ary); end
  private def init_with_hash(hash); end
end

class Rinda::TupleBag
  def initialize; end
  def delete(tuple); end
  def delete_unless_alive; end
  def find(template); end
  def find_all(template); end
  def find_all_template(tuple); end
  def has_expires?; end
  def push(tuple); end
  private def bin_for_find(template); end
  private def bin_key(tuple); end
  private def each_entry(&blk); end
end

class Rinda::TupleEntry
  include ::DRb::DRbUndumped
  def initialize(ary, sec = T.unsafe(nil)); end
  def [](key); end
  def alive?; end
  def cancel; end
  def canceled?; end
  def expired?; end
  def expires; end
  def expires=(_arg0); end
  def fetch(key); end
  def make_expires(sec = T.unsafe(nil)); end
  def make_tuple(ary); end
  def renew(sec_or_renewer); end
  def size; end
  def value; end
  private def get_renewer(it); end
end

class Rinda::TupleSpace
  include ::DRb::DRbUndumped
  include ::MonitorMixin
  def initialize(period = T.unsafe(nil)); end
  def move(port, tuple, sec = T.unsafe(nil)); end
  def notify(event, tuple, sec = T.unsafe(nil)); end
  def read(tuple, sec = T.unsafe(nil)); end
  def read_all(tuple); end
  def take(tuple, sec = T.unsafe(nil), &block); end
  def write(tuple, sec = T.unsafe(nil)); end
  private def create_entry(tuple, sec); end
  private def keep_clean; end
  private def need_keeper?; end
  private def notify_event(event, tuple); end
  private def start_keeper; end
end

class Rinda::TupleSpaceProxy
  def initialize(ts); end
  def notify(ev, tuple, sec = T.unsafe(nil)); end
  def read(tuple, sec = T.unsafe(nil), &block); end
  def read_all(tuple); end
  def take(tuple, sec = T.unsafe(nil), &block); end
  def write(tuple, sec = T.unsafe(nil)); end
end

class Rinda::WaitTemplateEntry < ::Rinda::TemplateEntry
  def initialize(place, ary, expires = T.unsafe(nil)); end
  def cancel; end
  def found; end
  def read(tuple); end
  def signal; end
  def wait; end
end

class DRb::DRbArray
  def initialize(ary); end
  def _dump(lv); end
  def self._load(s); end
end

class DRb::DRbBadScheme < ::DRb::DRbError; end
class DRb::DRbBadURI < ::DRb::DRbError; end

class DRb::DRbConn
  def initialize(remote_uri); end
  def alive?; end
  def close; end
  def send_message(ref, msg_id, arg, block); end
  def uri; end
  def self.make_pool; end
  def self.open(remote_uri); end
  def self.stop_pool; end
end

class DRb::DRbConnError < ::DRb::DRbError; end
class DRb::DRbError < ::RuntimeError; end

class DRb::DRbIdConv
  def to_id(obj); end
  def to_obj(ref); end
end

class DRb::DRbMessage
  def initialize(config); end
  def dump(obj, error = T.unsafe(nil)); end
  def load(soc); end
  def recv_reply(stream); end
  def recv_request(stream); end
  def send_reply(stream, succ, result); end
  def send_request(stream, ref, msg_id, arg, b); end
  private def make_proxy(obj, error = T.unsafe(nil)); end
end

class DRb::DRbObject
  def initialize(obj, uri = T.unsafe(nil)); end
  def ==(other); end
  def __drbref; end
  def __drburi; end
  def _dump(lv); end
  def eql?(other); end
  def hash; end
  def method_missing(msg_id, *a, &b); end
  def pretty_print(q); end
  def pretty_print_cycle(q); end
  def respond_to?(msg_id, priv = T.unsafe(nil)); end
  def self._load(s); end
  def self.new_with(uri, ref); end
  def self.new_with_uri(uri); end
  def self.prepare_backtrace(uri, result); end
  def self.with_friend(uri); end
end

module DRb::DRbObservable
  include ::Observable
  def notify_observers(*arg); end
end

module DRb::DRbProtocol
  private def add_protocol(prot); end
  private def auto_load(uri); end
  private def open(uri, config, first = T.unsafe(nil)); end
  private def open_server(uri, config, first = T.unsafe(nil)); end
  private def uri_option(uri, config, first = T.unsafe(nil)); end
  def self.add_protocol(prot); end
  def self.auto_load(uri); end
  def self.open(uri, config, first = T.unsafe(nil)); end
  def self.open_server(uri, config, first = T.unsafe(nil)); end
  def self.uri_option(uri, config, first = T.unsafe(nil)); end
end

class DRb::DRbRemoteError < ::DRb::DRbError
  def initialize(error); end
  def reason; end
end

class DRb::DRbSSLSocket < ::DRb::DRbTCPSocket
  def initialize(uri, soc, config, is_established); end
  def accept; end
  def close; end
  def stream; end
  def self.open(uri, config); end
  def self.open_server(uri, config); end
  def self.parse_uri(uri); end
  def self.uri_option(uri, config); end
end

class DRb::DRbServer
  def initialize(uri = T.unsafe(nil), front = T.unsafe(nil), config_or_acl = T.unsafe(nil)); end
  def alive?; end
  def check_insecure_method(obj, msg_id); end
  def config; end
  def front; end
  def here?(uri); end
  def stop_service; end
  def thread; end
  def to_id(obj); end
  def to_obj(ref); end
  def uri; end
  def verbose; end
  def verbose=(v); end
  private def any_to_s(obj); end
  private def error_print(exception); end
  private def insecure_method?(msg_id); end
  private def main_loop; end
  private def run; end
  private def shutdown; end
  def self.default_acl(acl); end
  def self.default_argc_limit(argc); end
  def self.default_id_conv(idconv); end
  def self.default_load_limit(sz); end
  def self.make_config(hash = T.unsafe(nil)); end
  def self.verbose; end
  def self.verbose=(on); end
end

class DRb::DRbServerNotFound < ::DRb::DRbError; end

class DRb::DRbTCPSocket
  def initialize(uri, soc, config = T.unsafe(nil)); end
  def accept; end
  def alive?; end
  def close; end
  def peeraddr; end
  def recv_reply; end
  def recv_request; end
  def send_reply(succ, result); end
  def send_request(ref, msg_id, arg, b); end
  def set_sockopt(soc); end
  def shutdown; end
  def stream; end
  def uri; end
  private def accept_or_shutdown; end
  private def close_shutdown_pipe; end
  def self.getservername; end
  def self.open(uri, config); end
  def self.open_server(uri, config); end
  def self.open_server_inaddr_any(host, port); end
  def self.parse_uri(uri); end
  def self.uri_option(uri, config); end
end

class DRb::DRbUNIXSocket < ::DRb::DRbTCPSocket
  def initialize(uri, soc, config = T.unsafe(nil), server_mode = T.unsafe(nil)); end
  def accept; end
  def close; end
  def set_sockopt(soc); end
  def self.open(uri, config); end
  def self.open_server(uri, config); end
  def self.parse_uri(uri); end
  def self.temp_server; end
  def self.uri_option(uri, config); end
end

class DRb::DRbURIOption
  def initialize(option); end
  def ==(other); end
  def eql?(other); end
  def hash; end
  def option; end
  def to_s; end
end

module DRb::DRbUndumped
  def _dump(dummy); end
end

class DRb::DRbUnknown
  def initialize(err, buf); end
  def _dump(lv); end
  def buf; end
  def exception; end
  def name; end
  def reload; end
  def self._load(s); end
end

class DRb::DRbUnknownError < ::DRb::DRbError
  def initialize(unknown); end
  def _dump(lv); end
  def unknown; end
  def self._load(s); end
end

class DRb::ExtServ
  include ::MonitorMixin
  include ::DRb::DRbUndumped
  def initialize(there, name, server = T.unsafe(nil)); end
  def alive?; end
  def front; end
  def server; end
  def stop_service; end
end

class DRb::ExtServManager
  include ::DRb::DRbUndumped
  include ::MonitorMixin
  def initialize; end
  def regist(name, ro); end
  def service(name); end
  def unregist(name); end
  def uri; end
  def uri=(_arg0); end
  private def invoke_service(name); end
  private def invoke_service_command(name, command); end
  private def invoke_thread; end
  def self.command; end
  def self.command=(cmd); end
end

class DRb::GW
  include ::MonitorMixin
  def initialize; end
  def [](key); end
  def []=(key, v); end
end

class DRb::GWIdConv < ::DRb::DRbIdConv
  def to_obj(ref); end
end

class DRb::ThreadObject
  include ::MonitorMixin
  def initialize(&blk); end
  def _execute; end
  def alive?; end
  def kill; end
  def method_missing(msg, *arg, &blk); end
end

class DRb::TimerIdConv < ::DRb::DRbIdConv
  def initialize(keeping = T.unsafe(nil)); end
  def to_id(obj); end
  def to_obj(ref); end
end

DRb::VERSION = T.let(T.unsafe(nil), String)

class DRb::WeakIdConv < ::DRb::DRbIdConv
  def initialize; end
  def to_id(obj); end
  def to_obj(ref); end
end

module Comparable
  def <(_arg0); end
  def <=(_arg0); end
  def ==(_arg0); end
  def >(_arg0); end
  def >=(_arg0); end
  def between?(_arg0, _arg1); end
  def clamp(*_arg0); end
end

class ArgumentError < ::StandardError; end
Socket::Constants::AF_APPLETALK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_CCITT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_CHAOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_CNT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_COIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_DATAKIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_DLI = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_E164 = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_ECMA = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_HYLINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_IMPLINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_INET = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_INET6 = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_IPX = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_ISDN = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_ISO = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_LAT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_LINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_LOCAL = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_MAX = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_NATM = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_NDRV = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_NETBIOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_NS = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_OSI = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_PPP = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_PUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_ROUTE = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_SIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_SNA = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_UNIX = T.let(T.unsafe(nil), Integer)
Socket::Constants::AF_UNSPEC = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_ADDRCONFIG = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_ALL = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_CANONNAME = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_DEFAULT = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_MASK = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_NUMERICHOST = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_NUMERICSERV = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_PASSIVE = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_V4MAPPED = T.let(T.unsafe(nil), Integer)
Socket::Constants::AI_V4MAPPED_CFG = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_ADDRFAMILY = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_AGAIN = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_BADFLAGS = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_BADHINTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_FAIL = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_FAMILY = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_MAX = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_MEMORY = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_NODATA = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_NONAME = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_OVERFLOW = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_PROTOCOL = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_SERVICE = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_SOCKTYPE = T.let(T.unsafe(nil), Integer)
Socket::Constants::EAI_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_ALLMULTI = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_ALTPHYS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_DEBUG = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_LINK0 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_LINK1 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_LINK2 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_LOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_MULTICAST = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_NOARP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_NOTRAILERS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_OACTIVE = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_POINTOPOINT = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_PROMISC = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_RUNNING = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_SIMPLEX = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFF_UP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IFNAMSIZ = T.let(T.unsafe(nil), Integer)
Socket::Constants::IF_NAMESIZE = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_ALLHOSTS_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_ANY = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_LOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_MAX_LOCAL_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_NONE = T.let(T.unsafe(nil), Integer)
Socket::Constants::INADDR_UNSPEC_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::INET6_ADDRSTRLEN = T.let(T.unsafe(nil), Integer)
Socket::Constants::INET_ADDRSTRLEN = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPORT_RESERVED = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPORT_USERRESERVED = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_AH = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_DSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_EGP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_EON = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ESP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_FRAGMENT = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_GGP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_HELLO = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_HOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ICMP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ICMPV6 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_IDP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_IGMP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_IP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_IPV6 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_MAX = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ND = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_NONE = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_PUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_RAW = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_ROUTING = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_TCP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_TP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_UDP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPPROTO_XTP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_CHECKSUM = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_DONTFRAG = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_DSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_HOPLIMIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_HOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_JOIN_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_LEAVE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_MULTICAST_HOPS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_MULTICAST_IF = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_NEXTHOP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_PATHMTU = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_PKTINFO = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVDSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVHOPLIMIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVHOPOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVPATHMTU = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVPKTINFO = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVRTHDR = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RECVTCLASS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RTHDR = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RTHDRDSTOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_RTHDR_TYPE_0 = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_TCLASS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_UNICAST_HOPS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_USE_MIN_MTU = T.let(T.unsafe(nil), Integer)
Socket::Constants::IPV6_V6ONLY = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_ADD_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_ADD_SOURCE_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_BLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DEFAULT_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DEFAULT_MULTICAST_TTL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DONTFRAG = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DROP_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_DROP_SOURCE_MEMBERSHIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_HDRINCL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_IPSEC_POLICY = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MAX_MEMBERSHIPS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MSFILTER = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MULTICAST_IF = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MULTICAST_LOOP = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_MULTICAST_TTL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_OPTIONS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_PKTINFO = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_PORTRANGE = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVDSTADDR = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVIF = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVRETOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVTOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RECVTTL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_RETOPTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_TOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_TTL = T.let(T.unsafe(nil), Integer)
Socket::Constants::IP_UNBLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::Constants::LOCAL_PEERCRED = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_BLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_EXCLUDE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_INCLUDE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_JOIN_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_JOIN_SOURCE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_LEAVE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_LEAVE_SOURCE_GROUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::MCAST_UNBLOCK_SOURCE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_CTRUNC = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_DONTROUTE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_DONTWAIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_EOF = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_EOR = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_FLUSH = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_HAVEMORE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_HOLD = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_NOSIGNAL = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_OOB = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_PEEK = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_RCVMORE = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_SEND = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_TRUNC = T.let(T.unsafe(nil), Integer)
Socket::Constants::MSG_WAITALL = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_DGRAM = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_MAXHOST = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_MAXSERV = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_NAMEREQD = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_NOFQDN = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_NUMERICHOST = T.let(T.unsafe(nil), Integer)
Socket::Constants::NI_NUMERICSERV = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_APPLETALK = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_CCITT = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_CHAOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_CNT = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_COIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_DATAKIT = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_DLI = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_ECMA = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_HYLINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_IMPLINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_INET = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_INET6 = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_IPX = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_ISDN = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_ISO = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_KEY = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_LAT = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_LINK = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_LOCAL = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_MAX = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_NATM = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_NDRV = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_NETBIOS = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_NS = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_OSI = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_PIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_PPP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_PUP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_ROUTE = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_RTIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_SIP = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_SNA = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_SYSTEM = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_UNIX = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_UNSPEC = T.let(T.unsafe(nil), Integer)
Socket::Constants::PF_XTP = T.let(T.unsafe(nil), Integer)
Socket::Constants::SCM_CREDS = T.let(T.unsafe(nil), Integer)
Socket::Constants::SCM_RIGHTS = T.let(T.unsafe(nil), Integer)
Socket::Constants::SCM_TIMESTAMP = T.let(T.unsafe(nil), Integer)
Socket::Constants::SHUT_RD = T.let(T.unsafe(nil), Integer)
Socket::Constants::SHUT_RDWR = T.let(T.unsafe(nil), Integer)
Socket::Constants::SHUT_WR = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_DGRAM = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_RAW = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_RDM = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_SEQPACKET = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOCK_STREAM = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOL_SOCKET = T.let(T.unsafe(nil), Integer)
Socket::Constants::SOMAXCONN = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_ACCEPTCONN = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_BROADCAST = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_DEBUG = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_DONTROUTE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_DONTTRUNC = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_ERROR = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_KEEPALIVE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_LINGER = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_NKE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_NOSIGPIPE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_NREAD = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_OOBINLINE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_RCVBUF = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_RCVLOWAT = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_RCVTIMEO = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_REUSEADDR = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_REUSEPORT = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_SNDBUF = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_SNDLOWAT = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_SNDTIMEO = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_TIMESTAMP = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_TYPE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_USELOOPBACK = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_WANTMORE = T.let(T.unsafe(nil), Integer)
Socket::Constants::SO_WANTOOBFLAG = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_FASTOPEN = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_KEEPCNT = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_KEEPINTVL = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_MAXSEG = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_NODELAY = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_NOOPT = T.let(T.unsafe(nil), Integer)
Socket::Constants::TCP_NOPUSH = T.let(T.unsafe(nil), Integer)

class Exception
  def initialize(*_arg0); end
  def ==(_arg0); end
  def backtrace; end
  def backtrace_locations; end
  def cause; end
  def exception(*_arg0); end
  def full_message(*_arg0); end
  def inspect; end
  def message; end
  def respond_to?(*_arg0); end
  def set_backtrace(_arg0); end
  def to_s; end
  private def method_missing(*_arg0); end
  private def respond_to_missing?(_arg0, _arg1); end
  def self.exception(*_arg0); end
  def self.to_tty?; end
end

class IO::ConsoleMode
  def echo=(_arg0); end
  def raw(*_arg0); end
  def raw!(*_arg0); end
  private def initialize_copy(_arg0); end
end

class IO::EAGAINWaitReadable < ::Errno::EAGAIN
  include ::IO::WaitReadable
end

class IO::EAGAINWaitWritable < ::Errno::EAGAIN
  include ::IO::WaitWritable
end

class IO::EINPROGRESSWaitReadable < ::Errno::EINPROGRESS
  include ::IO::WaitReadable
end

class IO::EINPROGRESSWaitWritable < ::Errno::EINPROGRESS
  include ::IO::WaitWritable
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable
IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable
IO::PRIORITY = T.let(T.unsafe(nil), Integer)
IO::READABLE = T.let(T.unsafe(nil), Integer)
IO::SEEK_CUR = T.let(T.unsafe(nil), Integer)
IO::SEEK_DATA = T.let(T.unsafe(nil), Integer)
IO::SEEK_END = T.let(T.unsafe(nil), Integer)
IO::SEEK_HOLE = T.let(T.unsafe(nil), Integer)
IO::SEEK_SET = T.let(T.unsafe(nil), Integer)
IO::WRITABLE = T.let(T.unsafe(nil), Integer)
module IO::WaitReadable; end
module IO::WaitWritable; end
class ThreadError < ::StandardError; end
class RuntimeError < ::StandardError; end

class Rinda::RingServer::Renewer
  include ::DRb::DRbUndumped
  def initialize; end
  def renew; end
  def renew=(_arg0); end
end

class Rinda::TupleBag::TupleBin
  extend ::Forwardable
  def initialize; end
  def add(tuple); end
  def delete(tuple); end
  def delete_if(*args, &block); end
  def each(*args, &block); end
  def empty?(*args, &block); end
  def find; end
  def find_all(*args, &block); end
end

class Rinda::TupleSpaceProxy::Port
  def initialize; end
  def close; end
  def push(value); end
  def value; end
  def self.deliver; end
end

DRb::DRbConn::POOL_SIZE = T.let(T.unsafe(nil), Integer)

class DRb::DRbSSLSocket::SSLConfig
  def initialize(config); end
  def [](key); end
  def accept(tcp); end
  def connect(tcp); end
  def setup_certificate; end
  def setup_ssl_context; end
end

DRb::DRbServer::INSECURE_METHOD = T.let(T.unsafe(nil), Array)

class DRb::DRbServer::InvokeMethod
  include ::DRb::DRbServer::InvokeMethod18Mixin
  def initialize(drb_server, client); end
  def perform; end
  private def check_insecure_method; end
  private def init_with_client; end
  private def perform_without_block; end
  private def setup_message; end
end

module DRb::DRbServer::InvokeMethod18Mixin
  def block_yield(x); end
  def perform_with_block; end
end

DRb::DRbUNIXSocket::Max_try = T.let(T.unsafe(nil), Integer)

class DRb::TimerIdConv::TimerHolder2
  include ::MonitorMixin
  def initialize(keeping = T.unsafe(nil)); end
  def add(obj); end
  def fetch(key); end
  private def invoke_keeper; end
  private def on_gc; end
  private def peek(key); end
  private def rotate; end
end

class DRb::WeakIdConv::WeakSet
  include ::MonitorMixin
  def initialize; end
  def add(obj); end
  def fetch(ref); end
end

module Enumerable
  def all?(*_arg0); end
  def any?(*_arg0); end
  def chain(*_arg0); end
  def chunk; end
  def chunk_while; end
  def collect; end
  def collect_concat; end
  def count(*_arg0); end
  def cycle(*_arg0); end
  def detect(*_arg0); end
  def drop(_arg0); end
  def drop_while; end
  def each_cons(_arg0); end
  def each_entry(*_arg0); end
  def each_slice(_arg0); end
  def each_with_index(*_arg0); end
  def each_with_object(_arg0); end
  def entries(*_arg0); end
  def filter; end
  def filter_map; end
  def find(*_arg0); end
  def find_all; end
  def find_index(*_arg0); end
  def first(*_arg0); end
  def flat_map; end
  def grep(_arg0); end
  def grep_v(_arg0); end
  def group_by; end
  def include?(_arg0); end
  def inject(*_arg0); end
  def lazy; end
  def map; end
  def max(*_arg0); end
  def max_by(*_arg0); end
  def member?(_arg0); end
  def min(*_arg0); end
  def min_by(*_arg0); end
  def minmax; end
  def minmax_by; end
  def none?(*_arg0); end
  def one?(*_arg0); end
  def partition; end
  def reduce(*_arg0); end
  def reject; end
  def reverse_each(*_arg0); end
  def select; end
  def slice_after(*_arg0); end
  def slice_before(*_arg0); end
  def slice_when; end
  def sort; end
  def sort_by; end
  def sum(*_arg0); end
  def take(_arg0); end
  def take_while; end
  def tally; end
  def to_a(*_arg0); end
  def to_h(*_arg0); end
  def to_set(klass = T.unsafe(nil), *args, &block); end
  def uniq; end
  def zip(*_arg0); end
end

module File::Constants; end

module MonitorMixin
  def initialize(*_arg0, &_arg1); end
  def mon_enter; end
  def mon_exit; end
  def mon_locked?; end
  def mon_owned?; end
  def mon_synchronize(&b); end
  def mon_try_enter; end
  def new_cond; end
  def synchronize(&b); end
  def try_mon_enter; end
  private def mon_check_owner; end
  private def mon_initialize; end
  def self.extend_object(obj); end
end

module Observable
  def add_observer(observer, func = T.unsafe(nil)); end
  def changed(state = T.unsafe(nil)); end
  def changed?; end
  def count_observers; end
  def delete_observer(observer); end
  def delete_observers; end
  def notify_observers(*arg); end
end

class Errno::EAGAIN < ::SystemCallError; end
class Errno::EINPROGRESS < ::SystemCallError; end
DRb::DRbSSLSocket::SSLConfig::DEFAULT = T.let(T.unsafe(nil), Hash)
class DRb::TimerIdConv::TimerHolder2::InvalidIndexError < ::RuntimeError; end
File::Constants::APPEND = T.let(T.unsafe(nil), Integer)
File::Constants::BINARY = T.let(T.unsafe(nil), Integer)
File::Constants::CREAT = T.let(T.unsafe(nil), Integer)
File::Constants::DSYNC = T.let(T.unsafe(nil), Integer)
File::Constants::EXCL = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_CASEFOLD = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_DOTMATCH = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_EXTGLOB = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_NOESCAPE = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_PATHNAME = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_SHORTNAME = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_SYSCASE = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_EX = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_NB = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_SH = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_UN = T.let(T.unsafe(nil), Integer)
File::Constants::NOCTTY = T.let(T.unsafe(nil), Integer)
File::Constants::NOFOLLOW = T.let(T.unsafe(nil), Integer)
File::Constants::NONBLOCK = T.let(T.unsafe(nil), Integer)
File::Constants::NULL = T.let(T.unsafe(nil), String)
File::Constants::RDONLY = T.let(T.unsafe(nil), Integer)
File::Constants::RDWR = T.let(T.unsafe(nil), Integer)
File::Constants::SHARE_DELETE = T.let(T.unsafe(nil), Integer)
File::Constants::SYNC = T.let(T.unsafe(nil), Integer)
File::Constants::TRUNC = T.let(T.unsafe(nil), Integer)
File::Constants::WRONLY = T.let(T.unsafe(nil), Integer)

class MonitorMixin::ConditionVariable
  def initialize(monitor); end
  def broadcast; end
  def signal; end
  def wait(timeout = T.unsafe(nil)); end
  def wait_until; end
  def wait_while; end
end

Observable::VERSION = T.let(T.unsafe(nil), String)

class SystemCallError < ::StandardError
  def initialize(*_arg0); end
  def errno; end
  def self.===(_arg0); end
end

Errno::EAGAIN::Errno = T.let(T.unsafe(nil), Integer)
Errno::EINPROGRESS::Errno = T.let(T.unsafe(nil), Integer)

module SecureRandom
  extend ::Random::Formatter
  def self.bytes(n); end
  def self.gen_random(n); end
  private def self.gen_random_openssl(n); end
  private def self.gen_random_urandom(n); end
end

module Random::Formatter
  def alphanumeric(n = T.unsafe(nil)); end
  def base64(n = T.unsafe(nil)); end
  def hex(n = T.unsafe(nil)); end
  def rand(*_arg0); end
  def random_bytes(n = T.unsafe(nil)); end
  def random_number(*_arg0); end
  def urlsafe_base64(n = T.unsafe(nil), padding = T.unsafe(nil)); end
  def uuid; end
  private def choose(source, n); end
  private def gen_random(n); end
end

Random::Formatter::ALPHANUMERIC = T.let(T.unsafe(nil), Array)

module Shellwords
  private def shellescape(str); end
  private def shelljoin(array); end
  private def shellsplit(line); end
  private def shellwords(line); end
  def self.escape(str); end
  def self.join(array); end
  def self.shellescape(str); end
  def self.shelljoin(array); end
  def self.shellsplit(line); end
  def self.shellwords(line); end
  def self.split(line); end
end
module Singleton
  mixes_in_class_methods ::Singleton::SingletonClassMethods
  def _dump(depth = T.unsafe(nil)); end
  def clone; end
  def dup; end
  def self.__init__(klass); end
  private def self.append_features(mod); end
  private def self.included(klass); end
end

module Singleton::SingletonClassMethods
  def _load(str); end
  def clone; end
  def instance; end
  private def inherited(sub_klass); end
end

Singleton::VERSION = T.let(T.unsafe(nil), String)
module FileUtils
  include ::FileUtils::StreamUtils_
  extend ::FileUtils::StreamUtils_
  private def apply_mask(mode, user_mask, op, mode_mask); end
  private def cd(dir, verbose: T.unsafe(nil), &block); end
  private def chdir(dir, verbose: T.unsafe(nil), &block); end
  private def chmod(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def chmod_R(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end
  private def chown(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def chown_R(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end
  private def cmp(a, b); end
  private def compare_file(a, b); end
  private def compare_stream(a, b); end
  private def copy(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def copy_entry(src, dest, preserve = T.unsafe(nil), dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end
  private def copy_file(src, dest, preserve = T.unsafe(nil), dereference = T.unsafe(nil)); end
  private def copy_stream(src, dest); end
  private def cp(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end
  private def cp_r(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end
  private def fu_each_src_dest(src, dest); end
  private def fu_each_src_dest0(src, dest); end
  private def fu_get_gid(group); end
  private def fu_get_uid(user); end
  private def fu_have_symlink?; end
  private def fu_list(arg); end
  private def fu_mkdir(path, mode); end
  private def fu_mode(mode, path); end
  private def fu_output_message(msg); end
  private def fu_same?(a, b); end
  private def fu_stat_identical_entry?(a, b); end
  private def getwd; end
  private def identical?(a, b); end
  private def install(src, dest, mode: T.unsafe(nil), owner: T.unsafe(nil), group: T.unsafe(nil), preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def link(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def link_entry(src, dest, dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end
  private def ln(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def ln_s(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def ln_sf(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def makedirs(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def mkdir(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def mkdir_p(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def mkpath(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def mode_to_s(mode); end
  private def move(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def mv(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def pwd; end
  private def remove(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def remove_dir(path, force = T.unsafe(nil)); end
  private def remove_entry(path, force = T.unsafe(nil)); end
  private def remove_entry_secure(path, force = T.unsafe(nil)); end
  private def remove_file(path, force = T.unsafe(nil)); end
  private def remove_trailing_slash(dir); end
  private def rm(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def rm_f(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def rm_r(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def rm_rf(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def rmdir(list, parents: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def rmtree(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def safe_unlink(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def symbolic_modes_to_i(mode_sym, path); end
  private def symlink(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def touch(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), mtime: T.unsafe(nil), nocreate: T.unsafe(nil)); end
  private def uptodate?(new, old_list); end
  private def user_mask(target); end
  def self.cd(dir, verbose: T.unsafe(nil), &block); end
  def self.chdir(dir, verbose: T.unsafe(nil), &block); end
  def self.chmod(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.chmod_R(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end
  def self.chown(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.chown_R(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end
  def self.cmp(a, b); end
  def self.collect_method(opt); end
  def self.commands; end
  def self.compare_file(a, b); end
  def self.compare_stream(a, b); end
  def self.copy(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.copy_entry(src, dest, preserve = T.unsafe(nil), dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end
  def self.copy_file(src, dest, preserve = T.unsafe(nil), dereference = T.unsafe(nil)); end
  def self.copy_stream(src, dest); end
  def self.cp(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end
  def self.cp_r(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end
  def self.getwd; end
  def self.have_option?(mid, opt); end
  def self.identical?(a, b); end
  def self.install(src, dest, mode: T.unsafe(nil), owner: T.unsafe(nil), group: T.unsafe(nil), preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.link(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.link_entry(src, dest, dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end
  def self.ln(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.ln_s(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.ln_sf(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.makedirs(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.mkdir(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.mkdir_p(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.mkpath(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.move(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.mv(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.options; end
  def self.options_of(mid); end
  def self.private_module_function(name); end
  def self.pwd; end
  def self.remove(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.remove_dir(path, force = T.unsafe(nil)); end
  def self.remove_entry(path, force = T.unsafe(nil)); end
  def self.remove_entry_secure(path, force = T.unsafe(nil)); end
  def self.remove_file(path, force = T.unsafe(nil)); end
  def self.rm(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.rm_f(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.rm_r(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.rm_rf(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.rmdir(list, parents: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.rmtree(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.safe_unlink(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.symlink(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.touch(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), mtime: T.unsafe(nil), nocreate: T.unsafe(nil)); end
  def self.uptodate?(new, old_list); end
  private def self.apply_mask(mode, user_mask, op, mode_mask); end
  private def self.fu_each_src_dest(src, dest); end
  private def self.fu_each_src_dest0(src, dest); end
  private def self.fu_get_gid(group); end
  private def self.fu_get_uid(user); end
  private def self.fu_have_symlink?; end
  private def self.fu_list(arg); end
  private def self.fu_mkdir(path, mode); end
  private def self.fu_mode(mode, path); end
  private def self.fu_output_message(msg); end
  private def self.fu_same?(a, b); end
  private def self.fu_stat_identical_entry?(a, b); end
  private def self.mode_to_s(mode); end
  private def self.remove_trailing_slash(dir); end
  private def self.symbolic_modes_to_i(mode_sym, path); end
  private def self.user_mask(target); end
end

class Tempfile
  def initialize(basename = T.unsafe(nil), tmpdir = T.unsafe(nil), mode: T.unsafe(nil), **options); end
  def close(unlink_now = T.unsafe(nil)); end
  def close!; end
  def delete; end
  def inspect; end
  def length; end
  def open; end
  def path; end
  def size; end
  def unlink; end
  protected def _close; end
  def self.create(basename = T.unsafe(nil), tmpdir = T.unsafe(nil), mode: T.unsafe(nil), **options); end
  def self.open(*args, **kw); end
end

class Delegator < ::BasicObject
  def initialize(obj); end
  def !; end
  def !=(obj); end
  def ==(obj); end
  def __getobj__; end
  def __setobj__(obj); end
  def eql?(obj); end
  def freeze; end
  def marshal_dump; end
  def marshal_load(data); end
  def method_missing(m, *args, &block); end
  def methods(all = T.unsafe(nil)); end
  def protected_methods(all = T.unsafe(nil)); end
  def public_methods(all = T.unsafe(nil)); end
  private def initialize_clone(obj, freeze: T.unsafe(nil)); end
  private def initialize_dup(obj); end
  private def respond_to_missing?(m, include_private); end
  private def target_respond_to?(target, m, include_private); end
  def self.const_missing(n); end
  def self.delegating_block(mid); end
  def self.public_api; end
end

class SimpleDelegator
  def __getobj__; end
  def __setobj__(obj); end
end

module Etc
  private def confstr(_arg0); end
  private def endgrent; end
  private def endpwent; end
  private def getgrent; end
  private def getgrgid(*_arg0); end
  private def getgrnam(_arg0); end
  private def getlogin; end
  private def getpwent; end
  private def getpwnam(_arg0); end
  private def getpwuid(*_arg0); end
  private def group; end
  private def nprocessors; end
  private def passwd; end
  private def setgrent; end
  private def setpwent; end
  private def sysconf(_arg0); end
  private def sysconfdir; end
  private def systmpdir; end
  private def uname; end
  def self.confstr(_arg0); end
  def self.endgrent; end
  def self.endpwent; end
  def self.getgrent; end
  def self.getgrgid(*_arg0); end
  def self.getgrnam(_arg0); end
  def self.getlogin; end
  def self.getpwent; end
  def self.getpwnam(_arg0); end
  def self.getpwuid(*_arg0); end
  def self.group; end
  def self.nprocessors; end
  def self.passwd; end
  def self.setgrent; end
  def self.setpwent; end
  def self.sysconf(_arg0); end
  def self.sysconfdir; end
  def self.systmpdir; end
  def self.uname; end
end

module FileUtils::DryRun
  include ::FileUtils::StreamUtils_
  include ::FileUtils
  include ::FileUtils::LowMethods
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils
  extend ::FileUtils::LowMethods
  extend ::FileUtils::DryRun
  private def chmod(*args, **options); end
  private def chmod_R(*args, **options); end
  private def chown(*args, **options); end
  private def chown_R(*args, **options); end
  private def copy(*args, **options); end
  private def cp(*args, **options); end
  private def cp_lr(*args, **options); end
  private def cp_r(*args, **options); end
  private def install(*args, **options); end
  private def link(*args, **options); end
  private def ln(*args, **options); end
  private def ln_s(*args, **options); end
  private def ln_sf(*args, **options); end
  private def makedirs(*args, **options); end
  private def mkdir(*args, **options); end
  private def mkdir_p(*args, **options); end
  private def mkpath(*args, **options); end
  private def move(*args, **options); end
  private def mv(*args, **options); end
  private def remove(*args, **options); end
  private def rm(*args, **options); end
  private def rm_f(*args, **options); end
  private def rm_r(*args, **options); end
  private def rm_rf(*args, **options); end
  private def rmdir(*args, **options); end
  private def rmtree(*args, **options); end
  private def safe_unlink(*args, **options); end
  private def symlink(*args, **options); end
  private def touch(*args, **options); end
end

class FileUtils::Entry_
  include ::FileUtils::StreamUtils_
  def initialize(a, b = T.unsafe(nil), deref = T.unsafe(nil)); end
  def blockdev?; end
  def chardev?; end
  def chmod(mode); end
  def chown(uid, gid); end
  def copy(dest); end
  def copy_file(dest); end
  def copy_metadata(path); end
  def dereference?; end
  def directory?; end
  def door?; end
  def entries; end
  def exist?; end
  def file?; end
  def inspect; end
  def link(dest); end
  def lstat; end
  def lstat!; end
  def path; end
  def pipe?; end
  def platform_support; end
  def postorder_traverse; end
  def prefix; end
  def preorder_traverse; end
  def rel; end
  def remove; end
  def remove_dir1; end
  def remove_file; end
  def socket?; end
  def stat; end
  def stat!; end
  def symlink?; end
  def traverse; end
  def wrap_traverse(pre, post); end
  private def check_have_lchmod?; end
  private def check_have_lchown?; end
  private def descendant_directory?(descendant, ascendant); end
  private def have_lchmod?; end
  private def have_lchown?; end
  private def join(dir, base); end
end

FileUtils::LOW_METHODS = T.let(T.unsafe(nil), Array)

module FileUtils::LowMethods
  private def _do_nothing(*_arg0); end
  private def cd(*_arg0); end
  private def chdir(*_arg0); end
  private def cmp(*_arg0); end
  private def collect_method(*_arg0); end
  private def commands(*_arg0); end
  private def compare_file(*_arg0); end
  private def compare_stream(*_arg0); end
  private def copy_entry(*_arg0); end
  private def copy_file(*_arg0); end
  private def copy_stream(*_arg0); end
  private def getwd(*_arg0); end
  private def have_option?(*_arg0); end
  private def identical?(*_arg0); end
  private def link_entry(*_arg0); end
  private def options(*_arg0); end
  private def options_of(*_arg0); end
  private def private_module_function(*_arg0); end
  private def pwd(*_arg0); end
  private def remove_dir(*_arg0); end
  private def remove_entry(*_arg0); end
  private def remove_entry_secure(*_arg0); end
  private def remove_file(*_arg0); end
  private def uptodate?(*_arg0); end
end

FileUtils::METHODS = T.let(T.unsafe(nil), Array)

module FileUtils::NoWrite
  include ::FileUtils::StreamUtils_
  include ::FileUtils
  include ::FileUtils::LowMethods
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils
  extend ::FileUtils::LowMethods
  extend ::FileUtils::NoWrite
  private def chmod(*args, **options); end
  private def chmod_R(*args, **options); end
  private def chown(*args, **options); end
  private def chown_R(*args, **options); end
  private def copy(*args, **options); end
  private def cp(*args, **options); end
  private def cp_lr(*args, **options); end
  private def cp_r(*args, **options); end
  private def install(*args, **options); end
  private def link(*args, **options); end
  private def ln(*args, **options); end
  private def ln_s(*args, **options); end
  private def ln_sf(*args, **options); end
  private def makedirs(*args, **options); end
  private def mkdir(*args, **options); end
  private def mkdir_p(*args, **options); end
  private def mkpath(*args, **options); end
  private def move(*args, **options); end
  private def mv(*args, **options); end
  private def remove(*args, **options); end
  private def rm(*args, **options); end
  private def rm_f(*args, **options); end
  private def rm_r(*args, **options); end
  private def rm_rf(*args, **options); end
  private def rmdir(*args, **options); end
  private def rmtree(*args, **options); end
  private def safe_unlink(*args, **options); end
  private def symlink(*args, **options); end
  private def touch(*args, **options); end
end

FileUtils::OPT_TABLE = T.let(T.unsafe(nil), Hash)

module FileUtils::StreamUtils_
  private def fu_blksize(st); end
  private def fu_copy_stream0(src, dest, blksize = T.unsafe(nil)); end
  private def fu_default_blksize; end
  private def fu_stream_blksize(*streams); end
  private def fu_windows?; end
end

FileUtils::VERSION = T.let(T.unsafe(nil), String)

module FileUtils::Verbose
  include ::FileUtils::StreamUtils_
  include ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils
  extend ::FileUtils::Verbose
  private def cd(*args, **options); end
  private def chdir(*args, **options); end
  private def chmod(*args, **options); end
  private def chmod_R(*args, **options); end
  private def chown(*args, **options); end
  private def chown_R(*args, **options); end
  private def copy(*args, **options); end
  private def cp(*args, **options); end
  private def cp_lr(*args, **options); end
  private def cp_r(*args, **options); end
  private def install(*args, **options); end
  private def link(*args, **options); end
  private def ln(*args, **options); end
  private def ln_s(*args, **options); end
  private def ln_sf(*args, **options); end
  private def makedirs(*args, **options); end
  private def mkdir(*args, **options); end
  private def mkdir_p(*args, **options); end
  private def mkpath(*args, **options); end
  private def move(*args, **options); end
  private def mv(*args, **options); end
  private def remove(*args, **options); end
  private def rm(*args, **options); end
  private def rm_f(*args, **options); end
  private def rm_r(*args, **options); end
  private def rm_rf(*args, **options); end
  private def rmdir(*args, **options); end
  private def rmtree(*args, **options); end
  private def safe_unlink(*args, **options); end
  private def symlink(*args, **options); end
  private def touch(*args, **options); end
end

class Tempfile::Remover
  def initialize(tmpfile); end
  def call(*args); end
end

class BasicObject
  def initialize; end
  def !; end
  def !=(_arg0); end
  def ==(_arg0); end
  def __id__; end
  def __send__(*_arg0); end
  def equal?(_arg0); end
  def instance_eval(*_arg0); end
  def instance_exec(*_arg0); end
  private def method_missing(*_arg0); end
  private def singleton_method_added(_arg0); end
  private def singleton_method_removed(_arg0); end
  private def singleton_method_undefined(_arg0); end
end

Delegator::VERSION = T.let(T.unsafe(nil), String)
Etc::CS_PATH = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_ILP32_OFF32_CFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_ILP32_OFF32_LDFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_ILP32_OFF32_LIBS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_ILP32_OFFBIG_LIBS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_LP64_OFF64_CFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_LP64_OFF64_LDFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_LP64_OFF64_LIBS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_LPBIG_OFFBIG_LIBS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_WIDTH_RESTRICTED_ENVS = T.let(T.unsafe(nil), Integer)

class Etc::Group < ::Struct
  extend ::Enumerable
  def gid; end
  def gid=(_); end
  def mem; end
  def mem=(_); end
  def name; end
  def name=(_); end
  def passwd; end
  def passwd=(_); end
  def self.[](*_arg0); end
  def self.each; end
  def self.inspect; end
  def self.members; end
  def self.new(*_arg0); end
end

Etc::PC_2_SYMLINKS = T.let(T.unsafe(nil), Integer)
Etc::PC_ALLOC_SIZE_MIN = T.let(T.unsafe(nil), Integer)
Etc::PC_ASYNC_IO = T.let(T.unsafe(nil), Integer)
Etc::PC_CHOWN_RESTRICTED = T.let(T.unsafe(nil), Integer)
Etc::PC_FILESIZEBITS = T.let(T.unsafe(nil), Integer)
Etc::PC_LINK_MAX = T.let(T.unsafe(nil), Integer)
Etc::PC_MAX_CANON = T.let(T.unsafe(nil), Integer)
Etc::PC_MAX_INPUT = T.let(T.unsafe(nil), Integer)
Etc::PC_NAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::PC_NO_TRUNC = T.let(T.unsafe(nil), Integer)
Etc::PC_PATH_MAX = T.let(T.unsafe(nil), Integer)
Etc::PC_PIPE_BUF = T.let(T.unsafe(nil), Integer)
Etc::PC_PRIO_IO = T.let(T.unsafe(nil), Integer)
Etc::PC_REC_INCR_XFER_SIZE = T.let(T.unsafe(nil), Integer)
Etc::PC_REC_MAX_XFER_SIZE = T.let(T.unsafe(nil), Integer)
Etc::PC_REC_MIN_XFER_SIZE = T.let(T.unsafe(nil), Integer)
Etc::PC_REC_XFER_ALIGN = T.let(T.unsafe(nil), Integer)
Etc::PC_SYMLINK_MAX = T.let(T.unsafe(nil), Integer)
Etc::PC_SYNC_IO = T.let(T.unsafe(nil), Integer)
Etc::PC_VDISABLE = T.let(T.unsafe(nil), Integer)

class Etc::Passwd < ::Struct
  extend ::Enumerable
  def change; end
  def change=(_); end
  def dir; end
  def dir=(_); end
  def expire; end
  def expire=(_); end
  def gecos; end
  def gecos=(_); end
  def gid; end
  def gid=(_); end
  def name; end
  def name=(_); end
  def passwd; end
  def passwd=(_); end
  def shell; end
  def shell=(_); end
  def uclass; end
  def uclass=(_); end
  def uid; end
  def uid=(_); end
  def self.[](*_arg0); end
  def self.each; end
  def self.inspect; end
  def self.members; end
  def self.new(*_arg0); end
end

Etc::SC_2_CHAR_TERM = T.let(T.unsafe(nil), Integer)
Etc::SC_2_C_BIND = T.let(T.unsafe(nil), Integer)
Etc::SC_2_C_DEV = T.let(T.unsafe(nil), Integer)
Etc::SC_2_FORT_DEV = T.let(T.unsafe(nil), Integer)
Etc::SC_2_FORT_RUN = T.let(T.unsafe(nil), Integer)
Etc::SC_2_LOCALEDEF = T.let(T.unsafe(nil), Integer)
Etc::SC_2_PBS = T.let(T.unsafe(nil), Integer)
Etc::SC_2_PBS_ACCOUNTING = T.let(T.unsafe(nil), Integer)
Etc::SC_2_PBS_CHECKPOINT = T.let(T.unsafe(nil), Integer)
Etc::SC_2_PBS_LOCATE = T.let(T.unsafe(nil), Integer)
Etc::SC_2_PBS_MESSAGE = T.let(T.unsafe(nil), Integer)
Etc::SC_2_PBS_TRACK = T.let(T.unsafe(nil), Integer)
Etc::SC_2_SW_DEV = T.let(T.unsafe(nil), Integer)
Etc::SC_2_UPE = T.let(T.unsafe(nil), Integer)
Etc::SC_2_VERSION = T.let(T.unsafe(nil), Integer)
Etc::SC_ADVISORY_INFO = T.let(T.unsafe(nil), Integer)
Etc::SC_AIO_LISTIO_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_AIO_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_AIO_PRIO_DELTA_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_ARG_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_ASYNCHRONOUS_IO = T.let(T.unsafe(nil), Integer)
Etc::SC_ATEXIT_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_BARRIERS = T.let(T.unsafe(nil), Integer)
Etc::SC_BC_BASE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_BC_DIM_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_BC_SCALE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_BC_STRING_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_CHILD_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_CLK_TCK = T.let(T.unsafe(nil), Integer)
Etc::SC_CLOCK_SELECTION = T.let(T.unsafe(nil), Integer)
Etc::SC_COLL_WEIGHTS_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_CPUTIME = T.let(T.unsafe(nil), Integer)
Etc::SC_DELAYTIMER_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_EXPR_NEST_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_FSYNC = T.let(T.unsafe(nil), Integer)
Etc::SC_GETGR_R_SIZE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_GETPW_R_SIZE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_HOST_NAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_IOV_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_IPV6 = T.let(T.unsafe(nil), Integer)
Etc::SC_JOB_CONTROL = T.let(T.unsafe(nil), Integer)
Etc::SC_LINE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_LOGIN_NAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_MAPPED_FILES = T.let(T.unsafe(nil), Integer)
Etc::SC_MEMLOCK = T.let(T.unsafe(nil), Integer)
Etc::SC_MEMLOCK_RANGE = T.let(T.unsafe(nil), Integer)
Etc::SC_MEMORY_PROTECTION = T.let(T.unsafe(nil), Integer)
Etc::SC_MESSAGE_PASSING = T.let(T.unsafe(nil), Integer)
Etc::SC_MONOTONIC_CLOCK = T.let(T.unsafe(nil), Integer)
Etc::SC_MQ_OPEN_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_MQ_PRIO_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_NGROUPS_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_NPROCESSORS_CONF = T.let(T.unsafe(nil), Integer)
Etc::SC_NPROCESSORS_ONLN = T.let(T.unsafe(nil), Integer)
Etc::SC_OPEN_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_PAGESIZE = T.let(T.unsafe(nil), Integer)
Etc::SC_PAGE_SIZE = T.let(T.unsafe(nil), Integer)
Etc::SC_PHYS_PAGES = T.let(T.unsafe(nil), Integer)
Etc::SC_PRIORITIZED_IO = T.let(T.unsafe(nil), Integer)
Etc::SC_PRIORITY_SCHEDULING = T.let(T.unsafe(nil), Integer)
Etc::SC_RAW_SOCKETS = T.let(T.unsafe(nil), Integer)
Etc::SC_READER_WRITER_LOCKS = T.let(T.unsafe(nil), Integer)
Etc::SC_REALTIME_SIGNALS = T.let(T.unsafe(nil), Integer)
Etc::SC_REGEXP = T.let(T.unsafe(nil), Integer)
Etc::SC_RE_DUP_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_RTSIG_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_SAVED_IDS = T.let(T.unsafe(nil), Integer)
Etc::SC_SEMAPHORES = T.let(T.unsafe(nil), Integer)
Etc::SC_SEM_NSEMS_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_SEM_VALUE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_SHARED_MEMORY_OBJECTS = T.let(T.unsafe(nil), Integer)
Etc::SC_SHELL = T.let(T.unsafe(nil), Integer)
Etc::SC_SIGQUEUE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_SPAWN = T.let(T.unsafe(nil), Integer)
Etc::SC_SPIN_LOCKS = T.let(T.unsafe(nil), Integer)
Etc::SC_SPORADIC_SERVER = T.let(T.unsafe(nil), Integer)
Etc::SC_SS_REPL_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_STREAM_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_SYMLOOP_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_SYNCHRONIZED_IO = T.let(T.unsafe(nil), Integer)
Etc::SC_THREADS = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_ATTR_STACKADDR = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_ATTR_STACKSIZE = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_CPUTIME = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_DESTRUCTOR_ITERATIONS = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_KEYS_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_PRIORITY_SCHEDULING = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_PRIO_INHERIT = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_PRIO_PROTECT = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_PROCESS_SHARED = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_SAFE_FUNCTIONS = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_SPORADIC_SERVER = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_STACK_MIN = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_THREADS_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TIMEOUTS = T.let(T.unsafe(nil), Integer)
Etc::SC_TIMERS = T.let(T.unsafe(nil), Integer)
Etc::SC_TIMER_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_EVENT_FILTER = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_EVENT_NAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_INHERIT = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_LOG = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_NAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_SYS_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_USER_EVENT_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TTY_NAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TYPED_MEMORY_OBJECTS = T.let(T.unsafe(nil), Integer)
Etc::SC_TZNAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_V6_ILP32_OFF32 = T.let(T.unsafe(nil), Integer)
Etc::SC_V6_ILP32_OFFBIG = T.let(T.unsafe(nil), Integer)
Etc::SC_V6_LP64_OFF64 = T.let(T.unsafe(nil), Integer)
Etc::SC_V6_LPBIG_OFFBIG = T.let(T.unsafe(nil), Integer)
Etc::SC_VERSION = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_CRYPT = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_ENH_I18N = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_REALTIME = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_REALTIME_THREADS = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_SHM = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_STREAMS = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_UNIX = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_VERSION = T.let(T.unsafe(nil), Integer)
Etc::VERSION = T.let(T.unsafe(nil), String)
FileUtils::Entry_::DIRECTORY_TERM = T.let(T.unsafe(nil), String)
FileUtils::Entry_::S_IF_DOOR = T.let(T.unsafe(nil), Integer)

class Struct
  include ::Enumerable
  def initialize(*_arg0); end
  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def deconstruct; end
  def deconstruct_keys(_arg0); end
  def dig(*_arg0); end
  def each; end
  def each_pair; end
  def eql?(_arg0); end
  def filter(*_arg0); end
  def hash; end
  def inspect; end
  def length; end
  def members; end
  def pretty_print(q); end
  def pretty_print_cycle(q); end
  def select(*_arg0); end
  def size; end
  def to_a; end
  def to_h; end
  def to_s; end
  def values; end
  def values_at(*_arg0); end
  private def initialize_copy(_arg0); end
  def self.new(*_arg0); end
end

module Enumerable
  def all?(*_arg0); end
  def any?(*_arg0); end
  def chain(*_arg0); end
  def chunk; end
  def chunk_while; end
  def collect; end
  def collect_concat; end
  def count(*_arg0); end
  def cycle(*_arg0); end
  def detect(*_arg0); end
  def drop(_arg0); end
  def drop_while; end
  def each_cons(_arg0); end
  def each_entry(*_arg0); end
  def each_slice(_arg0); end
  def each_with_index(*_arg0); end
  def each_with_object(_arg0); end
  def entries(*_arg0); end
  def filter; end
  def filter_map; end
  def find(*_arg0); end
  def find_all; end
  def find_index(*_arg0); end
  def first(*_arg0); end
  def flat_map; end
  def grep(_arg0); end
  def grep_v(_arg0); end
  def group_by; end
  def include?(_arg0); end
  def inject(*_arg0); end
  def lazy; end
  def map; end
  def max(*_arg0); end
  def max_by(*_arg0); end
  def member?(_arg0); end
  def min(*_arg0); end
  def min_by(*_arg0); end
  def minmax; end
  def minmax_by; end
  def none?(*_arg0); end
  def one?(*_arg0); end
  def partition; end
  def reduce(*_arg0); end
  def reject; end
  def reverse_each(*_arg0); end
  def select; end
  def slice_after(*_arg0); end
  def slice_before(*_arg0); end
  def slice_when; end
  def sort; end
  def sort_by; end
  def sum(*_arg0); end
  def take(_arg0); end
  def take_while; end
  def tally; end
  def to_a(*_arg0); end
  def to_h(*_arg0); end
  def to_set(klass = T.unsafe(nil), *args, &block); end
  def uniq; end
  def zip(*_arg0); end
end

Struct::Group = Etc::Group
Struct::Passwd = Etc::Passwd
class DateTime < ::Date
  def hour; end
  def iso8601(*_arg0); end
  def jisx0301(*_arg0); end
  def min; end
  def minute; end
  def new_offset(*_arg0); end
  def offset; end
  def rfc3339(*_arg0); end
  def sec; end
  def sec_fraction; end
  def second; end
  def second_fraction; end
  def strftime(*_arg0); end
  def to_date; end
  def to_datetime; end
  def to_s; end
  def to_time; end
  def xmlschema(*_arg0); end
  def zone; end
  def self._strptime(*_arg0); end
  def self.civil(*_arg0); end
  def self.commercial(*_arg0); end
  def self.httpdate(*_arg0); end
  def self.iso8601(*_arg0); end
  def self.jd(*_arg0); end
  def self.jisx0301(*_arg0); end
  def self.new(*_arg0); end
  def self.now(*_arg0); end
  def self.ordinal(*_arg0); end
  def self.parse(*_arg0); end
  def self.rfc2822(*_arg0); end
  def self.rfc3339(*_arg0); end
  def self.rfc822(*_arg0); end
  def self.strptime(*_arg0); end
  def self.xmlschema(*_arg0); end
end

class Date
  include ::Comparable
  def initialize(*_arg0); end
  def +(_arg0); end
  def -(_arg0); end
  def <<(_arg0); end
  def <=>(_arg0); end
  def ===(_arg0); end
  def >>(_arg0); end
  def ajd; end
  def amjd; end
  def asctime; end
  def ctime; end
  def cwday; end
  def cweek; end
  def cwyear; end
  def day; end
  def day_fraction; end
  def downto(_arg0); end
  def england; end
  def eql?(_arg0); end
  def friday?; end
  def gregorian; end
  def gregorian?; end
  def hash; end
  def httpdate; end
  def infinite?; end
  def inspect; end
  def iso8601; end
  def italy; end
  def jd; end
  def jisx0301; end
  def julian; end
  def julian?; end
  def ld; end
  def leap?; end
  def marshal_dump; end
  def marshal_load(_arg0); end
  def mday; end
  def mjd; end
  def mon; end
  def monday?; end
  def month; end
  def new_start(*_arg0); end
  def next; end
  def next_day(*_arg0); end
  def next_month(*_arg0); end
  def next_year(*_arg0); end
  def prev_day(*_arg0); end
  def prev_month(*_arg0); end
  def prev_year(*_arg0); end
  def rfc2822; end
  def rfc3339; end
  def rfc822; end
  def saturday?; end
  def start; end
  def step(*_arg0); end
  def strftime(*_arg0); end
  def succ; end
  def sunday?; end
  def thursday?; end
  def to_date; end
  def to_datetime; end
  def to_s; end
  def to_time; end
  def tuesday?; end
  def upto(_arg0); end
  def wday; end
  def wednesday?; end
  def xmlschema; end
  def yday; end
  def year; end
  private def hour; end
  private def initialize_copy(_arg0); end
  private def min; end
  private def minute; end
  private def sec; end
  private def second; end
  def self._httpdate(_arg0); end
  def self._iso8601(_arg0); end
  def self._jisx0301(_arg0); end
  def self._load(_arg0); end
  def self._parse(*_arg0); end
  def self._rfc2822(_arg0); end
  def self._rfc3339(_arg0); end
  def self._rfc822(_arg0); end
  def self._strptime(*_arg0); end
  def self._xmlschema(_arg0); end
  def self.civil(*_arg0); end
  def self.commercial(*_arg0); end
  def self.gregorian_leap?(_arg0); end
  def self.httpdate(*_arg0); end
  def self.iso8601(*_arg0); end
  def self.jd(*_arg0); end
  def self.jisx0301(*_arg0); end
  def self.julian_leap?(_arg0); end
  def self.leap?(_arg0); end
  def self.ordinal(*_arg0); end
  def self.parse(*_arg0); end
  def self.rfc2822(*_arg0); end
  def self.rfc3339(*_arg0); end
  def self.rfc822(*_arg0); end
  def self.strptime(*_arg0); end
  def self.today(*_arg0); end
  def self.valid_civil?(*_arg0); end
  def self.valid_commercial?(*_arg0); end
  def self.valid_date?(*_arg0); end
  def self.valid_jd?(*_arg0); end
  def self.valid_ordinal?(*_arg0); end
  def self.xmlschema(*_arg0); end
end

Date::ABBR_DAYNAMES = T.let(T.unsafe(nil), Array)
Date::ABBR_MONTHNAMES = T.let(T.unsafe(nil), Array)
Date::DAYNAMES = T.let(T.unsafe(nil), Array)
Date::ENGLAND = T.let(T.unsafe(nil), Integer)
class Date::Error < ::ArgumentError; end
Date::GREGORIAN = T.let(T.unsafe(nil), Float)
Date::ITALY = T.let(T.unsafe(nil), Integer)

class Date::Infinity < ::Numeric
  def initialize(d = T.unsafe(nil)); end
  def +@; end
  def -@; end
  def <=>(other); end
  def abs; end
  def coerce(other); end
  def finite?; end
  def infinite?; end
  def nan?; end
  def to_f; end
  def zero?; end
  protected def d; end
end

Date::JULIAN = T.let(T.unsafe(nil), Float)
Date::MONTHNAMES = T.let(T.unsafe(nil), Array)

module Comparable
  def <(_arg0); end
  def <=(_arg0); end
  def ==(_arg0); end
  def >(_arg0); end
  def >=(_arg0); end
  def between?(_arg0, _arg1); end
  def clamp(*_arg0); end
end

class ArgumentError < ::StandardError; end

class Numeric
  include ::Comparable
  def %(_arg0); end
  def +@; end
  def -@; end
  def <=>(_arg0); end
  def abs; end
  def abs2; end
  def angle; end
  def arg; end
  def ceil(*_arg0); end
  def clone(*_arg0); end
  def coerce(_arg0); end
  def conj; end
  def conjugate; end
  def denominator; end
  def div(_arg0); end
  def divmod(_arg0); end
  def dup; end
  def eql?(_arg0); end
  def fdiv(_arg0); end
  def finite?; end
  def floor(*_arg0); end
  def i; end
  def imag; end
  def imaginary; end
  def infinite?; end
  def integer?; end
  def magnitude; end
  def modulo(_arg0); end
  def negative?; end
  def nonzero?; end
  def numerator; end
  def phase; end
  def polar; end
  def positive?; end
  def pretty_print(q); end
  def pretty_print_cycle(q); end
  def quo(_arg0); end
  def real; end
  def real?; end
  def rect; end
  def rectangular; end
  def remainder(_arg0); end
  def round(*_arg0); end
  def singleton_method_added(_arg0); end
  def step(*_arg0); end
  def to_c; end
  def to_int; end
  def truncate(*_arg0); end
  def zero?; end
end

class StandardError < ::Exception; end

class Exception
  def initialize(*_arg0); end
  def ==(_arg0); end
  def backtrace; end
  def backtrace_locations; end
  def cause; end
  def exception(*_arg0); end
  def full_message(*_arg0); end
  def inspect; end
  def message; end
  def respond_to?(*_arg0); end
  def set_backtrace(_arg0); end
  def to_s; end
  private def method_missing(*_arg0); end
  private def respond_to_missing?(_arg0, _arg1); end
  def self.exception(*_arg0); end
  def self.to_tty?; end
end
module Timeout
  private def timeout(sec, klass = T.unsafe(nil), message = T.unsafe(nil), &block); end
  def self.timeout(sec, klass = T.unsafe(nil), message = T.unsafe(nil), &block); end
end

class Timeout::Error < ::RuntimeError
  def exception(*_arg0); end
  def thread; end
  def self.catch(*args); end
end

Timeout::VERSION = T.let(T.unsafe(nil), String)
class RuntimeError < ::StandardError; end
class StandardError < ::Exception; end

class Exception
  def initialize(*_arg0); end
  def ==(_arg0); end
  def backtrace; end
  def backtrace_locations; end
  def cause; end
  def exception(*_arg0); end
  def full_message(*_arg0); end
  def inspect; end
  def message; end
  def respond_to?(*_arg0); end
  def set_backtrace(_arg0); end
  def to_s; end
  private def method_missing(*_arg0); end
  private def respond_to_missing?(_arg0, _arg1); end
  def self.exception(*_arg0); end
  def self.to_tty?; end
end
module FileUtils
  include ::FileUtils::StreamUtils_
  extend ::FileUtils::StreamUtils_
  private def apply_mask(mode, user_mask, op, mode_mask); end
  private def cd(dir, verbose: T.unsafe(nil), &block); end
  private def chdir(dir, verbose: T.unsafe(nil), &block); end
  private def chmod(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def chmod_R(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end
  private def chown(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def chown_R(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end
  private def cmp(a, b); end
  private def compare_file(a, b); end
  private def compare_stream(a, b); end
  private def copy(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def copy_entry(src, dest, preserve = T.unsafe(nil), dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end
  private def copy_file(src, dest, preserve = T.unsafe(nil), dereference = T.unsafe(nil)); end
  private def copy_stream(src, dest); end
  private def cp(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end
  private def cp_r(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end
  private def fu_each_src_dest(src, dest); end
  private def fu_each_src_dest0(src, dest); end
  private def fu_get_gid(group); end
  private def fu_get_uid(user); end
  private def fu_have_symlink?; end
  private def fu_list(arg); end
  private def fu_mkdir(path, mode); end
  private def fu_mode(mode, path); end
  private def fu_output_message(msg); end
  private def fu_same?(a, b); end
  private def fu_stat_identical_entry?(a, b); end
  private def getwd; end
  private def identical?(a, b); end
  private def install(src, dest, mode: T.unsafe(nil), owner: T.unsafe(nil), group: T.unsafe(nil), preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def link(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def link_entry(src, dest, dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end
  private def ln(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def ln_s(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def ln_sf(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def makedirs(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def mkdir(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def mkdir_p(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def mkpath(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def mode_to_s(mode); end
  private def move(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def mv(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def pwd; end
  private def remove(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def remove_dir(path, force = T.unsafe(nil)); end
  private def remove_entry(path, force = T.unsafe(nil)); end
  private def remove_entry_secure(path, force = T.unsafe(nil)); end
  private def remove_file(path, force = T.unsafe(nil)); end
  private def remove_trailing_slash(dir); end
  private def rm(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def rm_f(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def rm_r(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def rm_rf(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def rmdir(list, parents: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def rmtree(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def safe_unlink(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def symbolic_modes_to_i(mode_sym, path); end
  private def symlink(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def touch(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), mtime: T.unsafe(nil), nocreate: T.unsafe(nil)); end
  private def uptodate?(new, old_list); end
  private def user_mask(target); end
  def self.cd(dir, verbose: T.unsafe(nil), &block); end
  def self.chdir(dir, verbose: T.unsafe(nil), &block); end
  def self.chmod(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.chmod_R(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end
  def self.chown(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.chown_R(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end
  def self.cmp(a, b); end
  def self.collect_method(opt); end
  def self.commands; end
  def self.compare_file(a, b); end
  def self.compare_stream(a, b); end
  def self.copy(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.copy_entry(src, dest, preserve = T.unsafe(nil), dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end
  def self.copy_file(src, dest, preserve = T.unsafe(nil), dereference = T.unsafe(nil)); end
  def self.copy_stream(src, dest); end
  def self.cp(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end
  def self.cp_r(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end
  def self.getwd; end
  def self.have_option?(mid, opt); end
  def self.identical?(a, b); end
  def self.install(src, dest, mode: T.unsafe(nil), owner: T.unsafe(nil), group: T.unsafe(nil), preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.link(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.link_entry(src, dest, dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end
  def self.ln(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.ln_s(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.ln_sf(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.makedirs(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.mkdir(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.mkdir_p(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.mkpath(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.move(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.mv(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.options; end
  def self.options_of(mid); end
  def self.private_module_function(name); end
  def self.pwd; end
  def self.remove(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.remove_dir(path, force = T.unsafe(nil)); end
  def self.remove_entry(path, force = T.unsafe(nil)); end
  def self.remove_entry_secure(path, force = T.unsafe(nil)); end
  def self.remove_file(path, force = T.unsafe(nil)); end
  def self.rm(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.rm_f(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.rm_r(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.rm_rf(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.rmdir(list, parents: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.rmtree(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.safe_unlink(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.symlink(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.touch(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), mtime: T.unsafe(nil), nocreate: T.unsafe(nil)); end
  def self.uptodate?(new, old_list); end
  private def self.apply_mask(mode, user_mask, op, mode_mask); end
  private def self.fu_each_src_dest(src, dest); end
  private def self.fu_each_src_dest0(src, dest); end
  private def self.fu_get_gid(group); end
  private def self.fu_get_uid(user); end
  private def self.fu_have_symlink?; end
  private def self.fu_list(arg); end
  private def self.fu_mkdir(path, mode); end
  private def self.fu_mode(mode, path); end
  private def self.fu_output_message(msg); end
  private def self.fu_same?(a, b); end
  private def self.fu_stat_identical_entry?(a, b); end
  private def self.mode_to_s(mode); end
  private def self.remove_trailing_slash(dir); end
  private def self.symbolic_modes_to_i(mode_sym, path); end
  private def self.user_mask(target); end
end

module Etc
  private def confstr(_arg0); end
  private def endgrent; end
  private def endpwent; end
  private def getgrent; end
  private def getgrgid(*_arg0); end
  private def getgrnam(_arg0); end
  private def getlogin; end
  private def getpwent; end
  private def getpwnam(_arg0); end
  private def getpwuid(*_arg0); end
  private def group; end
  private def nprocessors; end
  private def passwd; end
  private def setgrent; end
  private def setpwent; end
  private def sysconf(_arg0); end
  private def sysconfdir; end
  private def systmpdir; end
  private def uname; end
  def self.confstr(_arg0); end
  def self.endgrent; end
  def self.endpwent; end
  def self.getgrent; end
  def self.getgrgid(*_arg0); end
  def self.getgrnam(_arg0); end
  def self.getlogin; end
  def self.getpwent; end
  def self.getpwnam(_arg0); end
  def self.getpwuid(*_arg0); end
  def self.group; end
  def self.nprocessors; end
  def self.passwd; end
  def self.setgrent; end
  def self.setpwent; end
  def self.sysconf(_arg0); end
  def self.sysconfdir; end
  def self.systmpdir; end
  def self.uname; end
end

module FileUtils::DryRun
  include ::FileUtils::StreamUtils_
  include ::FileUtils
  include ::FileUtils::LowMethods
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils
  extend ::FileUtils::LowMethods
  extend ::FileUtils::DryRun
  private def chmod(*args, **options); end
  private def chmod_R(*args, **options); end
  private def chown(*args, **options); end
  private def chown_R(*args, **options); end
  private def copy(*args, **options); end
  private def cp(*args, **options); end
  private def cp_lr(*args, **options); end
  private def cp_r(*args, **options); end
  private def install(*args, **options); end
  private def link(*args, **options); end
  private def ln(*args, **options); end
  private def ln_s(*args, **options); end
  private def ln_sf(*args, **options); end
  private def makedirs(*args, **options); end
  private def mkdir(*args, **options); end
  private def mkdir_p(*args, **options); end
  private def mkpath(*args, **options); end
  private def move(*args, **options); end
  private def mv(*args, **options); end
  private def remove(*args, **options); end
  private def rm(*args, **options); end
  private def rm_f(*args, **options); end
  private def rm_r(*args, **options); end
  private def rm_rf(*args, **options); end
  private def rmdir(*args, **options); end
  private def rmtree(*args, **options); end
  private def safe_unlink(*args, **options); end
  private def symlink(*args, **options); end
  private def touch(*args, **options); end
end

class FileUtils::Entry_
  include ::FileUtils::StreamUtils_
  def initialize(a, b = T.unsafe(nil), deref = T.unsafe(nil)); end
  def blockdev?; end
  def chardev?; end
  def chmod(mode); end
  def chown(uid, gid); end
  def copy(dest); end
  def copy_file(dest); end
  def copy_metadata(path); end
  def dereference?; end
  def directory?; end
  def door?; end
  def entries; end
  def exist?; end
  def file?; end
  def inspect; end
  def link(dest); end
  def lstat; end
  def lstat!; end
  def path; end
  def pipe?; end
  def platform_support; end
  def postorder_traverse; end
  def prefix; end
  def preorder_traverse; end
  def rel; end
  def remove; end
  def remove_dir1; end
  def remove_file; end
  def socket?; end
  def stat; end
  def stat!; end
  def symlink?; end
  def traverse; end
  def wrap_traverse(pre, post); end
  private def check_have_lchmod?; end
  private def check_have_lchown?; end
  private def descendant_directory?(descendant, ascendant); end
  private def have_lchmod?; end
  private def have_lchown?; end
  private def join(dir, base); end
end

FileUtils::LOW_METHODS = T.let(T.unsafe(nil), Array)

module FileUtils::LowMethods
  private def _do_nothing(*_arg0); end
  private def cd(*_arg0); end
  private def chdir(*_arg0); end
  private def cmp(*_arg0); end
  private def collect_method(*_arg0); end
  private def commands(*_arg0); end
  private def compare_file(*_arg0); end
  private def compare_stream(*_arg0); end
  private def copy_entry(*_arg0); end
  private def copy_file(*_arg0); end
  private def copy_stream(*_arg0); end
  private def getwd(*_arg0); end
  private def have_option?(*_arg0); end
  private def identical?(*_arg0); end
  private def link_entry(*_arg0); end
  private def options(*_arg0); end
  private def options_of(*_arg0); end
  private def private_module_function(*_arg0); end
  private def pwd(*_arg0); end
  private def remove_dir(*_arg0); end
  private def remove_entry(*_arg0); end
  private def remove_entry_secure(*_arg0); end
  private def remove_file(*_arg0); end
  private def uptodate?(*_arg0); end
end

FileUtils::METHODS = T.let(T.unsafe(nil), Array)

module FileUtils::NoWrite
  include ::FileUtils::StreamUtils_
  include ::FileUtils
  include ::FileUtils::LowMethods
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils
  extend ::FileUtils::LowMethods
  extend ::FileUtils::NoWrite
  private def chmod(*args, **options); end
  private def chmod_R(*args, **options); end
  private def chown(*args, **options); end
  private def chown_R(*args, **options); end
  private def copy(*args, **options); end
  private def cp(*args, **options); end
  private def cp_lr(*args, **options); end
  private def cp_r(*args, **options); end
  private def install(*args, **options); end
  private def link(*args, **options); end
  private def ln(*args, **options); end
  private def ln_s(*args, **options); end
  private def ln_sf(*args, **options); end
  private def makedirs(*args, **options); end
  private def mkdir(*args, **options); end
  private def mkdir_p(*args, **options); end
  private def mkpath(*args, **options); end
  private def move(*args, **options); end
  private def mv(*args, **options); end
  private def remove(*args, **options); end
  private def rm(*args, **options); end
  private def rm_f(*args, **options); end
  private def rm_r(*args, **options); end
  private def rm_rf(*args, **options); end
  private def rmdir(*args, **options); end
  private def rmtree(*args, **options); end
  private def safe_unlink(*args, **options); end
  private def symlink(*args, **options); end
  private def touch(*args, **options); end
end

FileUtils::OPT_TABLE = T.let(T.unsafe(nil), Hash)

module FileUtils::StreamUtils_
  private def fu_blksize(st); end
  private def fu_copy_stream0(src, dest, blksize = T.unsafe(nil)); end
  private def fu_default_blksize; end
  private def fu_stream_blksize(*streams); end
  private def fu_windows?; end
end

FileUtils::VERSION = T.let(T.unsafe(nil), String)

module FileUtils::Verbose
  include ::FileUtils::StreamUtils_
  include ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils
  extend ::FileUtils::Verbose
  private def cd(*args, **options); end
  private def chdir(*args, **options); end
  private def chmod(*args, **options); end
  private def chmod_R(*args, **options); end
  private def chown(*args, **options); end
  private def chown_R(*args, **options); end
  private def copy(*args, **options); end
  private def cp(*args, **options); end
  private def cp_lr(*args, **options); end
  private def cp_r(*args, **options); end
  private def install(*args, **options); end
  private def link(*args, **options); end
  private def ln(*args, **options); end
  private def ln_s(*args, **options); end
  private def ln_sf(*args, **options); end
  private def makedirs(*args, **options); end
  private def mkdir(*args, **options); end
  private def mkdir_p(*args, **options); end
  private def mkpath(*args, **options); end
  private def move(*args, **options); end
  private def mv(*args, **options); end
  private def remove(*args, **options); end
  private def rm(*args, **options); end
  private def rm_f(*args, **options); end
  private def rm_r(*args, **options); end
  private def rm_rf(*args, **options); end
  private def rmdir(*args, **options); end
  private def rmtree(*args, **options); end
  private def safe_unlink(*args, **options); end
  private def symlink(*args, **options); end
  private def touch(*args, **options); end
end

Etc::CS_PATH = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_ILP32_OFF32_CFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_ILP32_OFF32_LDFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_ILP32_OFF32_LIBS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_ILP32_OFFBIG_LIBS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_LP64_OFF64_CFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_LP64_OFF64_LDFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_LP64_OFF64_LIBS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_LPBIG_OFFBIG_LIBS = T.let(T.unsafe(nil), Integer)
Etc::CS_POSIX_V6_WIDTH_RESTRICTED_ENVS = T.let(T.unsafe(nil), Integer)

class Etc::Group < ::Struct
  extend ::Enumerable
  def gid; end
  def gid=(_); end
  def mem; end
  def mem=(_); end
  def name; end
  def name=(_); end
  def passwd; end
  def passwd=(_); end
  def self.[](*_arg0); end
  def self.each; end
  def self.inspect; end
  def self.members; end
  def self.new(*_arg0); end
end

Etc::PC_2_SYMLINKS = T.let(T.unsafe(nil), Integer)
Etc::PC_ALLOC_SIZE_MIN = T.let(T.unsafe(nil), Integer)
Etc::PC_ASYNC_IO = T.let(T.unsafe(nil), Integer)
Etc::PC_CHOWN_RESTRICTED = T.let(T.unsafe(nil), Integer)
Etc::PC_FILESIZEBITS = T.let(T.unsafe(nil), Integer)
Etc::PC_LINK_MAX = T.let(T.unsafe(nil), Integer)
Etc::PC_MAX_CANON = T.let(T.unsafe(nil), Integer)
Etc::PC_MAX_INPUT = T.let(T.unsafe(nil), Integer)
Etc::PC_NAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::PC_NO_TRUNC = T.let(T.unsafe(nil), Integer)
Etc::PC_PATH_MAX = T.let(T.unsafe(nil), Integer)
Etc::PC_PIPE_BUF = T.let(T.unsafe(nil), Integer)
Etc::PC_PRIO_IO = T.let(T.unsafe(nil), Integer)
Etc::PC_REC_INCR_XFER_SIZE = T.let(T.unsafe(nil), Integer)
Etc::PC_REC_MAX_XFER_SIZE = T.let(T.unsafe(nil), Integer)
Etc::PC_REC_MIN_XFER_SIZE = T.let(T.unsafe(nil), Integer)
Etc::PC_REC_XFER_ALIGN = T.let(T.unsafe(nil), Integer)
Etc::PC_SYMLINK_MAX = T.let(T.unsafe(nil), Integer)
Etc::PC_SYNC_IO = T.let(T.unsafe(nil), Integer)
Etc::PC_VDISABLE = T.let(T.unsafe(nil), Integer)

class Etc::Passwd < ::Struct
  extend ::Enumerable
  def change; end
  def change=(_); end
  def dir; end
  def dir=(_); end
  def expire; end
  def expire=(_); end
  def gecos; end
  def gecos=(_); end
  def gid; end
  def gid=(_); end
  def name; end
  def name=(_); end
  def passwd; end
  def passwd=(_); end
  def shell; end
  def shell=(_); end
  def uclass; end
  def uclass=(_); end
  def uid; end
  def uid=(_); end
  def self.[](*_arg0); end
  def self.each; end
  def self.inspect; end
  def self.members; end
  def self.new(*_arg0); end
end

Etc::SC_2_CHAR_TERM = T.let(T.unsafe(nil), Integer)
Etc::SC_2_C_BIND = T.let(T.unsafe(nil), Integer)
Etc::SC_2_C_DEV = T.let(T.unsafe(nil), Integer)
Etc::SC_2_FORT_DEV = T.let(T.unsafe(nil), Integer)
Etc::SC_2_FORT_RUN = T.let(T.unsafe(nil), Integer)
Etc::SC_2_LOCALEDEF = T.let(T.unsafe(nil), Integer)
Etc::SC_2_PBS = T.let(T.unsafe(nil), Integer)
Etc::SC_2_PBS_ACCOUNTING = T.let(T.unsafe(nil), Integer)
Etc::SC_2_PBS_CHECKPOINT = T.let(T.unsafe(nil), Integer)
Etc::SC_2_PBS_LOCATE = T.let(T.unsafe(nil), Integer)
Etc::SC_2_PBS_MESSAGE = T.let(T.unsafe(nil), Integer)
Etc::SC_2_PBS_TRACK = T.let(T.unsafe(nil), Integer)
Etc::SC_2_SW_DEV = T.let(T.unsafe(nil), Integer)
Etc::SC_2_UPE = T.let(T.unsafe(nil), Integer)
Etc::SC_2_VERSION = T.let(T.unsafe(nil), Integer)
Etc::SC_ADVISORY_INFO = T.let(T.unsafe(nil), Integer)
Etc::SC_AIO_LISTIO_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_AIO_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_AIO_PRIO_DELTA_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_ARG_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_ASYNCHRONOUS_IO = T.let(T.unsafe(nil), Integer)
Etc::SC_ATEXIT_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_BARRIERS = T.let(T.unsafe(nil), Integer)
Etc::SC_BC_BASE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_BC_DIM_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_BC_SCALE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_BC_STRING_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_CHILD_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_CLK_TCK = T.let(T.unsafe(nil), Integer)
Etc::SC_CLOCK_SELECTION = T.let(T.unsafe(nil), Integer)
Etc::SC_COLL_WEIGHTS_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_CPUTIME = T.let(T.unsafe(nil), Integer)
Etc::SC_DELAYTIMER_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_EXPR_NEST_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_FSYNC = T.let(T.unsafe(nil), Integer)
Etc::SC_GETGR_R_SIZE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_GETPW_R_SIZE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_HOST_NAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_IOV_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_IPV6 = T.let(T.unsafe(nil), Integer)
Etc::SC_JOB_CONTROL = T.let(T.unsafe(nil), Integer)
Etc::SC_LINE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_LOGIN_NAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_MAPPED_FILES = T.let(T.unsafe(nil), Integer)
Etc::SC_MEMLOCK = T.let(T.unsafe(nil), Integer)
Etc::SC_MEMLOCK_RANGE = T.let(T.unsafe(nil), Integer)
Etc::SC_MEMORY_PROTECTION = T.let(T.unsafe(nil), Integer)
Etc::SC_MESSAGE_PASSING = T.let(T.unsafe(nil), Integer)
Etc::SC_MONOTONIC_CLOCK = T.let(T.unsafe(nil), Integer)
Etc::SC_MQ_OPEN_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_MQ_PRIO_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_NGROUPS_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_NPROCESSORS_CONF = T.let(T.unsafe(nil), Integer)
Etc::SC_NPROCESSORS_ONLN = T.let(T.unsafe(nil), Integer)
Etc::SC_OPEN_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_PAGESIZE = T.let(T.unsafe(nil), Integer)
Etc::SC_PAGE_SIZE = T.let(T.unsafe(nil), Integer)
Etc::SC_PHYS_PAGES = T.let(T.unsafe(nil), Integer)
Etc::SC_PRIORITIZED_IO = T.let(T.unsafe(nil), Integer)
Etc::SC_PRIORITY_SCHEDULING = T.let(T.unsafe(nil), Integer)
Etc::SC_RAW_SOCKETS = T.let(T.unsafe(nil), Integer)
Etc::SC_READER_WRITER_LOCKS = T.let(T.unsafe(nil), Integer)
Etc::SC_REALTIME_SIGNALS = T.let(T.unsafe(nil), Integer)
Etc::SC_REGEXP = T.let(T.unsafe(nil), Integer)
Etc::SC_RE_DUP_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_RTSIG_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_SAVED_IDS = T.let(T.unsafe(nil), Integer)
Etc::SC_SEMAPHORES = T.let(T.unsafe(nil), Integer)
Etc::SC_SEM_NSEMS_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_SEM_VALUE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_SHARED_MEMORY_OBJECTS = T.let(T.unsafe(nil), Integer)
Etc::SC_SHELL = T.let(T.unsafe(nil), Integer)
Etc::SC_SIGQUEUE_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_SPAWN = T.let(T.unsafe(nil), Integer)
Etc::SC_SPIN_LOCKS = T.let(T.unsafe(nil), Integer)
Etc::SC_SPORADIC_SERVER = T.let(T.unsafe(nil), Integer)
Etc::SC_SS_REPL_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_STREAM_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_SYMLOOP_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_SYNCHRONIZED_IO = T.let(T.unsafe(nil), Integer)
Etc::SC_THREADS = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_ATTR_STACKADDR = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_ATTR_STACKSIZE = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_CPUTIME = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_DESTRUCTOR_ITERATIONS = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_KEYS_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_PRIORITY_SCHEDULING = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_PRIO_INHERIT = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_PRIO_PROTECT = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_PROCESS_SHARED = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_SAFE_FUNCTIONS = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_SPORADIC_SERVER = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_STACK_MIN = T.let(T.unsafe(nil), Integer)
Etc::SC_THREAD_THREADS_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TIMEOUTS = T.let(T.unsafe(nil), Integer)
Etc::SC_TIMERS = T.let(T.unsafe(nil), Integer)
Etc::SC_TIMER_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_EVENT_FILTER = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_EVENT_NAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_INHERIT = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_LOG = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_NAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_SYS_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TRACE_USER_EVENT_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TTY_NAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_TYPED_MEMORY_OBJECTS = T.let(T.unsafe(nil), Integer)
Etc::SC_TZNAME_MAX = T.let(T.unsafe(nil), Integer)
Etc::SC_V6_ILP32_OFF32 = T.let(T.unsafe(nil), Integer)
Etc::SC_V6_ILP32_OFFBIG = T.let(T.unsafe(nil), Integer)
Etc::SC_V6_LP64_OFF64 = T.let(T.unsafe(nil), Integer)
Etc::SC_V6_LPBIG_OFFBIG = T.let(T.unsafe(nil), Integer)
Etc::SC_VERSION = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_CRYPT = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_ENH_I18N = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_REALTIME = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_REALTIME_THREADS = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_SHM = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_STREAMS = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_UNIX = T.let(T.unsafe(nil), Integer)
Etc::SC_XOPEN_VERSION = T.let(T.unsafe(nil), Integer)
Etc::VERSION = T.let(T.unsafe(nil), String)
FileUtils::Entry_::DIRECTORY_TERM = T.let(T.unsafe(nil), String)
FileUtils::Entry_::S_IF_DOOR = T.let(T.unsafe(nil), Integer)

class Struct
  include ::Enumerable
  def initialize(*_arg0); end
  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def deconstruct; end
  def deconstruct_keys(_arg0); end
  def dig(*_arg0); end
  def each; end
  def each_pair; end
  def eql?(_arg0); end
  def filter(*_arg0); end
  def hash; end
  def inspect; end
  def length; end
  def members; end
  def pretty_print(q); end
  def pretty_print_cycle(q); end
  def select(*_arg0); end
  def size; end
  def to_a; end
  def to_h; end
  def to_s; end
  def values; end
  def values_at(*_arg0); end
  private def initialize_copy(_arg0); end
  def self.new(*_arg0); end
end

module Enumerable
  def all?(*_arg0); end
  def any?(*_arg0); end
  def chain(*_arg0); end
  def chunk; end
  def chunk_while; end
  def collect; end
  def collect_concat; end
  def count(*_arg0); end
  def cycle(*_arg0); end
  def detect(*_arg0); end
  def drop(_arg0); end
  def drop_while; end
  def each_cons(_arg0); end
  def each_entry(*_arg0); end
  def each_slice(_arg0); end
  def each_with_index(*_arg0); end
  def each_with_object(_arg0); end
  def entries(*_arg0); end
  def filter; end
  def filter_map; end
  def find(*_arg0); end
  def find_all; end
  def find_index(*_arg0); end
  def first(*_arg0); end
  def flat_map; end
  def grep(_arg0); end
  def grep_v(_arg0); end
  def group_by; end
  def include?(_arg0); end
  def inject(*_arg0); end
  def lazy; end
  def map; end
  def max(*_arg0); end
  def max_by(*_arg0); end
  def member?(_arg0); end
  def min(*_arg0); end
  def min_by(*_arg0); end
  def minmax; end
  def minmax_by; end
  def none?(*_arg0); end
  def one?(*_arg0); end
  def partition; end
  def reduce(*_arg0); end
  def reject; end
  def reverse_each(*_arg0); end
  def select; end
  def slice_after(*_arg0); end
  def slice_before(*_arg0); end
  def slice_when; end
  def sort; end
  def sort_by; end
  def sum(*_arg0); end
  def take(_arg0); end
  def take_while; end
  def tally; end
  def to_a(*_arg0); end
  def to_h(*_arg0); end
  def to_set(klass = T.unsafe(nil), *args, &block); end
  def uniq; end
  def zip(*_arg0); end
end

Struct::Group = Etc::Group
Struct::Passwd = Etc::Passwd
SCRIPT_LINES__ = T.let(T.unsafe(nil), Hash)

class Tracer
  def initialize; end
  def add_filter(p = T.unsafe(nil), &b); end
  def get_line(file, line); end
  def get_thread_no; end
  def off; end
  def on; end
  def set_get_line_procs(file, p = T.unsafe(nil), &b); end
  def stdout; end
  def trace_func(event, file, line, id, binding, klass, *_arg6); end
  def self.add_filter(p = T.unsafe(nil), &b); end
  def self.display_c_call; end
  def self.display_c_call=(_arg0); end
  def self.display_c_call?; end
  def self.display_process_id; end
  def self.display_process_id=(_arg0); end
  def self.display_process_id?; end
  def self.display_thread_id; end
  def self.display_thread_id=(_arg0); end
  def self.display_thread_id?; end
  def self.off; end
  def self.on; end
  def self.set_get_line_procs(file_name, p = T.unsafe(nil), &b); end
  def self.stdout; end
  def self.stdout=(_arg0); end
  def self.stdout_mutex; end
  def self.verbose; end
  def self.verbose=(_arg0); end
  def self.verbose?; end
end

Tracer::EVENT_SYMBOL = T.let(T.unsafe(nil), Hash)
Tracer::Single = T.let(T.unsafe(nil), Tracer)
Tracer::VERSION = T.let(T.unsafe(nil), String)
module TSort
  def each_strongly_connected_component(&block); end
  def each_strongly_connected_component_from(node, id_map = T.unsafe(nil), stack = T.unsafe(nil), &block); end
  def strongly_connected_components; end
  def tsort; end
  def tsort_each(&block); end
  def tsort_each_child(node); end
  def tsort_each_node; end
  def self.each_strongly_connected_component(each_node, each_child); end
  def self.each_strongly_connected_component_from(node, each_child, id_map = T.unsafe(nil), stack = T.unsafe(nil)); end
  def self.strongly_connected_components(each_node, each_child); end
  def self.tsort(each_node, each_child); end
  def self.tsort_each(each_node, each_child); end
end

class TSort::Cyclic < ::StandardError; end
class StandardError < ::Exception; end

class Exception
  def initialize(*_arg0); end
  def ==(_arg0); end
  def backtrace; end
  def backtrace_locations; end
  def cause; end
  def exception(*_arg0); end
  def full_message(*_arg0); end
  def inspect; end
  def message; end
  def respond_to?(*_arg0); end
  def set_backtrace(_arg0); end
  def to_s; end
  private def method_missing(*_arg0); end
  private def respond_to_missing?(_arg0, _arg1); end
  def self.exception(*_arg0); end
  def self.to_tty?; end
end
OptParse = OptionParser

module FileUtils
  include ::FileUtils::StreamUtils_
  extend ::FileUtils::StreamUtils_
  private def apply_mask(mode, user_mask, op, mode_mask); end
  private def cd(dir, verbose: T.unsafe(nil), &block); end
  private def chdir(dir, verbose: T.unsafe(nil), &block); end
  private def chmod(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def chmod_R(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end
  private def chown(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def chown_R(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end
  private def cmp(a, b); end
  private def compare_file(a, b); end
  private def compare_stream(a, b); end
  private def copy(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def copy_entry(src, dest, preserve = T.unsafe(nil), dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end
  private def copy_file(src, dest, preserve = T.unsafe(nil), dereference = T.unsafe(nil)); end
  private def copy_stream(src, dest); end
  private def cp(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end
  private def cp_r(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end
  private def fu_each_src_dest(src, dest); end
  private def fu_each_src_dest0(src, dest); end
  private def fu_get_gid(group); end
  private def fu_get_uid(user); end
  private def fu_have_symlink?; end
  private def fu_list(arg); end
  private def fu_mkdir(path, mode); end
  private def fu_mode(mode, path); end
  private def fu_output_message(msg); end
  private def fu_same?(a, b); end
  private def fu_stat_identical_entry?(a, b); end
  private def getwd; end
  private def identical?(a, b); end
  private def install(src, dest, mode: T.unsafe(nil), owner: T.unsafe(nil), group: T.unsafe(nil), preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def link(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def link_entry(src, dest, dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end
  private def ln(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def ln_s(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def ln_sf(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def makedirs(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def mkdir(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def mkdir_p(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def mkpath(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def mode_to_s(mode); end
  private def move(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def mv(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def pwd; end
  private def remove(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def remove_dir(path, force = T.unsafe(nil)); end
  private def remove_entry(path, force = T.unsafe(nil)); end
  private def remove_entry_secure(path, force = T.unsafe(nil)); end
  private def remove_file(path, force = T.unsafe(nil)); end
  private def remove_trailing_slash(dir); end
  private def rm(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def rm_f(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def rm_r(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def rm_rf(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def rmdir(list, parents: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def rmtree(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  private def safe_unlink(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def symbolic_modes_to_i(mode_sym, path); end
  private def symlink(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  private def touch(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), mtime: T.unsafe(nil), nocreate: T.unsafe(nil)); end
  private def uptodate?(new, old_list); end
  private def user_mask(target); end
  def self.cd(dir, verbose: T.unsafe(nil), &block); end
  def self.chdir(dir, verbose: T.unsafe(nil), &block); end
  def self.chmod(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.chmod_R(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end
  def self.chown(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.chown_R(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end
  def self.cmp(a, b); end
  def self.collect_method(opt); end
  def self.commands; end
  def self.compare_file(a, b); end
  def self.compare_stream(a, b); end
  def self.copy(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.copy_entry(src, dest, preserve = T.unsafe(nil), dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end
  def self.copy_file(src, dest, preserve = T.unsafe(nil), dereference = T.unsafe(nil)); end
  def self.copy_stream(src, dest); end
  def self.cp(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end
  def self.cp_r(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end
  def self.getwd; end
  def self.have_option?(mid, opt); end
  def self.identical?(a, b); end
  def self.install(src, dest, mode: T.unsafe(nil), owner: T.unsafe(nil), group: T.unsafe(nil), preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.link(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.link_entry(src, dest, dereference_root = T.unsafe(nil), remove_destination = T.unsafe(nil)); end
  def self.ln(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.ln_s(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.ln_sf(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.makedirs(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.mkdir(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.mkdir_p(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.mkpath(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.move(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.mv(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.options; end
  def self.options_of(mid); end
  def self.private_module_function(name); end
  def self.pwd; end
  def self.remove(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.remove_dir(path, force = T.unsafe(nil)); end
  def self.remove_entry(path, force = T.unsafe(nil)); end
  def self.remove_entry_secure(path, force = T.unsafe(nil)); end
  def self.remove_file(path, force = T.unsafe(nil)); end
  def self.rm(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.rm_f(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.rm_r(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.rm_rf(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.rmdir(list, parents: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.rmtree(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end
  def self.safe_unlink(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.symlink(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
  def self.touch(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), mtime: T.unsafe(nil), nocreate: T.unsafe(nil)); end
  def self.uptodate?(new, old_list); end
  private def self.apply_mask(mode, user_mask, op, mode_mask); end
  private def self.fu_each_src_dest(src, dest); end
  private def self.fu_each_src_dest0(src, dest); end
  private def self.fu_get_gid(group); end
  private def self.fu_get_uid(user); end
  private def self.fu_have_symlink?; end
  private def self.fu_list(arg); end
  private def self.fu_mkdir(path, mode); end
  private def self.fu_mode(mode, path); end
  private def self.fu_output_message(msg); end
  private def self.fu_same?(a, b); end
  private def self.fu_stat_identical_entry?(a, b); end
  private def self.mode_to_s(mode); end
  private def self.remove_trailing_slash(dir); end
  private def self.symbolic_modes_to_i(mode_sym, path); end
  private def self.user_mask(target); end
end

class OptionParser
  def initialize(banner = T.unsafe(nil), width = T.unsafe(nil), indent = T.unsafe(nil)); end
  def abort(mesg = T.unsafe(nil)); end
  def accept(*args, &blk); end
  def add_officious; end
  def additional_message(typ, opt); end
  def banner; end
  def banner=(_arg0); end
  def base; end
  def candidate(word); end
  def compsys(to, name = T.unsafe(nil)); end
  def def_head_option(*opts, &block); end
  def def_option(*opts, &block); end
  def def_tail_option(*opts, &block); end
  def default_argv; end
  def default_argv=(_arg0); end
  def define(*opts, &block); end
  def define_by_keywords(options, meth, **opts); end
  def define_head(*opts, &block); end
  def define_tail(*opts, &block); end
  def environment(env = T.unsafe(nil)); end
  def getopts(*args); end
  def help; end
  def inc(*args); end
  def load(filename = T.unsafe(nil)); end
  def make_switch(opts, block = T.unsafe(nil)); end
  def new; end
  def on(*opts, &block); end
  def on_head(*opts, &block); end
  def on_tail(*opts, &block); end
  def order(*argv, into: T.unsafe(nil), &nonopt); end
  def order!(argv = T.unsafe(nil), into: T.unsafe(nil), &nonopt); end
  def parse(*argv, into: T.unsafe(nil)); end
  def parse!(argv = T.unsafe(nil), into: T.unsafe(nil)); end
  def permute(*argv, into: T.unsafe(nil)); end
  def permute!(argv = T.unsafe(nil), into: T.unsafe(nil)); end
  def program_name; end
  def program_name=(_arg0); end
  def reject(*args, &blk); end
  def release; end
  def release=(_arg0); end
  def remove; end
  def separator(string); end
  def set_banner(_arg0); end
  def set_program_name(_arg0); end
  def set_summary_indent(_arg0); end
  def set_summary_width(_arg0); end
  def summarize(to = T.unsafe(nil), width = T.unsafe(nil), max = T.unsafe(nil), indent = T.unsafe(nil), &blk); end
  def summary_indent; end
  def summary_indent=(_arg0); end
  def summary_width; end
  def summary_width=(_arg0); end
  def terminate(arg = T.unsafe(nil)); end
  def to_a; end
  def to_s; end
  def top; end
  def ver; end
  def version; end
  def version=(_arg0); end
  def warn(mesg = T.unsafe(nil)); end
  private def complete(typ, opt, icase = T.unsafe(nil), *pat); end
  private def notwice(obj, prv, msg); end
  private def parse_in_order(argv = T.unsafe(nil), setter = T.unsafe(nil), &nonopt); end
  private def search(id, key); end
  private def visit(id, *args, &block); end
  def self.accept(*args, &blk); end
  def self.each_const(path, base = T.unsafe(nil)); end
  def self.getopts(*args); end
  def self.inc(arg, default = T.unsafe(nil)); end
  def self.reject(*args, &blk); end
  def self.search_const(klass, name); end
  def self.show_version(*pkgs); end
  def self.terminate(arg = T.unsafe(nil)); end
  def self.top; end
  def self.with(*args, &block); end
end

module UN
  private def help(argv, output: T.unsafe(nil)); end
  def self.help(argv, output: T.unsafe(nil)); end
end

module FileUtils::DryRun
  include ::FileUtils::StreamUtils_
  include ::FileUtils
  include ::FileUtils::LowMethods
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils
  extend ::FileUtils::LowMethods
  extend ::FileUtils::DryRun
  private def chmod(*args, **options); end
  private def chmod_R(*args, **options); end
  private def chown(*args, **options); end
  private def chown_R(*args, **options); end
  private def copy(*args, **options); end
  private def cp(*args, **options); end
  private def cp_lr(*args, **options); end
  private def cp_r(*args, **options); end
  private def install(*args, **options); end
  private def link(*args, **options); end
  private def ln(*args, **options); end
  private def ln_s(*args, **options); end
  private def ln_sf(*args, **options); end
  private def makedirs(*args, **options); end
  private def mkdir(*args, **options); end
  private def mkdir_p(*args, **options); end
  private def mkpath(*args, **options); end
  private def move(*args, **options); end
  private def mv(*args, **options); end
  private def remove(*args, **options); end
  private def rm(*args, **options); end
  private def rm_f(*args, **options); end
  private def rm_r(*args, **options); end
  private def rm_rf(*args, **options); end
  private def rmdir(*args, **options); end
  private def rmtree(*args, **options); end
  private def safe_unlink(*args, **options); end
  private def symlink(*args, **options); end
  private def touch(*args, **options); end
end

class FileUtils::Entry_
  include ::FileUtils::StreamUtils_
  def initialize(a, b = T.unsafe(nil), deref = T.unsafe(nil)); end
  def blockdev?; end
  def chardev?; end
  def chmod(mode); end
  def chown(uid, gid); end
  def copy(dest); end
  def copy_file(dest); end
  def copy_metadata(path); end
  def dereference?; end
  def directory?; end
  def door?; end
  def entries; end
  def exist?; end
  def file?; end
  def inspect; end
  def link(dest); end
  def lstat; end
  def lstat!; end
  def path; end
  def pipe?; end
  def platform_support; end
  def postorder_traverse; end
  def prefix; end
  def preorder_traverse; end
  def rel; end
  def remove; end
  def remove_dir1; end
  def remove_file; end
  def socket?; end
  def stat; end
  def stat!; end
  def symlink?; end
  def traverse; end
  def wrap_traverse(pre, post); end
  private def check_have_lchmod?; end
  private def check_have_lchown?; end
  private def descendant_directory?(descendant, ascendant); end
  private def have_lchmod?; end
  private def have_lchown?; end
  private def join(dir, base); end
end

FileUtils::LOW_METHODS = T.let(T.unsafe(nil), Array)

module FileUtils::LowMethods
  private def _do_nothing(*_arg0); end
  private def cd(*_arg0); end
  private def chdir(*_arg0); end
  private def cmp(*_arg0); end
  private def collect_method(*_arg0); end
  private def commands(*_arg0); end
  private def compare_file(*_arg0); end
  private def compare_stream(*_arg0); end
  private def copy_entry(*_arg0); end
  private def copy_file(*_arg0); end
  private def copy_stream(*_arg0); end
  private def getwd(*_arg0); end
  private def have_option?(*_arg0); end
  private def identical?(*_arg0); end
  private def link_entry(*_arg0); end
  private def options(*_arg0); end
  private def options_of(*_arg0); end
  private def private_module_function(*_arg0); end
  private def pwd(*_arg0); end
  private def remove_dir(*_arg0); end
  private def remove_entry(*_arg0); end
  private def remove_entry_secure(*_arg0); end
  private def remove_file(*_arg0); end
  private def uptodate?(*_arg0); end
end

FileUtils::METHODS = T.let(T.unsafe(nil), Array)

module FileUtils::NoWrite
  include ::FileUtils::StreamUtils_
  include ::FileUtils
  include ::FileUtils::LowMethods
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils
  extend ::FileUtils::LowMethods
  extend ::FileUtils::NoWrite
  private def chmod(*args, **options); end
  private def chmod_R(*args, **options); end
  private def chown(*args, **options); end
  private def chown_R(*args, **options); end
  private def copy(*args, **options); end
  private def cp(*args, **options); end
  private def cp_lr(*args, **options); end
  private def cp_r(*args, **options); end
  private def install(*args, **options); end
  private def link(*args, **options); end
  private def ln(*args, **options); end
  private def ln_s(*args, **options); end
  private def ln_sf(*args, **options); end
  private def makedirs(*args, **options); end
  private def mkdir(*args, **options); end
  private def mkdir_p(*args, **options); end
  private def mkpath(*args, **options); end
  private def move(*args, **options); end
  private def mv(*args, **options); end
  private def remove(*args, **options); end
  private def rm(*args, **options); end
  private def rm_f(*args, **options); end
  private def rm_r(*args, **options); end
  private def rm_rf(*args, **options); end
  private def rmdir(*args, **options); end
  private def rmtree(*args, **options); end
  private def safe_unlink(*args, **options); end
  private def symlink(*args, **options); end
  private def touch(*args, **options); end
end

FileUtils::OPT_TABLE = T.let(T.unsafe(nil), Hash)

module FileUtils::StreamUtils_
  private def fu_blksize(st); end
  private def fu_copy_stream0(src, dest, blksize = T.unsafe(nil)); end
  private def fu_default_blksize; end
  private def fu_stream_blksize(*streams); end
  private def fu_windows?; end
end

FileUtils::VERSION = T.let(T.unsafe(nil), String)

module FileUtils::Verbose
  include ::FileUtils::StreamUtils_
  include ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils
  extend ::FileUtils::Verbose
  private def cd(*args, **options); end
  private def chdir(*args, **options); end
  private def chmod(*args, **options); end
  private def chmod_R(*args, **options); end
  private def chown(*args, **options); end
  private def chown_R(*args, **options); end
  private def copy(*args, **options); end
  private def cp(*args, **options); end
  private def cp_lr(*args, **options); end
  private def cp_r(*args, **options); end
  private def install(*args, **options); end
  private def link(*args, **options); end
  private def ln(*args, **options); end
  private def ln_s(*args, **options); end
  private def ln_sf(*args, **options); end
  private def makedirs(*args, **options); end
  private def mkdir(*args, **options); end
  private def mkdir_p(*args, **options); end
  private def mkpath(*args, **options); end
  private def move(*args, **options); end
  private def mv(*args, **options); end
  private def remove(*args, **options); end
  private def rm(*args, **options); end
  private def rm_f(*args, **options); end
  private def rm_r(*args, **options); end
  private def rm_rf(*args, **options); end
  private def rmdir(*args, **options); end
  private def rmtree(*args, **options); end
  private def safe_unlink(*args, **options); end
  private def symlink(*args, **options); end
  private def touch(*args, **options); end
end

class OptionParser::AC < ::OptionParser
  def ac_arg_disable(name, help_string, &block); end
  def ac_arg_enable(name, help_string, &block); end
  def ac_arg_with(name, help_string, &block); end
  private def _ac_arg_enable(prefix, name, help_string, block); end
  private def _check_ac_args(name, block); end
end

module OptionParser::Acceptables; end
class OptionParser::AmbiguousArgument < ::OptionParser::InvalidArgument; end
class OptionParser::AmbiguousOption < ::OptionParser::ParseError; end

module OptionParser::Arguable
  def initialize(*args); end
  def getopts(*args); end
  def options; end
  def options=(opt); end
  def order!(&blk); end
  def parse!; end
  def permute!; end
  def self.extend_object(obj); end
end

OptionParser::ArgumentStyle = T.let(T.unsafe(nil), Hash)
OptionParser::COMPSYS_HEADER = T.let(T.unsafe(nil), String)

class OptionParser::CompletingHash < ::Hash
  include ::OptionParser::Completion
  def match(key); end
end

module OptionParser::Completion
  def candidate(key, icase = T.unsafe(nil), pat = T.unsafe(nil)); end
  def complete(key, icase = T.unsafe(nil), pat = T.unsafe(nil)); end
  def convert(opt = T.unsafe(nil), val = T.unsafe(nil), *_arg2); end
  def self.candidate(key, icase = T.unsafe(nil), pat = T.unsafe(nil), &block); end
  def self.regexp(key, icase); end
end

OptionParser::DecimalInteger = T.let(T.unsafe(nil), Regexp)
OptionParser::DecimalNumeric = T.let(T.unsafe(nil), Regexp)
OptionParser::DefaultList = T.let(T.unsafe(nil), OptionParser::List)
class OptionParser::InvalidArgument < ::OptionParser::ParseError; end
class OptionParser::InvalidOption < ::OptionParser::ParseError; end

class OptionParser::List
  def initialize; end
  def accept(t, pat = T.unsafe(nil), &block); end
  def add_banner(to); end
  def append(*args); end
  def atype; end
  def complete(id, opt, icase = T.unsafe(nil), *pat, &block); end
  def compsys(*args, &block); end
  def each_option(&block); end
  def get_candidates(id); end
  def list; end
  def long; end
  def prepend(*args); end
  def reject(t); end
  def search(id, key); end
  def short; end
  def summarize(*args, &block); end
  private def update(sw, sopts, lopts, nsw = T.unsafe(nil), nlopts = T.unsafe(nil)); end
end

class OptionParser::MissingArgument < ::OptionParser::ParseError; end
OptionParser::NO_ARGUMENT = T.let(T.unsafe(nil), Symbol)
class OptionParser::NeedlessArgument < ::OptionParser::ParseError; end
OptionParser::NoArgument = T.let(T.unsafe(nil), Array)
OptionParser::OPTIONAL_ARGUMENT = T.let(T.unsafe(nil), Symbol)
OptionParser::OctalInteger = T.let(T.unsafe(nil), Regexp)
OptionParser::Officious = T.let(T.unsafe(nil), Hash)

class OptionParser::OptionMap < ::Hash
  include ::OptionParser::Completion
end

OptionParser::OptionalArgument = T.let(T.unsafe(nil), Array)

class OptionParser::ParseError < ::RuntimeError
  def initialize(*args, additional: T.unsafe(nil)); end
  def additional; end
  def additional=(_arg0); end
  def args; end
  def inspect; end
  def message; end
  def reason; end
  def reason=(_arg0); end
  def recover(argv); end
  def set_backtrace(array); end
  def set_option(opt, eq); end
  def to_s; end
  def self.filter_backtrace(array); end
end

OptionParser::REQUIRED_ARGUMENT = T.let(T.unsafe(nil), Symbol)
OptionParser::RequiredArgument = T.let(T.unsafe(nil), Array)
OptionParser::SPLAT_PROC = T.let(T.unsafe(nil), Proc)

class OptionParser::Switch
  def initialize(pattern = T.unsafe(nil), conv = T.unsafe(nil), short = T.unsafe(nil), long = T.unsafe(nil), arg = T.unsafe(nil), desc = T.unsafe(nil), block = T.unsafe(nil), &_block); end
  def add_banner(to); end
  def arg; end
  def block; end
  def compsys(sdone, ldone); end
  def conv; end
  def desc; end
  def long; end
  def match_nonswitch?(str); end
  def pattern; end
  def short; end
  def summarize(sdone = T.unsafe(nil), ldone = T.unsafe(nil), width = T.unsafe(nil), max = T.unsafe(nil), indent = T.unsafe(nil)); end
  def switch_name; end
  private def conv_arg(arg, val = T.unsafe(nil)); end
  private def parse_arg(arg); end
  def self.guess(arg); end
  def self.incompatible_argument_styles(arg, t); end
  def self.pattern; end
end

OptionParser::Version = T.let(T.unsafe(nil), String)
FileUtils::Entry_::DIRECTORY_TERM = T.let(T.unsafe(nil), String)
FileUtils::Entry_::S_IF_DOOR = T.let(T.unsafe(nil), Integer)
OptionParser::AC::ARG_CONV = T.let(T.unsafe(nil), Proc)
OptionParser::Acceptables::DecimalInteger = T.let(T.unsafe(nil), Regexp)
OptionParser::Acceptables::DecimalNumeric = T.let(T.unsafe(nil), Regexp)
OptionParser::Acceptables::OctalInteger = T.let(T.unsafe(nil), Regexp)
OptionParser::AmbiguousArgument::Reason = T.let(T.unsafe(nil), String)
OptionParser::AmbiguousOption::Reason = T.let(T.unsafe(nil), String)

class Hash
  include ::Enumerable
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  def initialize(*_arg0); end
  def <(_arg0); end
  def <=(_arg0); end
  def ==(_arg0); end
  def >(_arg0); end
  def >=(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def any?(*_arg0); end
  def assoc(_arg0); end
  def clear; end
  def compact; end
  def compact!; end
  def compare_by_identity; end
  def compare_by_identity?; end
  def deconstruct_keys(_arg0); end
  def default(*_arg0); end
  def default=(_arg0); end
  def default_proc; end
  def default_proc=(_arg0); end
  def delete(_arg0); end
  def delete_if; end
  def dig(*_arg0); end
  def each; end
  def each_key; end
  def each_pair; end
  def each_value; end
  def empty?; end
  def eql?(_arg0); end
  def except(*_arg0); end
  def fetch(*_arg0); end
  def fetch_values(*_arg0); end
  def filter; end
  def filter!; end
  def flatten(*_arg0); end
  def has_key?(_arg0); end
  def has_value?(_arg0); end
  def hash; end
  def include?(_arg0); end
  def inspect; end
  def invert; end
  def keep_if; end
  def key(_arg0); end
  def key?(_arg0); end
  def keys; end
  def length; end
  def member?(_arg0); end
  def merge(*_arg0); end
  def merge!(*_arg0); end
  def pretty_print(q); end
  def pretty_print_cycle(q); end
  def rassoc(_arg0); end
  def rehash; end
  def reject; end
  def reject!; end
  def replace(_arg0); end
  def select; end
  def select!; end
  def shift; end
  def size; end
  def slice(*_arg0); end
  def store(_arg0, _arg1); end
  def to_a; end
  def to_h; end
  def to_hash; end
  def to_proc; end
  def to_s; end
  def transform_keys(*_arg0); end
  def transform_keys!(*_arg0); end
  def transform_values; end
  def transform_values!; end
  def update(*_arg0); end
  def value?(_arg0); end
  def values; end
  def values_at(*_arg0); end
  private def initialize_copy(_arg0); end
  def self.[](*_arg0); end
  def self.ruby2_keywords_hash(_arg0); end
  def self.ruby2_keywords_hash?(_arg0); end
  def self.try_convert(_arg0); end
end

OptionParser::InvalidArgument::Reason = T.let(T.unsafe(nil), String)
OptionParser::InvalidOption::Reason = T.let(T.unsafe(nil), String)
OptionParser::MissingArgument::Reason = T.let(T.unsafe(nil), String)
OptionParser::NeedlessArgument::Reason = T.let(T.unsafe(nil), String)
class RuntimeError < ::StandardError; end
OptionParser::ParseError::Reason = T.let(T.unsafe(nil), String)

class OptionParser::Switch::NoArgument < ::OptionParser::Switch
  def parse(arg, argv); end
  def self.incompatible_argument_styles(*_arg0); end
  def self.pattern; end
end

class OptionParser::Switch::OptionalArgument < ::OptionParser::Switch
  def parse(arg, argv, &error); end
end

class OptionParser::Switch::PlacedArgument < ::OptionParser::Switch
  def parse(arg, argv, &error); end
end

class OptionParser::Switch::RequiredArgument < ::OptionParser::Switch
  def parse(arg, argv); end
end

class StandardError < ::Exception; end

module Enumerable
  def all?(*_arg0); end
  def any?(*_arg0); end
  def chain(*_arg0); end
  def chunk; end
  def chunk_while; end
  def collect; end
  def collect_concat; end
  def count(*_arg0); end
  def cycle(*_arg0); end
  def detect(*_arg0); end
  def drop(_arg0); end
  def drop_while; end
  def each_cons(_arg0); end
  def each_entry(*_arg0); end
  def each_slice(_arg0); end
  def each_with_index(*_arg0); end
  def each_with_object(_arg0); end
  def entries(*_arg0); end
  def filter; end
  def filter_map; end
  def find(*_arg0); end
  def find_all; end
  def find_index(*_arg0); end
  def first(*_arg0); end
  def flat_map; end
  def grep(_arg0); end
  def grep_v(_arg0); end
  def group_by; end
  def include?(_arg0); end
  def inject(*_arg0); end
  def lazy; end
  def map; end
  def max(*_arg0); end
  def max_by(*_arg0); end
  def member?(_arg0); end
  def min(*_arg0); end
  def min_by(*_arg0); end
  def minmax; end
  def minmax_by; end
  def none?(*_arg0); end
  def one?(*_arg0); end
  def partition; end
  def reduce(*_arg0); end
  def reject; end
  def reverse_each(*_arg0); end
  def select; end
  def slice_after(*_arg0); end
  def slice_before(*_arg0); end
  def slice_when; end
  def sort; end
  def sort_by; end
  def sum(*_arg0); end
  def take(_arg0); end
  def take_while; end
  def tally; end
  def to_a(*_arg0); end
  def to_h(*_arg0); end
  def to_set(klass = T.unsafe(nil), *args, &block); end
  def uniq; end
  def zip(*_arg0); end
end

module JSON::Ext::Generator::GeneratorMethods::Hash
  def to_json(*_arg0); end
end

class Exception
  def initialize(*_arg0); end
  def ==(_arg0); end
  def backtrace; end
  def backtrace_locations; end
  def cause; end
  def exception(*_arg0); end
  def full_message(*_arg0); end
  def inspect; end
  def message; end
  def respond_to?(*_arg0); end
  def set_backtrace(_arg0); end
  def to_s; end
  private def method_missing(*_arg0); end
  private def respond_to_missing?(_arg0, _arg1); end
  def self.exception(*_arg0); end
  def self.to_tty?; end
end

class IPSocket < ::BasicSocket
  def addr(*_arg0); end
  def inspect; end
  def peeraddr(*_arg0); end
  def recvfrom(*_arg0); end
  def self.getaddress(host); end
  def self.original_resolv_getaddress(_arg0); end
end

class IPAddr
  include ::Comparable
  def initialize(addr = T.unsafe(nil), family = T.unsafe(nil)); end
  def &(other); end
  def <<(num); end
  def <=>(other); end
  def ==(other); end
  def ===(other); end
  def >>(num); end
  def eql?(other); end
  def family; end
  def hash; end
  def hton; end
  def include?(other); end
  def inspect; end
  def ip6_arpa; end
  def ip6_int; end
  def ipv4?; end
  def ipv4_compat; end
  def ipv4_compat?; end
  def ipv4_mapped; end
  def ipv4_mapped?; end
  def ipv6?; end
  def link_local?; end
  def loopback?; end
  def mask(prefixlen); end
  def native; end
  def prefix; end
  def prefix=(prefix); end
  def private?; end
  def reverse; end
  def succ; end
  def to_i; end
  def to_range; end
  def to_s; end
  def to_string; end
  def |(other); end
  def ~; end
  protected def mask!(mask); end
  protected def set(addr, *family); end
  private def _ipv4_compat?; end
  private def _reverse; end
  private def _to_string(addr); end
  private def addr_mask(addr); end
  private def coerce_other(other); end
  private def in6_addr(left); end
  private def in_addr(addr); end
  def self.new_ntoh(addr); end
  def self.ntop(addr); end
end

module URI
  include ::URI::RFC2396_REGEXP
  def self.decode_www_form(str, enc = T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end
  def self.decode_www_form_component(str, enc = T.unsafe(nil)); end
  def self.encode_www_form(enum, enc = T.unsafe(nil)); end
  def self.encode_www_form_component(str, enc = T.unsafe(nil)); end
  def self.extract(str, schemes = T.unsafe(nil), &block); end
  def self.for(scheme, *arguments, default: T.unsafe(nil)); end
  def self.get_encoding(label); end
  def self.join(*str); end
  def self.open(name, *rest, &block); end
  def self.parse(uri); end
  def self.regexp(schemes = T.unsafe(nil)); end
  def self.scheme_list; end
  def self.split(uri); end
end

class BasicSocket < ::IO
  def close_read; end
  def close_write; end
  def connect_address; end
  def do_not_reverse_lookup; end
  def do_not_reverse_lookup=(_arg0); end
  def getpeereid; end
  def getpeername; end
  def getsockname; end
  def getsockopt(_arg0, _arg1); end
  def local_address; end
  def recv(*_arg0); end
  def recv_nonblock(len, flag = T.unsafe(nil), str = T.unsafe(nil), exception: T.unsafe(nil)); end
  def recvmsg(dlen = T.unsafe(nil), flags = T.unsafe(nil), clen = T.unsafe(nil), scm_rights: T.unsafe(nil)); end
  def recvmsg_nonblock(dlen = T.unsafe(nil), flags = T.unsafe(nil), clen = T.unsafe(nil), scm_rights: T.unsafe(nil), exception: T.unsafe(nil)); end
  def remote_address; end
  def send(*_arg0); end
  def sendmsg(mesg, flags = T.unsafe(nil), dest_sockaddr = T.unsafe(nil), *controls); end
  def sendmsg_nonblock(mesg, flags = T.unsafe(nil), dest_sockaddr = T.unsafe(nil), *controls, exception: T.unsafe(nil)); end
  def setsockopt(*_arg0); end
  def shutdown(*_arg0); end
  private def __recv_nonblock(_arg0, _arg1, _arg2, _arg3); end
  private def __recvmsg(_arg0, _arg1, _arg2, _arg3); end
  private def __recvmsg_nonblock(_arg0, _arg1, _arg2, _arg3, _arg4); end
  private def __sendmsg(_arg0, _arg1, _arg2, _arg3); end
  private def __sendmsg_nonblock(_arg0, _arg1, _arg2, _arg3, _arg4); end
  def self.do_not_reverse_lookup; end
  def self.do_not_reverse_lookup=(_arg0); end
  def self.for_fd(_arg0); end
end

class IPAddr::AddressFamilyError < ::IPAddr::Error; end
class IPAddr::Error < ::ArgumentError; end
IPAddr::IN4MASK = T.let(T.unsafe(nil), Integer)
IPAddr::IN6FORMAT = T.let(T.unsafe(nil), String)
IPAddr::IN6MASK = T.let(T.unsafe(nil), Integer)
class IPAddr::InvalidAddressError < ::IPAddr::Error; end
class IPAddr::InvalidPrefixError < ::IPAddr::InvalidAddressError; end
IPAddr::RE_IPV4ADDRLIKE = T.let(T.unsafe(nil), Regexp)
IPAddr::RE_IPV6ADDRLIKE_COMPRESSED = T.let(T.unsafe(nil), Regexp)
IPAddr::RE_IPV6ADDRLIKE_FULL = T.let(T.unsafe(nil), Regexp)
URI::ABS_PATH = T.let(T.unsafe(nil), Regexp)
URI::ABS_URI = T.let(T.unsafe(nil), Regexp)
URI::ABS_URI_REF = T.let(T.unsafe(nil), Regexp)
class URI::BadURIError < ::URI::Error; end
URI::DEFAULT_PARSER = T.let(T.unsafe(nil), URI::RFC2396_Parser)
URI::ESCAPED = T.let(T.unsafe(nil), Regexp)
class URI::Error < ::StandardError; end
URI::FRAGMENT = T.let(T.unsafe(nil), Regexp)

class URI::FTP < ::URI::Generic
  include ::OpenURI::OpenRead
  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser = T.unsafe(nil), arg_check = T.unsafe(nil)); end
  def buffer_open(buf, proxy, options); end
  def merge(oth); end
  def path; end
  def to_s; end
  def typecode; end
  def typecode=(typecode); end
  protected def set_path(v); end
  protected def set_typecode(v); end
  private def check_typecode(v); end
  def self.build(args); end
  def self.new2(user, password, host, port, path, typecode = T.unsafe(nil), arg_check = T.unsafe(nil)); end
end

class URI::File < ::URI::Generic
  def check_password(user); end
  def check_user(user); end
  def check_userinfo(user); end
  def set_host(v); end
  def set_password(v); end
  def set_port(v); end
  def set_user(v); end
  def set_userinfo(v); end
  def self.build(args); end
end

class URI::Generic
  include ::URI::RFC2396_REGEXP
  include ::URI
  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser = T.unsafe(nil), arg_check = T.unsafe(nil)); end
  def +(oth); end
  def -(oth); end
  def ==(oth); end
  def absolute; end
  def absolute?; end
  def coerce(oth); end
  def component; end
  def default_port; end
  def eql?(oth); end
  def find_proxy(env = T.unsafe(nil)); end
  def fragment; end
  def fragment=(v); end
  def hash; end
  def hierarchical?; end
  def host; end
  def host=(v); end
  def hostname; end
  def hostname=(v); end
  def inspect; end
  def merge(oth); end
  def merge!(oth); end
  def normalize; end
  def normalize!; end
  def opaque; end
  def opaque=(v); end
  def parser; end
  def password; end
  def password=(password); end
  def path; end
  def path=(v); end
  def port; end
  def port=(v); end
  def query; end
  def query=(v); end
  def registry; end
  def registry=(v); end
  def relative?; end
  def route_from(oth); end
  def route_to(oth); end
  def scheme; end
  def scheme=(v); end
  def select(*components); end
  def to_s; end
  def user; end
  def user=(user); end
  def userinfo; end
  def userinfo=(userinfo); end
  protected def component_ary; end
  protected def set_host(v); end
  protected def set_opaque(v); end
  protected def set_password(v); end
  protected def set_path(v); end
  protected def set_port(v); end
  protected def set_registry(v); end
  protected def set_scheme(v); end
  protected def set_user(v); end
  protected def set_userinfo(user, password = T.unsafe(nil)); end
  private def check_host(v); end
  private def check_opaque(v); end
  private def check_password(v, user = T.unsafe(nil)); end
  private def check_path(v); end
  private def check_port(v); end
  private def check_registry(v); end
  private def check_scheme(v); end
  private def check_user(v); end
  private def check_userinfo(user, password = T.unsafe(nil)); end
  private def escape_userpass(v); end
  private def merge_path(base, rel); end
  private def replace!(oth); end
  private def route_from0(oth); end
  private def route_from_path(src, dst); end
  private def split_path(path); end
  private def split_userinfo(ui); end
  def self.build(args); end
  def self.build2(args); end
  def self.component; end
  def self.default_port; end
  def self.use_proxy?(hostname, addr, port, no_proxy); end
  def self.use_registry; end
end

URI::HOST = T.let(T.unsafe(nil), Regexp)

class URI::HTTP < ::URI::Generic
  include ::OpenURI::OpenRead
  def buffer_open(buf, proxy, options); end
  def request_uri; end
  def self.build(args); end
end

class URI::HTTPS < ::URI::HTTP; end
class URI::InvalidComponentError < ::URI::Error; end
class URI::InvalidURIError < ::URI::Error; end

class URI::LDAP < ::URI::Generic
  def initialize(*arg); end
  def attributes; end
  def attributes=(val); end
  def dn; end
  def dn=(val); end
  def extensions; end
  def extensions=(val); end
  def filter; end
  def filter=(val); end
  def hierarchical?; end
  def scope; end
  def scope=(val); end
  protected def set_attributes(val); end
  protected def set_dn(val); end
  protected def set_extensions(val); end
  protected def set_filter(val); end
  protected def set_scope(val); end
  private def build_path_query; end
  private def parse_dn; end
  private def parse_query; end
  def self.build(args); end
end

class URI::LDAPS < ::URI::LDAP; end

class URI::MailTo < ::URI::Generic
  def initialize(*arg); end
  def headers; end
  def headers=(v); end
  def to; end
  def to=(v); end
  def to_mailtext; end
  def to_rfc822text; end
  def to_s; end
  protected def set_headers(v); end
  protected def set_to(v); end
  private def check_headers(v); end
  private def check_to(v); end
  def self.build(args); end
end

URI::OPAQUE = T.let(T.unsafe(nil), Regexp)
URI::PORT = T.let(T.unsafe(nil), Regexp)
URI::Parser = URI::RFC2396_Parser
URI::QUERY = T.let(T.unsafe(nil), Regexp)
URI::REGEXP = URI::RFC2396_REGEXP
URI::REGISTRY = T.let(T.unsafe(nil), Regexp)
URI::REL_PATH = T.let(T.unsafe(nil), Regexp)
URI::REL_URI = T.let(T.unsafe(nil), Regexp)
URI::REL_URI_REF = T.let(T.unsafe(nil), Regexp)

class URI::RFC2396_Parser
  include ::URI::RFC2396_REGEXP
  def initialize(opts = T.unsafe(nil)); end
  def escape(str, unsafe = T.unsafe(nil)); end
  def extract(str, schemes = T.unsafe(nil)); end
  def inspect; end
  def join(*uris); end
  def make_regexp(schemes = T.unsafe(nil)); end
  def parse(uri); end
  def pattern; end
  def regexp; end
  def split(uri); end
  def unescape(str, escaped = T.unsafe(nil)); end
  private def convert_to_uri(uri); end
  private def initialize_pattern(opts = T.unsafe(nil)); end
  private def initialize_regexp(pattern); end
end

module URI::RFC2396_REGEXP; end
URI::RFC3986_PARSER = T.let(T.unsafe(nil), URI::RFC3986_Parser)

class URI::RFC3986_Parser
  def initialize; end
  def inspect; end
  def join(*uris); end
  def parse(uri); end
  def regexp; end
  def split(uri); end
  private def convert_to_uri(uri); end
  private def default_regexp; end
end

URI::SCHEME = T.let(T.unsafe(nil), Regexp)
URI::TBLDECWWWCOMP_ = T.let(T.unsafe(nil), Hash)
URI::TBLENCWWWCOMP_ = T.let(T.unsafe(nil), Hash)
URI::UNSAFE = T.let(T.unsafe(nil), Regexp)
URI::URI_REF = T.let(T.unsafe(nil), Regexp)
URI::USERINFO = T.let(T.unsafe(nil), Regexp)

module URI::Util
  private def make_components_hash(klass, array_hash); end
  def self.make_components_hash(klass, array_hash); end
end

URI::VERSION = T.let(T.unsafe(nil), String)
URI::VERSION_CODE = T.let(T.unsafe(nil), String)
URI::WEB_ENCODINGS_ = T.let(T.unsafe(nil), Hash)

class URI::WS < ::URI::Generic
  def request_uri; end
  def self.build(args); end
end

class URI::WSS < ::URI::WS; end

module Comparable
  def <(_arg0); end
  def <=(_arg0); end
  def ==(_arg0); end
  def >(_arg0); end
  def >=(_arg0); end
  def between?(_arg0, _arg1); end
  def clamp(*_arg0); end
end

class IO
  include ::Enumerable
  include ::File::Constants
  def initialize(*_arg0); end
  def <<(_arg0); end
  def advise(*_arg0); end
  def autoclose=(_arg0); end
  def autoclose?; end
  def beep; end
  def binmode; end
  def binmode?; end
  def check_winsize_changed; end
  def clear_screen; end
  def close; end
  def close_on_exec=(_arg0); end
  def close_on_exec?; end
  def close_read; end
  def close_write; end
  def closed?; end
  def console_mode; end
  def console_mode=(_arg0); end
  def cooked; end
  def cooked!; end
  def cursor; end
  def cursor=(_arg0); end
  def cursor_down(_arg0); end
  def cursor_left(_arg0); end
  def cursor_right(_arg0); end
  def cursor_up(_arg0); end
  def each(*_arg0); end
  def each_byte; end
  def each_char; end
  def each_codepoint; end
  def each_line(*_arg0); end
  def echo=(_arg0); end
  def echo?; end
  def eof; end
  def eof?; end
  def erase_line(_arg0); end
  def erase_screen(_arg0); end
  def expect(pat, timeout = T.unsafe(nil)); end
  def external_encoding; end
  def fcntl(*_arg0); end
  def fdatasync; end
  def fileno; end
  def flush; end
  def fsync; end
  def getbyte; end
  def getc; end
  def getch(*_arg0); end
  def getpass(*_arg0); end
  def gets(*_arg0); end
  def goto(_arg0, _arg1); end
  def goto_column(_arg0); end
  def iflush; end
  def inspect; end
  def internal_encoding; end
  def ioctl(*_arg0); end
  def ioflush; end
  def isatty; end
  def lineno; end
  def lineno=(_arg0); end
  def noecho; end
  def nonblock(*_arg0); end
  def nonblock=(_arg0); end
  def nonblock?; end
  def nread; end
  def oflush; end
  def pathconf(_arg0); end
  def pid; end
  def pos; end
  def pos=(_arg0); end
  def pread(*_arg0); end
  def pressed?; end
  def print(*_arg0); end
  def printf(*_arg0); end
  def putc(_arg0); end
  def puts(*_arg0); end
  def pwrite(_arg0, _arg1); end
  def raw(*_arg0); end
  def raw!(*_arg0); end
  def read(*_arg0); end
  def read_nonblock(len, buf = T.unsafe(nil), exception: T.unsafe(nil)); end
  def readbyte; end
  def readchar; end
  def readline(*_arg0); end
  def readlines(*_arg0); end
  def readpartial(*_arg0); end
  def ready?; end
  def reopen(*_arg0); end
  def rewind; end
  def scroll_backward(_arg0); end
  def scroll_forward(_arg0); end
  def seek(*_arg0); end
  def set_encoding(*_arg0); end
  def set_encoding_by_bom; end
  def stat; end
  def sync; end
  def sync=(_arg0); end
  def sysread(*_arg0); end
  def sysseek(*_arg0); end
  def syswrite(_arg0); end
  def tell; end
  def to_i; end
  def to_io; end
  def tty?; end
  def ungetbyte(_arg0); end
  def ungetc(_arg0); end
  def wait(*_arg0); end
  def wait_priority(*_arg0); end
  def wait_readable(*_arg0); end
  def wait_writable(*_arg0); end
  def winsize; end
  def winsize=(_arg0); end
  def write(*_arg0); end
  def write_nonblock(buf, exception: T.unsafe(nil)); end
  private def initialize_copy(_arg0); end
  def self.binread(*_arg0); end
  def self.binwrite(*_arg0); end
  def self.console(*_arg0); end
  def self.copy_stream(*_arg0); end
  def self.for_fd(*_arg0); end
  def self.foreach(*_arg0); end
  def self.new(*_arg0); end
  def self.open(*_arg0); end
  def self.pipe(*_arg0); end
  def self.popen(*_arg0); end
  def self.read(*_arg0); end
  def self.readlines(*_arg0); end
  def self.select(*_arg0); end
  def self.sysopen(*_arg0); end
  def self.try_convert(_arg0); end
  def self.write(*_arg0); end
end

class ArgumentError < ::StandardError; end
class StandardError < ::Exception; end
URI::FTP::COMPONENT = T.let(T.unsafe(nil), Array)
URI::FTP::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
URI::FTP::TYPECODE = T.let(T.unsafe(nil), Array)
URI::FTP::TYPECODE_PREFIX = T.let(T.unsafe(nil), String)
URI::File::COMPONENT = T.let(T.unsafe(nil), Array)
URI::Generic::COMPONENT = T.let(T.unsafe(nil), Array)
URI::HTTP::COMPONENT = T.let(T.unsafe(nil), Array)
URI::HTTP::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
URI::HTTPS::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
URI::LDAP::COMPONENT = T.let(T.unsafe(nil), Array)
URI::LDAP::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
URI::LDAP::SCOPE = T.let(T.unsafe(nil), Array)
URI::LDAP::SCOPE_BASE = T.let(T.unsafe(nil), String)
URI::LDAP::SCOPE_ONE = T.let(T.unsafe(nil), String)
URI::LDAP::SCOPE_SUB = T.let(T.unsafe(nil), String)
URI::LDAPS::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
URI::MailTo::COMPONENT = T.let(T.unsafe(nil), Array)
URI::MailTo::EMAIL_REGEXP = T.let(T.unsafe(nil), Regexp)
URI::MailTo::HEADER_REGEXP = T.let(T.unsafe(nil), Regexp)
module URI::RFC2396_REGEXP::PATTERN; end
URI::RFC3986_Parser::RFC3986_URI = T.let(T.unsafe(nil), Regexp)
URI::RFC3986_Parser::RFC3986_relative_ref = T.let(T.unsafe(nil), Regexp)
URI::WS::COMPONENT = T.let(T.unsafe(nil), Array)
URI::WS::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
URI::WSS::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)

module OpenURI::OpenRead
  def open(*rest, &block); end
  def read(options = T.unsafe(nil)); end
end

class IO::ConsoleMode
  def echo=(_arg0); end
  def raw(*_arg0); end
  def raw!(*_arg0); end
  private def initialize_copy(_arg0); end
end

class IO::EAGAINWaitReadable < ::Errno::EAGAIN
  include ::IO::WaitReadable
end

class IO::EAGAINWaitWritable < ::Errno::EAGAIN
  include ::IO::WaitWritable
end

class IO::EINPROGRESSWaitReadable < ::Errno::EINPROGRESS
  include ::IO::WaitReadable
end

class IO::EINPROGRESSWaitWritable < ::Errno::EINPROGRESS
  include ::IO::WaitWritable
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable
IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable
IO::PRIORITY = T.let(T.unsafe(nil), Integer)
IO::READABLE = T.let(T.unsafe(nil), Integer)
IO::SEEK_CUR = T.let(T.unsafe(nil), Integer)
IO::SEEK_DATA = T.let(T.unsafe(nil), Integer)
IO::SEEK_END = T.let(T.unsafe(nil), Integer)
IO::SEEK_HOLE = T.let(T.unsafe(nil), Integer)
IO::SEEK_SET = T.let(T.unsafe(nil), Integer)
IO::WRITABLE = T.let(T.unsafe(nil), Integer)
module IO::WaitReadable; end
module IO::WaitWritable; end

class Exception
  def initialize(*_arg0); end
  def ==(_arg0); end
  def backtrace; end
  def backtrace_locations; end
  def cause; end
  def exception(*_arg0); end
  def full_message(*_arg0); end
  def inspect; end
  def message; end
  def respond_to?(*_arg0); end
  def set_backtrace(_arg0); end
  def to_s; end
  private def method_missing(*_arg0); end
  private def respond_to_missing?(_arg0, _arg1); end
  def self.exception(*_arg0); end
  def self.to_tty?; end
end

URI::RFC2396_REGEXP::PATTERN::ABS_PATH = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::ABS_URI = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::ALNUM = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::ALPHA = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::DOMLABEL = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::ESCAPED = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::FRAGMENT = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::HEX = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::HIER_PART = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::HOST = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::HOSTNAME = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::HOSTPORT = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::IPV4ADDR = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::IPV6ADDR = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::IPV6REF = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::NET_PATH = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::OPAQUE_PART = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::PATH_SEGMENTS = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::PORT = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::QUERY = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::REG_NAME = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::REL_PATH = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::REL_SEGMENT = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::REL_URI = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::RESERVED = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::SCHEME = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::TOPLABEL = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::UNRESERVED = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::URIC = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::URIC_NO_SLASH = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::URI_REF = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::USERINFO = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::X_ABS_URI = T.let(T.unsafe(nil), String)
URI::RFC2396_REGEXP::PATTERN::X_REL_URI = T.let(T.unsafe(nil), String)

module Enumerable
  def all?(*_arg0); end
  def any?(*_arg0); end
  def chain(*_arg0); end
  def chunk; end
  def chunk_while; end
  def collect; end
  def collect_concat; end
  def count(*_arg0); end
  def cycle(*_arg0); end
  def detect(*_arg0); end
  def drop(_arg0); end
  def drop_while; end
  def each_cons(_arg0); end
  def each_entry(*_arg0); end
  def each_slice(_arg0); end
  def each_with_index(*_arg0); end
  def each_with_object(_arg0); end
  def entries(*_arg0); end
  def filter; end
  def filter_map; end
  def find(*_arg0); end
  def find_all; end
  def find_index(*_arg0); end
  def first(*_arg0); end
  def flat_map; end
  def grep(_arg0); end
  def grep_v(_arg0); end
  def group_by; end
  def include?(_arg0); end
  def inject(*_arg0); end
  def lazy; end
  def map; end
  def max(*_arg0); end
  def max_by(*_arg0); end
  def member?(_arg0); end
  def min(*_arg0); end
  def min_by(*_arg0); end
  def minmax; end
  def minmax_by; end
  def none?(*_arg0); end
  def one?(*_arg0); end
  def partition; end
  def reduce(*_arg0); end
  def reject; end
  def reverse_each(*_arg0); end
  def select; end
  def slice_after(*_arg0); end
  def slice_before(*_arg0); end
  def slice_when; end
  def sort; end
  def sort_by; end
  def sum(*_arg0); end
  def take(_arg0); end
  def take_while; end
  def tally; end
  def to_a(*_arg0); end
  def to_h(*_arg0); end
  def to_set(klass = T.unsafe(nil), *args, &block); end
  def uniq; end
  def zip(*_arg0); end
end

module File::Constants; end
class Errno::EAGAIN < ::SystemCallError; end
class Errno::EINPROGRESS < ::SystemCallError; end
File::Constants::APPEND = T.let(T.unsafe(nil), Integer)
File::Constants::BINARY = T.let(T.unsafe(nil), Integer)
File::Constants::CREAT = T.let(T.unsafe(nil), Integer)
File::Constants::DSYNC = T.let(T.unsafe(nil), Integer)
File::Constants::EXCL = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_CASEFOLD = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_DOTMATCH = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_EXTGLOB = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_NOESCAPE = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_PATHNAME = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_SHORTNAME = T.let(T.unsafe(nil), Integer)
File::Constants::FNM_SYSCASE = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_EX = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_NB = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_SH = T.let(T.unsafe(nil), Integer)
File::Constants::LOCK_UN = T.let(T.unsafe(nil), Integer)
File::Constants::NOCTTY = T.let(T.unsafe(nil), Integer)
File::Constants::NOFOLLOW = T.let(T.unsafe(nil), Integer)
File::Constants::NONBLOCK = T.let(T.unsafe(nil), Integer)
File::Constants::NULL = T.let(T.unsafe(nil), String)
File::Constants::RDONLY = T.let(T.unsafe(nil), Integer)
File::Constants::RDWR = T.let(T.unsafe(nil), Integer)
File::Constants::SHARE_DELETE = T.let(T.unsafe(nil), Integer)
File::Constants::SYNC = T.let(T.unsafe(nil), Integer)
File::Constants::TRUNC = T.let(T.unsafe(nil), Integer)
File::Constants::WRONLY = T.let(T.unsafe(nil), Integer)

class SystemCallError < ::StandardError
  def initialize(*_arg0); end
  def errno; end
  def self.===(_arg0); end
end

Errno::EAGAIN::Errno = T.let(T.unsafe(nil), Integer)
Errno::EINPROGRESS::Errno = T.let(T.unsafe(nil), Integer)
class Delegator < ::BasicObject
  def initialize(obj); end
  def !; end
  def !=(obj); end
  def ==(obj); end
  def __getobj__; end
  def __setobj__(obj); end
  def eql?(obj); end
  def freeze; end
  def marshal_dump; end
  def marshal_load(data); end
  def method_missing(m, *args, &block); end
  def methods(all = T.unsafe(nil)); end
  def protected_methods(all = T.unsafe(nil)); end
  def public_methods(all = T.unsafe(nil)); end
  private def initialize_clone(obj, freeze: T.unsafe(nil)); end
  private def initialize_dup(obj); end
  private def respond_to_missing?(m, include_private); end
  private def target_respond_to?(target, m, include_private); end
  def self.const_missing(n); end
  def self.delegating_block(mid); end
  def self.public_api; end
end

class WeakRef
  def initialize(orig); end
  def __getobj__; end
  def __setobj__(obj); end
  def weakref_alive?; end
end

class SimpleDelegator
  def __getobj__; end
  def __setobj__(obj); end
end

class BasicObject
  def initialize; end
  def !; end
  def !=(_arg0); end
  def ==(_arg0); end
  def __id__; end
  def __send__(*_arg0); end
  def equal?(_arg0); end
  def instance_eval(*_arg0); end
  def instance_exec(*_arg0); end
  private def method_missing(*_arg0); end
  private def singleton_method_added(_arg0); end
  private def singleton_method_removed(_arg0); end
  private def singleton_method_undefined(_arg0); end
end

Delegator::VERSION = T.let(T.unsafe(nil), String)
class WeakRef::RefError < ::StandardError; end
WeakRef::VERSION = T.let(T.unsafe(nil), String)
class StandardError < ::Exception; end

class Exception
  def initialize(*_arg0); end
  def ==(_arg0); end
  def backtrace; end
  def backtrace_locations; end
  def cause; end
  def exception(*_arg0); end
  def full_message(*_arg0); end
  def inspect; end
  def message; end
  def respond_to?(*_arg0); end
  def set_backtrace(_arg0); end
  def to_s; end
  private def method_missing(*_arg0); end
  private def respond_to_missing?(_arg0, _arg1); end
  def self.exception(*_arg0); end
  def self.to_tty?; end
end
module Forwardable
  def def_delegator(accessor, method, ali = T.unsafe(nil)); end
  def def_delegators(accessor, *methods); end
  def def_instance_delegator(accessor, method, ali = T.unsafe(nil)); end
  def def_instance_delegators(accessor, *methods); end
  def delegate(hash); end
  def instance_delegate(hash); end
  def self._compile_method(src, file, line); end
  def self._delegator_method(obj, accessor, method, ali); end
  def self._valid_method?(method); end
  def self.debug; end
  def self.debug=(_arg0); end
end

module SingleForwardable
  def def_delegator(accessor, method, ali = T.unsafe(nil)); end
  def def_delegators(accessor, *methods); end
  def def_single_delegator(accessor, method, ali = T.unsafe(nil)); end
  def def_single_delegators(accessor, *methods); end
  def delegate(hash); end
  def single_delegate(hash); end
end

class DBM
  include ::Enumerable
  def initialize(*_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clear; end
  def close; end
  def closed?; end
  def delete(_arg0); end
  def delete_if; end
  def each; end
  def each_key; end
  def each_pair; end
  def each_value; end
  def empty?; end
  def fetch(*_arg0); end
  def has_key?(_arg0); end
  def has_value?(_arg0); end
  def include?(_arg0); end
  def index(_arg0); end
  def invert; end
  def key(_arg0); end
  def key?(_arg0); end
  def keys; end
  def length; end
  def member?(_arg0); end
  def reject; end
  def reject!; end
  def replace(_arg0); end
  def select; end
  def shift; end
  def size; end
  def store(_arg0, _arg1); end
  def to_a; end
  def to_hash; end
  def update(_arg0); end
  def value?(_arg0); end
  def values; end
  def values_at(*_arg0); end
  def self.open(*_arg0); end
end

class DBMError < ::StandardError; end

class PStore
  def initialize(file, thread_safe = T.unsafe(nil)); end
  def [](name); end
  def []=(name, value); end
  def abort; end
  def commit; end
  def delete(name); end
  def fetch(name, default = T.unsafe(nil)); end
  def path; end
  def root?(name); end
  def roots; end
  def transaction(read_only = T.unsafe(nil)); end
  def ultra_safe; end
  def ultra_safe=(_arg0); end
  private def dump(table); end
  private def empty_marshal_checksum; end
  private def empty_marshal_data; end
  private def in_transaction; end
  private def in_transaction_wr; end
  private def load(content); end
  private def load_data(file, read_only); end
  private def on_windows?; end
  private def open_and_lock_file(filename, read_only); end
  private def save_data(original_checksum, original_file_size, file); end
  private def save_data_with_atomic_file_rename_strategy(data, file); end
  private def save_data_with_fast_strategy(data, file); end
end

class StringIO
  include ::Enumerable
  def initialize(*_arg0); end
  def binmode; end
  def close; end
  def close_read; end
  def close_write; end
  def closed?; end
  def closed_read?; end
  def closed_write?; end
  def each(*_arg0); end
  def each_byte; end
  def each_char; end
  def each_codepoint; end
  def each_line(*_arg0); end
  def eof; end
  def eof?; end
  def external_encoding; end
  def fcntl(*_arg0); end
  def fileno; end
  def flush; end
  def fsync; end
  def getbyte; end
  def getc; end
  def gets(*_arg0); end
  def internal_encoding; end
  def isatty; end
  def length; end
  def lineno; end
  def lineno=(_arg0); end
  def pid; end
  def pos; end
  def pos=(_arg0); end
  def putc(_arg0); end
  def read(*_arg0); end
  def readlines(*_arg0); end
  def reopen(*_arg0); end
  def rewind; end
  def seek(*_arg0); end
  def set_encoding(*_arg0); end
  def set_encoding_by_bom; end
  def size; end
  def string; end
  def string=(_arg0); end
  def sync; end
  def sync=(_arg0); end
  def tell; end
  def truncate(_arg0); end
  def tty?; end
  def ungetbyte(_arg0); end
  def ungetc(_arg0); end
  def write(*_arg0); end
  private def initialize_copy(_arg0); end
  def self.new(*_arg0); end
  def self.open(*_arg0); end
end

module Psych
  def self.add_builtin_type(type_tag, &block); end
  def self.add_domain_type(domain, type_tag, &block); end
  def self.add_tag(tag, klass); end
  def self.config; end
  def self.domain_types(*args, &block); end
  def self.domain_types=(*args, &block); end
  def self.dump(o, io = T.unsafe(nil), options = T.unsafe(nil)); end
  def self.dump_stream(*objects); end
  def self.dump_tags(*args, &block); end
  def self.dump_tags=(*args, &block); end
  def self.libyaml_version; end
  def self.load(yaml, legacy_filename = T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil), freeze: T.unsafe(nil)); end
  def self.load_file(filename, **kwargs); end
  def self.load_stream(yaml, legacy_filename = T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil), **kwargs); end
  def self.load_tags(*args, &block); end
  def self.load_tags=(*args, &block); end
  def self.parse(yaml, legacy_filename = T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil)); end
  def self.parse_file(filename, fallback: T.unsafe(nil)); end
  def self.parse_stream(yaml, legacy_filename = T.unsafe(nil), filename: T.unsafe(nil), &block); end
  def self.parser; end
  def self.remove_type(type_tag); end
  def self.safe_load(yaml, legacy_permitted_classes = T.unsafe(nil), legacy_permitted_symbols = T.unsafe(nil), legacy_aliases = T.unsafe(nil), legacy_filename = T.unsafe(nil), permitted_classes: T.unsafe(nil), permitted_symbols: T.unsafe(nil), aliases: T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil), freeze: T.unsafe(nil)); end
  def self.safe_load_file(filename, **kwargs); end
  def self.to_json(object); end
  private def self.parse_caller(at); end
  private def self.warn_with_uplevel(message, uplevel: T.unsafe(nil)); end
end

module Digest
  private def hexencode(_arg0); end
  def self.const_missing(name); end
  def self.hexencode(_arg0); end
end

Forwardable::FORWARDABLE_VERSION = T.let(T.unsafe(nil), String)
Forwardable::VERSION = T.let(T.unsafe(nil), String)
DBM::NEWDB = T.let(T.unsafe(nil), Integer)
DBM::READER = T.let(T.unsafe(nil), Integer)
DBM::VERSION = T.let(T.unsafe(nil), String)
DBM::WRCREAT = T.let(T.unsafe(nil), Integer)
DBM::WRITER = T.let(T.unsafe(nil), Integer)
class StandardError < ::Exception; end
PStore::CHECKSUM_ALGO = Digest::SHA512
PStore::EMPTY_MARSHAL_CHECKSUM = T.let(T.unsafe(nil), String)
PStore::EMPTY_MARSHAL_DATA = T.let(T.unsafe(nil), String)
PStore::EMPTY_STRING = T.let(T.unsafe(nil), String)
class PStore::Error < ::StandardError; end
PStore::RDWR_ACCESS = T.let(T.unsafe(nil), Hash)
PStore::RD_ACCESS = T.let(T.unsafe(nil), Hash)
PStore::VERSION = T.let(T.unsafe(nil), String)
PStore::WR_ACCESS = T.let(T.unsafe(nil), Hash)
StringIO::VERSION = T.let(T.unsafe(nil), String)
class Psych::BadAlias < ::Psych::Exception; end

class Psych::ClassLoader
  def initialize; end
  def big_decimal; end
  def complex; end
  def date; end
  def date_time; end
  def exception; end
  def load(klassname); end
  def object; end
  def psych_omap; end
  def psych_set; end
  def range; end
  def rational; end
  def regexp; end
  def struct; end
  def symbol; end
  def symbolize(sym); end
  private def find(klassname); end
  private def path2class(_arg0); end
  private def resolve(klassname); end
end

class Psych::Coder
  def initialize(tag); end
  def [](k); end
  def []=(k, v); end
  def add(k, v); end
  def implicit; end
  def implicit=(_arg0); end
  def map(tag = T.unsafe(nil), style = T.unsafe(nil)); end
  def map=(map); end
  def object; end
  def object=(_arg0); end
  def represent_map(tag, map); end
  def represent_object(tag, obj); end
  def represent_scalar(tag, value); end
  def represent_seq(tag, list); end
  def scalar(*args); end
  def scalar=(value); end
  def seq; end
  def seq=(list); end
  def style; end
  def style=(_arg0); end
  def tag; end
  def tag=(_arg0); end
  def type; end
end

class Psych::DBM < ::DBM
  def [](key); end
  def []=(key, val); end
  def delete(key); end
  def delete_if; end
  def each; end
  def each_pair; end
  def each_value; end
  def fetch(keystr, ifnone = T.unsafe(nil)); end
  def has_value?(val); end
  def index(keystr); end
  def invert; end
  def key(keystr); end
  def reject; end
  def replace(hsh); end
  def select(*keys); end
  def shift; end
  def store(key, val); end
  def to_a; end
  def to_hash; end
  def update(hsh); end
  def values; end
  def values_at(*keys); end
end

class Psych::DisallowedClass < ::Psych::Exception
  def initialize(klass_name); end
end

class Psych::Emitter < ::Psych::Handler
  def initialize(*_arg0); end
  def alias(_arg0); end
  def canonical; end
  def canonical=(_arg0); end
  def end_document(_arg0); end
  def end_mapping; end
  def end_sequence; end
  def end_stream; end
  def indentation; end
  def indentation=(_arg0); end
  def line_width; end
  def line_width=(_arg0); end
  def scalar(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5); end
  def start_document(_arg0, _arg1, _arg2); end
  def start_mapping(_arg0, _arg1, _arg2, _arg3); end
  def start_sequence(_arg0, _arg1, _arg2, _arg3); end
  def start_stream(_arg0); end
end

class Psych::Exception < ::RuntimeError; end

class Psych::Handler
  def alias(anchor); end
  def empty; end
  def end_document(implicit); end
  def end_mapping; end
  def end_sequence; end
  def end_stream; end
  def event_location(start_line, start_column, end_line, end_column); end
  def scalar(value, anchor, tag, plain, quoted, style); end
  def start_document(version, tag_directives, implicit); end
  def start_mapping(anchor, tag, implicit, style); end
  def start_sequence(anchor, tag, implicit, style); end
  def start_stream(encoding); end
  def streaming?; end
end

module Psych::Handlers; end
module Psych::JSON; end
Psych::LIBYAML_VERSION = T.let(T.unsafe(nil), String)
module Psych::Nodes; end
class Psych::Omap < ::Hash; end

class Psych::Parser
  def initialize(handler = T.unsafe(nil)); end
  def external_encoding=(_arg0); end
  def handler; end
  def handler=(_arg0); end
  def mark; end
  def parse(*_arg0); end
end

class Psych::ScalarScanner
  def initialize(class_loader); end
  def class_loader; end
  def parse_int(string); end
  def parse_time(string); end
  def tokenize(string); end
end

class Psych::Set < ::Hash; end

class Psych::Store < ::PStore
  def initialize(*o); end
  def dump(table); end
  def empty_marshal_checksum; end
  def empty_marshal_data; end
  def load(content); end
  def marshal_dump_supports_canonical_option?; end
end

class Psych::Stream < ::Psych::Visitors::YAMLTree
  include ::Psych::Streaming
  extend ::Psych::Streaming::ClassMethods
end

module Psych::Streaming
  def start(encoding = T.unsafe(nil)); end
  private def register(target, obj); end
end

class Psych::SyntaxError < ::Psych::Exception
  def initialize(file, line, col, offset, problem, context); end
  def column; end
  def context; end
  def file; end
  def line; end
  def offset; end
  def problem; end
end

class Psych::TreeBuilder < ::Psych::Handler
  def initialize; end
  def alias(anchor); end
  def end_document(implicit_end = T.unsafe(nil)); end
  def end_mapping; end
  def end_sequence; end
  def end_stream; end
  def event_location(start_line, start_column, end_line, end_column); end
  def root; end
  def scalar(value, anchor, tag, plain, quoted, style); end
  def start_document(version, tag_directives, implicit); end
  def start_mapping(anchor, tag, implicit, style); end
  def start_sequence(anchor, tag, implicit, style); end
  def start_stream(encoding); end
  private def pop; end
  private def push(value); end
  private def set_end_location(node); end
  private def set_location(node); end
  private def set_start_location(node); end
end

Psych::VERSION = T.let(T.unsafe(nil), String)
module Psych::Visitors; end

class Digest::Base < ::Digest::Class
  def <<(_arg0); end
  def block_length; end
  def digest_length; end
  def reset; end
  def update(_arg0); end
  private def finish; end
  private def initialize_copy(_arg0); end
end

class Digest::Class
  include ::Digest::Instance
  def initialize; end
  def self.base64digest(str, *args); end
  def self.digest(*_arg0); end
  def self.file(name, *args); end
  def self.hexdigest(*_arg0); end
end

module Digest::Instance
  def <<(_arg0); end
  def ==(_arg0); end
  def base64digest(str = T.unsafe(nil)); end
  def base64digest!; end
  def block_length; end
  def digest(*_arg0); end
  def digest!; end
  def digest_length; end
  def file(name); end
  def hexdigest(*_arg0); end
  def hexdigest!; end
  def inspect; end
  def length; end
  def new; end
  def reset; end
  def size; end
  def to_s; end
  def update(_arg0); end
  private def finish; end
end

class Digest::MD5 < ::Digest::Base; end
Digest::REQUIRE_MUTEX = T.let(T.unsafe(nil), Thread::Mutex)
class Digest::SHA1 < ::Digest::Base; end

class Digest::SHA2 < ::Digest::Class
  def initialize(bitlen = T.unsafe(nil)); end
  def <<(str); end
  def block_length; end
  def digest_length; end
  def inspect; end
  def reset; end
  def update(str); end
  private def finish; end
  private def initialize_copy(other); end
end

class Digest::SHA256 < ::Digest::Base; end
class Digest::SHA384 < ::Digest::Base; end
class Digest::SHA512 < ::Digest::Base; end
Digest::VERSION = T.let(T.unsafe(nil), String)

module Enumerable
  def all?(*_arg0); end
  def any?(*_arg0); end
  def chain(*_arg0); end
  def chunk; end
  def chunk_while; end
  def collect; end
  def collect_concat; end
  def count(*_arg0); end
  def cycle(*_arg0); end
  def detect(*_arg0); end
  def drop(_arg0); end
  def drop_while; end
  def each_cons(_arg0); end
  def each_entry(*_arg0); end
  def each_slice(_arg0); end
  def each_with_index(*_arg0); end
  def each_with_object(_arg0); end
  def entries(*_arg0); end
  def filter; end
  def filter_map; end
  def find(*_arg0); end
  def find_all; end
  def find_index(*_arg0); end
  def first(*_arg0); end
  def flat_map; end
  def grep(_arg0); end
  def grep_v(_arg0); end
  def group_by; end
  def include?(_arg0); end
  def inject(*_arg0); end
  def lazy; end
  def map; end
  def max(*_arg0); end
  def max_by(*_arg0); end
  def member?(_arg0); end
  def min(*_arg0); end
  def min_by(*_arg0); end
  def minmax; end
  def minmax_by; end
  def none?(*_arg0); end
  def one?(*_arg0); end
  def partition; end
  def reduce(*_arg0); end
  def reject; end
  def reverse_each(*_arg0); end
  def select; end
  def slice_after(*_arg0); end
  def slice_before(*_arg0); end
  def slice_when; end
  def sort; end
  def sort_by; end
  def sum(*_arg0); end
  def take(_arg0); end
  def take_while; end
  def tally; end
  def to_a(*_arg0); end
  def to_h(*_arg0); end
  def to_set(klass = T.unsafe(nil), *args, &block); end
  def uniq; end
  def zip(*_arg0); end
end

class Exception
  def initialize(*_arg0); end
  def ==(_arg0); end
  def backtrace; end
  def backtrace_locations; end
  def cause; end
  def exception(*_arg0); end
  def full_message(*_arg0); end
  def inspect; end
  def message; end
  def respond_to?(*_arg0); end
  def set_backtrace(_arg0); end
  def to_s; end
  private def method_missing(*_arg0); end
  private def respond_to_missing?(_arg0, _arg1); end
  def self.exception(*_arg0); end
  def self.to_tty?; end
end

Psych::ClassLoader::BIG_DECIMAL = T.let(T.unsafe(nil), String)
Psych::ClassLoader::CACHE = T.let(T.unsafe(nil), Hash)
Psych::ClassLoader::COMPLEX = T.let(T.unsafe(nil), String)
Psych::ClassLoader::DATE = T.let(T.unsafe(nil), String)
Psych::ClassLoader::DATE_TIME = T.let(T.unsafe(nil), String)
Psych::ClassLoader::EXCEPTION = T.let(T.unsafe(nil), String)
Psych::ClassLoader::OBJECT = T.let(T.unsafe(nil), String)
Psych::ClassLoader::PSYCH_OMAP = T.let(T.unsafe(nil), String)
Psych::ClassLoader::PSYCH_SET = T.let(T.unsafe(nil), String)
Psych::ClassLoader::RANGE = T.let(T.unsafe(nil), String)
Psych::ClassLoader::RATIONAL = T.let(T.unsafe(nil), String)
Psych::ClassLoader::REGEXP = T.let(T.unsafe(nil), String)

class Psych::ClassLoader::Restricted < ::Psych::ClassLoader
  def initialize(classes, symbols); end
  def symbolize(sym); end
  private def find(klassname); end
end

Psych::ClassLoader::STRUCT = T.let(T.unsafe(nil), String)
Psych::ClassLoader::SYMBOL = T.let(T.unsafe(nil), String)
Psych::DBM::VERSION = T.let(T.unsafe(nil), String)
class RuntimeError < ::StandardError; end

class Psych::Handler::DumperOptions
  def initialize; end
  def canonical; end
  def canonical=(_arg0); end
  def indentation; end
  def indentation=(_arg0); end
  def line_width; end
  def line_width=(_arg0); end
end

Psych::Handler::EVENTS = T.let(T.unsafe(nil), Array)
Psych::Handler::OPTIONS = T.let(T.unsafe(nil), Psych::Handler::DumperOptions)

class Psych::Handlers::DocumentStream < ::Psych::TreeBuilder
  def initialize(&block); end
  def end_document(implicit_end = T.unsafe(nil)); end
  def start_document(version, tag_directives, implicit); end
end

module Psych::JSON::RubyEvents
  def visit_DateTime(o); end
  def visit_String(o); end
  def visit_Symbol(o); end
  def visit_Time(o); end
end

class Psych::JSON::Stream < ::Psych::Visitors::JSONTree
  include ::Psych::Streaming
  extend ::Psych::Streaming::ClassMethods
end

class Psych::JSON::TreeBuilder < ::Psych::TreeBuilder
  include ::Psych::JSON::YAMLEvents
end

module Psych::JSON::YAMLEvents
  def end_document(implicit_end = T.unsafe(nil)); end
  def scalar(value, anchor, tag, plain, quoted, style); end
  def start_document(version, tag_directives, implicit); end
  def start_mapping(anchor, tag, implicit, style); end
  def start_sequence(anchor, tag, implicit, style); end
end

class Psych::Nodes::Alias < ::Psych::Nodes::Node
  def initialize(anchor); end
  def alias?; end
  def anchor; end
  def anchor=(_arg0); end
end

class Psych::Nodes::Document < ::Psych::Nodes::Node
  def initialize(version = T.unsafe(nil), tag_directives = T.unsafe(nil), implicit = T.unsafe(nil)); end
  def document?; end
  def implicit; end
  def implicit=(_arg0); end
  def implicit_end; end
  def implicit_end=(_arg0); end
  def root; end
  def tag_directives; end
  def tag_directives=(_arg0); end
  def version; end
  def version=(_arg0); end
end

class Psych::Nodes::Mapping < ::Psych::Nodes::Node
  def initialize(anchor = T.unsafe(nil), tag = T.unsafe(nil), implicit = T.unsafe(nil), style = T.unsafe(nil)); end
  def anchor; end
  def anchor=(_arg0); end
  def implicit; end
  def implicit=(_arg0); end
  def mapping?; end
  def style; end
  def style=(_arg0); end
  def tag; end
  def tag=(_arg0); end
end

class Psych::Nodes::Node
  include ::Enumerable
  def initialize; end
  def alias?; end
  def children; end
  def document?; end
  def each(&block); end
  def end_column; end
  def end_column=(_arg0); end
  def end_line; end
  def end_line=(_arg0); end
  def mapping?; end
  def scalar?; end
  def sequence?; end
  def start_column; end
  def start_column=(_arg0); end
  def start_line; end
  def start_line=(_arg0); end
  def stream?; end
  def tag; end
  def to_ruby(symbolize_names: T.unsafe(nil), freeze: T.unsafe(nil)); end
  def to_yaml(io = T.unsafe(nil), options = T.unsafe(nil)); end
  def transform(symbolize_names: T.unsafe(nil), freeze: T.unsafe(nil)); end
  def yaml(io = T.unsafe(nil), options = T.unsafe(nil)); end
end

class Psych::Nodes::Scalar < ::Psych::Nodes::Node
  def initialize(value, anchor = T.unsafe(nil), tag = T.unsafe(nil), plain = T.unsafe(nil), quoted = T.unsafe(nil), style = T.unsafe(nil)); end
  def anchor; end
  def anchor=(_arg0); end
  def plain; end
  def plain=(_arg0); end
  def quoted; end
  def quoted=(_arg0); end
  def scalar?; end
  def style; end
  def style=(_arg0); end
  def tag; end
  def tag=(_arg0); end
  def value; end
  def value=(_arg0); end
end

class Psych::Nodes::Sequence < ::Psych::Nodes::Node
  def initialize(anchor = T.unsafe(nil), tag = T.unsafe(nil), implicit = T.unsafe(nil), style = T.unsafe(nil)); end
  def anchor; end
  def anchor=(_arg0); end
  def implicit; end
  def implicit=(_arg0); end
  def sequence?; end
  def style; end
  def style=(_arg0); end
  def tag; end
  def tag=(_arg0); end
end

class Psych::Nodes::Stream < ::Psych::Nodes::Node
  def initialize(encoding = T.unsafe(nil)); end
  def encoding; end
  def encoding=(_arg0); end
  def stream?; end
end

class Hash
  include ::Enumerable
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  def initialize(*_arg0); end
  def <(_arg0); end
  def <=(_arg0); end
  def ==(_arg0); end
  def >(_arg0); end
  def >=(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def any?(*_arg0); end
  def assoc(_arg0); end
  def clear; end
  def compact; end
  def compact!; end
  def compare_by_identity; end
  def compare_by_identity?; end
  def deconstruct_keys(_arg0); end
  def default(*_arg0); end
  def default=(_arg0); end
  def default_proc; end
  def default_proc=(_arg0); end
  def delete(_arg0); end
  def delete_if; end
  def dig(*_arg0); end
  def each; end
  def each_key; end
  def each_pair; end
  def each_value; end
  def empty?; end
  def eql?(_arg0); end
  def except(*_arg0); end
  def fetch(*_arg0); end
  def fetch_values(*_arg0); end
  def filter; end
  def filter!; end
  def flatten(*_arg0); end
  def has_key?(_arg0); end
  def has_value?(_arg0); end
  def hash; end
  def include?(_arg0); end
  def inspect; end
  def invert; end
  def keep_if; end
  def key(_arg0); end
  def key?(_arg0); end
  def keys; end
  def length; end
  def member?(_arg0); end
  def merge(*_arg0); end
  def merge!(*_arg0); end
  def pretty_print(q); end
  def pretty_print_cycle(q); end
  def rassoc(_arg0); end
  def rehash; end
  def reject; end
  def reject!; end
  def replace(_arg0); end
  def select; end
  def select!; end
  def shift; end
  def size; end
  def slice(*_arg0); end
  def store(_arg0, _arg1); end
  def to_a; end
  def to_h; end
  def to_hash; end
  def to_proc; end
  def to_s; end
  def transform_keys(*_arg0); end
  def transform_keys!(*_arg0); end
  def transform_values; end
  def transform_values!; end
  def update(*_arg0); end
  def value?(_arg0); end
  def values; end
  def values_at(*_arg0); end
  private def initialize_copy(_arg0); end
  def self.[](*_arg0); end
  def self.ruby2_keywords_hash(_arg0); end
  def self.ruby2_keywords_hash?(_arg0); end
  def self.try_convert(_arg0); end
end

Psych::Parser::ANY = T.let(T.unsafe(nil), Integer)
class Psych::Parser::Mark < ::Struct; end
Psych::Parser::UTF16BE = T.let(T.unsafe(nil), Integer)
Psych::Parser::UTF16LE = T.let(T.unsafe(nil), Integer)
Psych::Parser::UTF8 = T.let(T.unsafe(nil), Integer)
Psych::ScalarScanner::FLOAT = T.let(T.unsafe(nil), Regexp)
Psych::ScalarScanner::INTEGER = T.let(T.unsafe(nil), Regexp)
Psych::ScalarScanner::TIME = T.let(T.unsafe(nil), Regexp)

class Psych::Visitors::YAMLTree < ::Psych::Visitors::Visitor
  def initialize(emitter, ss, options); end
  def <<(object); end
  def accept(target); end
  def finish; end
  def finished; end
  def finished?; end
  def push(object); end
  def start(encoding = T.unsafe(nil)); end
  def started; end
  def started?; end
  def tree; end
  def visit_Array(o); end
  def visit_BasicObject(o); end
  def visit_BigDecimal(o); end
  def visit_Class(o); end
  def visit_Complex(o); end
  def visit_Date(o); end
  def visit_DateTime(o); end
  def visit_Delegator(o); end
  def visit_Encoding(o); end
  def visit_Enumerator(o); end
  def visit_Exception(o); end
  def visit_FalseClass(o); end
  def visit_Float(o); end
  def visit_Hash(o); end
  def visit_Integer(o); end
  def visit_Module(o); end
  def visit_NameError(o); end
  def visit_NilClass(o); end
  def visit_Object(o); end
  def visit_Psych_Omap(o); end
  def visit_Psych_Set(o); end
  def visit_Range(o); end
  def visit_Rational(o); end
  def visit_Regexp(o); end
  def visit_String(o); end
  def visit_Struct(o); end
  def visit_Symbol(o); end
  def visit_Time(o); end
  def visit_TrueClass(o); end
  private def binary?(string); end
  private def dump_coder(o); end
  private def dump_exception(o, msg); end
  private def dump_ivars(target); end
  private def dump_list(o); end
  private def emit_coder(c, o); end
  private def format_time(time); end
  private def register(target, yaml_obj); end
  private def visit_array_subclass(o); end
  private def visit_hash_subclass(o); end
  def self.create(options = T.unsafe(nil), emitter = T.unsafe(nil)); end
end

class Psych::Stream::Emitter < ::Psych::Emitter
  def end_document(implicit_end = T.unsafe(nil)); end
  def streaming?; end
end

module Psych::Streaming::ClassMethods
  def new(io); end
end

class Psych::Visitors::DepthFirst < ::Psych::Visitors::Visitor
  def initialize(block); end
  private def nary(o); end
  private def terminal(o); end
  private def visit_Psych_Nodes_Alias(o); end
  private def visit_Psych_Nodes_Document(o); end
  private def visit_Psych_Nodes_Mapping(o); end
  private def visit_Psych_Nodes_Scalar(o); end
  private def visit_Psych_Nodes_Sequence(o); end
  private def visit_Psych_Nodes_Stream(o); end
end

class Psych::Visitors::Emitter < ::Psych::Visitors::Visitor
  def initialize(io, options = T.unsafe(nil)); end
  def visit_Psych_Nodes_Alias(o); end
  def visit_Psych_Nodes_Document(o); end
  def visit_Psych_Nodes_Mapping(o); end
  def visit_Psych_Nodes_Scalar(o); end
  def visit_Psych_Nodes_Sequence(o); end
  def visit_Psych_Nodes_Stream(o); end
end

class Psych::Visitors::JSONTree < ::Psych::Visitors::YAMLTree
  include ::Psych::JSON::RubyEvents
  def accept(target); end
  def self.create(options = T.unsafe(nil)); end
end

class Psych::Visitors::NoAliasRuby < ::Psych::Visitors::ToRuby
  def visit_Psych_Nodes_Alias(o); end
end

class Psych::Visitors::ToRuby < ::Psych::Visitors::Visitor
  def initialize(ss, class_loader, symbolize_names: T.unsafe(nil), freeze: T.unsafe(nil)); end
  def accept(target); end
  def class_loader; end
  def visit_Psych_Nodes_Alias(o); end
  def visit_Psych_Nodes_Document(o); end
  def visit_Psych_Nodes_Mapping(o); end
  def visit_Psych_Nodes_Scalar(o); end
  def visit_Psych_Nodes_Sequence(o); end
  def visit_Psych_Nodes_Stream(o); end
  private def build_exception(_arg0, _arg1); end
  private def deduplicate(key); end
  private def deserialize(o); end
  private def init_with(o, h, node); end
  private def merge_key(hash, key, val); end
  private def register(node, object); end
  private def register_empty(object); end
  private def resolve_class(klassname); end
  private def revive(klass, node); end
  private def revive_hash(hash, o); end
  def self.create(symbolize_names: T.unsafe(nil), freeze: T.unsafe(nil)); end
end

class Psych::Visitors::Visitor
  def accept(target); end
  private def dispatch; end
  private def visit(target); end
  def self.dispatch_cache; end
end

class Psych::JSON::Stream::Emitter < ::Psych::Stream::Emitter
  include ::Psych::JSON::YAMLEvents
end

Psych::Nodes::Mapping::ANY = T.let(T.unsafe(nil), Integer)
Psych::Nodes::Mapping::BLOCK = T.let(T.unsafe(nil), Integer)
Psych::Nodes::Mapping::FLOW = T.let(T.unsafe(nil), Integer)
Psych::Nodes::Scalar::ANY = T.let(T.unsafe(nil), Integer)
Psych::Nodes::Scalar::DOUBLE_QUOTED = T.let(T.unsafe(nil), Integer)
Psych::Nodes::Scalar::FOLDED = T.let(T.unsafe(nil), Integer)
Psych::Nodes::Scalar::LITERAL = T.let(T.unsafe(nil), Integer)
Psych::Nodes::Scalar::PLAIN = T.let(T.unsafe(nil), Integer)
Psych::Nodes::Scalar::SINGLE_QUOTED = T.let(T.unsafe(nil), Integer)
Psych::Nodes::Sequence::ANY = T.let(T.unsafe(nil), Integer)
Psych::Nodes::Sequence::BLOCK = T.let(T.unsafe(nil), Integer)
Psych::Nodes::Sequence::FLOW = T.let(T.unsafe(nil), Integer)
Psych::Nodes::Stream::ANY = T.let(T.unsafe(nil), Integer)
Psych::Nodes::Stream::UTF16BE = T.let(T.unsafe(nil), Integer)
Psych::Nodes::Stream::UTF16LE = T.let(T.unsafe(nil), Integer)
Psych::Nodes::Stream::UTF8 = T.let(T.unsafe(nil), Integer)

class Struct
  include ::Enumerable
  def initialize(*_arg0); end
  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def deconstruct; end
  def deconstruct_keys(_arg0); end
  def dig(*_arg0); end
  def each; end
  def each_pair; end
  def eql?(_arg0); end
  def filter(*_arg0); end
  def hash; end
  def inspect; end
  def length; end
  def members; end
  def pretty_print(q); end
  def pretty_print_cycle(q); end
  def select(*_arg0); end
  def size; end
  def to_a; end
  def to_h; end
  def to_s; end
  def values; end
  def values_at(*_arg0); end
  private def initialize_copy(_arg0); end
  def self.new(*_arg0); end
end

class Psych::Visitors::YAMLTree::Registrar
  def initialize; end
  def id_for(target); end
  def key?(target); end
  def node_for(target); end
  def register(target, node); end
end

module JSON::Ext::Generator::GeneratorMethods::Hash
  def to_json(*_arg0); end
end

Struct::Group = Etc::Group
Struct::Passwd = Etc::Passwd
